Function: !_
Class: basic
Section: symbolic_operators
C-Name: gnot
Prototype: G
Help: !a: boolean operator "not".
Description: 
 (negbool):bool:parens                $1
 (bool):negbool:parens                $1

Function: #_
Class: basic
Section: symbolic_operators
C-Name: glength
Prototype: lG
Help: #x: number of non code words in x, number of characters for a string.
Description: 
 (vecsmall):lg      lg($1)
 (vec):lg           lg($1)
 (pol):small        lgpol($1)
 (gen):small        glength($1)

Function: %
Class: basic
Section: symbolic_operators
C-Name: pari_get_hist
Prototype: D0,L,
Help: last history item.

Function: %#
Class: basic
Section: symbolic_operators
C-Name: pari_histtime
Prototype: D0,L,
Help: time to compute last history item.

Function: +_
Class: basic
Section: symbolic_operators
Help: +_: copy and return its argument
Description: 
 (small):small:parens                      $1
 (int):int:parens:copy                     $1
 (real):real:parens:copy                   $1
 (mp):mp:parens:copy                       $1
 (gen):gen:parens:copy                     $1

Function: -_
Class: basic
Section: symbolic_operators
C-Name: gneg
Prototype: G
Help: -_: negate argument
Description: 
 (small):small:parens           -$(1)
 (int):int                      negi($1)
 (real):real                    negr($1)
 (mp):mp                        mpneg($1)
 (gen):gen                      gneg($1)
 
 (Fp):Fp     Fp_neg($1, p)
 (FpX):FpX   FpX_neg($1, p)
 (Fq):Fq     Fq_neg($1, T, p)
 (FqX):FqX   FqX_neg($1, T, p)

Function: Catalan
Class: basic
Section: transcendental
C-Name: mpcatalan
Prototype: p
Help: Catalan=Catalan(): Catalan's number with current precision.
Description: 
 ():real:prec        mpcatalan($prec)
Doc: Catalan's constant $G = \sum_{n>=0}\dfrac{(-1)^n}{(2n+1)^2}=0.91596\cdots$.
 Note that \kbd{Catalan} is one of the few reserved names which cannot be
 used for user variables.

Function: Col
Class: basic
Section: conversions
C-Name: gtocol0
Prototype: GD0,L,
Help: Col(x, {n}): transforms the object x into a column vector of dimension n.
Description: 
 (gen):vec     gtocol($1)
Doc: 
 transforms the object $x$ into a column vector. The dimension of the
 resulting vector can be optionally specified via the extra parameter $n$.
 
 If $n$ is omitted or $0$, the dimension depends on the type of $x$; the
 vector has a single component, except when $x$ is
 
 \item a vector or a quadratic form (in which case the resulting vector
 is simply the initial object considered as a row vector),
 
 \item a polynomial or a power series. In the case of a polynomial, the
 coefficients of the vector start with the leading coefficient of the
 polynomial, while for power series only the significant coefficients are
 taken into account, but this time by increasing order of degree.
 In this last case, \kbd{Vec} is the reciprocal function of \kbd{Pol} and
 \kbd{Ser} respectively,
 
 \item a matrix (the column of row vector comprising the matrix is returned),
 
 \item a character string (a vector of individual characters is returned).
 
 In the last two cases (matrix and character string), $n$ is meaningless and
 must be omitted or an error is raised. Otherwise, if $n$ is given, $0$
 entries are appended at the end of the vector if $n > 0$, and prepended at
 the beginning if $n < 0$. The dimension of the resulting vector is $|n|$.
 
 See ??Vec for examples.
Variant: \fun{GEN}{gtocol}{GEN x} is also available.

Function: Colrev
Class: basic
Section: conversions
C-Name: gtocolrev0
Prototype: GD0,L,
Help: Colrev(x, {n}): transforms the object x into a column vector of
 dimension n in reverse order with respect to Col(x, {n}). Empty vector if x
 is omitted.
Description: 
 (gen):vec     gtocolrev($1)
Doc: 
 as $\kbd{Col}(x, -n)$, then reverse the result. In particular,
 \kbd{Colrev} is the reciprocal function of \kbd{Polrev}: the
 coefficients of the vector start with the constant coefficient of the
 polynomial and the others follow by increasing degree.
Variant: \fun{GEN}{gtocolrev}{GEN x} is also available.

Function: DEBUGLEVEL
Class: gp2c
C-Name: DEBUGLEVEL
Prototype: v
Description: 
 ():small                         DEBUGLEVEL

Function: Euler
Class: basic
Section: transcendental
C-Name: mpeuler
Prototype: p
Help: Euler=Euler(): Euler's constant with current precision.
Description: 
 ():real:prec        mpeuler($prec)
Doc: Euler's constant $\gamma=0.57721\cdots$. Note that
 \kbd{Euler} is one of the few reserved names which cannot be used for
 user variables.

Function: I
Class: basic
Section: transcendental
C-Name: gen_I
Prototype: 
Help: I=I(): square root of -1.
Description: 
Doc: the complex number $\sqrt{-1}$.

Function: List
Class: basic
Section: conversions
C-Name: gtolist
Prototype: DG
Help: List({x=[]}): transforms the vector or list x into a list. Empty list
 if x is omitted.
Description: 
 ():list           mklist()
 (gen):list        listinit(gtolist($1))
Doc: 
 transforms a (row or column) vector $x$ into a list, whose components are
 the entries of $x$. Similarly for a list, but rather useless in this case.
 For other types, creates a list with the single element $x$.
Variant: The variant \fun{GEN}{mklist}{void} creates an empty list.

Function: Map
Class: basic
Section: conversions
C-Name: gtomap
Prototype: DG
Help: Map({x}): converts the matrix [a_1,b_1;a_2,b_2;...;a_n,b_n] to the map a_i->b_i.
Description: 
 ():list           mkmap()
 (gen):list        listinit(gtomap($1))
Doc: A ``Map'' is an associative array, or dictionary: a data
 type composed of a collection of (\emph{key}, \emph{value}) pairs, such that
 each key appears just once in the collection. This function
 converts the matrix $[a_1,b_1;a_2,b_2;\dots;a_n,b_n]$ to the map $a_i\mapsto
 b_i$.
 \bprog
 ? M = Map(factor(13!));
 ? mapget(M, 3)
 %2 = 5
 ? P = Map(matreduce(primes([1,20])))
 %3 = Map([2,1;3,1;5,1;7,1;11,1;13,1;17,1;19,1])
 ? select(i->mapisdefined(P,i), [1..20])
 %4 = [2, 3, 5, 7, 11, 13, 17, 19]
 @eprog\noindent If the argument $x$ is omitted, creates an empty map, which
 may be filled later via \tet{mapput}.

Function: Mat
Class: basic
Section: conversions
C-Name: gtomat
Prototype: DG
Help: Mat({x=[]}): transforms any GEN x into a matrix. Empty matrix if x is
 omitted.
Description: 
 ():vec        cgetg(1, t_MAT)
 (gen):vec     gtomat($1)
Doc: 
 transforms the object $x$ into a matrix.
 If $x$ is already a matrix, a copy of $x$ is created.
 If $x$ is a row (resp. column) vector, this creates a 1-row (resp.
 1-column) matrix, \emph{unless} all elements are column (resp.~row) vectors
 of the same length, in which case the vectors are concatenated sideways
 and the attached big matrix is returned.
 If $x$ is a binary quadratic form, creates the attached $2\times 2$
 matrix. Otherwise, this creates a $1\times 1$ matrix containing $x$.
 
 \bprog
 ? Mat(x + 1)
 %1 =
 [x + 1]
 ? Vec( matid(3) )
 %2 = [[1, 0, 0]~, [0, 1, 0]~, [0, 0, 1]~]
 ? Mat(%)
 %3 =
 [1 0 0]
 
 [0 1 0]
 
 [0 0 1]
 ? Col( [1,2; 3,4] )
 %4 = [[1, 2], [3, 4]]~
 ? Mat(%)
 %5 =
 [1 2]
 
 [3 4]
 ? Mat(Qfb(1,2,3))
 %6 =
 [1 1]
 
 [1 3]
 @eprog

Function: Mod
Class: basic
Section: conversions
C-Name: gmodulo
Prototype: GG
Help: Mod(a,b): create 'a modulo b'.
Description: 
 (small, small):gen         gmodulss($1, $2)
 (small, gen):gen           gmodulsg($1, $2)
 (gen, gen):gen             gmodulo($1, $2)
Doc: in its basic form, create an intmod or a polmod $(a \mod b)$; $b$ must
 be an integer or a polynomial. We then obtain a \typ{INTMOD} and a
 \typ{POLMOD} respectively:
 \bprog
 ? t = Mod(2,17); t^8
 %1 = Mod(1, 17)
 ? t = Mod(x,x^2+1); t^2
 %2 = Mod(-1, x^2+1)
 @eprog\noindent If $a \% b$ makes sense and yields a result of the
 appropriate type (\typ{INT} or scalar/\typ{POL}), the operation succeeds as
 well:
 \bprog
 ? Mod(1/2, 5)
 %3 = Mod(3, 5)
 ? Mod(7 + O(3^6), 3)
 %4 = Mod(1, 3)
 ? Mod(Mod(1,12), 9)
 %5 = Mod(1, 3)
 ? Mod(1/x, x^2+1)
 %6 = Mod(-x, x^2+1)
 ? Mod(exp(x), x^4)
 %7 = Mod(1/6*x^3 + 1/2*x^2 + x + 1, x^4)
 @eprog
 If $a$ is a complex object, ``base change'' it to $\Z/b\Z$ or $K[x]/(b)$,
 which is equivalent to, but faster than, multiplying it by \kbd{Mod(1,b)}:
 \bprog
 ? Mod([1,2;3,4], 2)
 %8 =
 [Mod(1, 2) Mod(0, 2)]
 
 [Mod(1, 2) Mod(0, 2)]
 ? Mod(3*x+5, 2)
 %9 = Mod(1, 2)*x + Mod(1, 2)
 ? Mod(x^2 + y*x + y^3, y^2+1)
 %10 = Mod(1, y^2 + 1)*x^2 + Mod(y, y^2 + 1)*x + Mod(-y, y^2 + 1)
 @eprog
 
 This function is not the same as $x$ \kbd{\%} $y$, the result of which
 has no knowledge of the intended modulus $y$. Compare
 \bprog
 ? x = 4 % 5; x + 1
 %11 = 5
 ? x = Mod(4,5); x + 1
 %12 = Mod(0,5)
 @eprog Note that such ``modular'' objects can be lifted via \tet{lift} or
 \tet{centerlift}. The modulus of a \typ{INTMOD} or \typ{POLMOD} $z$ can
 be recovered via \kbd{$z$.mod}.

Function: O
Class: basic
Section: polynomials
C-Name: ggrando
Prototype: 
Help: O(p^e): p-adic or power series zero with precision given by e.
Doc: if $p$ is an integer
 greater than $2$, returns a $p$-adic $0$ of precision $e$. In all other
 cases, returns a power series zero with precision given by $e v$, where $v$
 is the $X$-adic valuation of $p$ with respect to its main variable.
Variant: \fun{GEN}{zeropadic}{GEN p, long e} for a $p$-adic and
 \fun{GEN}{zeroser}{long v, long e} for a power series zero in variable $v$.

Function: O(_^_)
Class: basic
Section: programming/internals
C-Name: ggrando
Prototype: GD1,L,
Help: O(p^e): p-adic or power series zero with precision given by e.
Description: 
 (gen):gen          ggrando($1, 1)
 (1,small):gen      ggrando(gen_1, $2)
 (int,small):gen    zeropadic($1, $2)
 (gen,small):gen    ggrando($1, $2)
 (var,small):gen    zeroser($1, $2)

Function: Pi
Class: basic
Section: transcendental
C-Name: mppi
Prototype: p
Help: Pi=Pi(): the constant pi, with current precision.
Description: 
 ():real:prec        mppi($prec)
Doc: the constant $\pi$ ($3.14159\cdots$). Note that \kbd{Pi} is one of the few
 reserved names which cannot be used for user variables.

Function: Pol
Class: basic
Section: conversions
C-Name: gtopoly
Prototype: GDn
Help: Pol(t,{v='x}): convert t (usually a vector or a power series) into a
 polynomial with variable v, starting with the leading coefficient.
Description: 
 (gen,?var):pol  gtopoly($1, $2)
Doc: 
 transforms the object $t$ into a polynomial with main variable $v$. If $t$
 is a scalar, this gives a constant polynomial. If $t$ is a power series with
 nonnegative valuation or a rational function, the effect is similar to
 \kbd{truncate}, i.e.~we chop off the $O(X^k)$ or compute the Euclidean
 quotient of the numerator by the denominator, then change the main variable
 of the result to $v$.
 
 The main use of this function is when $t$ is a vector: it creates the
 polynomial whose coefficients are given by $t$, with $t[1]$ being the leading
 coefficient (which can be zero). It is much faster to evaluate
 \kbd{Pol} on a vector of coefficients in this way, than the corresponding
 formal expression $a_n X^n + \dots + a_0$, which is evaluated naively exactly
 as written (linear versus quadratic time in $n$). \tet{Polrev} can be used if
 one wants $x[1]$ to be the constant coefficient:
 \bprog
 ? Pol([1,2,3])
 %1 = x^2 + 2*x + 3
 ? Polrev([1,2,3])
 %2 = 3*x^2 + 2*x + 1
 @eprog\noindent
 The reciprocal function of \kbd{Pol} (resp.~\kbd{Polrev}) is \kbd{Vec} (resp.~
 \kbd{Vecrev}).
 \bprog
 ? Vec(Pol([1,2,3]))
 %1 = [1, 2, 3]
 ? Vecrev( Polrev([1,2,3]) )
 %2 = [1, 2, 3]
 @eprog\noindent
 
 \misctitle{Warning} This is \emph{not} a substitution function. It will not
 transform an object containing variables of higher priority than~$v$.
 \bprog
 ? Pol(x + y, y)
   ***   at top-level: Pol(x+y,y)
   ***                 ^----------
   *** Pol: variable must have higher priority in gtopoly.
 @eprog

Function: Polrev
Class: basic
Section: conversions
C-Name: gtopolyrev
Prototype: GDn
Help: Polrev(t,{v='x}): convert t (usually a vector or a power series) into a
 polynomial with variable v, starting with the constant term.
Description: 
 (gen,?var):pol  gtopolyrev($1, $2)
Doc: 
 transform the object $t$ into a polynomial
 with main variable $v$. If $t$ is a scalar, this gives a constant polynomial.
 If $t$ is a power series, the effect is identical to \kbd{truncate}, i.e.~it
 chops off the $O(X^k)$.
 
 The main use of this function is when $t$ is a vector: it creates the
 polynomial whose coefficients are given by $t$, with $t[1]$ being the
 constant term. \tet{Pol} can be used if one wants $t[1]$ to be the leading
 coefficient:
 \bprog
 ? Polrev([1,2,3])
 %1 = 3*x^2 + 2*x + 1
 ? Pol([1,2,3])
 %2 = x^2 + 2*x + 3
 @eprog
 The reciprocal function of \kbd{Pol} (resp.~\kbd{Polrev}) is \kbd{Vec} (resp.~
 \kbd{Vecrev}).

Function: Qfb
Class: basic
Section: conversions
C-Name: Qfb0
Prototype: GDGDG
Help: Qfb(a,{b},{c}): binary quadratic form a*x^2+b*x*y+c*y^2.
Doc: creates the binary quadratic form\sidx{binary quadratic form}
 $ax^2+bxy+cy^2$. Negative definite forms are not implemented,
 use their positive definite counterpart instead.
 The syntax Qfb([a,b,c]) is also accepted.

Function: Ser
Class: basic
Section: conversions
C-Name: Ser0
Prototype: GDnDGDP
Help: Ser(s,{v='x},{d=seriesprecision}): convert s into a power series with
 variable v and precision d, starting with the constant coefficient.
Doc: transforms the object $s$ into a power series with main variable $v$
 ($x$ by default) and precision (number of significant terms) equal to
 $d \geq 0$ ($d = \kbd{seriesprecision}$ by default). If $s$ is a
 scalar, this gives a constant power series in $v$ with precision \kbd{d}.
 If $s$ is a polynomial, the polynomial is truncated to $d$ terms if needed
 \bprog
 ? \ps
   seriesprecision = 16 significant terms
 ? Ser(1)  \\ 16 terms by default
 %1 = 1 + O(x^16)
 ? Ser(1, 'y, 5)
 %2 = 1 + O(y^5)
 ? Ser(x^2,, 5)
 %3 = x^2 + O(x^7)
 ? T = polcyclo(100)
 %4 = x^40 - x^30 + x^20 - x^10 + 1
 ? Ser(T, 'x, 11)
 %5 = 1 - x^10 + O(x^11)
 @eprog\noindent The function is more or less equivalent with multiplication by
 $1 + O(v^d)$ in theses cases, only faster.
 
 For the remaining types, vectors and power series, we first explain what
 occurs if $d$ is omitted. In this case, the function uses exactly the amount
 of information given in the input:
 
 \item If $s$ is already a power series in $v$, we return it verbatim;
 
 \item If $s$ is a vector, the coefficients of the vector are
 understood to be the coefficients of the power series starting from the
 constant term (as in \tet{Polrev}$(x)$); in other words we convert
 \typ{VEC} / \typ{COL} to the power series whose significant terms are exactly
 given by the vector entries.
 
 On the other hand, if $d$ is explicitly given, we abide by its value
 and return a series, truncated or extended with zeros as needed, with
 $d$ significant terms.
 
 \bprog
 ? v = [1,2,3];
 ? Ser(v, t) \\ 3 terms: seriesprecision is ignored!
 %7 = 1 + 2*t + 3*t^2 + O(t^3)
 ? Ser(v, t, 7)  \\ 7 terms as explicitly requested
 %8 = 1 + 2*t + 3*t^2 + O(t^7)
 ? s = 1+x+O(x^2);
 ? Ser(s)
 %10 = 1 + x + O(x^2)  \\ 2 terms: seriesprecision is ignored
 ? Ser(s, x, 7)  \\ extend to 7 terms
 %11 = 1 + x + O(x^7)
 ? Ser(s, x, 1)  \\ truncate to 1 term
 %12 = 1 + O(x)
 @eprog\noindent
 The warning given for \kbd{Pol} also applies here: this is not a substitution
 function.

Function: Set
Class: basic
Section: conversions
C-Name: gtoset
Prototype: DG
Help: Set({x=[]}): convert x into a set, i.e. a row vector with strictly
 increasing coefficients. Empty set if x is omitted.
Description: 
 ():vec           cgetg(1,t_VEC)
 (gen):vec        gtoset($1)
Doc: 
 converts $x$ into a set, i.e.~into a row vector, with strictly increasing
 entries with respect to the (somewhat arbitrary) universal comparison function
 \tet{cmp}. Standard container types \typ{VEC}, \typ{COL}, \typ{LIST} and
 \typ{VECSMALL} are converted to the set with corresponding elements. All
 others are converted to a set with one element.
 \bprog
 ? Set([1,2,4,2,1,3])
 %1 = [1, 2, 3, 4]
 ? Set(x)
 %2 = [x]
 ? Set(Vecsmall([1,3,2,1,3]))
 %3 = [1, 2, 3]
 @eprog

Function: Str
Class: basic
Section: conversions
C-Name: Str
Prototype: s*
Help: Str({x}*): concatenates its (string) argument into a single string.
Description: 
 (gen):genstr:copy:parens      $genstr:1
 (gen,gen):genstr              Str(mkvec2($1, $2))
 (gen,gen,gen):genstr          Str(mkvec3($1, $2, $3))
 (gen,gen,gen,gen):genstr      Str(mkvec4($1, $2, $3, $4))
 (gen,...):genstr              Str(mkvecn($#, $2))
Doc: 
 converts its argument list into a
 single character string (type \typ{STR}, the empty string if $x$ is omitted).
 To recover an ordinary \kbd{GEN} from a string, apply \kbd{eval} to it. The
 arguments of \kbd{Str} are evaluated in string context, see \secref{se:strings}.
 
 \bprog
 ? x2 = 0; i = 2; Str(x, i)
 %1 = "x2"
 ? eval(%)
 %2 = 0
 @eprog\noindent
 This function is mostly useless in library mode. Use the pair
 \tet{strtoGEN}/\tet{GENtostr} to convert between \kbd{GEN} and \kbd{char*}.
 The latter returns a malloced string, which should be freed after usage.
 %\syn{NO}

Function: Strchr
Class: basic
Section: programming/specific
C-Name: pari_strchr
Prototype: G
Obsolete: 2018-10-01
Help: Strchr(x): deprecated alias for strchr.
Doc: deprecated alias for strchr.

Function: Strexpand
Class: basic
Section: programming/specific
C-Name: strexpand
Prototype: s*
Obsolete: 2018-10-01
Help: Strexpand({x}*): deprecated alias for strexpand
Doc: deprecated alias for strexpand

Function: Strprintf
Class: basic
Section: programming/specific
C-Name: strprintf
Prototype: ss*
Obsolete: 2018-10-01
Help: Strprintf(fmt,{x}*): deprecated alias for strprintf.
Doc: deprecated alias for strprintf.

Function: Strtex
Class: basic
Section: programming/specific
C-Name: strtex
Prototype: s*
Obsolete: 2018-10-01
Help: Strtex({x}*): deprecated alias for strtex.
Doc: deprecated alias for strtex.

Function: Vec
Class: basic
Section: conversions
C-Name: gtovec0
Prototype: GD0,L,
Help: Vec(x, {n}): transforms the object x into a vector of dimension n.
Description: 
 (gen):vec        gtovec($1)
Doc: transforms the object $x$ into a row vector. The dimension of the
 resulting vector can be optionally specified via the extra parameter $n$.
 If $n$ is omitted or $0$, the dimension depends on the type of $x$; the
 vector has a single component, except when $x$ is
 
 \item a vector or a quadratic form: returns the initial object considered as a
 row vector,
 
 \item a polynomial or a power series: returns a vector consisting of the
 coefficients. In the case of a polynomial, the coefficients of the vector
 start with the leading coefficient of the polynomial, while for power series
 only the significant coefficients are taken into account, but this time by
 increasing order of degree. In particular the valuation is ignored
 (which makes the function useful for series of negative valuation):
 \bprog
 ? Vec(3*x^2 + x)
 %1 = [3, 1, 0]
 ? Vec(x^2 + 3*x^3 + O(x^5))
 %2 = [1, 3, 0]
 ? Vec(x^-2 + 3*x^-1 + O(x))
 %3 = [1, 3, 0]
 @eprog\noindent \kbd{Vec} is the reciprocal function of \kbd{Pol} for a
 polynomial and of \kbd{Ser} for power series of valuation $0$.
 
 \item a matrix: returns the vector of columns comprising the matrix,
 \bprog
 ? m = [1,2,3;4,5,6]
 %4 =
 [1 2 3]
 
 [4 5 6]
 ? Vec(m)
 %5 = [[1, 4]~, [2, 5]~, [3, 6]~]
 @eprog
 
 \item a character string: returns the vector of individual characters,
 \bprog
 ? Vec("PARI")
 %6 = ["P", "A", "R", "I"]
 @eprog
 
 \item a map: returns the vector of the domain of the map,
 
 \item an error context (\typ{ERROR}): returns the error components, see
 \tet{iferr}.
 
 In the last four cases (matrix, character string, map, error), $n$ is
 meaningless and must be omitted or an error is raised. Otherwise, if $n$ is
 given, $0$ entries are appended at the end of the vector if $n > 0$, and
 prepended at the beginning if $n < 0$. The dimension of the resulting vector
 is $|n|$. This allows to write a conversion function for series that
 takes positive valuations into account:
 \bprog
 ? serVec(s) = Vec(s, -serprec(s,variable(s)));
 ? Vec(x^2 + 3*x^3 + O(x^5))
 %2 = [0, 0, 1, 3, 0]
 @eprog (That function is not intended for series of negative valuation.)
Variant: \fun{GEN}{gtovec}{GEN x} is also available.

Function: Vecrev
Class: basic
Section: conversions
C-Name: gtovecrev0
Prototype: GD0,L,
Help: Vecrev(x, {n}): transforms the object x into a vector of dimension n
 in reverse order with respect to Vec(x, {n}).
Description: 
 (gen):vec     gtovecrev($1)
Doc: 
 as $\kbd{Vec}(x, -n)$, then reverse the result. In particular,
 \kbd{Vecrev} is the reciprocal function of \kbd{Polrev}: the
 coefficients of the vector start with the constant coefficient of the
 polynomial and the others follow by increasing degree.
Variant: \fun{GEN}{gtovecrev}{GEN x} is also available.

Function: Vecsmall
Class: basic
Section: conversions
C-Name: gtovecsmall0
Prototype: GD0,L,
Help: Vecsmall(x, {n}): transforms the object x into a VECSMALL of dimension n.
Description: 
 (gen):vecsmall                gtovecsmall($1)
Doc: 
 transforms the object $x$ into a row vector of type \typ{VECSMALL}. The
 dimension of the resulting vector can be optionally specified via the extra
 parameter $n$.
 
 This acts as \kbd{Vec}$(x,n)$, but only on a limited set of objects:
 the result must be representable as a vector of small integers.
 If $x$ is a character string, a vector of individual characters in ASCII
 encoding is returned (\tet{strchr} yields back the character string).
Variant: \fun{GEN}{gtovecsmall}{GEN x} is also available.

Function: [_.._]
Class: basic
Section: programming/internals
C-Name: vecrange
Prototype: GG
Help: [a..b] = [a,a+1,...,b]
Description: 
 (gen,gen):vec     vecrange($1, $2)
 (small,small):vec vecrangess($1, $2)

Function: [_|_<-_,_;_]
Class: basic
Section: programming/internals
C-Name: vecexpr1
Prototype: mGVDEDE
Help: [a(x)|x<-b,c(x);...]
Wrapper: (,,G,bG)
Description: 
 (gen,,closure):gen         veccatapply(${3 cookie}, ${3 wrapper}, $1)
 (gen,,closure,closure):gen veccatselapply(${4 cookie}, ${4 wrapper}, ${3 cookie}, ${3 wrapper}, $1)

Function: [_|_<-_,_]
Class: basic
Section: programming/internals
C-Name: vecexpr0
Prototype: GVDEDE
Help: [a(x)|x<-b,c(x)] = apply(a,select(c,b))
Wrapper: (,,G,bG)
Description: 
 (gen,,closure):gen         vecapply(${3 cookie}, ${3 wrapper}, $1)
 (gen,,,closure):gen        vecselect(${4 cookie}, ${4 wrapper}, $1)
 (gen,,closure,closure):gen vecselapply(${4 cookie}, ${4 wrapper}, ${3 cookie}, ${3 wrapper}, $1)

Function: _!
Class: basic
Section: symbolic_operators
C-Name: mpfact
Prototype: L
Help: n!: factorial of n.
Description: 
 (small):int                        mpfact($1)

Function: _!=_
Class: basic
Section: symbolic_operators
C-Name: gne
Prototype: GG
Help: a!=b: true if a and b are not equal.
Description: 
 (small, small):bool:parens             $(1) != $(2)
 (lg, lg):bool:parens                   $(1) != $(2)
 (small, int):negbool                   equalsi($1, $2)
 (int, small):negbool                   equalis($1, $2)
 (int, 1):negbool                       equali1($1)
 (int, -1):negbool                      equalim1($1)
 (int, int):negbool                     equalii($1, $2)
 (real,real):negbool                    equalrr($1, $2)
 (mp, mp):bool:parens                   mpcmp($1, $2) != 0
 (errtyp, errtyp):bool:parens           $(1) != $(2)
 (errtyp, #str):bool:parens             $(1) != $(errtyp:2)
 (#str, errtyp):bool:parens             $(errtyp:1) != $(2)
 (typ, typ):bool:parens                 $(1) != $(2)
 (typ, #str):bool:parens                $(1) != $(typ:2)
 (#str, typ):bool:parens                $(typ:1) != $(2)
 (str, str):bool                        strcmp($1, $2)
 (small, gen):negbool                   gequalsg($1, $2)
 (gen, small):negbool                   gequalgs($1, $2)
 (gen, gen):negbool                     gequal($1, $2)

Function: _%=_
Class: basic
Section: symbolic_operators
C-Name: gmode
Prototype: &G
Help: x%=y: shortcut for x=x%y.
Description: 
 (*small, small):small:parens            $1 = smodss($1, $2)
 (*int, small):int:parens                $1 = modis($1, $2)
 (*int, int):int:parens                  $1 = modii($1, $2)
 (*pol, gen):gen:parens                  $1 = gmod($1, $2)
 (*gen, small):gen:parens                $1 = gmodgs($1, $2)
 (*gen, gen):gen:parens                  $1 = gmod($1, $2)

Function: _%_
Class: basic
Section: symbolic_operators
C-Name: gmod
Prototype: GG
Help: x%y: Euclidean remainder of x and y.
Description: 
 (small, small):small            smodss($1, $2)
 (small, int):int                modsi($1, $2)
 (int, small):small              smodis($1, $2)
 (int, int):int                  modii($1, $2)
 (gen, small):gen                gmodgs($1, $2)
 (small, gen):gen                gmodsg($1, $2)
 (gen, gen):gen                  gmod($1, $2)
 
 (FpX,FpX):FpX                   FpX_rem($1, $2, p)
 (FqX,FqX):FqX                   FqX_rem($1, $2, T, p)

Function: _&&_
Class: basic
Section: symbolic_operators
C-Name: andpari
Prototype: GE
Help: a&&b: boolean operator "and".
Description: 
 (bool, bool):bool:parens               $(1) && $(2)

Function: _'
Class: basic
Section: symbolic_operators
C-Name: deriv
Prototype: GDn
Help: x': derivative of x with respect to the main variable.

Function: _'_
Class: basic
Section: symbolic_operators
C-Name: derivn
Prototype: GLDn
Help: x': derivative of x with respect to the main variable.
Description: 
 (gen,1):gen                      deriv($1, -1)
 
 (FpX,1):FpX                      FpX_deriv($1, p)
 (FqX,1):FqX                      FqX_deriv($1, T, p)

Function: _(_)
Class: basic
Section: symbolic_operators
Help: f(a,b,...): evaluate the function f on a,b,...
Description: 
 (gen):gen          closure_callgenall($1, 0)
 (gen,gen):gen      closure_callgen1($1, $2)
 (gen,gen,gen):gen  closure_callgen2($1, $2, $3)
 (gen,gen,...):gen  closure_callgenall($1, ${nbarg 1 sub}, $3)

Function: _*=_
Class: basic
Section: symbolic_operators
C-Name: gmule
Prototype: &G
Help: x*=y: shortcut for x=x*y.
Description: 
 (*small, small):small:parens             $1 *= $(2)
 (*int, small):int:parens                 $1 = mulis($1, $2)
 (*int, int):int:parens                   $1 = mulii($1, $2)
 (*real, small):real:parens               $1 = mulrs($1, $2)
 (*real, int):real:parens                 $1 = mulri($1, $2)
 (*real, real):real:parens                $1 = mulrr($1, $2)
 (*mp, mp):mp:parens                      $1 = mpmul($1, $2)
 (*pol, small):gen:parens                 $1 = gmulgs($1, $2)
 (*pol, gen):gen:parens                   $1 = gmul($1, $2)
 (*vec, gen):gen:parens                   $1 = gmul($1, $2)
 (*gen, small):gen:parens                 $1 = gmulgs($1, $2)
 (*gen, gen):gen:parens                   $1 = gmul($1, $2)

Function: _*_
Class: basic
Section: symbolic_operators
C-Name: gmul
Prototype: GG
Help: x*y: product of x and y.
Description: 
 (small, small):small:parens     $(1)*$(2)
 (int, small):int                mulis($1, $2)
 (small, int):int                mulsi($1, $2)
 (int, int):int                  mulii($1, $2)
 (0, mp):small                   ($2, 0)/*for side effect*/
 (#small, real):real             mulsr($1, $2)
 (small, real):mp                gmulsg($1, $2)
 (mp, 0):small                   ($1, 0)/*for side effect*/
 (real, #small):real             mulrs($1, $2)
 (real, small):mp                gmulgs($1, $2)
 (real, real):real               mulrr($1, $2)
 (mp, mp):mp                     gmul($1, $2)
 (gen, small):gen                gmulgs($1, $2)
 (small, gen):gen                gmulsg($1, $2)
 (vecsmall, vecsmall):vecsmall   perm_mul($1, $2)
 (gen, gen):gen                  gmul($1, $2)
 
 (usmall,Fp):Fp                  Fp_mulu($2, $1, p)
 (small,Fp):Fp                   Fp_muls($2, $1, p)
 (Fp, usmall):Fp                 Fp_mulu($1, $2, p)
 (Fp, small):Fp                  Fp_muls($1, $2, p)
 (usmall,FpX):FpX                FpX_mulu($2, $1, p)
 (FpX, usmall):FpX               FpX_mulu($1, $2, p)
 (Fp, FpX):FpX                   FpX_Fp_mul($2, $1, p)
 (FpX, Fp):FpX                   FpX_Fp_mul($1, $2, p)
 (FpX, FpX):FpX                  FpX_mul($1, $2, p)
 
 (usmall,Fq):Fq                  Fq_mulu($2, $1, T, p)
 (Fq, usmall):Fq                 Fq_mulu($1, $2, T, p)
 (Fq,Fp):Fq                      Fq_Fp_mul($1, $2, T, p)
 (Fp,Fq):Fq                      Fq_Fp_mul($2, $1, T, p)
 (usmall,FqX):FqX                FqX_mulu($2, $1, T, p)
 (FqX, usmall):FqX               FqX_mulu($1, $2, T, p)
 (FqX,Fp):FqX                    FqX_Fp_mul($1, $2, T, p)
 (Fp,FqX):FqX                    FqX_Fp_mul($2, $1, T, p)
 (Fq, FqX):FqX                   FqX_Fq_mul($2, $1, T, p)
 (FqX, Fq):FqX                   FqX_Fq_mul($1, $2, T, p)
 (FqX, FqX):FqX                  FqX_mul($1, $2, T, p)

Function: _++
Class: basic
Section: symbolic_operators
C-Name: gadd1e
Prototype: &
Help: x++: set x to x+1.
Description: 
 (*bptr):bptr                            ++$1
 (*small):small                          ++$1
 (*lg):lg                                ++$1
 (*int):int:parens                       $1 = addis($1, 1)
 (*real):real:parens                     $1 = addrs($1, 1)
 (*mp):mp:parens                         $1 = mpadd($1, gen_1)
 (*pol):pol:parens                       $1 = gaddgs($1, 1)
 (*gen):gen:parens                       $1 = gaddgs($1, 1)

Function: _+=_
Class: basic
Section: symbolic_operators
C-Name: gadde
Prototype: &G
Help: x+=y: shortcut for x=x+y.
Description: 
 (*small, small):small:parens             $1 += $(2)
 (*lg, small):lg:parens                   $1 += $(2)
 (*int, small):int:parens                 $1 = addis($1, $2)
 (*int, int):int:parens                   $1 = addii($1, $2)
 (*real, small):real:parens               $1 = addrs($1, $2)
 (*real, int):real:parens                 $1 = addir($2, $1)
 (*real, real):real:parens                $1 = addrr($1, $2)
 (*mp, mp):mp:parens                      $1 = mpadd($1, $2)
 (*pol, small):gen:parens                 $1 = gaddgs($1, $2)
 (*pol, gen):gen:parens                   $1 = gadd($1, $2)
 (*vec, gen):gen:parens                   $1 = gadd($1, $2)
 (*gen, small):gen:parens                 $1 = gaddgs($1, $2)
 (*gen, gen):gen:parens                   $1 = gadd($1, $2)

Function: _+_
Class: basic
Section: symbolic_operators
C-Name: gadd
Prototype: GG
Help: x+y: sum of x and y.
Description: 
 (lg, 1):small:parens            $(1)
 (small, small):small:parens     $(1) + $(2)
 (lg, small):lg:parens           $(1) + $(2)
 (small, lg):lg:parens           $(1) + $(2)
 (int, small):int                addis($1, $2)
 (small, int):int                addsi($1, $2)
 (int, int):int                  addii($1, $2)
 (real, small):real              addrs($1, $2)
 (small, real):real              addsr($1, $2)
 (real, real):real               addrr($1, $2)
 (mp, real):real                 mpadd($1, $2)
 (real, mp):real                 mpadd($1, $2)
 (mp, mp):mp                     mpadd($1, $2)
 (gen, small):gen                gaddgs($1, $2)
 (small, gen):gen                gaddsg($1, $2)
 (gen, gen):gen                  gadd($1, $2)
 
 (Fp, Fp):Fp                     Fp_add($1, $2, p)
 (FpX, Fp):FpX                   FpX_Fp_add($1, $2, p)
 (Fp, FpX):FpX                   FpX_Fp_add($2, $1, p)
 (FpX, FpX):FpX                  FpX_add($1, $2, p)
 (Fq, Fq):Fq                     Fq_add($1, $2, T, p)
 (FqX, Fq):FqX                   FqX_Fq_add($1, $2, T, p)
 (Fq, FqX):FqX                   FqX_Fq_add($2, $1, T, p)
 (FqX, FqX):FqX                  FqX_add($1, $2, T, p)

Function: _--
Class: basic
Section: symbolic_operators
C-Name: gsub1e
Prototype: &
Help: x--: set x to x-1.
Description: 
 (*bptr):bptr                          --$1
 (*small):small                        --$1
 (*lg):lg                              --$1
 (*int):int:parens                     $1 = subis($1, 1)
 (*real):real:parens                   $1 = subrs($1, 1)
 (*mp):mp:parens                       $1 = mpsub($1, gen_1)
 (*pol):pol:parens                     $1 = gsubgs($1, 1)
 (*gen):gen:parens                     $1 = gsubgs($1, 1)

Function: _-=_
Class: basic
Section: symbolic_operators
C-Name: gsube
Prototype: &G
Help: x-=y: shortcut for x=x-y.
Description: 
 (*small, small):small:parens             $1 -= $(2)
 (*lg, small):lg:parens                   $1 -= $(2)
 (*int, small):int:parens                 $1 = subis($1, $2)
 (*int, int):int:parens                   $1 = subii($1, $2)
 (*real, small):real:parens               $1 = subrs($1, $2)
 (*real, int):real:parens                 $1 = subri($1, $2)
 (*real, real):real:parens                $1 = subrr($1, $2)
 (*mp, mp):mp:parens                      $1 = mpsub($1, $2)
 (*pol, small):gen:parens                 $1 = gsubgs($1, $2)
 (*pol, gen):gen:parens                   $1 = gsub($1, $2)
 (*vec, gen):gen:parens                   $1 = gsub($1, $2)
 (*gen, small):gen:parens                 $1 = gsubgs($1, $2)
 (*gen, gen):gen:parens                   $1 = gsub($1, $2)

Function: _-_
Class: basic
Section: symbolic_operators
C-Name: gsub
Prototype: GG
Help: x-y: difference of x and y.
Description: 
 (small, small):small:parens     $(1) - $(2)
 (lg, small):lg:parens           $(1) - $(2)
 (int, small):int                subis($1, $2)
 (small, int):int                subsi($1, $2)
 (int, int):int                  subii($1, $2)
 (real, small):real              subrs($1, $2)
 (small, real):real              subsr($1, $2)
 (real, real):real               subrr($1, $2)
 (mp, real):real                 mpsub($1, $2)
 (real, mp):real                 mpsub($1, $2)
 (mp, mp):mp                     mpsub($1, $2)
 (gen, small):gen                gsubgs($1, $2)
 (small, gen):gen                gsubsg($1, $2)
 (gen, gen):gen                  gsub($1, $2)
 
 (Fp, Fp):Fp                     Fp_sub($1, $2, p)
 (Fp, FpX):FpX                   Fp_FpX_sub($1, $2, p)
 (FpX, Fp):FpX                   FpX_Fp_sub($1, $2, p)
 (FpX, FpX):FpX                  FpX_sub($1, $2, p)
 (Fq, Fq):Fq                     Fq_sub($1, $2, T, p)
 (FqX, Fq):FqX                   FqX_Fq_sub($1, $2, T, p)
 (FqX, FqX):FqX                  FqX_sub($1, $2, T, p)

Function: _.a1
Class: basic
Section: member_functions
C-Name: member_a1
Prototype: mG
Help: _.a1
Description: 
 (ell):gen:copy        ell_get_a1($1)

Function: _.a2
Class: basic
Section: member_functions
C-Name: member_a2
Prototype: mG
Help: _.a2
Description: 
 (ell):gen:copy        ell_get_a2($1)

Function: _.a3
Class: basic
Section: member_functions
C-Name: member_a3
Prototype: mG
Help: _.a3
Description: 
 (ell):gen:copy        ell_get_a3($1)

Function: _.a4
Class: basic
Section: member_functions
C-Name: member_a4
Prototype: mG
Help: _.a4
Description: 
 (ell):gen:copy        ell_get_a4($1)

Function: _.a6
Class: basic
Section: member_functions
C-Name: member_a6
Prototype: mG
Help: _.a6
Description: 
 (ell):gen:copy         ell_get_a6($1)

Function: _.area
Class: basic
Section: member_functions
C-Name: member_area
Prototype: mG
Help: _.area

Function: _.b2
Class: basic
Section: member_functions
C-Name: member_b2
Prototype: mG
Help: _.b2
Description: 
 (ell):gen:copy         ell_get_b2($1)

Function: _.b4
Class: basic
Section: member_functions
C-Name: member_b4
Prototype: mG
Help: _.b4
Description: 
 (ell):gen:copy        ell_get_b4($1)

Function: _.b6
Class: basic
Section: member_functions
C-Name: member_b6
Prototype: mG
Help: _.b6
Description: 
 (ell):gen:copy               ell_get_b6($1)

Function: _.b8
Class: basic
Section: member_functions
C-Name: member_b8
Prototype: mG
Help: _.b8
Description: 
 (ell):gen:copy        ell_get_b8($1)

Function: _.bid
Class: basic
Section: member_functions
C-Name: member_bid
Prototype: mG
Help: _.bid
Description: 
 (bnr):gen:copy                 bnr_get_bid($1)
 (gen):gen:copy                 member_bid($1)

Function: _.bnf
Class: basic
Section: member_functions
C-Name: member_bnf
Prototype: mG
Help: _.bnf
Description: 
 (bnf):bnf:parens               $1
 (bnr):bnf:copy:parens          $bnf:1
 (gen):bnf:copy                 member_bnf($1)

Function: _.c4
Class: basic
Section: member_functions
C-Name: member_c4
Prototype: mG
Help: _.c4
Description: 
 (ell):gen:copy        ell_get_c4($1)

Function: _.c6
Class: basic
Section: member_functions
C-Name: member_c6
Prototype: mG
Help: _.c6
Description: 
 (ell):gen:copy        ell_get_c6($1)

Function: _.clgp
Class: basic
Section: member_functions
C-Name: member_clgp
Prototype: mG
Help: _.clgp
Description: 
 (bnf):clgp:copy:parens         $clgp:1
 (bnr):clgp:copy:parens         $clgp:1
 (clgp):clgp:parens             $1
 (gen):clgp:copy                member_clgp($1)

Function: _.codiff
Class: basic
Section: member_functions
C-Name: member_codiff
Prototype: mG
Help: _.codiff

Function: _.cyc
Class: basic
Section: member_functions
C-Name: member_cyc
Prototype: mG
Help: _.cyc
Description: 
 (bnr):vec:copy                 bnr_get_cyc($1)
 (bnf):vec:copy                 bnf_get_cyc($1)
 (clgp):vec:copy                gel($1, 2)
 (gen):vec:copy                 member_cyc($1)

Function: _.diff
Class: basic
Section: member_functions
C-Name: member_diff
Prototype: mG
Help: _.diff
Description: 
 (nf):gen:copy                  nf_get_diff($1)
 (gen):gen:copy                 member_diff($1)

Function: _.disc
Class: basic
Section: member_functions
C-Name: member_disc
Prototype: mG
Help: _.disc
Description: 
 (nf):int:copy                  nf_get_disc($1)
 (ell):gen:copy                 ell_get_disc($1)
 (gen):gen:copy                 member_disc($1)

Function: _.e
Class: basic
Section: member_functions
C-Name: member_e
Prototype: mG
Help: _.e
Description: 
 (prid):small        pr_get_e($1)

Function: _.eta
Class: basic
Section: member_functions
C-Name: member_eta
Prototype: mG
Help: _.eta

Function: _.f
Class: basic
Section: member_functions
C-Name: member_f
Prototype: mG
Help: _.f
Description: 
 (prid):small       pr_get_f($1)

Function: _.fu
Class: basic
Section: member_functions
C-Name: member_fu
Prototype: G
Help: _.fu
Description: 
 (bnr):void                $"ray units not implemented"
 (bnf):gen:copy         bnf_get_fu($1)
 (gen):gen              member_fu($1)

Function: _.gen
Class: basic
Section: member_functions
C-Name: member_gen
Prototype: mG
Help: _.gen
Description: 
 (bnr):vec:copy        bnr_get_gen($1)
 (bnf):vec:copy        bnf_get_gen($1)
 (gal):vecvecsmall:copy        gal_get_gen($1)
 (clgp):vec:copy       gel($1, 3)
 (prid):gen:copy       pr_get_gen($1)
 (gen):gen:copy        member_gen($1)

Function: _.group
Class: basic
Section: member_functions
C-Name: member_group
Prototype: mG
Help: _.group
Description: 
 (gal):vecvecsmall:copy        gal_get_group($1)
 (gen):vecvecsmall:copy        member_group($1)

Function: _.index
Class: basic
Section: member_functions
C-Name: member_index
Prototype: mG
Help: _.index
Description: 
 (nf):int:copy                  nf_get_index($1)
 (gen):int:copy                 member_index($1)

Function: _.j
Class: basic
Section: member_functions
C-Name: member_j
Prototype: mG
Help: _.j
Description: 
 (ell):gen:copy        ell_get_j($1)

Function: _.mod
Class: basic
Section: member_functions
C-Name: member_mod
Prototype: mG
Help: _.mod

Function: _.nf
Class: basic
Section: member_functions
C-Name: member_nf
Prototype: mG
Help: _.nf
Description: 
 (nf):nf:parens                $1
 (gen):nf:copy                 member_nf($1)

Function: _.no
Class: basic
Section: member_functions
C-Name: member_no
Prototype: mG
Help: _.no
Description: 
 (bnr):int:copy                 bnr_get_no($1)
 (bnf):int:copy                 bnf_get_no($1)
 (clgp):int:copy                gel($1, 1)
 (gen):int:copy                 member_no($1)

Function: _.omega
Class: basic
Section: member_functions
C-Name: member_omega
Prototype: mG
Help: _.omega

Function: _.orders
Class: basic
Section: member_functions
C-Name: member_orders
Prototype: mG
Help: _.orders
Description: 
 (gal):vecsmall:copy   gal_get_orders($1)

Function: _.p
Class: basic
Section: member_functions
C-Name: member_p
Prototype: mG
Help: _.p
Description: 
 (gal):int:copy                 gal_get_p($1)
 (prid):int:copy                pr_get_p($1)
 (gen):int:copy                 member_p($1)

Function: _.pol
Class: basic
Section: member_functions
C-Name: member_pol
Prototype: mG
Help: _.pol
Description: 
 (gal):gen:copy                 gal_get_pol($1)
 (nf):gen:copy                  nf_get_pol($1)
 (gen):gen:copy                 member_pol($1)

Function: _.polabs
Class: basic
Section: member_functions
C-Name: member_polabs
Prototype: mG
Help: _.polabs

Function: _.r1
Class: basic
Section: member_functions
C-Name: member_r1
Prototype: mG
Help: _.r1
Description: 
 (nf):small                     nf_get_r1($1)
 (gen):int:copy                 member_r1($1)

Function: _.r2
Class: basic
Section: member_functions
C-Name: member_r2
Prototype: mG
Help: _.r2
Description: 
 (nf):small                     nf_get_r2($1)
 (gen):int:copy                 member_r2($1)

Function: _.reg
Class: basic
Section: member_functions
C-Name: member_reg
Prototype: mG
Help: _.reg
Description: 
 (bnr):real             $"ray regulator not implemented"
 (bnf):real:copy        bnf_get_reg($1)
 (gen):real:copy        member_reg($1)

Function: _.roots
Class: basic
Section: member_functions
C-Name: member_roots
Prototype: mG
Help: _.roots
Description: 
 (gal):vec:copy                 gal_get_roots($1)
 (nf):vec:copy                  nf_get_roots($1)
 (gen):vec:copy                 member_roots($1)

Function: _.sign
Class: basic
Section: member_functions
C-Name: member_sign
Prototype: mG
Help: _.sign
Description: 
 (nf):vec:copy                  gel($1, 2)
 (gen):vec:copy                 member_sign($1)

Function: _.t2
Class: basic
Section: member_functions
C-Name: member_t2
Prototype: G
Help: _.t2
Description: 
 (gen):vec                      member_t2($1)

Function: _.tate
Class: basic
Section: member_functions
C-Name: member_tate
Prototype: mG
Help: _.tate

Function: _.tu
Class: basic
Section: member_functions
C-Name: member_tu
Prototype: G
Help: _.tu
Description: 
 (gen):gen:copy        member_tu($1)

Function: _.zk
Class: basic
Section: member_functions
C-Name: member_zk
Prototype: mG
Help: _.zk
Description: 
 (nf):vec:copy         nf_get_zk($1)
 (gen):vec:copy        member_zk($1)

Function: _.zkst
Class: basic
Section: member_functions
C-Name: member_zkst
Prototype: mG
Help: _.zkst
Description: 
 (bnr):gen:copy        bnr_get_bid($1)

Function: _/=_
Class: basic
Section: symbolic_operators
C-Name: gdive
Prototype: &G
Help: x/=y: shortcut for x=x/y.
Description: 
 (*small, gen):void                $"cannot divide small: use \= instead."
 (*int, gen):void                  $"cannot divide int: use \= instead."
 (*real, real):real:parens               $1 = divrr($1, $2)
 (*real, small):real:parens              $1 = divrs($1, $2)
 (*real, mp):real:parens                 $1 = mpdiv($1, $2)
 (*mp, real):mp:parens                   $1 = mpdiv($1, $2)
 (*pol, gen):gen:parens                  $1 = gdiv($1, $2)
 (*vec, gen):gen:parens                  $1 = gdiv($1, $2)
 (*gen, small):gen:parens                $1 = gdivgs($1, $2)
 (*gen, gen):gen:parens                  $1 = gdiv($1, $2)

Function: _/_
Class: basic
Section: symbolic_operators
C-Name: gdiv
Prototype: GG
Help: x/y: quotient of x and y.
Description: 
 (0, mp):small                   ($2, 0)/*for side effect*/
 (1, real):real                  invr($2)
 (#small, real):real             divsr($1, $2)
 (small, real):mp                divsr($1, $2)
 (real, small):real              divrs($1, $2)
 (real, real):real               divrr($1, $2)
 (real, mp):real                 mpdiv($1, $2)
 (mp, real):mp                   mpdiv($1, $2)
 (1, gen):gen                    ginv($2)
 (gen, small):gen                gdivgs($1, $2)
 (small, gen):gen                gdivsg($1, $2)
 (gen, gen):gen                  gdiv($1, $2)
 
 (Fp, 2):Fp                       Fp_halve($1, p)
 (Fp, Fp):Fp                     Fp_div($1, $2, p)
 (Fq, 2):Fq                       Fq_halve($1, T, p)
 (Fq, Fq):Fq                     Fq_div($1, $2, T, p)

Function: _<<=_
Class: basic
Section: symbolic_operators
C-Name: gshiftle
Prototype: &L
Help: x<<=y: shortcut for x=x<<y.
Description: 
 (*small, small):small:parens             $1 <<= $(2)
 (*int, small):int:parens                 $1 = shifti($1, $2)
 (*mp, small):mp:parens                   $1 = mpshift($1, $2)
 (*gen, small):mp:parens                  $1 = gshift($1, $2)

Function: _<<_
Class: basic
Section: symbolic_operators
C-Name: gshift
Prototype: GL
Help: x<<y: compute shift(x,y).
Description: 
 (int, small):int               shifti($1, $2)
 (mp, small):mp                 mpshift($1, $2)
 (gen, small):mp                gshift($1, $2)

Function: _<=_
Class: basic
Section: symbolic_operators
C-Name: gle
Prototype: GG
Help: x<=y: return 1 if x is less or equal to y, 0 otherwise.
Description: 
 (small, small):bool:parens              $(1) <= $(2)
 (small, lg):bool:parens                 $(1) < $(2)
 (lg, lg):bool:parens                    $(1) <= $(2)
 (small, int):bool:parens                cmpsi($1, $2) <= 0
 (int, lg):bool:parens                   cmpis($1, $2) < 0
 (int, small):bool:parens                cmpis($1, $2) <= 0
 (int, int):bool:parens                  cmpii($1, $2) <= 0
 (mp, mp):bool:parens                    mpcmp($1, $2) <= 0
 (str, str):bool:parens                  strcmp($1, $2) <= 0
 (small, gen):bool:parens                gcmpsg($1, $2) <= 0
 (gen, small):bool:parens                gcmpgs($1, $2) <= 0
 (gen, gen):bool:parens                  gcmp($1, $2) <= 0

Function: _<_
Class: basic
Section: symbolic_operators
C-Name: glt
Prototype: GG
Help: x<y: return 1 if x is strictly less than y, 0 otherwise.
Description: 
 (small, small):bool:parens              $(1) < $(2)
 (lg, lg):bool:parens                    $(1) < $(2)
 (lg, small):bool:parens                 $(1) <= $(2)
 (small, int):bool:parens                cmpsi($1, $2) < 0
 (int, small):bool:parens                cmpis($1, $2) < 0
 (int, int):bool:parens                  cmpii($1, $2) < 0
 (mp, mp):bool:parens                    mpcmp($1, $2) < 0
 (str, str):bool:parens                  strcmp($1, $2) < 0
 (small, gen):bool:parens                gcmpsg($1, $2) < 0
 (gen, small):bool:parens                gcmpgs($1, $2) < 0
 (gen, gen):bool:parens                  gcmp($1, $2) < 0

Function: _===_
Class: basic
Section: symbolic_operators
C-Name: gidentical
Prototype: iGG
Help: x===y: return 1 if x and y are identical, 0 otherwise.

Function: _==_
Class: basic
Section: symbolic_operators
C-Name: geq
Prototype: GG
Help: x==y: return 1 if x and y are equal, 0 otherwise.
Description: 
 (small, small):bool:parens             $(1) == $(2)
 (lg, lg):bool:parens                   $(1) == $(2)
 (small, int):bool                      equalsi($1, $2)
 (mp, 0):bool                           !signe($1)
 (int, 1):bool                          equali1($1)
 (int, -1):bool                         equalim1($1)
 (int, small):bool                      equalis($1, $2)
 (int, int):bool                        equalii($1, $2)
 (gen, 0):bool                          gequal0($1)
 (gen, 1):bool                          gequal1($1)
 (gen, -1):bool                         gequalm1($1)
 (real,real):bool                       equalrr($1, $2)
 (mp, mp):bool:parens                   mpcmp($1, $2) == 0
 (errtyp, errtyp):bool:parens           $(1) == $(2)
 (errtyp, #str):bool:parens             $(1) == $(errtyp:2)
 (#str, errtyp):bool:parens             $(errtyp:1) == $(2)
 (typ, typ):bool:parens                 $(1) == $(2)
 (typ, #str):bool:parens                $(1) == $(typ:2)
 (#str, typ):bool:parens                $(typ:1) == $(2)
 (str, str):negbool                     strcmp($1, $2)
 (small, gen):bool                      gequalsg($1, $2)
 (gen, small):bool                      gequalgs($1, $2)
 (gen, gen):bool                        gequal($1, $2)

Function: _>=_
Class: basic
Section: symbolic_operators
C-Name: gge
Prototype: GG
Help: x>=y: return 1 if x is greater or equal to y, 0 otherwise.
Description: 
 (small, small):bool:parens              $(1) >= $(2)
 (lg, lg):bool:parens                    $(1) >= $(2)
 (lg, small):bool:parens                 $(1) > $(2)
 (small, int):bool:parens                cmpsi($1, $2) >= 0
 (int, small):bool:parens                cmpis($1, $2) >= 0
 (int, int):bool:parens                  cmpii($1, $2) >= 0
 (mp, mp):bool:parens                    mpcmp($1, $2) >= 0
 (str, str):bool:parens                  strcmp($1, $2) >= 0
 (small, gen):bool:parens                gcmpsg($1, $2) >= 0
 (gen, small):bool:parens                gcmpgs($1, $2) >= 0
 (gen, gen):bool:parens                  gcmp($1, $2) >= 0

Function: _>>=_
Class: basic
Section: symbolic_operators
C-Name: gshiftre
Prototype: &L
Help: x>>=y: shortcut for x=x>>y.
Description: 
 (*small, small):small:parens             $1 >>= $(2)
 (*int, small):int:parens                 $1 = shifti($1, -$(2))
 (*mp, small):mp:parens                   $1 = mpshift($1, -$(2))
 (*gen, small):mp:parens                  $1 = gshift($1, -$(2))

Function: _>>_
Class: basic
Section: symbolic_operators
C-Name: gshift_right
Prototype: GL
Help: x>>y: compute shift(x,-y).
Description: 
 (small, small):small:parens     $(1)>>$(2)
 (int, small):int                shifti($1, -$(2))
 (mp, small):mp                  mpshift($1, -$(2))
 (gen, small):mp                 gshift($1, -$(2))

Function: _>_
Class: basic
Section: symbolic_operators
C-Name: ggt
Prototype: GG
Help: x>y: return 1 if x is strictly greater than y, 0 otherwise.
Description: 
 (small, small):bool:parens              $(1) > $(2)
 (lg, lg):bool:parens                    $(1) > $(2)
 (small, lg):bool:parens                 $(1) >= $(2)
 (small, int):bool:parens                cmpsi($1, $2) > 0
 (int, small):bool:parens                cmpis($1, $2) > 0
 (int, int):bool:parens                  cmpii($1, $2) > 0
 (mp, mp):bool:parens                    mpcmp($1, $2) > 0
 (str, str):bool:parens                  strcmp($1, $2) > 0
 (small, gen):bool:parens                gcmpsg($1, $2) > 0
 (gen, small):bool:parens                gcmpgs($1, $2) > 0
 (gen, gen):bool:parens                  gcmp($1, $2) > 0

Function: _F2xq_log_Coppersmith_worker
Class: basic
Section: programming/internals
C-Name: F2xq_log_Coppersmith_worker
Prototype: GLGG
Help: F2xq_log_Coppersmith_worker: worker for F2xq_log_Coppersmith

Function: _Flxq_log_Coppersmith_worker
Class: basic
Section: programming/internals
C-Name: Flxq_log_Coppersmith_worker
Prototype: GLGG
Help: Flxq_log_Coppersmith_worker: worker for Flxq_log_Coppersmith

Function: _FpM_ratlift_worker
Class: basic
Section: programming/internals
C-Name: FpM_ratlift_worker
Prototype: GGG
Help: worker for FpM_ratlift

Function: _Fp_log_sieve_worker
Class: basic
Section: programming/internals
C-Name: Fp_log_sieve_worker
Prototype: LLGGGGGG
Help: Fp_log_sieve_worker: worker for Fp_log_sieve

Function: _QM_charpoly_ZX_worker
Class: basic
Section: programming/internals
C-Name: QM_charpoly_ZX_worker
Prototype: GGG
Help: worker for QM_charpoly_ZX

Function: _QXQ_div_worker
Class: basic
Section: programming/internals
C-Name: QXQ_div_worker
Prototype: GGGG
Help: worker for QXQ_div

Function: _QXQ_inv_worker
Class: basic
Section: programming/internals
C-Name: QXQ_inv_worker
Prototype: GGG
Help: worker for QXQ_inv

Function: _ZM_det_worker
Class: basic
Section: programming/internals
C-Name: ZM_det_worker
Prototype: GG
Help: worker for ZM_det

Function: _ZM_inv_worker
Class: basic
Section: programming/internals
C-Name: ZM_inv_worker
Prototype: GG
Help: worker for ZM_inv

Function: _ZM_ker_worker
Class: basic
Section: programming/internals
C-Name: ZM_ker_worker
Prototype: GG
Help: worker for ZM_ker

Function: _ZM_mul_worker
Class: basic
Section: programming/internals
C-Name: ZM_mul_worker
Prototype: GGG
Help: worker for ZM_mul

Function: _ZXQX_direct_compositum_worker
Class: basic
Section: programming/internals
C-Name: ZXQX_direct_compositum_worker
Prototype: GGGG
Help: worker for ZX_direct_compositum

Function: _ZXQX_resultant_worker
Class: basic
Section: programming/internals
C-Name: ZXQX_resultant_worker
Prototype: GGGGG
Help: worker for ZXQX_resultant

Function: _ZXQ_minpoly_worker
Class: basic
Section: programming/internals
C-Name: ZXQ_minpoly_worker
Prototype: GGGL
Help: worker for ZXQ_minpoly

Function: _ZX_ZXY_resultant_worker
Class: basic
Section: programming/internals
C-Name: ZX_ZXY_resultant_worker
Prototype: GGGGG
Help: worker for ZX_ZXY_resultant

Function: _ZX_direct_compositum_worker
Class: basic
Section: programming/internals
C-Name: ZX_direct_compositum_worker
Prototype: GGG
Help: worker for ZX_direct_compositum

Function: _ZX_gcd_worker
Class: basic
Section: programming/internals
C-Name: ZX_gcd_worker
Prototype: GGGG
Help: worker for ZX_gcd

Function: _ZX_resultant_worker
Class: basic
Section: programming/internals
C-Name: ZX_resultant_worker
Prototype: GGGG
Help: worker for ZX_resultant

Function: _ZabM_inv_worker
Class: basic
Section: programming/internals
C-Name: ZabM_inv_worker
Prototype: GGG
Help: worker for ZabM_inv

Function: _[_,]
Class: basic
Section: symbolic_operators
Help: x[y,]: y-th row of x.
Description: 
 (mp,small):gen                 $"Scalar has no rows"
 (vec,small):vec                rowcopy($1, $2)
 (gen,small):vec                rowcopy($1, $2)

Function: _[_,_]
Class: basic
Section: symbolic_operators
Help: x[i{,j}]: i coefficient of a vector, i,j coefficient of a matrix
Description: 
 (mp,small):gen                 $"Scalar has no components"
 (mp,small,small):gen           $"Scalar has no components"
 (vecsmall,small):small         $(1)[$2]
 (vecsmall,small,small):gen     $"Vecsmall are single-dimensional"
 (list,small):gen:copy          gel(list_data($1), $2)
 (vecvecsmall,small):vecsmall   gel($1, $2)
 (vec,small):gen:copy           gel($1, $2)
 (vec,small,small):gen:copy     gcoeff($1, $2, $3)
 (gen,small):gen:copy           gel($1, $2)
 (gen,small,small):gen:copy     gcoeff($1, $2, $3)

Function: _[_.._,_.._]
Class: basic
Section: symbolic_operators
C-Name: matslice0
Prototype: GD0,L,D0,L,D0,L,D0,L,
Help: x[a..b,c..d] = [x[a,c],  x[a+1,c],  ...,x[b,c];
                      x[a,c+1],x[a+1,c+1],...,x[b,c+1];
                        ...       ...          ...
                      x[a,d],  x[a+1,d]  ,...,x[b,d]]

Function: _[_.._]
Class: basic
Section: symbolic_operators
C-Name: vecslice0
Prototype: GD0,L,L
Help: x[a..b] = [x[a],x[a+1],...,x[b]]

Function: _\/=_
Class: basic
Section: symbolic_operators
C-Name: gdivrounde
Prototype: &G
Help: x\/=y: shortcut for x=x\/y.
Description: 
 (*int, int):int:parens                         $1 = gdivround($1, $2)
 (*pol, gen):gen:parens                         $1 = gdivround($1, $2)
 (*gen, gen):gen:parens                         $1 = gdivround($1, $2)

Function: _\/_
Class: basic
Section: symbolic_operators
C-Name: gdivround
Prototype: GG
Help: x\/y: rounded Euclidean quotient of x and y.
Description: 
 (int, int):int                        gdivround($1, $2)
 (gen, gen):gen                        gdivround($1, $2)

Function: _\=_
Class: basic
Section: symbolic_operators
C-Name: gdivente
Prototype: &G
Help: x\=y: shortcut for x=x\y.
Description: 
 (*small, small):small:parens                   $1 /= $(2)
 (*int, int):int:parens                         $1 = gdivent($1, $2)
 (*pol, gen):gen:parens                         $1 = gdivent($1, $2)
 (*gen, gen):gen:parens                         $1 = gdivent($1, $2)

Function: _\_
Class: basic
Section: symbolic_operators
C-Name: gdivent
Prototype: GG
Help: x\y: Euclidean quotient of x and y.
Description: 
 (small, small):small:parens             $(1)/$(2)
 (int, small):int                        truedivis($1, $2)
 (small, int):int                        gdiventsg($1, $2)
 (int, int):int                          truedivii($1, $2)
 (gen, small):gen                        gdiventgs($1, $2)
 (small, gen):gen                        gdiventsg($1, $2)
 (gen, gen):gen                          gdivent($1, $2)

Function: _^_
Class: basic
Section: symbolic_operators
C-Name: gpow
Prototype: GGp
Help: x^y: compute x to the power y.
Description: 
 (usmall,2):int              sqru($1)
 (small,2):int               sqrs($1)
 (int, 2):int                sqri($1)
 (int, 3):int                powiu($1, 3)
 (int, 4):int                powiu($1, 4)
 (int, 5):int                powiu($1, 5)
 (real, -1):real             invr($1)
 (mp, -1):mp                 ginv($1)
 (gen, -1):gen               ginv($1)
 (real, 2):real              sqrr($1)
 (mp, 2):mp                  mpsqr($1)
 (gen, 2):gen                gsqr($1)
 (int, small):gen            powis($1, $2)
 (real, small):real          gpowgs($1, $2)
 (gen, small):gen            gpowgs($1, $2)
 (real, int):real            powgi($1, $2)
 (gen, int):gen              powgi($1, $2)
 (gen, gen):gen:prec         gpow($1, $2, $prec)
 
 (Fp, 2):Fp                  Fp_sqr($1, p)
 (Fp, usmall):Fp             Fp_powu($1, $2, p)
 (Fp, small):Fp              Fp_pows($1, $2, p)
 (Fp, int):Fp                Fp_pow($1, $2, p)
 (FpX, 2):FpX                FpX_sqr($1, p)
 (FpX, usmall):FpX           FpX_powu($1, $2, p)
 (Fq, 2):Fq                  Fq_sqr($1, T, p)
 (Fq, usmall):Fq             Fq_powu($1, $2, T, p)
 (Fq, int):Fq                Fq_pow($1, $2, T, p)
 (Fq, 2):Fq                  Fq_sqr($1, T, p)
 (Fq, usmall):Fq             Fq_powu($1, $2, T, p)
 (Fq, int):Fq                Fq_pow($1, $2, T, p)
 (FqX, 2):FqX                FqX_sqr($1, T, p)
 (FqX, usmall):FqX           FqX_powu($1, $2, T, p)

Function: _^s
Class: basic
Section: programming/internals
C-Name: gpowgs
Prototype: GL
Help: return x^n where n is a small integer

Function: __
Class: basic
Section: symbolic_operators
Help: __: integral concatenation of strings.
Description: 
 (genstr, genstr):genstr                gconcat($1, $2)
 (genstr, gen):genstr                   gconcat($1, $2)
 (gen, genstr):genstr                   gconcat($1, $2)
 (gen, gen):genstr                      gconcat($genstr:1, $2)

Function: _aprcl_step4_worker
Class: basic
Section: programming/internals
C-Name: aprcl_step4_worker
Prototype: UGGG
Help: worker for isprime (APRCL step 4)

Function: _aprcl_step6_worker
Class: basic
Section: programming/internals
C-Name: aprcl_step6_worker
Prototype: GLGGG
Help: worker for isprime (APRCL step 6)

Function: _avma
Class: gp2c_internal
Description: 
 ():pari_sp                avma

Function: _badtype
Class: gp2c_internal
Help: Code to check types. If not void, will be used as if(...).
Description: 
 (int):bool:parens              typ($1) != t_INT
 (real):bool:parens             typ($1) != t_REAL
 (mp):negbool                   is_intreal_t(typ($1))
 (vec):negbool                  is_matvec_t(typ($1))
 (vecsmall):bool:parens         typ($1) != t_VECSMALL
 (pol):bool:parens              typ($1) != t_POL
 (list):bool:parens             typ($1) != t_LIST
 (*nf):void:parens              $1 = checknf($1)
 (*bnf):void:parens             $1 = checkbnf($1)
 (bnr):void                     checkbnr($1)
 (prid):void                    checkprid($1)
 (clgp):void                    checkabgrp($1)
 (ell):void                     checkell($1)
 (*gal):void:parens             $1 = checkgal($1)

Function: _cast
Class: gp2c_internal
Help: (type1):type2 : cast expression of type1 to type2
Description: 
 (void):bool           0
 (#negbool):bool       ${1 value not}
 (negbool):bool        !$(1)
 (small_int):bool
 (usmall):bool
 (small):bool
 (lg):bool:parens      $(1)!=1
 (bptr):bool           *$(1)
 (gen):bool            !gequal0($1)
 (real):bool           signe($1)
 (int):bool            signe($1)
 (mp):bool             signe($1)
 (pol):bool            signe($1)
 
 (void):negbool        1
 (#bool):negbool       ${1 value not}
 (bool):negbool        !$(1)
 (lg):negbool:parens   $(1)==1
 (bptr):negbool        !*$(1)
 (gen):negbool         gequal0($1)
 (int):negbool         !signe($1)
 (real):negbool        !signe($1)
 (mp):negbool          !signe($1)
 (pol):negbool         !signe($1)
 
 (bool):small_int
 (typ):small_int
 (small):small_int
 
 (bool):usmall
 (typ):usmall
 (small):usmall
 
 (bool):small
 (typ):small
 (small_int):small
 (usmall):small
 (bptr):small           *$(1)
 (int):small            itos($1)
 (int):usmall           itou($1)
 (#lg):small:parens     ${1 value 1 sub}
 (lg):small:parens      $(1)-1
 (gen):small            gtos($1)
 (gen):usmall           gtou($1)
 
 (void):int             gen_0
 (-2):int               gen_m2
 (-1):int               gen_m1
 (0):int                gen_0
 (1):int                gen_1
 (2):int                gen_2
 (bool):int             stoi($1)
 (small):int            stoi($1)
 (usmall):int           utoi($1)
 (mp):int
 (gen):int
 
 (mp):real
 (gen):real
 
 (int):mp
 (real):mp
 (gen):mp
 
 (#bool):lg:parens             ${1 1 value add}
 (bool):lg:parens              $(1)+1
 (#small):lg:parens            ${1 1 value add}
 (small):lg:parens             $(1)+1
 
 (gen):error
 (gen):closure
 (gen):vecsmall
 
 (nf):vec
 (bnf):vec
 (bnr):vec
 (ell):vec
 (clgp):vec
 (prid):vec
 (gal):vec
 (vecvecsmall):vec
 (gen):vec
 
 (vec):vecvecsmall
 
 (gen):list
 
 (pol):var      varn($1)
 (gen):var      gvar($1)
 
 (var):pol      pol_x($1)
 (gen):pol
 
 (int):gen
 (mp):gen
 (vecsmall):gen
 (vec):gen
 (vecvecsmall):gen
 (list):gen
 (pol):gen
 (genstr):gen
 (error):gen
 (closure):gen
 (Fp):gen
 (FpX):gen
 (Fq):gen
 (FqX):gen
 (gen):Fp
 (gen):FpX
 (gen):Fq
 (gen):FqX
 
 (gen):genstr GENtoGENstr($1)
 (str):genstr strtoGENstr($1)
 
 (gen):str GENtostr_unquoted($1)
 (genstr):str GSTR($1)
 (typ):str type_name($1)
 (errtyp):str numerr_name($1)
 
 (#str):typ  ${1 str_format}
 (#str):errtyp  ${1 str_format}
 
 (bnf):nf              bnf_get_nf($1)
 (gen):nf
 (bnr):bnf             bnr_get_bnf($1)
 (gen):bnf
 (gen):bnr
 (bnf):clgp            bnf_get_clgp($1)
 (bnr):clgp            bnr_get_clgp($1)
 (gen):clgp
 (gen):ell
 (gen):gal
 (gen):prid
 
 (Fp):Fq

Function: _cgetg
Class: gp2c_internal
Description: 
 (lg,#str):gen              cgetg($1, ${2 str_raw})
 (gen,lg,#str):gen          $1 = cgetg($2, ${3 str_raw})

Function: _chinese_unit_worker
Class: basic
Section: programming/internals
C-Name: chinese_unit_worker
Prototype: GGGGGG
Help: worker for _.fu

Function: _const_expr
Class: gp2c_internal
Description: 
 (str):gen       readseq($1)

Function: _const_quote
Class: gp2c_internal
Description: 
 ("x"):var       0
 ("y"):var       1
 (str):var       fetch_user_var($1)

Function: _const_real
Class: gp2c_internal
Description: 
 (str):real:prec       strtor($1, $prec)

Function: _const_smallreal
Class: gp2c_internal
Description: 
 (0):real:prec       real_0($prec)
 (1):real:prec       real_1($prec)
 (-1):real:prec      real_m1($prec)
 (small):real:prec   stor($1, $prec)

Function: _decl_base
Class: gp2c_internal
Description: 
 (C!void)            void
 (C!long)            long
 (C!ulong)           ulong
 (C!int)             int
 (C!GEN)             GEN
 (C!char*)           char
 (C!byteptr)         byteptr
 (C!pari_sp)         pari_sp
 (C!func_GG)         GEN
 (C!forprime_t)      forprime_t
 (C!forcomposite_t)  forcomposite_t
 (C!forpart_t)       forpart_t
 (C!forperm_t)       forperm_t
 (C!forvec_t)        forvec_t
 (C!forsubset_t)     forsubset_t
 (C!parfor_t)        parfor_t
 (C!parforeach_t)    parforeach_t
 (C!parforprime_t)   parforprime_t
 (C!parforvec_t)     parforvec_t

Function: _decl_ext
Class: gp2c_internal
Description: 
 (C!char*)         *$1
 (C!func_GG)       (*$1)(GEN, GEN)

Function: _def_TeXstyle
Class: default
Section: default
C-Name: sd_TeXstyle
Prototype: 
Help: 
Doc: the bits of this default allow
 \kbd{gp} to use less rigid TeX formatting commands in the logfile. This
 default is only taken into account when $\kbd{log} = 3$. The bits of
 \kbd{TeXstyle} have the following meaning
 
 2: insert \kbd{{\bs}right} / \kbd{{\bs}left} pairs where appropriate.
 
 4: insert discretionary breaks in polynomials, to enhance the probability of
 a good line break. You \emph{must} then define \kbd{{\bs}PARIbreak} as
 follows:
 \bprog
    \def\PARIbreak{\hskip 0pt plus \hsize\relax\discretionary{}{}{}}
 @eprog
 
 The default value is \kbd{0}.

Function: _def_breakloop
Class: default
Section: default
C-Name: sd_breakloop
Prototype: 
Help: 
Doc: if true, enables the ``break loop'' debugging mode, see
 \secref{se:break_loop}.
 
 The default value is \kbd{1} if we are running an interactive \kbd{gp}
 session, and \kbd{0} otherwise.

Function: _def_colors
Class: default
Section: default
C-Name: sd_colors
Prototype: 
Help: 
Doc: this default is only usable if \kbd{gp}
 is running within certain color-capable terminals. For instance \kbd{rxvt},
 \kbd{color\_xterm} and modern versions of \kbd{xterm} under X Windows, or
 standard Linux/DOS text consoles. It causes \kbd{gp} to use a small palette of
 colors for its output. With xterms, the colormap used corresponds to the
 resources \kbd{Xterm*color$n$} where $n$ ranges from $0$ to $15$ (see the
 file \kbd{misc/color.dft} for an example). Accepted values for this
 default are strings \kbd{"$a_1$,\dots,$a_k$"} where $k\le7$ and each
 $a_i$ is either
 
 \noindent\item the keyword \kbd{no} (use the default color, usually
 black on transparent background)
 
 \noindent\item an integer between 0 and 15 corresponding to the
 aforementioned colormap
 
 \noindent\item a triple $[c_0,c_1,c_2]$ where $c_0$ stands for foreground
 color, $c_1$ for background color, and $c_2$ for attributes (0 is default, 1
 is bold, 4 is underline).
 
 The output objects thus affected are respectively error messages,
 history numbers, prompt, input line, output, help messages, timer (that's
 seven of them). If $k < 7$, the remaining $a_i$ are assumed to be $no$. For
 instance
 %
 \bprog
 default(colors, "9, 5, no, no, 4")
 @eprog
 \noindent
 typesets error messages in color $9$, history numbers in color $5$, output in
 color $4$, and does not affect the rest.
 
 A set of default colors for dark (reverse video or PC console) and light
 backgrounds respectively is activated when \kbd{colors} is set to
 \kbd{darkbg}, resp.~\kbd{lightbg} (or any proper prefix: \kbd{d} is
 recognized as an abbreviation for \kbd{darkbg}). A bold variant of
 \kbd{darkbg}, called \kbd{boldfg}, is provided if you find the former too
 pale.
 
 \emacs In the present version, this default is incompatible with PariEmacs.
 Changing it will just fail silently (the alternative would be to display
 escape sequences as is, since Emacs will refuse to interpret them).
 You must customize color highlighting from the PariEmacs side, see its
 documentation.
 
 The default value is \kbd{""} (no colors).

Function: _def_compatible
Class: default
Section: default
C-Name: sd_compatible
Prototype: 
Obsolete: 2014-10-11
Help: 
Doc: Obsolete. This default is now a no-op.

Function: _def_datadir
Class: default
Section: default
C-Name: sd_datadir
Prototype: 
Help: 
Doc: the name of directory containing the optional data files. For now,
 this includes the \kbd{elldata}, \kbd{galdata}, \kbd{galpol}, \kbd{seadata}
 packages.
 
 The default value is \kbd{/usr/local/share/pari}, or the override specified
 via \kbd{Configure --datadir=}.
 
 \misctitle{Windows-specific note} On Windows operating systems, the
 special value \kbd{@} stands for ``the directory where the \kbd{gp}
 binary is installed''. This is the default value.

Function: _def_debug
Class: default
Section: default
C-Name: sd_debug
Prototype: 
Help: 
Doc: debugging level. If it is nonzero, some extra messages may be printed,
 according to what is going on (see~\b{g}). To turn on and off diagnostics
 attached to a specific feature (such as the LLL algorithm), use
 \tet{setdebug}.
 
 The default value is \kbd{0} (no debugging messages).

Function: _def_debugfiles
Class: default
Section: default
C-Name: sd_debugfiles
Prototype: 
Obsolete: 2021-06-14
Help: 
Doc: This is a deprecated alias for \kbd{setdebug("io",)}. If nonzero,
 \kbd{gp} will print information on file descriptors in use and I/O
 operations (see~\b{gf}).
 
 The default value is \kbd{0} (no debugging messages).

Function: _def_debugmem
Class: default
Section: default
C-Name: sd_debugmem
Prototype: 
Help: 
Doc: memory debugging level (see \b{gm}). If this is nonzero, \kbd{gp} will
 print increasingly precise notifications about memory use:
 
 \item $\kbd{debugmem} > 0$, notify when \kbd{parisize} changes (within the
 boundaries set by \kbd{parisizemax});
 
 \item $\kbd{debugmem} > 1$, indicate any important garbage collection and the
 function it is taking place in;
 
 \item $\kbd{debugmem} > 2$, indicate the creation/destruction of
 ``blocks'' (or clones); expect lots of messages.
 
 \noindent {\bf Important Note:}
 if you are running a version compiled for debugging (see Appendix~A) and
 $\kbd{debugmem} > 1$, \kbd{gp} will further regularly print information on
 memory usage, notifying whenever stack usage goes up or down by 1 MByte.
 This functionality is disabled on non-debugging builds as it noticeably
 slows down the performance.
 
 The default value is \kbd{1}.

Function: _def_echo
Class: default
Section: default
C-Name: sd_echo
Prototype: 
Help: 
Doc: this default can be 0 (off), 1 (on) or 2 (on, raw). When \kbd{echo}
 mode is on, each command is reprinted before being executed. This can be
 useful when reading a file with the \b{r} or \kbd{read} commands. For
 example, it is turned on at the beginning of the test files used to check
 whether \kbd{gp} has been built correctly (see \b{e}). When \kbd{echo} is set
 to 1 the input is cleaned up, removing white space and comments and uniting
 multi-line input. When set to 2 (raw), the input is written as-is, without any
 pre-processing.
 
 The default value is \kbd{0} (no echo).

Function: _def_factor_add_primes
Class: default
Section: default
C-Name: sd_factor_add_primes
Prototype: 
Help: 
Doc: this toggle is either 1 (on) or 0 (off). If on,
 the integer factorization machinery calls \tet{addprimes} on prime
 factors that were difficult to find (larger than $2^{24}$), so they are
 automatically tried first in other factorizations. If a routine is performing
 (or has performed) a factorization and is interrupted by an error or via
 Control-C, this lets you recover the prime factors already found. The
 downside is that a huge \kbd{addprimes} table unrelated to the current
 computations will slow down arithmetic functions relying on integer
 factorization; one should then empty the table using \tet{removeprimes}.
 
 The default value is \kbd{0}.

Function: _def_factor_proven
Class: default
Section: default
C-Name: sd_factor_proven
Prototype: 
Help: 
Doc: this toggle is either 1 (on) or 0 (off). By
 default, the factors output by the integer factorization machinery are
 only pseudo-primes, not proven primes. If this toggle is
 set, a primality proof is done for each factor and all results depending on
 integer factorization are fully proven. This flag does not affect partial
 factorization when it is explicitly requested. It also does not affect the
 private table managed by \tet{addprimes}: its entries are included as is in
 factorizations, without being tested for primality.
 
 The default value is \kbd{0}.

Function: _def_format
Class: default
Section: default
C-Name: sd_format
Prototype: 
Help: 
Doc: of the form x$.n$, where x (conversion style)
 is a letter in $\{\kbd{e},\kbd{f},\kbd{g}\}$, and $n$ (precision) is an
 integer; this affects the way real numbers are printed:
 
 \item If the conversion style is \kbd{e}, real numbers are printed in
 \idx{scientific format}, always with an explicit exponent,
 e.g.~\kbd{3.3 E-5}.
 
 \item In style \kbd{f}, real numbers are generally printed in
 \idx{fixed floating point format} without exponent, e.g.~\kbd{0.000033}. A
 large real number, whose integer part is not well defined (not enough
 significant digits), is printed in style~\kbd{e}. For instance
 \kbd{10.\pow 100} known to ten significant digits is always printed in style
 \kbd{e}.
 
 \item In style \kbd{g}, nonzero real numbers are printed in \kbd{f} format,
 except when their decimal exponent is $< -4$, in which case they are printed
 in \kbd{e} format. Real zeroes (of arbitrary exponent) are printed in \kbd{e}
 format.
 
 The precision $n$ is the number of significant digits printed for real
 numbers, except if $n<0$ where all the significant digits will be printed
 (initial default 28, or 38 for 64-bit machines). For more powerful formatting
 possibilities, see \tet{printf} and \tet{strprintf}.
 
 The default value is \kbd{"g.28"} and \kbd{"g.38"} on 32-bit and
 64-bit machines, respectively.

Function: _def_graphcolormap
Class: default
Section: default
C-Name: sd_graphcolormap
Prototype: 
Help: 
Doc: a vector of colors, to be used by hi-res graphing routines. Its length is
 arbitrary, but it must contain at least 3 entries: the first 3 colors are
 used for background, frame/ticks and axes respectively. All colors in the
 colormap may be freely used in \tet{plotcolor} calls.
 
 A color is either given as in the default by character strings or by an RGB
 code. For valid color names, see the standard \kbd{rgb.txt} file in X11
 distributions, where we restrict to lowercase letters and remove all
 whitespace from color names. An RGB code is a vector with 3 integer entries
 between 0 and 255 or a \kbd{\#} followed by 6 hexadecimal digits.
 For instance \kbd{[250, 235, 215]}, \kbd{"\#faebd7"}  and
 \kbd{"antiquewhite"} all represent the same color.
 
 The default value is [\kbd{"white"}, \kbd{"black"}, \kbd{"blue"},
 \kbd{"violetred"}, \kbd{"red"}, \kbd{"green"}, \kbd{"grey"},
 \kbd{"gainsboro"}].

Function: _def_graphcolors
Class: default
Section: default
C-Name: sd_graphcolors
Prototype: 
Help: 
Doc: entries in the
 \tet{graphcolormap} that will be used to plot multi-curves. The successive
 curves are drawn in colors
 
 \kbd{graphcolormap[graphcolors[1]]}, \kbd{graphcolormap[graphcolors[2]]},
   \dots
 
 cycling when the \kbd{graphcolors} list is exhausted.
 
 The default value is \kbd{[4,5]}.

Function: _def_help
Class: default
Section: default
C-Name: sd_help
Prototype: 
Help: 
Doc: name of the external help program to use from within \kbd{gp} when
 extended help is invoked, usually through a \kbd{??} or \kbd{???} request
 (see \secref{se:exthelp}), or \kbd{M-H} under readline (see
 \secref{se:readline}).
 
 \misctitle{Windows-specific note} On Windows operating systems, if the
 first character of \kbd{help} is \kbd{@}, it is replaced by ``the directory
 where the \kbd{gp} binary is installed''.
 
 The default value is the path to the \kbd{gphelp} script we install.

Function: _def_histfile
Class: default
Section: default
C-Name: sd_histfile
Prototype: 
Help: 
Doc: name of a file where
 \kbd{gp} will keep a history of all \emph{input} commands (results are
 omitted). If this file exists when the value of \kbd{histfile} changes,
 it is read in and becomes part of the session history. Thus, setting this
 default in your gprc saves your readline history between sessions. Setting
 this default to the empty string \kbd{""} changes it to
 \kbd{$<$undefined$>$}. Note that, by default, the number of history entries
 saved is not limited: set \kbd{history-size} in readline's \kbd{.inputrc}
 to limit the file size.
 
 The default value is \kbd{$<$undefined$>$} (no history file).

Function: _def_histsize
Class: default
Section: default
C-Name: sd_histsize
Prototype: 
Help: 
Doc: \kbd{gp} keeps a history of the last
 \kbd{histsize} results computed so far, which you can recover using the
 \kbd{\%} notation (see \secref{se:history}). When this number is exceeded,
 the oldest values are erased. Tampering with this default is the only way to
 get rid of the ones you do not need anymore.
 
 The default value is \kbd{5000}.

Function: _def_lines
Class: default
Section: default
C-Name: sd_lines
Prototype: 
Help: 
Doc: if set to a positive value, \kbd{gp} prints at
 most that many lines from each result, terminating the last line shown with
 \kbd{[+++]} if further material has been suppressed. The various \kbd{print}
 commands (see \secref{se:gp_program}) are unaffected, so you can always type
 \kbd{print(\%)} or \b{a} to view the full result. If the actual screen width
 cannot be determined, a ``line'' is assumed to be 80 characters long.
 
 The default value is \kbd{0}.

Function: _def_linewrap
Class: default
Section: default
C-Name: sd_linewrap
Prototype: 
Help: 
Doc: if set to a positive value, \kbd{gp} wraps every single line after
 printing that many characters.
 
 The default value is \kbd{0} (unset).

Function: _def_log
Class: default
Section: default
C-Name: sd_log
Prototype: 
Help: 
Doc: this can be either 0 (off) or 1, 2, 3
 (on, see below for the various modes). When logging mode is turned on, \kbd{gp}
 opens a log file, whose exact name is determined by the \kbd{logfile}
 default. Subsequently, all the commands and results will be written to that
 file (see \b{l}). In case a file with this precise name already existed, it
 will not be erased: your data will be \emph{appended} at the end.
 
 The specific positive values of \kbd{log} have the following meaning
 
 1: plain logfile
 
 2: emit color codes to the logfile (if \kbd{colors} is set).
 
 3: write LaTeX output to the logfile (can be further customized using
 \tet{TeXstyle}).
 
 The default value is \kbd{0}.
 
 \misctitle{Note} Logging starts as soon as \kbd{log} is set to a nonzero
 value. In particular, when \kbd{log} is set in \kbd{gprc}, warnings and
 errors triggered from the rest of the file will be written in the logfile.
 For instance, on clean startup, the logfile will start by \kbd{Done.}
 (from the \kbd{Reading GPRC:\dots Done.} diagnostic printed when starting
 \kbd{gp}), then the \kbd{gp} header and prompt.

Function: _def_logfile
Class: default
Section: default
C-Name: sd_logfile
Prototype: 
Help: 
Doc: name of the log file to be used when the \kbd{log} toggle is on.
 Environment and time expansion are performed.
 
 The default value is \kbd{"pari.log"}.

Function: _def_nbthreads
Class: default
Section: default
C-Name: sd_nbthreads
Prototype: 
Help: 
Doc: This default is specific to the \emph{parallel} version of PARI and gp
 (built via \kbd{Configure --mt=prthread} or \kbd{mpi}) and is ignored
 otherwise. In parallel mode, it governs the number of threads to use for
 parallel computing. The exact meaning and default value depend on the
 \kbd{mt} engine used:
 
 \item \kbd{single}: not used (always a single thread).
 
 \item \kbd{pthread}: number of threads (unlimited, default: number of cores)
 
 \item \kbd{mpi}: number of MPI processes to use (limited to the number
 allocated by \kbd{mpirun}, default: use all allocated processes).
 
 See also \kbd{threadsize} and \kbd{threadsizemax}.

Function: _def_new_galois_format
Class: default
Section: default
C-Name: sd_new_galois_format
Prototype: 
Help: 
Doc: this toggle is either 1 (on) or 0 (off). If on,
 the \tet{polgalois} command will use a different, more
 consistent, naming scheme for Galois groups. This default is provided to
 ensure that scripts can control this behavior and do not break unexpectedly.
 
 The default value is \kbd{0}. This value will change to $1$ (set) in the next
 major version.

Function: _def_output
Class: default
Section: default
C-Name: sd_output
Prototype: 
Help: 
Doc: there are three possible values: 0
 (=~\var{raw}), 1 (=~\var{prettymatrix}), or 3
 (=~\var{external} \var{prettyprint}). This
 means that, independently of the default \kbd{format} for reals which we
 explained above, you can print results in three ways:
 
 \item \tev{raw format}, i.e.~a format which is equivalent to what you
 input, including explicit multiplication signs, and everything typed on a
 line instead of two dimensional boxes. This can have several advantages, for
 instance it allows you to pick the result with a mouse or an editor, and to
 paste it somewhere else.
 
 \item \tev{prettymatrix format}: this is identical to raw format, except
 that matrices are printed as boxes instead of horizontally. This is
 prettier, but takes more space and cannot be used for input. Column vectors
 are still printed horizontally.
 
 \item \tev{external prettyprint}: pipes all \kbd{gp}
 output in TeX format to an external prettyprinter, according to the value of
 \tet{prettyprinter}. The default script (\tet{tex2mail}) converts its input
 to readable two-dimensional text.
 
 Independently of the setting of this default, an object can be printed
 in any of the three formats at any time using the commands \b{a} and \b{m}
 and \b{B} respectively.
 
 The default value is \kbd{1} (\var{prettymatrix}).

Function: _def_parisize
Class: default
Section: default
C-Name: sd_parisize
Prototype: 
Help: 
Doc: \kbd{gp}, and in fact any program using the PARI
 library, needs a \tev{stack} in which to do its computations; \kbd{parisize}
 is the stack size, in bytes. It is recommended to increase this
 default using a \tet{gprc}, to the value you believe PARI should be happy
 with, given your typical computation. We strongly recommend to also
 set \tet{parisizemax} to a much larger value in your \kbd{gprc}, about what
 you believe your machine can stand: PARI will then try to fit its
 computations within about \kbd{parisize} bytes, but will increase the stack
 size if needed (up to \kbd{parisizemax}). Once the memory intensive
 computation is over, PARI will restore the stack size to the originally
 requested \kbd{parisize}.
 
 If \tet{parisizemax} is unset, this command has a very unintuitive behaviour
 since it must abort pending operations, see \kbd{??allocatemem}.
 
 The default value is 4M, resp.~8M on a 32-bit, resp.~64-bit machine.

Function: _def_parisizemax
Class: default
Section: default
C-Name: sd_parisizemax
Prototype: 
Help: 
Doc: \kbd{gp}, and in fact any program using the PARI library, needs a
 \tev{stack} in which to do its computations.  If nonzero,  \tet{parisizemax}
 is the maximum size the stack can grow to, in bytes.  If zero, the stack will
 not automatically grow, and will be limited to the value of \kbd{parisize}.
 
 When \kbd{parisizemax} is set, PARI tries to fit its
 computations within about \kbd{parisize} bytes, but will increase the stack
 size if needed, roughly doubling it each time (up to \kbd{parisizemax}
 of course!) and printing a message such as \kbd{Warning: increasing stack size to}
 \var{some value}. Once the memory intensive computation is over, PARI
 will restore the stack size to the originally requested \kbd{parisize}
 without printing further messages.
 
 We \emph{strongly} recommend to set \tet{parisizemax} permanently to a large
 nonzero value in your \tet{gprc}, about what you believe your machine can
 stand. It is possible to increase or decrease \kbd{parisizemax} inside a
 running \kbd{gp} session, just use \kbd{default} as usual.
 
 The default value is $0$, for backward compatibility reasons.

Function: _def_path
Class: default
Section: default
C-Name: sd_path
Prototype: 
Help: 
Doc: this is a list of directories, separated by colons ':'
 (semicolons ';' in the DOS world, since colons are preempted for drive names).
 When asked to read a file whose name is not given by an absolute path
 (does not start with \kbd{/}, \kbd{./} or \kbd{../}), \kbd{gp} will look for
 it in these directories, in the order they were written in \kbd{path}. Here,
 as usual, \kbd{.} means the current directory, and \kbd{..} its immediate
 parent. Environment expansion is performed.
 
 The default value is \kbd{".:\til:\til/gp"} on UNIX systems,
 \kbd{".;C:\bs;C:\bs GP"} on DOS, OS/2 and Windows, and \kbd{"."} otherwise.

Function: _def_plothsizes
Class: default
Section: default
C-Name: sd_plothsizes
Prototype: 
Help: 
Doc: if the graphic driver allows it, the array contains the size of the
 terminal, the size of the font, the size of the ticks.

Function: _def_prettyprinter
Class: default
Section: default
C-Name: sd_prettyprinter
Prototype: 
Help: 
Doc: the name of an external prettyprinter to use when
 \kbd{output} is~3 (alternate prettyprinter). Note that the default
 \tet{tex2mail} looks much nicer than the built-in ``beautified
 format'' ($\kbd{output} = 2$).
 
 The default value is \kbd{"tex2mail -TeX -noindent -ragged -by\_par"}.

Function: _def_primelimit
Class: default
Section: default
C-Name: sd_primelimit
Prototype: 
Help: 
Doc: \kbd{gp} precomputes a list of
 all primes less than \kbd{primelimit} at initialization time, and can build
 fast sieves on demand to quickly iterate over primes up to the \emph{square}
 of \kbd{primelimit}. These are used by many arithmetic functions, usually for
 trial division purposes. The maximal value is $2^{32} - 2049$ (resp $2^{64} -
 2049$) on a 32-bit (resp.~64-bit) machine, but values beyond $10^8$,
 allowing to iterate over primes up to $10^{16}$, do not seem useful.
 
 Since almost all arithmetic functions eventually require some table of prime
 numbers, PARI guarantees that the first 6547 primes, up to and
 including 65557, are precomputed, even if \kbd{primelimit} is $1$.
 
 This default is only used on startup: changing it will not recompute a new
 table.
 
 \misctitle{Deprecated feature} \kbd{primelimit} was used in some
 situations by algebraic number theory functions using the
 \tet{nf_PARTIALFACT} flag (\tet{nfbasis}, \tet{nfdisc}, \tet{nfinit}, \dots):
 this assumes that all primes $p > \kbd{primelimit}$ have a certain
 property (the equation order is $p$-maximal). This is never done by default,
 and must be explicitly set by the user of such functions. Nevertheless,
 these functions now provide a more flexible interface, and their use
 of the global default \kbd{primelimit} is deprecated.
 
 \misctitle{Deprecated feature} \kbd{factor(N, 0)} was used to partially
 factor integers by removing all prime factors $\leq$ \kbd{primelimit}.
 Don't use this, supply an explicit bound: \kbd{factor(N, bound)},
 which avoids relying on an unpredictable global variable.
 
 The default value is \kbd{500k}.

Function: _def_prompt
Class: default
Section: default
C-Name: sd_prompt
Prototype: 
Help: 
Doc: a string that will be printed as
 prompt. Note that most usual escape sequences are available there: \b{e} for
 Esc, \b{n} for Newline, \dots, \kbd{\bs\bs} for \kbd{\bs}. Time expansion is
 performed.
 
 This string is sent through the library function \tet{strftime} (on a
 Unix system, you can try \kbd{man strftime} at your shell prompt). This means
 that \kbd{\%} constructs have a special meaning, usually related to the time
 and date. For instance, \kbd{\%H} = hour (24-hour clock) and \kbd{\%M} =
 minute [00,59] (use \kbd{\%\%} to get a real \kbd{\%}).
 
 If you use \kbd{readline}, escape sequences in your prompt will result in
 display bugs. If you have a relatively recent \kbd{readline} (see the comment
 at the end of \secref{se:def,colors}), you can brace them with special sequences
 (\kbd{\bs[} and \kbd{\bs]}), and you will be safe. If these just result in
 extra spaces in your prompt, then you'll have to get a more recent
 \kbd{readline}. See the file \kbd{misc/gprc.dft} for an example.
 
 \emacs {\bf Caution}: PariEmacs needs to know about the prompt pattern to
 separate your input from previous \kbd{gp} results, without ambiguity. It is
 not a trivial problem to adapt automatically this regular expression to an
 arbitrary prompt (which can be self-modifying!). See PariEmacs's
 documentation.
 
 The default value is \kbd{"? "}.

Function: _def_prompt_cont
Class: default
Section: default
C-Name: sd_prompt_cont
Prototype: 
Help: 
Doc: a string that will be printed
 to prompt for continuation lines (e.g. in between braces, or after a
 line-terminating backslash). Everything that applies to \kbd{prompt}
 applies to \kbd{prompt\_cont} as well.
 
 The default value is \kbd{""}.

Function: _def_psfile
Class: default
Section: default
C-Name: sd_psfile
Prototype: 
Obsolete: 2018-02-01
Help: 
Doc: This default is obsolete, use one of plotexport, plothexport or
 plothrawexport functions and write the result to file.

Function: _def_readline
Class: default
Section: default
C-Name: sd_readline
Prototype: 
Help: 
Doc: switches readline line-editing
 facilities on and off. This may be useful if you are running \kbd{gp} in a Sun
 \tet{cmdtool}, which interacts badly with readline. Of course, until readline
 is switched on again, advanced editing features like automatic completion
 and editing history are not available.
 
 The default value is \kbd{1}.

Function: _def_realbitprecision
Class: default
Section: default
C-Name: sd_realbitprecision
Prototype: 
Help: 
Doc: the number of significant bits used to convert exact inputs given to
 transcendental functions (see \secref{se:trans}), or to create
 absolute floating point constants (input as \kbd{1.0} or \kbd{Pi} for
 instance). Unless you tamper with the \tet{format} default, this is also
 the number of significant bits used to print a \typ{REAL} number;
 \kbd{format} will override this latter behavior, and allow you to have a
 large internal precision while outputting few digits for instance.
 
 Note that most PARI's functions currently handle precision on a word basis (by
 increments of 32 or 64 bits), hence bit precision may be a little larger
 than the number of bits you expected. For instance to get 10 bits of
 precision, you need one word of precision which, on a 64-bit machine,
 correspond to 64 bits. To make things even more confusing, this internal bit
 accuracy is converted to decimal digits when printing floating point numbers:
 now 64 bits correspond to 19 printed decimal digits
 ($19 <  \log_{10}(2^{64}) < 20$).
 
 The value returned when typing \kbd{default(realbitprecision)} is the internal
 number of significant bits, not the number of printed decimal digits:
 \bprog
 ? default(realbitprecision, 10)
 ? \pb
       realbitprecision = 64 significant bits
 ? default(realbitprecision)
 %1 = 64
 ? \p
       realprecision = 3 significant digits
 ? default(realprecision)
 %2 = 19
 @eprog\noindent Note that \tet{realprecision} and \kbd{\bs p} allow
 to view and manipulate the internal precision in decimal digits.
 
 The default value is \kbd{128}, resp.~\kbd{96}, on a 64-bit, resp~.32-bit,
 machine.

Function: _def_realprecision
Class: default
Section: default
C-Name: sd_realprecision
Prototype: 
Help: 
Doc: the number of significant digits used to convert exact inputs given to
 transcendental functions (see \secref{se:trans}), or to create
 absolute floating point constants (input as \kbd{1.0} or \kbd{Pi} for
 instance). Unless you tamper with the \tet{format} default, this is also
 the number of significant digits used to print a \typ{REAL} number;
 \kbd{format} will override this latter behavior, and allow you to have a
 large internal precision while outputting few digits for instance.
 
 Note that PARI's internal precision works on a word basis (by increments of
 32 or 64 bits), hence may be a little larger than the number of decimal
 digits you expected. For instance to get 2 decimal digits you need one word
 of precision which, on a 64-bit machine, actually gives you 19 digits ($19 <
 \log_{10}(2^{64}) < 20$). The value returned when typing
 \kbd{default(realprecision)} is the internal number of significant digits,
 not the number of printed digits:
 \bprog
 ? default(realprecision, 2)
       realprecision = 19 significant digits (2 digits displayed)
 ? default(realprecision)
 %1 = 19
 @eprog
 The default value is \kbd{38}, resp.~\kbd{28}, on a 64-bit, resp.~32-bit,
 machine.

Function: _def_recover
Class: default
Section: default
C-Name: sd_recover
Prototype: 
Help: 
Doc: this toggle is either 1 (on) or 0 (off). If you change this to $0$, any
 error becomes fatal and causes the gp interpreter to exit immediately. Can be
 useful in batch job scripts.
 
 The default value is \kbd{1}.

Function: _def_secure
Class: default
Section: default
C-Name: sd_secure
Prototype: 
Help: 
Doc: this toggle is either 1 (on) or 0 (off). If on, the \tet{system} and
 \tet{extern} command are disabled. These two commands are potentially
 dangerous when you execute foreign scripts since they let \kbd{gp} execute
 arbitrary UNIX commands. \kbd{gp} will ask for confirmation before letting
 you (or a script) unset this toggle.
 
 The default value is \kbd{0}.

Function: _def_seriesprecision
Class: default
Section: default
C-Name: sd_seriesprecision
Prototype: 
Help: 
Doc: number of significant terms
 when converting a polynomial or rational function to a power series
 (see~\b{ps}).
 
 The default value is \kbd{16}.

Function: _def_simplify
Class: default
Section: default
C-Name: sd_simplify
Prototype: 
Help: 
Doc: this toggle is either 1 (on) or 0 (off). When the PARI library computes
 something, the type of the
 result is not always the simplest possible. The only type conversions which
 the PARI library does automatically are rational numbers to integers (when
 they are of type \typ{FRAC} and equal to integers), and similarly rational
 functions to polynomials (when they are of type \typ{RFRAC} and equal to
 polynomials). This feature is useful in many cases, and saves time, but can
 be annoying at times. Hence you can disable this and, whenever you feel like
 it, use the function \kbd{simplify} (see Chapter 3) which allows you to
 simplify objects to the simplest possible types recursively (see~\b{y}).
 \sidx{automatic simplification}
 
 The default value is \kbd{1}.

Function: _def_sopath
Class: default
Section: default
C-Name: sd_sopath
Prototype: 
Help: 
Doc: this is a list of directories, separated by colons ':'
 (semicolons ';' in the DOS world, since colons are preempted for drive names).
 When asked to \tet{install} an external symbol from a shared library whose
 name is not given by an absolute path (does not start with \kbd{/}, \kbd{./}
 or \kbd{../}), \kbd{gp} will look for it in these directories, in the order
 they were written in \kbd{sopath}. Here, as usual, \kbd{.} means the current
 directory, and \kbd{..} its immediate parent. Environment expansion is
 performed.
 
 The default value is \kbd{""}, corresponding to an empty list of
 directories: \tet{install} will use the library name as input (and look in
 the current directory if the name is not an absolute path).

Function: _def_strictargs
Class: default
Section: default
C-Name: sd_strictargs
Prototype: 
Help: 
Doc: this toggle is either 1 (on) or 0 (off). If on, all arguments to \emph{new}
 user functions are mandatory unless the function supplies an explicit default
 value.
 Otherwise arguments have the default value $0$.
 
 In this example,
 \bprog
   fun(a,b=2)=a+b
 @eprog
 \kbd{a} is mandatory, while \kbd{b} is optional. If \kbd{strictargs} is on:
 \bprog
 ? fun()
  ***   at top-level: fun()
  ***                 ^-----
  ***   in function fun: a,b=2
  ***                    ^-----
  ***   missing mandatory argument 'a' in user function.
 @eprog
 This applies to functions defined while \kbd{strictargs} is on. Changing \kbd{strictargs}
 does not affect the behavior of previously defined functions.
 
 The default value is \kbd{0}.

Function: _def_strictmatch
Class: default
Section: default
C-Name: sd_strictmatch
Prototype: 
Obsolete: 2014-10-11
Help: 
Doc: Obsolete. This toggle is now a no-op.

Function: _def_threadsize
Class: default
Section: default
C-Name: sd_threadsize
Prototype: 
Help: 
Doc: This default is specific to the \emph{parallel} version of PARI and gp
 (built via \kbd{Configure --mt=prthread} or \kbd{mpi}) and is ignored
 otherwise. In parallel mode,
 each thread allocates its own private \tev{stack} for its
 computations, see \kbd{parisize}. This value determines the size in bytes of
 the stacks of each thread, so the total memory allocated will be
 $\kbd{parisize}+\kbd{nbthreads}\times\kbd{threadsize}$.
 
 If set to $0$, the value used is the same as \kbd{parisize}. It is not
 easy to estimate reliably a sufficient value for this parameter because PARI
 itself will parallelize computations and we recommend to not set this value
 explicitly unless it solves a specific problem for you. For instance if you
 see frequent messages of the form
 \bprog
  *** Warning: not enough memory, new thread stack 10000002048
 @eprog (Meaning that \kbd{threadsize} had to be temporarily increased.)
 On the other hand we strongly recommend to set \kbd{parisizemax} and
 \kbd{threadsizemax} to a nonzero value.
 
 The default value is $0$.

Function: _def_threadsizemax
Class: default
Section: default
C-Name: sd_threadsizemax
Prototype: 
Help: 
Doc: This default is specific to the \emph{parallel} version of PARI and gp
 (built via \kbd{Configure --mt=pthread} or \kbd{mpi}) and is ignored
 otherwise. In parallel mode,
 each threads allocates its own private \tev{stack} for
 its computations, see \kbd{parisize} and \kbd{parisizemax}. The
 values of \kbd{threadsize} and \kbd{threadsizemax} determine the usual
 and maximal size in bytes of the stacks of each thread, so the total memory
 allocated will
 be between $\kbd{parisize}+\kbd{nbthreads}\times\kbd{threadsize}$. and
 $\kbd{parisizemax}+\kbd{nbthreads}\times\kbd{threadsizemax}$.
 
 If set to $0$, the value used is the same as \kbd{threadsize}. We strongy
 recommend to set both \kbd{parisizemax} and \kbd{threadsizemax} to a
 nonzero value.
 
 The default value is $0$.

Function: _def_timer
Class: default
Section: default
C-Name: sd_timer
Prototype: 
Help: 
Doc: this toggle is either 1 (on) or 0 (off). Every instruction sequence
 in the gp calculator (anything ended by a newline in your input) is timed,
 to some accuracy depending on the hardware and operating system. When
 \tet{timer} is on, each such timing is printed immediately before the
 output as follows:
 \bprog
 ? factor(2^2^7+1)
 time = 108 ms.     \\ this line omitted if 'timer' is 0
 %1 =
 [     59649589127497217 1]
 
 [5704689200685129054721 1]
 @eprog\noindent (See also \kbd{\#} and \kbd{\#\#}.)
 
 The time measured is the user \idx{CPU time}, \emph{not} including the time
 for printing the results. If the time is negligible ($< 1$ ms.), nothing is
 printed: in particular, no timing should be printed when defining a user
 function or an alias, or installing a symbol from the library.
 
 The default value is \kbd{0} (off).

Function: _default_check
Class: gp2c_internal
Help: Code to check for the default marker
Description: 
 (C!GEN):bool    !$(1)
 (var):bool      $(1) == -1

Function: _default_marker
Class: gp2c_internal
Help: Code for default value of GP function
Description: 
 (C!GEN)      NULL
 (var)        -1
 (small)      0
 (str)        ""

Function: _derivfun
Class: basic
Section: programming/internals
C-Name: derivfun0
Prototype: GGGD1,L,p
Help: _derivfun(args,def,closure,k) numerical kth-derivation of closure with respect to
 the first variable at args

Function: _diffptr
Class: gp2c_internal
Help: Table of difference of primes.
Description: 
 ():bptr        diffptr

Function: _dirartin_worker
Class: basic
Section: programming/internals
C-Name: dirartin_worker
Prototype: GUGGGG
Help: lfunartin worker

Function: _direllnf_worker
Class: basic
Section: programming/internals
C-Name: direllnf_worker
Prototype: GUG
Help: ellan worker

Function: _direllsympow_worker
Class: basic
Section: programming/internals
C-Name: direllsympow_worker
Prototype: GUGU
Help: lfunsympow worker

Function: _dirgenus2_worker
Class: basic
Section: programming/internals
C-Name: dirgenus2_worker
Prototype: GLG
Help: lfungenus2 worker

Function: _dirhgm_worker
Class: basic
Section: programming/internals
C-Name: dirhgm_worker
Prototype: GUGG
Help: worker for hgmcoefs

Function: _ecpp_ispsp_worker
Class: basic
Section: programming/internals
C-Name: ecpp_ispsp_worker
Prototype: G
Help: worker for isprime (ECPP ispseudoprime step)

Function: _ecpp_sqrt_worker
Class: basic
Section: programming/internals
C-Name: ecpp_sqrt_worker
Prototype: GGG
Help: worker for isprime (ECPP sqrt step)

Function: _ecpp_step2_worker
Class: basic
Section: programming/internals
C-Name: ecpp_step2_worker
Prototype: GGGL
Help: worker for isprime (step 2)

Function: _eisker_worker
Class: basic
Section: programming/internals
C-Name: eisker_worker
Prototype: GGGGG
Help: worker for eisker

Function: _ellQ_factorback_worker
Class: basic
Section: programming/internals
C-Name: ellQ_factorback_worker
Prototype: GGGGU
Help: worker for ellQ_factorback

Function: _err_primes
Class: gp2c_internal
Description: 
 ():void  pari_err(e_MAXPRIME)

Function: _err_type
Class: gp2c_internal
Description: 
 (str,gen):void  pari_err_TYPE($1,$2)

Function: _eval_mnemonic
Class: basic
Section: programming/internals
C-Name: eval_mnemonic
Prototype: lGs
Help: Convert a mnemonic string to a flag.

Function: _factor_Aurifeuille
Class: basic
Section: programming/internals
C-Name: factor_Aurifeuille
Prototype: GL
Help: _factor_Aurifeuille(a,d): return an algebraic factor of Phi_d(a), a != 0

Function: _factor_Aurifeuille_prime
Class: basic
Section: programming/internals
C-Name: factor_Aurifeuille_prime
Prototype: GL
Help: _factor_Aurifeuille_prime(p,d): return an algebraic factor of Phi_d(p), p prime

Function: _forcomposite_init
Class: gp2c_internal
Help: Initialize forcomposite_t.
Description: 
 (forcomposite,int):void                  forcomposite_init(&$1, $2, NULL)
 (forcomposite,int,?int):void             forcomposite_init(&$1, $2, $3)

Function: _forcomposite_next
Class: gp2c_internal
Help: Compute the next composite.
Description: 
 (forcomposite):int                       forcomposite_next(&$1)

Function: _formatcode
Class: gp2c_internal
Description: 
 (#small):void                    $1
 (small):small                    %ld
 (small_int):small_int            %d
 (#str):void                      $%1
 (str):str                        %s
 (gen):gen                        %Ps

Function: _forpart_init
Class: gp2c_internal
Help: Initialize forpart_t
Description: 
 (forpart,small,?gen,?gen):void      forpart_init(&$1, $2, $3, $4)

Function: _forpart_next
Class: gp2c_internal
Help: Compute the next part
Description: 
 (forpart):vecsmall                  forpart_next(&$1)

Function: _forperm_init
Class: gp2c_internal
Help: Initialize forperm_t
Description: 
 (forperm,gen):void      forperm_init(&$1, $2)

Function: _forperm_next
Class: gp2c_internal
Help: Compute the next permutation
Description: 
 (forperm):vecsmall      forperm_next(&$1)

Function: _forprime_init
Class: gp2c_internal
Help: Initialize forprime_t.
Description: 
 (forprime,int,?int):void             forprime_init(&$1, $2, $3);

Function: _forprime_next
Class: gp2c_internal
Help: Compute the next prime from the diffptr table.
Description: 
 (*small,*bptr):void  NEXT_PRIME_VIADIFF($1, $2)

Function: _forprime_next_
Class: gp2c_internal
Help: Compute the next prime.
Description: 
 (forprime):int                       forprime_next(&$1)

Function: _forprimestep_init
Class: gp2c_internal
Help: Initialize forprime_t.
Description: 
 (forprime,int,?int,int):void             forprimestep_init(&$1,$2,$3,$4);

Function: _forsubset_init
Class: gp2c_internal
Help: Initialize forsubset_t
Description: 
 (forsubset,small):void            forallsubset_init(&$1, $2)
 (forsubset,gen):void              forsubset_init(&$1, $2)

Function: _forsubset_next
Class: gp2c_internal
Help: Compute the next subset
Description: 
 (forsubset):vecsmall              forsubset_next(&$1)

Function: _forvec_init
Class: gp2c_internal
Help: Initializes parameters for forvec.
Description: 
 (forvec, gen, ?small):void    forvec_init(&$1, $2, $3)

Function: _forvec_next
Class: gp2c_internal
Help: Initializes parameters for forvec.
Description: 
 (forvec):vec    forvec_next(&$1)

Function: _gc_needed
Class: gp2c_internal
Description: 
 (pari_sp):bool                gc_needed($1, 1)

Function: _gerepileall
Class: gp2c_internal
Description: 
 (pari_sp,gen):void:parens    $2 = gerepilecopy($1, $2)
 (pari_sp,gen,...):void       gerepileall($1, ${nbarg 1 sub}, ${stdref 3 code})

Function: _gerepileupto
Class: gp2c_internal
Description: 
 (pari_sp, int):int               gerepileuptoint($1, $2)
 (pari_sp, mp):mp                 gerepileuptoleaf($1, $2)
 (pari_sp, vecsmall):vecsmall     gerepileuptoleaf($1, $2)
 (pari_sp, vec):vec               gerepileupto($1, $2)
 (pari_sp, gen):gen               gerepileupto($1, $2)

Function: _header_algebras
Class: header
Section: algebras
Doc: 
 \section{Associative and central simple algebras}
 
 This section collects functions related to associative algebras and central
 simple algebras (CSA) over number fields.
 
 \subsec{Algebra definitions} %GPHELPskip
 
 Let $A$ be a finite-dimensional unital associative algebra over a field $K$.
 The algebra $A$ is \emph{central} if its center is $K$ and it is
 \emph{simple} if it has no nontrivial two-sided ideals.
 
 We provide functions to handle associative algebras of finite
 dimension over~$\Q$ or~$\F_p$. We represent them by the left multiplication
 table on a basis over the prime subfield; the function \kbd{algtableinit}
 creates the object representing an associative algebra. We also provide
 functions to handle central simple algebras over a number field $K$. We
 represent them either by the left multiplication table on a basis over the
 center $K$ or by a cyclic algebra (see below); the function~\kbd{alginit}
 creates the object representing a central simple algebra.
 
 The set of elements of an algebra~$A$ that annihilate every simple left
 $A$-module is a two-sided ideal, called the \emph{Jacobson radical} of~$A$.
 If the Jacobson radical is trivial, the algebra is \emph{semisimple}: it is
 isomorphic to a direct product of simple algebras. The
 dimension of a CSA over its center $K$ is always a
 square $d^2$ and the integer $d$ is called the \emph{degree} of the
 algebra over~$K$. A CSA over a field~$K$ is always isomorphic to~$M_k(D)$
 for some integer~$k$ and some central division algebra~$D$ of degree~$e$:
 the integer~$e$ is the \emph{index} of the algebra.
 
 Let $L/K$ be a cyclic extension of degree $d$, let $\sigma$ be a
 generator of $\text{Gal}(L/K)$ and let $b\in K^*$. Then the
 \emph{cyclic algebra} $(L/K,\sigma,b)$ is the algebra
 $\bigoplus_{i=0}^{d-1}x^iL$ with $x^d=b$ and $\ell x=x\sigma(\ell)$ for
 all~$\ell\in L$. The algebra $(L/K,\sigma,b)$ is a central simple $K$-algebra
 of degree~$d$, and it is an $L$-vector space. Left multiplication is
 $L$-linear and induces a $K$-algebra isomorphism $(L/K,\sigma,b)\otimes_K L\to
 M_d(L)$.
 
 Let $K$ be a nonarchimedean local field with uniformizer $\pi$, and let
 $L/K$ be the unique unramified extension of degree $d$. Then every central
 simple algebra $A$ of degree $d$ over $K$ is isomorphic to
 $(L/K, \Frob, \pi^h)$ for some integer $h$. The element $h/d\in
 \Q/\Z$ is called the \emph{Hasse invariant} of $A$.
 
 \subsec{Orders in algebras} %GPHELPskip
 
 Let~$A$ be an algebra of finite dimension over~$\Q$. An \emph{order}
 in~$A$ is a finitely generated $\Z$-submodule~${\cal O}$ such
 that~$\Q{\cal O} = A$, that is also a subring with unit.
 By default the data computed by~\kbd{alginit} contains a~$\Z$-basis of a maximal
 order~${\cal O}_0$. We define natural
 orders in central simple algebras defined by a cyclic algebra or by a
 multiplication table over the center. Let~$A = (L/K,\sigma,b) =
 \bigoplus_{i=0}^{d-1}x^iL$ be a cyclic algebra over a number field~$K$ of
 degree~$n$ with ring of integers~$\Z_K$. Let~$\Z_L$ be the ring of integers
 of~$L$, and assume that~$b$ is integral. Then the submodule~${\cal O} =
 \bigoplus_{i=0}^{d-1}x^i\Z_L$ is an order in~$A$, called the
 \emph{natural order}. Let~$\omega_0,\dots,\omega_{nd-1}$ be a~$\Z$-basis
 of~$\Z_L$. The \emph{natural basis} of~${\cal O}$ is~$b_0,\dots,b_{nd^2-1}$
 where~$b_i = x^{i/(nd)}\omega_{(i \mod nd)}$. Now let~$A$ be a central simple
 algebra of degree~$d$ over a number field~$K$ of degree~$n$ with ring of
 integers~$\Z_K$. Let~$e_0,\dots,e_{d^2-1}$ be a basis of~$A$ over~$K$ and
 assume that the left multiplication table of~$A$ on~$(e_i)$ is integral. Then
 the submodule~${\cal O} = \bigoplus_{i=0}^{d^2-1}\Z_K e_i$ is an order
 in~$A$, called the \emph{natural order}. Let~$\omega_0,\dots,\omega_{n-1}$ be
 a~$\Z$-basis of~$\Z_K$. The \emph{natural basis} of~${\cal O}$
 is~$b_0,\dots,b_{nd^2-1}$ where~$b_i = \omega_{(i \mod n)}e_{i/n}$.
 
 \subsec{Lattices in algebras} %GPHELPskip
 
 We also provide functions to handle full lattices in algebras over~$\Q$. A
 full lattice~$J\subset A$ is represented by a $2$-component \typ{VEC}~$[I,t]$
 representing~$J = tI$, where
 
 \item $I$ is an integral nonsingular upper-triangular matrix representing a
 sublattice of~${\cal O}_0$ expressed on the integral basis, and
 
 \item $t\in\Q_{>0}$ is a \typ{INT} or \typ{FRAC}.
 
 For the sake of efficiency you should use matrices~$I$ that are primitive and
 in Hermite Normal Form; this makes the representation unique. No GP function
 uses this property, but all GP functions return lattices in this form. The
 prefix for lattice functions is \kbd{alglat}.
 
 \subsec{GP conventions for algebras} %GPHELPskip
 
 As with number fields, we represent elements of central simple algebras
 in two ways, called the \emph{algebraic representation} and the \emph{basis
 representation}, and you can convert betweeen the two with the functions
 \kbd{algalgtobasis} and \kbd{algbasistoalg}. In every central simple algebra
 object, we store a~$\Z$-basis of an order~${\cal O}_0$, and the basis
 representation is simply a \typ{COL} with coefficients in~$\Q$ expressing the
 element in that basis. If no maximal order was computed by~\kbd{alginit},
 then~${\cal O}_0$ is the natural order. If a maximal order was computed,
 then~${\cal O}_0$ is a maximal order containing the natural order. For a cyclic
 algebra~$A = (L/K,\sigma,b)$, the algebraic representation is a \typ{COL} with
 coefficients in~$L$ representing the element in the decomposition~$A =
 \bigoplus_{i=0}^{d-1}x^iL$. For a central simple algebra defined by a
 multiplication table over its center~$K$ on a basis~$(e_i)$, the algebraic
 representation is a \typ{COL} with coefficients in~$K$ representing the element
 on the basis~$(e_i)$.
 
 \misctitle{Warning} The coefficients in the decomposition~$A =
 \bigoplus_{i=0}^{d-1}x^iL$ are not the same as those in the decomposition~$A
 = \bigoplus_{i=0}^{d-1}Lx^i$! The $i$-th coefficients are related by
 conjugating by~$x^i$, which on~$L$ amounts to acting by~$\sigma^i$.
 
 \misctitle{Warning} For a central simple algebra over $\Q$ defined by a
 multiplication table, we cannot distinguish between the basis and the algebraic
 representations from the size of the vectors. The behavior is then to always
 interpret the column vector as a basis representation if the coefficients are
 \typ{INT} or \typ{FRAC}, and as an algebraic representation if the coefficients
 are \typ{POL} or \typ{POLMOD}.

Function: _header_combinatorics
Class: header
Section: combinatorics
Doc: 
 \section{Combinatorics}\label{se:combinat}
 
 Permutations are represented in gp as \typ{VECSMALL}s and can be input
 directly as \kbd{Vecsmall([1,3,2,4])} or obtained from the iterator
 \kbd{forperm}:
 \bprog
 ? forperm(3, p, print(p))  \\ iterate through S_3
 Vecsmall([1, 2, 3])
 Vecsmall([1, 3, 2])
 Vecsmall([2, 1, 3])
 Vecsmall([2, 3, 1])
 Vecsmall([3, 1, 2])
 Vecsmall([3, 2, 1])
 @eprog
 
 Permutations can be multiplied via \kbd{*}, raised to some power using
 \kbd{\pow}, inverted using \kbd{\pow(-1)}, conjugated as
 \kbd{p * q * p\pow(-1)}. Their order and signature is available via
 \kbd{permorder} and \kbd{permsign}.

Function: _header_conversions
Class: header
Section: conversions
Doc: 
 \section{Conversions and similar elementary functions or commands}
 \label{se:conversion}
 
 \noindent
 Many of the conversion functions are rounding or truncating operations. In
 this case, if the argument is a rational function, the result is the
 Euclidean quotient of the numerator by the denominator, and if the argument
 is a vector or a matrix, the operation is done componentwise. This will not
 be restated for every function.

Function: _header_default
Class: header
Section: default
Doc: 
 \section{GP defaults}
 \label{se:gp_defaults} This section documents the GP defaults,
 that can be set either by the GP function \tet{default} or in your GPRC.
 Be sure to check out \tet{parisize} and \tet{parisizemax} !

Function: _header_elliptic_curves
Class: header
Section: elliptic_curves
Doc: 
 \section{Elliptic curves}
 
 \subsec{Elliptic curve structures} %GPHELPskip
 An elliptic curve is given by a Weierstrass model\sidx{Weierstrass equation}
 $$
   y^2 + a_1 xy + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6,
 $$
 whose discriminant is nonzero. Affine points on \kbd{E} are represented as
 two-component vectors \kbd{[x,y]}; the point at infinity, i.e.~the identity
 element of the group law, is represented by the one-component vector
 \kbd{[0]}.
 
 Given a vector of coefficients $[a_1,a_2,a_3,a_4,a_6]$, the function
 \tet{ellinit} initializes and returns an \tev{ell} structure. An additional
 optional argument allows to specify the base field in case it cannot be
 inferred from the curve coefficients. This structure contains data needed by
 elliptic curve related functions, and is generally passed as a first argument.
 Expensive data are skipped on initialization: they will be dynamically
 computed when (and if) needed, and then inserted in the structure. The
 precise layout of the \tev{ell} structure is left undefined and should never
 be used directly. The following \idx{member functions} are available,
 depending on the underlying domain.
 
 \misctitle{All domains} %GPHELPskip
 
 \item \tet{a1}, \tet{a2}, \tet{a3}, \tet{a4}, \tet{a6}: coefficients of the
 elliptic curve.
 
 \item \tet{b2}, \tet{b4}, \tet{b6}, \tet{b8}: $b$-invariants of the curve; in
 characteristic $\neq 2$, for $Y = 2y + a_1x+a3$, the curve equation becomes
 $$ Y^2 = 4 x^3 + b_2 x^2 + 2b_4 x + b_6 =: g(x). $$
 
 \item \tet{c4}, \tet{c6}: $c$-invariants of the curve; in characteristic $\neq
 2,3$, for $X = x + b_2/12$ and $Y = 2y + a_1x+a3$, the curve equation becomes
 $$ Y^2 = 4 X^3 - (c_4/12) X - (c_6/216). $$
 
 \item \tet{disc}: discriminant of the curve. This is only required to be
 nonzero, not necessarily a unit.
 
 \item \tet{j}: $j$-invariant of the curve.
 
 \noindent These are used as follows:
 \bprog
 ? E = ellinit([0,0,0, a4,a6]);
 ? E.b4
 %2 = 2*a4
 ? E.disc
 %3 = -64*a4^3 - 432*a6^2
 @eprog
 
 \misctitle{Curves over $\C$} %GPHELPskip
 
 This in particular includes curves defined over $\Q$. All member functions in
 this section return data, as it is currently stored in the structure, if
 present; and otherwise compute it to the default accuracy, that was fixed
 \emph{at the time of ellinit} (via a \typ{REAL} $D$ domain argument, or
 \kbd{realprecision} by default). The function \tet{ellperiods} allows to
 recompute (and cache) the following data to \emph{current}
 \kbd{realprecision}.
 
 \item \tet{area}: volume of the complex lattice defining $E$.
 
 \item \tet{roots} is a vector whose three components contain the complex
 roots of the right hand side $g(x)$ of the attached $b$-model $Y^2 = g(x)$.
 If the roots are all real, they are ordered by decreasing value. If only one
 is real, it is the first component.
 
 \item \tet{omega}: $[\omega_1,\omega_2]$, periods forming a basis of the
 complex lattice defining $E$. The first component $\omega_1$ is the
 (positive) real period, in other words the integral of the N\'eron
 differential $dx/(2y+a_1x+a_3)$
 over the connected component of the identity component of $E(\R)$.
 The second component $\omega_2$ is a complex period, such that
 $\tau=\dfrac{\omega_1}{\omega_2}$ belongs to Poincar\'e's
 half-plane (positive imaginary part); not necessarily to the standard
 fundamental domain. It is normalized so that $\Im(\omega_2) < 0$
 and either $\Re(\omega_2) = 0$, when \kbd{E.disc > 0} ($E(\R)$ has two connected
 components), or $\Re(\omega_2) = \omega_1/2$
 
 \item \tet{eta} is a row vector containing the quasi-periods $\eta_1$ and
 $\eta_2$ such that $\eta_i = 2\zeta(\omega_i/2)$, where $\zeta$ is the
 Weierstrass zeta function attached to the period lattice; see
 \tet{ellzeta}. In particular, the Legendre relation holds: $\eta_2\omega_1 -
 \eta_1\omega_2 = 2\pi i$.
 
 \misctitle{Warning} As for the orientation of the basis of the period lattice,
 beware that many sources use the inverse convention where $\omega_2/\omega_1$
 has positive imaginary part and our $\omega_2$ is the negative of theirs. Our
 convention $\tau = \omega_1/\omega_2$  ensures that the action of
 $\text{PSL}_2$ is the natural one:
 $$[a,b;c,d]\cdot\tau = (a\tau+b)/(c\tau+d)
   = (a \omega_1 + b\omega_2)/(c\omega_1 + d\omega_2),$$
 instead of a twisted one. (Our $\tau$ is $-1/\tau$ in the above inverse
 convention.)
 
 \misctitle{Curves over $\Q_p$} %GPHELPskip
 
 We advise to input a model defined over $\Q$ for such curves. In any case,
 if you input an approximate model with \typ{PADIC} coefficients, it will be
 replaced by a lift to $\Q$ (an exact model ``close'' to the one that was
 input) and all quantities will then be computed in terms of this lifted
 model.
 
 For the time being only curves with multiplicative reduction (split or
 nonsplit), i.e. $v_p(j) < 0$, are supported by nontrivial functions. In
 this case the curve is analytically isomorphic to $\bar{\Q}_p^*/q^\Z :=
 E_q(\bar{\Q}_p)$, for some $p$-adic integer $q$ (the Tate period). In
 particular, we have $j(q) = j(E)$.
 
 \item \tet{p} is the residual characteristic
 
 \item \tet{roots} is a vector with a single component, equal to the $p$-adic
 root $e_1$ of the right hand side $g(x)$ of the attached $b$-model $Y^2
 = g(x)$. The point $(e_1,0)$ corresponds to $-1 \in \bar{\Q}_p^*/q^\Z$
 under the Tate parametrization.
 
 \item \tet{tate} returns $[u^2,u,q,[a,b],Ei,L]$ in the notation of
 Henniart-Mestre (CRAS t. 308, p.~391--395, 1989): $q$ is as above,
 $u\in \Q_p(\sqrt{-c_6})$ is such that $\phi^* dx/(2y + a_1x+a3) = u dt/t$,
 where $\phi: E_q\to E$ is an isomorphism (well defined up to sign) and
 $dt/t$ is the canonical invariant differential on the Tate curve; $u^2\in\Q_p$
 does not depend on $\phi$. (Technicality: if $u\not\in\Q_p$, it is stored as a
 quadratic \typ{POLMOD}.)
 The parameters $[a,b]$ satisfy $4u^2 b \cdot \text{agm}(\sqrt{a/b},1)^2 = 1$
 as in Theorem~2 (\emph{loc.~cit.}).
 \kbd{Ei} describes the sequence of 2-isogenous curves (with kernel generated
 by $[0,0]$) $E_i: y^2=x(x+A_i)(x+A_i-B_i)$ converging quadratically towards
 the singular curve $E_\infty$. Finally, $L$ is Mazur-Tate-Teitelbaum's
 ${\cal L}$-invariant, equal to $\log_p q / v_p(q)$.
 
 \misctitle{Curves over $\F_q$} %GPHELPskip
 
 \item \tet{p} is the characteristic of $\F_q$.
 
 \item \tet{no} is $\#E(\F_q)$.
 
 \item \tet{cyc} gives the cycle structure of $E(\F_q)$.
 
 \item \tet{gen} returns the generators of $E(\F_q)$.
 
 \item \tet{group} returns $[\kbd{no},\kbd{cyc},\kbd{gen}]$, i.e. $E(\F_q)$
 as an abelian group structure.
 
 \misctitle{Curves over $\Q$} %GPHELPskip
 
 All functions should return a correct result, whether the model is minimal or
 not, but it is a good idea to stick to minimal models whenever
 $\gcd(c_4,c_6)$ is easy to factor (minor speed-up). The construction
 \bprog
   E = ellminimalmodel(E0, &v)
 @eprog\noindent replaces the original model $E_0$ by a minimal model $E$,
 and the variable change $v$ allows to go between the two models:
 \bprog
   ellchangepoint(P0, v)
   ellchangepointinv(P, v)
 @eprog\noindent respectively map the point $P_0$ on $E_0$ to its image on
 $E$, and the point $P$ on $E$ to its pre-image on $E_0$.
 
 A few routines --- namely \tet{ellgenerators}, \tet{ellidentify},
 \tet{ellsearch}, \tet{forell} --- require the optional package \tet{elldata}
 (John Cremona's database) to be installed. In that case, the function
 \tet{ellinit} will allow alternative inputs, e.g.~\kbd{ellinit("11a1")}.
 Functions using this package need to load chunks of a large database in
 memory and require at least 2MB stack to avoid stack overflows.
 
 \item \tet{gen} returns the generators of $E(\Q)$, if known (from John
   Cremona's database)
 
 \misctitle{Curves over number fields} %GPHELPskip
 
 \item \tet{nf} return the \var{nf} structure attached to the number field
 over which $E$ is defined.
 
 \item \tet{bnf} return the \var{bnf} structure attached to the number field
 over which $E$ is defined or raise an error (if only an \var{nf} is available).
 
 \item \tet{omega}, \tet{eta}, \tet{area}: vectors of complex periods,
 quasi-periods and lattice areas attached to the complex embeddings of $E$,
 in the same order as \kbd{E.nf.roots}.
 
 \subsec{Reduction} %GPHELPskip
 Let $E$ be a curve defined over $\Q_p$ given by a $p$-integral model;
 if the curve has good reduction at $p$, we may define its reduction
 $\tilde{E}$ over the finite field $\F_p$:
 \bprog
 ? E = ellinit([-3,1], O(5^10));  \\ @com $E/\Q_5$
 ? Et = ellinit(E, 5)
 ? ellcard(Et)  \\ @com $\tilde{E}/\F_5$ has 7 points
 %3 = 7
 ? ellinit(E, 7)
  ***   at top-level: ellinit(E,7)
  ***                 ^------------
  *** ellinit: inconsistent moduli in ellinit: 5 != 7
 @eprog\noindent
 Likewise, if a curve is defined over a number field $K$ and $\goth{p}$ is a
 maximal ideal with finite residue field $\F_q$, we define the reduction
 $\tilde{E}/\F_q$ provided $E$ has good reduction at $\goth{p}$.
 $E/\Q$ is an important special case:
 \bprog
 ? E = ellinit([-3,1]);
 ? factor(E.disc)
 %2 =
 [2 4]
 
 [3 4]
 ? Et = ellinit(E, 5);
 ? ellcard(Et) \\ @com $\tilde{E} / \F_5$ has 7 points
 %4 = 7
 ? ellinit(E, 3)  \\ bad reduction at 3
 %5 = []
 @eprog\noindent General number fields are similar:
 \bprog
 ? K = nfinit(x^2+1); E = ellinit([x,x+1], K);
 ? idealfactor(K, E.disc)  \\ three primes of bad reduction
 %2 =
 [  [2, [1, 1]~, 2, 1, [1, -1; 1, 1]] 10]
 
 [ [5, [-2, 1]~, 1, 1, [2, -1; 1, 2]]  2]
 
 [[5, [2, 1]~, 1, 1, [-2, -1; 1, -2]]  2]
 ? P = idealprimedec(K, 3); \\ a prime of good reduction
 ? idealnorm(K, P)
 %4 = 9
 ? Et = ellinit(E, P);
 ? ellcard(Et)  \\ @com $\tilde{E} / \F_9$ has 4 points
 %6 = 4
 @eprog\noindent
 If the model is not locally minimal at $\goth{p}$, the above will fail:
 \kbd{elllocalred} and \kbd{ellchangecurve} allow to reduce to that case.
 
 Some functions such as \kbd{ellap}, \kbd{ellcard}, \kbd{ellgroup} and
 \kbd{ellissupersingular} even implicitly replace the given equation by
 a local minimal model and consider the group of nonsingular points
 $\tilde{E}^{ns}$ so they make sense even when the curve has bad reduction.

Function: _header_graphic
Class: header
Section: graphic
Doc: 
 \section{Plotting functions}
 
   Although plotting is not even a side purpose of PARI, a number of plotting
 functions are provided. There are three types of graphic functions.
 
 \subsec{High-level plotting functions} (all the functions starting with
 \kbd{ploth}) in which the user has little to do but explain what type of plot
 he wants, and whose syntax is similar to the one used in the preceding
 section.
 
 \subsec{Low-level plotting functions} (called \var{rectplot} functions,
 sharing the prefix \kbd{plot}), where every drawing primitive (point, line,
 box, etc.) is specified by the user. These low-level functions work as
 follows. You have at your disposal 16 virtual windows which are filled
 independently, and can then be physically ORed on a single window at
 user-defined positions. These windows are numbered from 0 to 15, and must be
 initialized before being used by the function \kbd{plotinit}, which specifies
 the height and width of the virtual window (called a \var{rectwindow} in the
 sequel). At all times, a virtual cursor (initialized at $[0,0]$) is attached
 to the window, and its current value can be obtained using the function
 \kbd{plotcursor}.
 
 A number of primitive graphic objects (called \var{rect} objects) can then
 be drawn in these windows, using a default color attached to that window
 (which can be changed using the \kbd{plotcolor} function) and only the part
 of the object which is inside the window will be drawn, with the exception of
 polygons and strings which are drawn entirely. The ones sharing the prefix
 \kbd{plotr} draw relatively to the current position of the virtual cursor,
 the others use absolute coordinates. Those having the prefix \kbd{plotrecth}
 put in the rectwindow a large batch of rect objects corresponding to the
 output of the related \kbd{ploth} function.
 
    Finally, the actual physical drawing is done using \kbd{plotdraw}. The
 rectwindows are preserved so that further drawings using the same windows at
 different positions or different windows can be done without extra work. To
 erase a window, use \kbd{plotkill}. It is not possible to partially erase a
 window: erase it completely, initialize it again, then fill it with the
 graphic objects that you want to keep.
 
    In addition to initializing the window, you may use a scaled window to
 avoid unnecessary conversions. For this, use \kbd{plotscale}. As long as this
 function is not called, the scaling is simply the number of pixels, the
 origin being at the upper left and the $y$-coordinates going downwards.
 
    Plotting functions are platform independent, but a number of graphical
 drivers are available for screen output: X11-windows (including
 Openwindows and Motif), Windows's Graphical Device Interface, the Qt and
 FLTK graphical libraries and one may even write the graphical objects to a
 PostScript or SVG file and use an external viewer to open it. The physical
 window opened by \kbd{plotdraw} or any of the \kbd{ploth*} functions is
 completely separated from \kbd{gp} (technically, a \kbd{fork} is done, and
 all memory unrelated to the graphics engine is immediately freed in the child
 process), which means you can go on working in the current \kbd{gp} session,
 without having to kill the window first. This window can be closed, enlarged
 or reduced using the standard window manager functions. No zooming procedure is
 implemented though.
 
 \subsec{Functions for PostScript or SVG output} in the same way that
 \kbd{printtex} allows you to have a \TeX\ output
 corresponding to printed results, the functions \kbd{plotexport},
 \kbd{plothexport} and \kbd{plothrawexport} convert a plot to a character
 string in either \tet{PostScript} or \tet{Scalable Vector Graphics} format.
 This string can then be written to a file in the customary way, using
 \kbd{write}. These export routines are available even if no Graphic Library is.
 \smallskip

Function: _header_hypergeometric_motives
Class: header
Section: hypergeometric_motives
Doc: 
 \section{Hypergeometric Motives}
 
 \subsec{Templates} %GPHELPskip
 
 A \emph{hypergeometric template} is a pair of multisets (i.e., sets with
 possibly repeated elements) of rational numbers $(\alpha_1,\dots,\alpha_d)$
 and $(\beta_1,\dots,\beta_d)$ having the same number of elements, and we set
 $$A(x)=\prod_{1\le j\le d}(x-e^{2\pi i\alpha_j}),\quad
 B(x)=\prod_{1\le k\le d}(x-e^{2\pi i\beta_k})\;.$$
 We make the following assumptions:
 
 \item $\alpha_j-\beta_k\notin\Z$ for all $j$ and $k$, or
 equivalently $\gcd(A,B)=1$.
 
 \item $\alpha_j\notin\Z$ for all $j$, or equivalently $A(1)\ne0$.
 
 \item our template is \emph{defined over $\Q$}, in other words
 $A,B\in\Z[x]$, or equivalently if some $a/D$ with $\gcd(a,D)=1$ occurs
 in the $\alpha_j$ or $\beta_k$, then all the $b/D$ modulo $1$ with
 $\gcd(b,D)=1$ also occur.
 
 The last assumption allows to abbreviate $[a_1/D,\dots,a_{\phi(D)}/D]$
 (where the $a_i$ range in $(\Z/D\Z)^*$) to $[D]$. We thus have two possible
 ways of giving a hypergeometric template: either by the two vectors
 $[\alpha_1,\dots,\alpha_d]$ and $[\beta_1,\dots,\beta_d]$, or by their
 denominators $[D_1,\dots,D_m]$ and $[E_1,\dots,E_n]$ , which are called the
 \emph{cyclotomic parameters}; note that $\sum_j\phi(D_j) = \sum_k\phi(E_k)=d$.
 A third way is to give the \emph{gamma vector} $(\gamma_n)$
 defined by $A(X)/B(X)=\prod_n(X^n-1)^{\gamma_n}$, which satisfies
 $\sum_n n\gamma_n=0$. To any such data we associate a hypergeometric template
 using the function \kbd{hgminit}; then the $\alpha_j$ and $\beta_k$
 are obtained using \kbd{hgmalpha}, cyclotomic parameters
 using \kbd{hgmcyclo} and the gamma vectors using \kbd{hgmgamma}.
 
 To such a hypergeometric template is associated a number of additional
 parameters, for which we do not give the definition but refer to the survey
 \emph{Hypergeometric Motives} by Roberts and Villegas,
 \kbd{https://arxiv.org/abs/2109.00027}:
 the degree $d$, the \emph{weight} $w$, a \emph{Hodge polynomial}~$P$,
 a \emph{Tate twist} $T$, and a normalizing M-factor
 $M = \prod_n n^{n\gamma_n}$. The \kbd{hgmparams} function returns
 $$[d,w,[P,T],M]\;.$$
 Example with cyclotomic parameters $[5],[1,1,1,1]$:
 \bprog
 ? H = hgminit([5]); \\ [1,1,1,1] can be omitted
 ? hgmparams(H)
 %2 = [4, 3, [x^3+x^2+x+1,0], 3125]
 ? hgmalpha(H)
 %3 = [[1/5, 2/5, 3/5, 4/5], [0, 0, 0, 0]]
 ? hgmcyclo(H)
 %4 = [Vecsmall([5]), Vecsmall([1, 1, 1, 1])]
 ? hgmgamma(H)
 %5 = Vecsmall([-5,0,0,0,1]) \\ A/B = (x^5-1) / (x-1)^5
 @eprog
 
 \subsec{Motives} %GPHELPskip
 
 A \emph{hypergeometric motive} (HGM for short) is a pair $(H,t)$, where
 $H$ is a hypergeometric template and $t\in\Q^*$. To such a motive and a
 finite field $\F_q$ one can associate via an explicit but
 complicated formula an \emph{integer} $N_q(H,t)$, see Beukers, Cohen and
 Mellit, \emph{Finite hypergeometric functions} Pure and Applied Math
 Quarterly 11 (2015), pp 559 - 589, \kbd{https://arxiv.org/abs/1505.02900}.
 
 \misctitle{Warning} Depending on the authors, $t$ may have to be replaced
  with $1/t$. The \kbd{Pari/GP} convention is the same as the one in
 \kbd{Magma}, but is the inverse of the one in the last reference.
 
 This formula does not make sense and is not valid for \emph{bad
 primes}~$p$: a \emph{wild prime} is a prime which divides a denominator of
 the $\alpha_j$ or $\beta_i$. If a prime $p$ is not wild, it can be
 \emph{good} if $v_p(t)=v_p(t-1)=0$, or \emph{tame} otherwise.
 The \emph{local Euler factor} at a good prime $p$ is then given by the
 (inverse of the) usual formula
 $$P_p(T)=\exp\left(-\sum_{f\ge1}\dfrac{N_{p^f}(H,t)}{f}T^f\right)\;,$$
 and in the case of HGM's it is always a polynomial (note that the Euler factor
 used in the global $L$-function is $1/P_p(p^{-s})$). At a tame prime $p$ it
 is necessary to modify the above formula, and usually (but not always) the
 degree of the local Euler factor decreases. Wild primes are currently not
 implemented by a formula but can be guessed via the global functional
 equation (see the next section). Continuing the previous example, we find
 \bprog
 ? hgmeulerfactor(H, -1, 3) \\ good prime
 %4 = 729*x^4 + 135*x^3 + 45*x^2 + 5*x + 1
 ? hgmeulerfactor(H, -1, 2) \\ tame prime
 %5 = 16*x^3 + 6*x^2 + x + 1
 ? hgmeulerfactor(H, -1, 5) \\ wild primes not implemented
 %6 = 0
 @eprog\noindent
 To obtain the Euler factor at wild primes, use \kbd{lfuneuler} once
 the global $L$-function is computed.
 
 \subsec{The Global $L$-function} %GPHELPskip
 
 A theorem of Katz tells us that if one suitably defines $P_p(T)$ for
 all primes $p$ including the wild ones, then the $L$-function defined
 by $L(H,s)=\prod_p P_p(p^{-s})^{-1}$ is motivic,
 with analytic continuation and functional equation,
 as used in the $L$-function package of \kbd{Pari/GP}. The command
 \kbd{L = lfunhgm(H,t)} creates such an $L$-function. In particular it must
 guess the local Euler factors at wild primes, which can be very expensive
 when the conductor \kbd{lfunparams}$(L)[1]$ is large.
 
 In our example, \kbd{L = lfunhgm(H,1/64)} finishes in about 20 seconds
 (the conductor is only 525000);
 this $L$-function can then be used with all the functions of the
 \kbd{lfun} package. For instance we can now obtain the global conductor and
 check the Euler factors at all bad primes:
 \bprog
 ? [N] = lfunparams(L); N \\ the conductor
 %7 = 525000
 ? factor(N)
 %8 =
 [2 3]
 
 [3 1]
 
 [5 5]
 
 [7 1]
 
 ? lfuneuler(L,2)
 %9 = 1/(-x + 1)
 ? lfuneuler(L,3)
 %10 = 1/(81*x^3 + 6*x^2 - 4*x + 1)
 ? lfuneuler(L,5)
 %11 = 1
 ? lfuneuler(L,7)
 %12 = 1/(2401*x^3 + 301*x^2 + x + 1)
 @eprog
 
 Two additional functions related to the global $L$-function are available
 which do \emph{not} require its full initialization:
 \kbd{hgmcoefs(H,t,n)} computes
 the first $n$ coefficients of the $L$-function by setting all wild Euler
 factors to $1$; this will be identical to \kbd{lfunan(L,n)} when this is
 indeed the case (as in the above example: only $5$ is wild), otherwise all
 coefficients divisible by a wild prime will be wrong.
 
 The second is the function \kbd{hgmcoef(H,t,n)} which only computes the
 $n$th coefficient of the global $L$-function. It gives an error if $n$
 is divisible by a wild prime. Compare \kbd{hgmcoefs(H,1/64,7\^{}6)[7\^{}6]}
 which requires more than 1 minute (it computes more than 100000 coefficients),
 with \kbd{hgmcoef(H,1/64,7\^{}6)} which outputs $-25290600$ instantaneously.

Function: _header_l_functions
Class: header
Section: l_functions
Doc: 
 \section{$L$-functions}
 
 This section describes routines related to $L$-functions. We first introduce
 the basic concept and notations, then explain how to represent them in GP.
 Let $\Gamma_{\R}(s) = \pi^{-s/2}\Gamma(s/2)$, where $\Gamma$ is Euler's gamma
 function. Given $d \geq 1$ and a $d$-tuple $A=[\alpha_1,\dots,\alpha_d]$ of
 complex numbers, we let $\gamma_A(s) = \prod_{\alpha \in A} \Gamma_{\R}(s +
 \alpha)$.
 
 Given a sequence $a = (a_n)_{n\geq 1}$ of complex numbers (such that $a_1 = 1$),
 a positive \emph{conductor} $N \in \Z$, and a \emph{gamma factor}
 $\gamma_A$ as above, we consider the Dirichlet series
 $$ L(a,s) = \sum_{n\geq 1} a_n n^{-s} $$
 and the attached completed function
 $$ \Lambda(a,s) = N^{s/2}\gamma_A(s) \cdot L(a,s). $$
 
 Such a datum defines an \emph{$L$-function} if it satisfies the three
 following assumptions:
 
 \item [Convergence] The $a_n = O_\epsilon(n^{k_1+\epsilon})$ have polynomial
 growth, equivalently $L(s)$ converges absolutely in some right half-plane
 $\Re(s) > k_1 + 1$.
 
 \item [Analytic continuation] $L(s)$ has a meromorphic continuation to the
 whole complex plane with finitely many poles.
 
 \item [Functional equation] There exist an integer $k$, a complex number
 $\epsilon$ (usually of modulus~$1$), and an attached sequence $a^*$
 defining both an $L$-function $L(a^*,s)$ satisfying the above two assumptions
 and a completed function $\Lambda(a^*,s) = N^{s/2}\gamma_A(s) \cdot
 L(a^*,s)$, such that
 $$\Lambda(a,k-s) = \epsilon \Lambda(a^*,s)$$
 for all regular points.
 
 More often than not in number theory we have $a^* = \overline{a}$ (which
 forces $|\epsilon| = 1$), but this needs not be the case. If $a$ is a real
 sequence and $a = a^*$, we say that $L$ is \emph{self-dual}. We do not assume
 that the $a_n$ are multiplicative, nor equivalently that $L(s)$ has an Euler
 product.
 
 \misctitle{Remark}
 Of course, $a$ determines the $L$-function, but the (redundant) datum $a,a^*,
 A, N, k, \epsilon$ describes the situation in a form more suitable for fast
 computations; knowing the polar part $r$ of $\Lambda(s)$ (a rational function
 such that $\Lambda-r$ is holomorphic) is also useful. A subset of these,
 including only finitely many $a_n$-values will still completely determine $L$
 (in suitable families), and we provide routines to try and compute missing
 invariants from whatever information is available.
 
 \misctitle{Important Caveat}
 The implementation assumes that the implied constants in the $O_\epsilon$ are
 small. In our generic framework, it is impossible to return proven results
 without more detailed information about the $L$ function. The intended use of
 the $L$-function package is not to prove theorems, but to experiment and
 formulate conjectures, so all numerical results should be taken with a grain
 of salt. One can always increase \kbd{realbitprecision} and recompute: the
 difference estimates the actual absolute error in the original output.
 
 \misctitle{Note} The requested precision has a major impact on runtimes.
 Because of this, most $L$-function routines, in particular \kbd{lfun} itself,
 specify the requested precision in \emph{bits}, not in decimal digits.
 This is transparent for the user once \tet{realprecision} or
 \tet{realbitprecision} are set. We advise to manipulate precision via
 \tet{realbitprecision} as it allows finer granularity: \kbd{realprecision}
 increases by increments of 64 bits, i.e. 19 decimal digits at a time.
 
 \subsec{Theta functions}
 
 Given an $L$-function as above, we define an attached theta function
 via Mellin inversion: for any positive real $t > 0$, we let
 $$ \theta(a,t) := \dfrac{1}{2\pi i}\int_{\Re(s) = c} t^{-s} \Lambda(s)\, ds $$
 where $c$ is any positive real number $c > k_1+1$ such that $c + \Re(a) > 0$
 for all $a\in A$. In fact, we have
 $$\theta(a,t) = \sum_{n\geq 1} a_n K(nt/N^{1/2})
 \quad\text{where}\quad
 K(t) := \dfrac{1}{2\pi i}\int_{\Re(s) = c} t^{-s} \gamma_A(s)\, ds.$$
 Note that this function is analytic and actually makes sense for complex $t$,
 such that $\Re(t^{2/d}) > 0$, i.e. in a cone containing the positive real
 half-line. The functional equation for $\Lambda$ translates into
 $$ \theta(a,1/t) - \epsilon t^k\theta(a^*,t) = P_\Lambda(t), $$
 where $P_\Lambda$ is an explicit polynomial in $t$ and $\log t$ given by the
 Taylor development of the polar part of $\Lambda$: there are no $\log$'s if
 all poles are simple, and $P = 0$ if $\Lambda$ is entire. The values
 $\theta(t)$ are generally easier to compute than the $L(s)$, and this
 functional equation provides a fast way to guess possible values for
 missing invariants in the $L$-function definition.
 
 \subsec{Data structures describing $L$ and theta functions}
 
 We have 3 levels of description:
 
 \item an \tet{Lmath} is an arbitrary description of the underlying
 mathematical situation (to which e.g., we associate the $a_p$ as traces of
 Frobenius elements); this is done via constructors to be described in the
 subsections below.
 
 \item an \tet{Ldata} is a computational description of situation, containing
 the complete datum ($a,a^*,A,k,N,\epsilon,r$). Where $a$ and $a^*$ describe
 the coefficients (given $n,b$ we must be able to compute $[a_1,\dots,a_n]$
 with bit accuracy $b$), $A$ describes the Euler factor, the (classical) weight
 is $k$, $N$ is the conductor, and $r$ describes the polar part of $L(s)$.
 This is obtained via the function \tet{lfuncreate}. N.B. For motivic
 $L$-functions, the motivic weight $w$ is $w = k-1$; but we also support
 nonmotivic $L$-functions.
 
 \misctitle{Technical note} When some components of an \kbd{Ldata} cannot be
 given exactly, usually $r$ or $\epsilon$, the \kbd{Ldata} may be given as a
 \emph{closure}. When evaluated at a given precision, the closure must return
 all components as exact data or floating point numbers at the requested
 precision, see \kbd{??lfuncreate}. The reason for this technicality is that
 the accuracy to which we must compute is not bounded a priori and unknown
 at this stage: it depends on the domain where we evaluate the $L$-function.
 
 \item an \tet{Linit} contains an \kbd{Ldata} and everything needed for fast
 \emph{numerical} computations. It specifies the functions to be considered
 (either $L^{(j)}(s)$ or $\theta^{(j)}(t)$ for derivatives of order $j \leq
 m$, where $m$ is now fixed) and specifies a \emph{domain} which limits
 the range of arguments ($t$ or $s$, respectively to certain cones and
 rectangular regions) and the output accuracy. This is obtained via the
 functions \tet{lfuninit} or \tet{lfunthetainit}.
 
 All the functions which are specific to $L$ or theta functions share the
 prefix \kbd{lfun}. They take as first argument either an \kbd{Lmath}, an
 \kbd{Ldata}, or an \kbd{Linit}. If a single value is to be computed,
 this makes no difference, but when many values are needed (e.g. for plots or
 when searching for zeros), one should first construct an \kbd{Linit}
 attached to the search range and use it in all subsequent calls.
 If you attempt to use an \kbd{Linit} outside the range for which it was
 initialized, a warning is issued, because the initialization is
 performed again, a major inefficiency:
 \bprog
 ? Z = lfuncreate(1); \\ Riemann zeta
 ? L = lfuninit(Z, [1/2, 0, 100]); \\ zeta(1/2+it), |t| < 100
 ? lfun(L, 1/2)    \\ OK, within domain
 %3 = -1.4603545088095868128894991525152980125
 ? lfun(L, 0)      \\ not on critical line !
   *** lfun: Warning: lfuninit: insufficient initialization.
 %4 = -0.50000000000000000000000000000000000000
 ? lfun(L, 1/2, 1) \\ attempt first derivative !
 *** lfun: Warning: lfuninit: insufficient initialization.
 %5 = -3.9226461392091517274715314467145995137
 @eprog
 
 For many $L$-functions, passing from \kbd{Lmath} to an \kbd{Ldata} is
 inexpensive: in that case one may use \kbd{lfuninit} directly from the
 \kbd{Lmath} even when evaluations in different domains are needed. The
 above example could equally have skipped the \kbd{lfuncreate}:
 \bprog
 ? L = lfuninit(1, [1/2, 0, 100]); \\ zeta(1/2+it), |t| < 100
 @eprog\noindent In fact, when computing a single value, you can even skip
 \kbd{lfuninit}:
 \bprog
 ? L = lfun(1, 1/2, 1); \\ zeta'(1/2)
 ? L = lfun(1, 1+x+O(x^5)); \\ first 5 terms of Taylor development at 1
 @eprog\noindent Both give the desired results with no warning.
 
 \misctitle{Complexity}
 The implementation requires $O(N(|t|+1))^{1/2}$ coefficients $a_n$
 to evaluate $L$ of conductor $N$ at $s = \sigma + i t$.
 
 We now describe the available high-level constructors, for built-in $L$
 functions.
 
 \subsec{Dirichlet $L$-functions} %GPHELPskip
 
 Given a Dirichlet character $\chi:(\Z/N\Z)^*\to \C$, we let
 $$L(\chi, s) = \sum_{n\geq 1} \chi(n) n^{-s}.$$
 Only primitive characters are supported. Given a nonzero
 integer $D$, the \typ{INT} $D$ encodes the function $L((D_0/.), s)$, for the
 quadratic Kronecker symbol attached to the fundamental discriminant
 $D_0 = \kbd{coredisc}(D)$. This includes Riemann $\zeta$ function via the
 special case $D = 1$.
 
 More general characters can be represented in a variety of ways:
 
 \item via Conrey notation (see \tet{znconreychar}): $\chi_N(m,\cdot)$
 is given as the \typ{INTMOD} \kbd{Mod(m,N)}.
 
 \item via a \var{znstar} structure describing the abelian  group $(\Z/N\Z)^*$,
 where the character is given in terms of the \var{znstar} generators:
 \bprog
   ? G = znstar(100, 1); \\ (Z/100Z)^*
   ? G.cyc \\ ~ Z/20 . g1  + Z/2 . g2 for some generators g1 and g2
   %2 = [20, 2]
   ? G.gen
   %3 = [77, 51]
   ? chi = [a, b]  \\ maps g1 to e(a/20) and g2 to e(b/2);  e(x) = exp(2ipi x)
 @eprog\noindent
 More generally, let $(\Z/N\Z)^* = \oplus (\Z/d_i\Z) g_i$ be given via a
 \var{znstar} structure $G$ (\kbd{G.cyc} gives the $d_i$ and \kbd{G.gen} the
 $g_i$). A \tev{character} $\chi$ on $G$ is given by a row vector
 $v = [a_1,\ldots,a_n]$ such that $\chi(\prod g_i^{n_i}) = \exp(2\pi i\sum a_i
 n_i / d_i)$. The pair $[G, v]$ encodes the \emph{primitive} character
 attached to $\chi$.
 
 \item in fact, this construction $[G, m]$ describing a character
 is more general: $m$ is also allowed to be a Conrey label as seen above,
 or a Conrey logarithm (see \tet{znconreylog}), and the latter format is
 actually the fastest one. Instead
 of a single character as above, one may use the construction
 \kbd{lfuncreate([G, vchi])} where \kbd{vchi} is a nonempty vector of
 characters \emph{of the same conductor} (more precisely, whose attached
 primitive characters have the same conductor) and \emph{same parity}.
 The function is then vector-valued, where the values are ordered as the
 characters in \kbd{vchi}. Conrey labels cannot be used in this last format
 because of the need to distinguish a single character given by a row vector
 of integers and a vector of characters given by their labels: use
 \kbd{znconreylog(G,i)} first to convert a label to Conrey logarithm.
 
 \item it is also possible to view Dirichlet characters as Hecke characters
 over $K = \Q$ (see below), for a modulus $[N, [1]]$ but this is both more
 complicated and less efficient.
 
 In all cases, a nonprimitive character is replaced by the attached primitive
 character.
 
 \subsec{Hecke $L$-functions of finite order characters} %GPHELPskip
 
 The Dedekind zeta function of a number field $K = \Q[X]/(T)$ is encoded
 either by the defining polynomial $T$, or any absolute number fields
 structure (preferably at least a \var{bnf}).
 
 Given a finite order Hecke character $\chi: Cl_f(K)\to \C$, we let
 $$L(\chi, s) = \sum_{A \subset O_K} \chi(A)\, \left(N_{K/\Q}A\right)^{-s}.$$
 
 Let $Cl_f(K) = \oplus (\Z/d_i\Z) g_i$ given by a \var{bnr} structure with
 generators: the $d_i$ are given by \kbd{K.cyc} and the $g_i$ by \kbd{K.gen}.
 A \tev{character} $\chi$ on the ray class group is given by a row vector
 $v = [a_1,\ldots,a_n]$ such that $\chi(\prod g_i^{n_i}) = \exp(2\pi i\sum
 a_i n_i / d_i)$. The pair $[\var{bnr}, v]$ encodes the \emph{primitive}
 character attached to $\chi$.
 
 \bprog
 ? K  = bnfinit(x^2-60);
 ? Cf = bnrinit(K, [7, [1,1]], 1); \\ f = 7 oo_1 oo_2
 ? Cf.cyc
 %3 = [6, 2, 2]
 ? Cf.gen
 %4 = [[2, 1; 0, 1], [22, 9; 0, 1], [-6, 7]~]
 ? lfuncreate([Cf, [1,0,0]]); \\@com $\chi(g_1) = \zeta_6$, $\chi(g_2)=\chi(g_3)=1$
 @eprog
 
 \noindent Dirichlet characters on $(\Z/N\Z)^*$ are a special case,
 where $K = \Q$:
 \bprog
 ? Q  = bnfinit(x);
 ? Cf = bnrinit(Q, [100, [1]]); \\ for odd characters on (Z/100Z)*
 @eprog\noindent
 For even characters, replace by \kbd{bnrinit(K, N)}. Note that the simpler
 direct construction in the previous section will be more efficient. Instead
 of a single character as above, one may use the construction
 \kbd{lfuncreate([Cf, vchi])} where \kbd{vchi} is a nonempty vector of
 characters \emph{of the same conductor} (more precisely, whose attached
 primitive characters have the same conductor). The function is then
 vector-valued, where the values are ordered as the characters in \kbd{vchi}.
 
 \subsec{General Hecke $L$-functions} %GPHELPskip
 
 Given a Hecke \tev{Grossencharacter} $\chi: \A^\times\to \C^\times$ of
 conductor~$\goth{f}$, we let
 $$L(\chi, s) = \sum_{A \subset \Z_K,\ A+\goth{f}=\Z_K} \chi(A)\, \left(N_{K/\Q}A\right)^{-s}.$$
 
 Let $C_K(\goth{m})=\A^\times/(K^\times\cdot U(\goth{m}))$ be a id\`ele class
 group of modulus $\goth{m}$ given by a \var{gchar} structure~\var{gc}.
 A Grossencharacter $\chi$ on $C_K(\goth{m})$ is given by a row
 vector of size \kbd{\#\var{gc}.cyc}.
 
 \bprog
 ? gc = gcharinit(x^3+4*x-1,[5,[1]]); \\ mod = 5.oo
 ? gc.cyc
 %3 = [4, 2, 0, 0]
 ? gcharlog(gc,idealprimedec(gc.bnf,5)[1]) \\@com logarithm map $C_K(\goth{m})\to \R^n$
 ? gcharduallog(gc,[1,0,0,1]) \\@com row vector of exponents in $\R^n$
 ? lfunzeros([gc,[1,0,0,1]],1) \\@com non algebraic $L$-function
 @eprog
 
 Finite order Hecke characters are a special case.
 
 \subsec{Artin $L$ functions} %GPHELPskip
 
 Given a Galois number field $N/\Q$ with group $G = \kbd{galoisinit}(N)$,
 a representation $\rho$ of $G$ over the cyclotomic field $\Q(\zeta_n)$
 is specified by the matrices giving the images of $\kbd{G.gen}$ by $\rho$.
 The corresponding Artin $L$ function is created using \tet{lfunartin}.
 \bprog
    P = quadhilbert(-47); \\  degree 5, Galois group D_5
    N = nfinit(nfsplitting(P)); \\ Galois closure
    G = galoisinit(N);
    [s,t] = G.gen; \\ order 5 and 2
    L = lfunartin(N,G, [[a,0;0,a^-1],[0,1;1,0]], 5); \\ irr. degree 2
 @eprog\noindent In the above, the polynomial variable (here \kbd{a}) represents
 $\zeta_5 := \exp(2i\pi/5)$ and the two matrices give the images of
 $s$ and $t$. Here, priority of \kbd{a} must be lower than the priority
 of \kbd{x}.
 
 \subsec{$L$-functions of algebraic varieties} %GPHELPskip
 
 $L$-function of elliptic curves over number fields are supported.
 \bprog
 ? E = ellinit([1,1]);
 ? L = lfuncreate(E);  \\ L-function of E/Q
 ? E2 = ellinit([1,a], nfinit(a^2-2));
 ? L2 = lfuncreate(E2);  \\ L-function of E/Q(sqrt(2))
 @eprog
 
 $L$-function of hyperelliptic genus-$2$ curve can be created with
 \kbd{lfungenus2}. To create the $L$ function of the curve
 $y^2+(x^3+x^2+1)y = x^2+x$:
 \bprog
 ? L = lfungenus2([x^2+x, x^3+x^2+1]);
 @eprog
 Currently, the model needs to be minimal at $2$, and if the conductor is even,
 its valuation at $2$ might be incorrect (a warning is issued).
 
 \subsec{Eta quotients / Modular forms} %GPHELPskip
 
 An eta quotient is created by applying \tet{lfunetaquo} to a matrix with
 2 columns $[m, r_m]$ representing
 $$ f(\tau) := \prod_m \eta(m\tau)^{r_m}. $$
 It is currently assumed that $f$ is a self-dual cuspidal form on
 $\Gamma_0(N)$ for some $N$.
 For instance, the $L$-function $\sum \tau(n) n^{-s}$
 attached to Ramanujan's $\Delta$ function is encoded as follows
 \bprog
 ? L = lfunetaquo(Mat([1,24]));
 ? lfunan(L, 100)  \\ first 100 values of tau(n)
 @eprog
 
 More general modular forms defined by modular symbols will be added later.
 
 \subsec{Low-level Ldata format} %GPHELPskip
 
 When no direct constructor is available, you can still input an $L$ function
 directly by supplying $[a, a^*,A, k, N, \epsilon, r]$ to \kbd{lfuncreate}
 (see \kbd{??lfuncreate} for details).
 
 It is \emph{strongly} suggested to first check consistency of the created
 $L$-function:
 \bprog
 ? L = lfuncreate([a, as, A, k, N, eps, r]);
 ? lfuncheckfeq(L)  \\ check functional equation
 @eprog

Function: _header_linear_algebra
Class: header
Section: linear_algebra
Doc: 
 \section{Vectors, matrices, linear algebra and sets}
 \label{se:linear_algebra}
 
 Note that most linear algebra functions operating on subspaces defined by
 generating sets (such as \tet{mathnf}, \tet{qflll}, etc.) take matrices as
 arguments. As usual, the generating vectors are taken to be the
 \emph{columns} of the given matrix.
 
 Since PARI does not have a strong typing system, scalars live in
 unspecified commutative base rings. It is very difficult to write
 robust linear algebra routines in such a general setting. We thus
 assume that the base ring is a domain and work over its field of
 fractions. If the base ring is \emph{not} a domain, one gets an error as soon
 as a nonzero pivot turns out to be noninvertible. Some functions,
 e.g.~\kbd{mathnf} or \kbd{mathnfmod}, specifically assume that the base ring is
 $\Z$.

Function: _header_modular_forms
Class: header
Section: modular_forms
Doc: 
 \section{Modular forms}
 
 This section describes routines for working with modular forms and modular
 form spaces.
 
 \subsec{Modular form spaces} %GPHELPskip
 
 These structures are initialized by the \kbd{mfinit} command; supported
 modular form \emph{spaces} with corresponding flags are the following:
 
 \item The full modular form space $M_k(\Gamma_0(N),\chi)$, where $k$ is an
 integer or a half-integer and $\chi$ a Dirichlet character modulo $N$
 (flag $4$, the default).
 
 \item The cuspidal space $S_k(\Gamma_0(N),\chi)$ (flag $1$).
 
 \item The Eisenstein space ${\cal E}_k(\Gamma_0(N),\chi)$ (flag $3$), so
 that $M_k={\cal E}_k\oplus S_k$.
 
 \item The new space $S_k^{\text{new}}(\Gamma_0(N),\chi)$ (flag $0$).
 
 \item The old space $S_k^{\text{old}}(\Gamma_0(N),\chi)$ (flag $2$), so that
 $S_k=S_k^{\text{new}}\oplus S_k^{\text{old}}$.
 
 These resulting \kbd{mf} structure contains a basis of modular forms, which
 is accessed by the function \kbd{mfbasis}; the elements of this basis have
 Fourier coefficients in the cyclotomic field $\Q(\chi)$. These coefficients
 are given algebraically, as rational numbers or \typ{POLMOD}s. The member
 function \kbd{mf.mod} recovers the modulus used to define $\Q(\chi)$, which
 is a cyclotomic polynomial $\Phi_n(t)$. When needed, the elements of
 $\Q(\chi)$ are considered to be canonically embedded into $\C$ via
 $\kbd{Mod}(t,\Phi_n(t)) \mapsto \exp(2i\pi/n)$.
 
 The basis of eigenforms for the new space is obtained by the function
 \kbd{mfeigenbasis}: the elements of this basis now have Fourier coefficients
 in a relative field extension of $\Q(\chi)$. Note that if the space is
 larger than the new space (i.e. is the cuspidal or full space) we
 nevertheless obtain only the eigenbasis for the new space.
 
 \subsec{Generalized modular forms} %GPHELPskip
 
 A modular form is represented in a special internal format giving the
 possibility to compute an arbitrary number of terms of its Fourier coefficients
 at infinity $[a(0),a(1),...,a(n)]$ using the function \kbd{mfcoefs}. These
 coefficients are given algebraically, as rational numbers or \typ{POLMOD}s.
 The member function \kbd{f.mod} recovers the modulus used in the
 coefficients of $f$, which will be the same as for $k = \Q(\chi)$ (a cyclotomic
 polynomial), or define a number field extension $K/k$.
 
 Modular forms are obtained either directly from other mathematical objects,
 e.g., elliptic curves, or by a specific formula, e.g., Eisenstein series or
 Ramanujan's Delta function, or by applying standard operators to existing forms
 (Hecke operators, Rankin--Cohen brackets, \dots). A function \kbd{mfparams} is
 provided so that one can recover the level, weight, character and field of
 definition corresponding to a given modular form.
 
 A number of creation functions and operations are provided. It is however
 important to note that strictly speaking some of these operations create
 objects which are \emph{not} modular forms: typical examples are
 derivation or integration of modular forms, the Eisenstein series $E_2$, eta
 quotients, or quotients of modular forms. These objects are nonetheless very
 important in the theory, so are not considered as errors; however the user must
 be aware that no attempt is made to check that the objects that he handles are
 really modular. When the documentation of a function does not state that it
 applies to generalized modular forms, then the output is undefined if the
 input is not a true modular form.

Function: _header_modular_symbols
Class: header
Section: modular_symbols
Doc: 
 \section{Modular symbols}
 
 Let $\Delta_0 := \text{Div}^0(\P^1(\Q))$ be the abelian group of divisors of
 degree $0$ on the rational projective line. The standard $\text{GL}(2,\Q)$
 action on $\P^1(\Q)$ via homographies naturally extends to $\Delta_0$. Given
 
 \item $G$ a finite index subgroup of $\text{SL}(2,\Z)$,
 
 \item a field $F$ and a finite dimensional representation $V/F$ of
   $\text{GL}(2,\Q)$,
 
 \noindent we consider the space of \emph{modular symbols} $M :=
 \Hom_G(\Delta_0, V)$. This finite dimensional $F$-vector
 space is a $G$-module, canonically isomorphic to $H^1_c(X(G), V)$,
 and allows to compute modular forms for $G$.
 
 Currently, we only support the groups $\Gamma_0(N)$ ($N > 0$ an integer)
 and the representations $V_k = \Q[X,Y]_{k-2}$ ($k \geq 2$ an integer) over
 $\Q$. We represent a space of modular symbols by an \var{ms} structure,
 created by the function \tet{msinit}. It encodes basic data attached to the
 space: chosen $\Z[G]$-generators $(g_i)$ for $\Delta_0$ (and relations among
 those) and an $F$-basis of $M$. A modular symbol $s$ is thus given either in
 terms of this fixed basis, or as a collection of values $s(g_i)$
 satisfying certain relations.
 
 A subspace of $M$ (e.g. the cuspidal or Eisenstein subspaces, the new or
 old modular symbols, etc.) is given by a structure allowing quick projection
 and restriction of linear operators; its first component is a matrix whose
 columns  form  an $F$-basis  of the subspace.

Function: _header_number_fields
Class: header
Section: number_fields
Doc: 
 \section{General number fields}
 
 In this section, we describe functions related to general number fields.
 Functions related to quadratic number fields are found in
 \secref{se:arithmetic} (Arithmetic functions).
 
 \subsec{Number field structures} %GPHELPskip
 
 Let $K = \Q[X] / (T)$ a number field, $\Z_K$ its ring of integers, $T\in\Z[X]$
 is monic. Three basic number field structures can be attached to $K$ in
 GP:
 
 \item $\tev{nf}$ denotes a number field, i.e.~a data structure output by
 \tet{nfinit}. This contains the basic arithmetic data attached to the
 number field: signature, maximal order (given by a basis \kbd{nf.zk}),
 discriminant, defining polynomial $T$, etc.
 
 \item $\tev{bnf}$ denotes a ``Buchmann's number field'', i.e.~a
 data structure output by \tet{bnfinit}. This contains
 $\var{nf}$ and the deeper invariants of the field: units $U(K)$, class group
 $\Cl(K)$, as well as technical data required to solve the two attached
 discrete logarithm problems.
 
 \item $\tev{bnr}$ denotes a ``ray number field'', i.e.~a data structure
 output by \kbd{bnrinit}, corresponding to the ray class group structure of
 the field, for some modulus $f$. It contains a \var{bnf}, the modulus
 $f$, the ray class group $\Cl_f(K)$ and data attached to
 the discrete logarithm problem therein.
 
 \subsec{Algebraic numbers and ideals} %GPHELPskip
 
 \noindent An \tev{algebraic number} belonging to $K = \Q[X]/(T)$ is given as
 
 \item a \typ{INT}, \typ{FRAC} or \typ{POL} (implicitly modulo $T$), or
 
 \item a \typ{POLMOD} (modulo $T$), or
 
 \item a \typ{COL}~\kbd{v} of dimension $N = [K:\Q]$, representing
 the element in terms of the computed integral basis, as
 \kbd{sum(i = 1, N,~v[i] * nf.zk[i])}. Note that a \typ{VEC}
 will not be recognized.
 \medskip
 
 \noindent An \tev{ideal} is given in any of the following ways:
 
 \item an algebraic number in one of the above forms, defining a principal ideal.
 
 \item a prime ideal, i.e.~a 5-component vector in the format output by
 \kbd{idealprimedec} or \kbd{idealfactor}.
 
 \item a \typ{MAT}, square and in Hermite Normal Form (or at least
 upper triangular with nonnegative coefficients), whose columns represent a
 $\Z$-basis of the ideal.
 
 One may use \kbd{idealhnf} to convert any ideal to the last (preferred) format.
 
 \item an \emph{extended ideal} \sidx{ideal (extended)} is a 2-component
 vector $[I, t]$, where $I$ is an ideal as above and $t$ is an algebraic
 number, representing the ideal $(t)I$. This is useful whenever \tet{idealred}
 is involved, implicitly working in the ideal class group, while keeping track
 of principal ideals. The following multiplicative ideal operations
 update the principal part: \kbd{idealmul}, \kbd{idealinv},
 \kbd{idealsqr}, \kbd{idealpow} and \kbd{idealred}; e.g.~using \kbd{idealmul}
 on $[I,t]$, $[J,u]$, we obtain $[IJ, tu]$. In all other
 functions, the extended part is silently discarded, e.g.~using
 \kbd{idealadd} with the above input produces $I+J$.
 
 The ``principal part'' $t$ in an extended ideal may be
 represented in any of the above forms, and \emph{also} as a factorization
 matrix (in terms of number field elements, not ideals!), possibly the empty
 factorization matrix \kbd{factor(1)} representing $1$; the empty matrix
 \kbd{[;]} is also accepted as a synonym for $1$. When $t$ is such a
 factorization matrix, elements stay in
 factored form, or \tev{famat} for \emph{fa}ctorization \emph{mat}rix, which
 is a convenient way to avoid coefficient explosion. To recover the
 conventional expanded form, try \tet{nffactorback}; but many functions
 already accept \var{famat}s as input, for instance \tet{ideallog}, so
 expanding huge elements should never be necessary.
 
 \subsec{Finite abelian groups} %GPHELPskip
 
 A finite abelian group $G$ in user-readable format is given by its Smith
 Normal Form as a pair $[h,d]$ or triple $[h,d,g]$.
 Here $h$ is the cardinality of $G$, $(d_i)$ is the vector of elementary
 divisors, and $(g_i)$ is a vector of generators. In short,
 $G = \oplus_{i\leq n} (\Z/d_i\Z) g_i$, with $d_n \mid \dots \mid d_2 \mid d_1$
 and $\prod d_i = h$. This information can also be retrieved as
 $G.\kbd{no}$, $G.\kbd{cyc}$ and $G.\kbd{gen}$.
 
 \item a \tev{character} on the abelian group
 $\oplus (\Z/d_j\Z) g_j$
 is given by a row vector $\chi = [a_1,\ldots,a_n]$ such that
 $\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$.
 
 \item given such a structure, a \tev{subgroup} $H$ is input as a square
 matrix in HNF, whose columns express generators of $H$ on the given generators
 $g_i$. Note that the determinant of that matrix is equal to the index $(G:H)$.
 
 \subsec{Relative extensions} %GPHELPskip
 
 We now have a look at data structures attached to relative extensions
 of number fields $L/K$, and to projective $\Z_K$-modules. When defining a
 relative extension $L/K$, the $\var{nf}$ attached to the base field $K$
 must be defined by a variable having a lower priority (see
 \secref{se:priority}) than the variable defining the extension. For example,
 you may use the variable name $y$ to define the base field $K$, and $x$ to
 define the relative extension $L/K$.
 
 \misctitle{Basic definitions}\label{se:ZKmodules} %GPHELPskip
 
 \item $\tev{rnf}$ denotes a relative number field, i.e.~a data structure
 output by \kbd{rnfinit}, attached to the extension $L/K$. The \var{nf}
 attached to be base field $K$ is \kbd{rnf.nf}.
 
 \item A \emph{relative matrix} is an $m\times n$ matrix whose entries are
 elements of $K$, in any form. Its $m$ columns $A_j$ represent elements
 in $K^n$.
 
 \item An \tev{ideal list} is a row vector of fractional ideals of the number
 field $\var{nf}$.
 
 \item A \tev{pseudo-matrix} is a 2-component row vector $(A,I)$ where $A$
 is a relative $m\times n$ matrix and $I$ an ideal list of length $n$. If $I =
 \{\goth{a}_1,\dots, \goth{a}_n\}$ and the columns of $A$ are $(A_1,\dots,
 A_n)$, this data defines the torsion-free (projective) $\Z_K$-module
 $\goth{a}_1 A_1\oplus \goth{a}_n A_n$.
 
 \item An \tev{integral pseudo-matrix} is a 3-component row vector $(A,I,J)$
 where $A = (a_{i,j})$ is an $m\times n$ relative matrix and $I =
 (\goth{b}_1,\dots, \goth{b}_m)$, $J = (\goth{a}_1,\dots, \goth{a}_n)$ are ideal
 lists, such that $a_{i,j} \in \goth{b}_i \goth{a}_j^{-1}$ for all $i,j$. This
 data defines two abstract projective $\Z_K$-modules
 $N = \goth{a}_1\omega_1\oplus \cdots\oplus \goth{a}_n\omega_n $ in $K^n$,
 $P = \goth{b}_1\eta_1\oplus \cdots\oplus \goth{b}_m\eta_m$ in $K^m$, and a
 $\Z_K$-linear map $f:N\to P$ given by
 $$ f(\sum \alpha_j\omega_j) = \sum_i \Big(a_{i,j}\alpha_j\Big) \eta_i.$$
 This data defines the $\Z_K$-module $M = P/f(N)$.
 
 \item Any \emph{projective} $\Z_K$-module\varsidx{projective module} $M$
 of finite type in $K^m$ can be given by a pseudo matrix $(A,I)$.
 
 \item An arbitrary $\Z_K$ module of finite type in $K^m$, with nontrivial
 torsion, is given by an integral pseudo-matrix $(A,I,J)$
 
 \misctitle{Algebraic numbers in relative extension}
 
 We are given a number field $K = \kbd{nfinit}(T)$, attached to $K = \Q[Y]/(T)$,
 $T \in \Q[Y]$, and a relative extension $L = \kbd{rnfinit}(K, P)$, attached
 to $L = K[X]/(P)$, $P \in K[X]$.
 In all contexts (except \kbd{rnfeltabstorel}, see below), an
 \tev{algebraic number} is given as
 
 \item a \typ{INT}, \typ{FRAC} or \typ{POL} in $\Q[Y]$ (implicitly modulo $T$)
 or a \typ{POL} in $K[X]$ (implicitly modulo $P$),
 
 \item a \typ{POLMOD} (modulo $T$ or $P$), or
 
 \item a \typ{COL}~\kbd{v} of dimension $m = [K:\Q]$, representing
 the element in terms of the integral basis \kbd{K.zk};
 
 \item if an absolute \kbd{nf} structure \kbd{Labs} was attached to $L$, via
 \kbd{Labs = nfinit}$(L)$, then we can also use a \typ{COL}~\kbd{v} of
 dimension $[L:\Q]$, representing the element in terms of the computed integral
 basis \kbd{Labs.zk}. Be careful that in the degenerate case
 $L = K$, then the previous interpretation (with respect to \kbd{$K$.zk})
 takes precedence. This is no concern when $K = \Q$ or if $P = X - Y$
 (because in that case the primitive
 polynomial \kbd{Labs.pol} defining $L$ of $\Q$ is \kbd{nf.pol} and the
 computation of \kbd{nf.zk} is deterministic); but in other cases, the
 integer bases attached to $K$ and \kbd{Labs} may differ.
 
 \misctitle{Special case: \kbd{rnfabstorel}} This function assumes
 that elements are given in absolute representation (with respect to
 \kbd{Labs.zk} or modulo \kbd{Labs.pol} and converts them to relative
 representation modulo \kbd{$L$.pol}. In that function (only), a \typ{POL} in
 $X$ is implicitly understood modulo \kbd{Labs.pol} and a \typ{COL}
 of length $[L:\Q]$ refers to the integral basis \kbd{Labs.zk} in all cases,
 including $L = K$.
 
 \misctitle{Pseudo-bases, determinant} %GPHELPskip
 
 \item The pair $(A,I)$ is a \tev{pseudo-basis} of the module it
 generates if the $\goth{a}_j$ are nonzero, and the $A_j$ are $K$-linearly
 independent. We call $n$ the \emph{size} of the pseudo-basis. If $A$ is a
 relative matrix, the latter condition means it is square with nonzero
 determinant; we say that it is in Hermite Normal
 Form\sidx{Hermite normal form} (HNF) if it is upper triangular and all the
 elements of the diagonal are equal to 1.
 
 \item For instance, the relative integer basis \kbd{rnf.zk} is a pseudo-basis
 $(A,I)$ of $\Z_L$, where $A = \kbd{rnf.zk[1]}$ is a vector of elements of $L$,
 which are $K$-linearly independent. Most \var{rnf} routines return and handle
 $\Z_K$-modules contained in $L$ (e.g.~$\Z_L$-ideals) via a pseudo-basis
 $(A',I')$, where $A'$ is a relative matrix representing a vector of elements of
 $L$ in terms of the fixed basis \kbd{rnf.zk[1]}
 
 \item The \emph{determinant} of a pseudo-basis $(A,I)$ is the ideal
 equal to the product of the determinant of $A$ by all the ideals of $I$. The
 determinant of a pseudo-matrix is the determinant of any pseudo-basis of the
 module it generates.
 
 \subsec{Class field theory}\label{se:CFT}
 
 A $\tev{modulus}$, in the sense of class field theory, is a divisor supported
 on the real and finite places of $K$. In PARI terms, this means either an
 ordinary ideal $I$ as above (no Archimedean component), or a pair $[I,a]$,
 where $a$ is a vector with $r_1$ $\{0,1\}$-components, corresponding to the
 infinite part of the divisor. More precisely, the $i$-th component of $a$
 corresponds to the real embedding attached to the $i$-th real root of
 \kbd{K.roots}. (That ordering is not canonical, but well defined once a
 defining polynomial for $K$ is chosen.) For instance, \kbd{[1, [1,1]]} is a
 modulus for a real quadratic field, allowing ramification at any of the two
 places at infinity, and nowhere else.
 
 A \tev{bid} or ``big ideal'' is a structure output by \kbd{idealstar}
 needed to compute in $(\Z_K/I)^*$, where $I$ is a modulus in the above sense.
 It is a finite abelian group as described above, supplemented by
 technical data needed to solve discrete log problems.
 
 Finally we explain how to input ray number fields (or \var{bnr}), using class
 field theory. These are defined by a triple $A$, $B$, $C$, where the
 defining set $[A,B,C]$ can have any of the following forms:
 $[\var{bnr}]$,
 $[\var{bnr},\var{subgroup}]$,
 $[\var{bnr},\var{character}]$,
 $[\var{bnf},\var{mod}]$,
 $[\var{bnf},\var{mod},\var{subgroup}]$. The last two forms are kept for
 backward compatibility, but no longer serve any real purpose (see example
 below); no newly written function will accept them.
 
 \item $\var{bnf}$ is as output by \kbd{bnfinit}, where units are mandatory
 unless the modulus is trivial; \var{bnr} is as output by \kbd{bnrinit}. This
 is the ground field $K$.
 
 \item \emph{mod} is a modulus $\goth{f}$, as described above.
 
 \item \emph{subgroup} a subgroup of the ray class group modulo $\goth{f}$ of
 $K$. As described above, this is input as a square matrix expressing
 generators of a subgroup of the ray class group \kbd{\var{bnr}.clgp} on the
 given generators. We also allow a \typ{INT} $n$ for $n \cdot \text{Cl}_f$.
 
 \item \emph{character} is a character $\chi$ of the ray class group modulo
 $\goth{f}$, representing the subgroup $\text{Ker} \chi$.
 
 The corresponding \var{bnr} is the subfield of the ray class field of $K$
 modulo $\goth{f}$, fixed by the given subgroup.
 
 \bprog
   ? K = bnfinit(y^2+1);
   ? bnr = bnrinit(K, 13)
   ? %.clgp
   %3 = [36, [12, 3]]
   ? bnrdisc(bnr); \\ discriminant of the full ray class field
   ? bnrdisc(bnr, [3,1;0,1]); \\ discriminant of cyclic cubic extension of K
   ? bnrconductor(bnr, [3,1]); \\ conductor of chi: g1->zeta_12^3, g2->zeta_3
 @eprog\noindent
 We could have written directly
 \bprog
   ? bnrdisc(K, 13);
   ? bnrdisc(K, 13, [3,1;0,1]);
 @eprog\noindent
 avoiding one \tet{bnrinit}, but this would actually be slower since the
 \kbd{bnrinit} is called internally anyway. And now twice!
 
 \subsec{General use}
 
 All the functions which are specific to relative extensions, number fields,
 Buchmann's number fields, Buchmann's number rays, share the prefix \kbd{rnf},
 \kbd{nf}, \kbd{bnf}, \kbd{bnr} respectively. They take as first argument a
 number field of that precise type, respectively output by \kbd{rnfinit},
 \kbd{nfinit}, \kbd{bnfinit}, and \kbd{bnrinit}.
 
 However, and even though it may not be specified in the descriptions of the
 functions below, it is permissible, if the function expects a $\var{nf}$, to
 use a $\var{bnf}$ instead, which contains much more information. On the other
 hand, if the function requires a \kbd{bnf}, it will \emph{not} launch
 \kbd{bnfinit} for you, which is a costly operation. Instead, it will give you
 a specific error message. In short, the types
 $$ \kbd{nf} \leq \kbd{bnf} \leq \kbd{bnr}$$
 are ordered, each function requires a minimal type to work properly, but you
 may always substitute a larger type.
 
 The data types corresponding to the structures described above are rather
 complicated. Thus, as we already have seen it with elliptic curves, GP
 provides ``member functions'' to retrieve data from these structures (once
 they have been initialized of course). The relevant types of number fields
 are indicated between parentheses: \smallskip
 
 \sidx{member functions}
 \settabs\+xxxxxxx&(\var{bnr},x&\var{bnf},x&nf\hskip2pt&)x&: &\cr
 \+\tet{bid}    &(\var{bnr}&&&)&: & bid ideal structure.\cr
 
 \+\tet{bnf}    &(\var{bnr},& \var{bnf}&&)&: & Buchmann's number field.\cr
 
 \+\tet{clgp}  &(\var{bnr},& \var{bnf}&&)&: & classgroup. This one admits the
 following three subclasses:\cr
 
 \+      \quad \tet{cyc} &&&&&: & \quad cyclic decomposition
  (SNF)\sidx{Smith normal form}.\cr
 
 \+      \quad \kbd{gen}\sidx{gen (member function)} &&&&&: &
  \quad generators.\cr
 
 \+      \quad \tet{no}  &&&&&: & \quad number of elements.\cr
 
 \+\tet{diff}  &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the different ideal.\cr
 
 \+\tet{codiff}&(\var{bnr},& \var{bnf},& \var{nf}&)&: & the codifferent
 (inverse of the different in the ideal group).\cr
 
 \+\tet{disc} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & discriminant.\cr
 
 \+\tet{fu}   &(          & \var{bnf}&&)&: & \idx{fundamental units}.\cr
 
 \+\tet{index}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: &
  \idx{index} of the power order in the ring of integers.\cr
 
 \+\tet{mod}   &(\var{bnr}&&&)&: & modulus.\cr
 
 \+\tet{nf}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & number field.\cr
 
 \+\tet{pol}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & defining polynomial.\cr
 
 \+\tet{r1} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the number
 of real embeddings.\cr
 
 \+\tet{r2} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the number
 of pairs of complex embeddings.\cr
 
 \+\tet{reg}  &(          & \var{bnf}&&)&: & regulator.\cr
 
 \+\tet{roots}&(\var{bnr},& \var{bnf},& \var{nf}&)&: & roots of the
 polynomial generating the field.\cr
 
 \+\tet{sign} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & signature $[r1,r2]$.\cr
 
 \+\tet{t2}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the $T_2$ matrix (see
 \kbd{nfinit}).\cr
 
 \+\tet{tu}   &(          & \var{bnf}&&)&: & a generator for the torsion
 units.\cr
 
 \+\tet{zk}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & integral basis, i.e.~a
 $\Z$-basis of the maximal order.\cr
 
 \+\tet{zkst}   &(\var{bnr}&&&)&: & structure of $(\Z_K/m)^*$.\cr
 
 The member functions \kbd{.codiff}, \kbd{.t2} and \kbd{.zk} perform a
 computation and are relatively expensive in large degree: move them out of
 tight loops and store them in variables.
 
   For instance, assume that $\var{bnf} = \kbd{bnfinit}(\var{pol})$, for some
 polynomial. Then \kbd{\var{bnf}.clgp} retrieves the class group, and
 \kbd{\var{bnf}.clgp.no} the class number. If we had set $\var{bnf} =
 \kbd{nfinit}(\var{pol})$, both would have output an error message. All these
 functions are completely recursive, thus for instance
 \kbd{\var{bnr}.bnf.nf.zk} will yield the maximal order of \var{bnr}, which
 you could get directly with a simple \kbd{\var{bnr}.zk}.
 
 \subsec{Class group, units, and the GRH}\label{se:GRHbnf}
 
 Some of the functions starting with \kbd{bnf} are implementations of the
 sub-exponential algorithms for finding class and unit groups under \idx{GRH},
 due to Hafner-McCurley, \idx{Buchmann} and Cohen-Diaz-Olivier. The general
 call to the functions concerning class groups of general number fields
 (i.e.~excluding \kbd{quadclassunit}) involves a polynomial $P$ and a
 technical vector
 $$\var{tech} = [c_1, c_2, \var{nrpid} ],$$
 where the parameters are to be understood as follows:
 
 $P$ is the defining polynomial for the number field, which must be in
 $\Z[X]$, irreducible and monic. In fact, if you supply a nonmonic polynomial
 at this point, \kbd{gp} issues a warning, then \emph{transforms your
 polynomial} so that it becomes monic. The \kbd{nfinit} routine
 will return a different result in this case: instead of \kbd{res}, you get a
 vector \kbd{[res,Mod(a,Q)]}, where \kbd{Mod(a,Q) = Mod(X,P)} gives the change
 of variables. In all other routines, the variable change is simply lost.
 
 The \var{tech} interface is obsolete and you should not tamper with
 these parameters. Indeed, from version 2.4.0 on,
 
 \item the results are always rigorous under \idx{GRH} (before that version,
 they relied on a heuristic strengthening, hence the need for overrides).
 
 \item the influence of these parameters on execution time and stack size is
 marginal. They \emph{can} be useful to fine-tune and experiment with the
 \kbd{bnfinit} code, but you will be better off modifying all tuning
 parameters in the C code (there are many more than just those three).
 We nevertheless describe it for completeness.
 
 The numbers $c_1 \leq c_2$ are nonnegative real numbers. By default they are
 chosen so that the result is correct under GRH. For $i = 1,2$, let
 $B_i = c_i(\log |d_K|)^2$, and denote by $S(B)$ the set of maximal ideals of
 $K$ whose norm is less than $B$. We want $S(B_1)$ to generate $\Cl(K)$ and hope
 that $S(B_2)$ can be \emph{proven} to generate $\Cl(K)$.
 
 More precisely, $S(B_1)$ is a factorbase used to compute a tentative
 $\Cl(K)$ by generators and relations. We then check explicitly, using
 essentially \kbd{bnfisprincipal}, that the elements of $S(B_2)$ belong to the
 span of $S(B_1)$. Under the assumption that $S(B_2)$ generates $\Cl(K)$, we
 are done. User-supplied $c_i$ are only used to compute initial guesses for
 the bounds $B_i$, and the algorithm increases them until one can \emph{prove}
 under GRH that $S(B_2)$ generates $\Cl(K)$. A uniform result of Bach says
 that $c_2 = 12$ is always suitable, but this bound is very pessimistic and a
 direct algorithm due to Belabas-Diaz-Friedman is used to check the condition,
 assuming GRH. The default values are $c_1 = c_2 = 0$. When $c_1$ is equal to
 $0$ the algorithm takes it equal to $c_2$.
 
 $\var{nrpid}$ is the maximal number of small norm relations attached to each
 ideal in the factor base. Set it to $0$ to disable the search for small norm
 relations. Otherwise, reasonable values are between 4 and 20. The default is
 4.
 
 \misctitle{Warning} Make sure you understand the above! By default, most of
 the \kbd{bnf} routines depend on the correctness of the GRH. In particular,
 any of the class number, class group structure, class group generators,
 regulator and fundamental units may be wrong, independently of each other.
 Any result computed from such a \kbd{bnf} may be wrong. The only guarantee is
 that the units given generate a subgroup of finite index in the full unit
 group. You must use \kbd{bnfcertify} to certify the computations
 unconditionally.
 
 \misctitle{Remarks}
 
 You do not need to supply the technical parameters (under the library you
 still need to send at least an empty vector, coded as \kbd{NULL}). However,
 should you choose to set some of them, they \emph{must} be given in the
 requested order. For example, if you want to specify a given value of
 \var{nrpid}, you must give some values as well for $c_1$ and $c_2$, and provide
 a vector $[c_1,c_2,\var{nrpid}]$.
 
 Note also that you can use an $\var{nf}$ instead of $P$, which avoids
 recomputing the integral basis and analogous quantities.
 
 \subsec{Hecke Grossencharacters}\label{se:GCHAR}
 
 Hecke Grossencharacters are continuous characters of the id\`ele class group;
 they generalize classical Hecke characters on ray class groups obtained through
 the $\var{bnr}$ structure.
 
 Let $K$ be a number field, $\A^\times$ its group of id\`eles.
 Every Grossencharacter
 $$
    \chi \colon \A^\times/K^\times \to \C^\times
 $$
 can be uniquely written~$\chi = \chi_0 \|\cdot \|^s$ for some~$s\in\C$
 and some character~$\chi_0$ of the compact
 group~$\A^\times/(K^\times\cdot\R_{>0})$,
 where~$\|a\| = \prod_v |a_v|_v$ is the id\`ele norm.
 
 Let~$\goth{m}$ be a modulus
 (an integral ideal and a finite set of real places). Let $U(\goth{m})$ be the
 subgroup of id\`eles congruent to $1$ modulo $\goth{m}$
 (units outside $\goth{m}$, positive at real places in $\goth{m}$).
 The Hecke Grossencharacters defined modulo $\goth{m}$ are the characters of
 the id\`ele class group
 $$
  C_K(\goth{m}) = \A^\times/(K^\times\cdot U(\goth{m})),
 $$
 that is, combinations of an archimedean
 character $\chi_\infty$ on the connected component $K_\infty^{\times \circ}$
 and a ray class group character $\chi_f$ satisfying a compatibility condition
 $\chi_\infty(a)\chi_f(a)=1$ for all units $a$ congruent to 1 modulo $\goth{m}$.
 
 \varsidx{gchar} %
 \item \var{gc} denotes a structure allowing to compute with Hecke
 Grossencharacters.
 
 \item \kbd{gcharinit(\var{bnf},\var{mod})} initializes the structure \var{gc}.
 The underlying number field and modulus can be accessed using
 \var{gc}\kbd{.bnf} and \var{gc}\kbd{.mod}.
 
 \item \var{gc}\kbd{.cyc} describes the finite abelian group structure of
 \var{gc}, the torsion part corresponding to finite order ray class
 characters, the exact zeros corresponding to a lattice of infinite order
 Grossencharacters, and the approximate zero being a placeholder for the
 complex powers of the id\`ele norm.
 
 \item A Hecke character of modulus~$\goth{m}$ is described as a \typ{COL} of
 coordinates corresponding to~\var{gc}\kbd{.cyc}: all the coordinates are
 integers except the last one, which can be an arbitrary complex number, or
 omitted instead of~$0$.
 
 \item Hecke Grossencharacters have $L$-functions and can be given to all \kbd{lfun} objects as a 2 components
 vector \kbd{[\var{gc},\var{chi}]}.

Function: _header_number_theoretical
Class: header
Section: number_theoretical
Doc: 
 \section{Arithmetic functions}\label{se:arithmetic}
 
 These functions are by definition functions whose natural domain of
 definition is either $\Z$ (or $\Z_{>0}$). The way these functions are used is
 completely different from transcendental functions in that there are no
 automatic type conversions: in general only integers are accepted as
 arguments. An integer argument $N$ can be given in the following alternate
 formats:
 
 \item \typ{MAT}: its factorization \kbd{fa = factor($N$)},
 
 \item \typ{VEC}: a pair \kbd{[$N$, fa]} giving both the integer and
   its factorization.
 
 This allows to compute different arithmetic functions at a given $N$
 while factoring the latter only once.
 
 \bprog
   ? N = 10!; faN = factor(N);
   ? eulerphi(N)
   %2 = 829440
   ? eulerphi(faN)
   %3 = 829440
   ? eulerphi(S = [N, faN])
   %4 = 829440
   ? sigma(S)
   %5 = 15334088
 @eprog
 
 \subsec{Arithmetic functions and the factoring engine}
 All arithmetic functions in the narrow sense of the word~--- Euler's
 totient\sidx{Euler totient function} function, the \idx{Moebius} function,
 the sums over divisors or powers of divisors etc.--- call, after trial
 division by small primes, the same versatile factoring machinery described
 under \kbd{factorint}. It includes \idx{Shanks SQUFOF}, \idx{Pollard Rho},
 \idx{ECM} and \idx{MPQS} stages, and has an early exit option for the
 functions \teb{moebius} and (the integer function underlying)
 \teb{issquarefree}. This machinery relies on a fairly strong
 probabilistic primality test, see \kbd{ispseudoprime}, but you may also set
 \bprog
   default(factor_proven, 1)
 @eprog\noindent to ensure that all tentative factorizations are fully proven.
 This should not slow down PARI too much, unless prime numbers with
 hundreds of decimal digits occur frequently in your application.
 
 \subsec{Orders in finite groups and Discrete Logarithm functions}
 \label{se:DLfun}
 
 The following functions compute the order of an element in a finite group:
 \kbd{ellorder} (the rational points on an elliptic curve defined over a
 finite field), \kbd{fforder} (the multiplicative group of a finite field),
 \kbd{znorder} (the invertible elements in $\Z/n\Z$). The following functions
 compute discrete logarithms in the same groups (whenever this is meaningful)
 \kbd{elllog}, \kbd{fflog}, \kbd{znlog}.
 
 All such functions allow an optional argument specifying an integer
 $N$, representing the order of the group. (The \emph{order} functions also
 allows any nonzero multiple of the order, with a minor loss of efficiency.)
 That optional argument follows the same format as given above:
 
 \item \typ{INT}: the integer $N$,
 
 \item \typ{MAT}: the factorization \kbd{fa = factor($N$)},
 
 \item \typ{VEC}: this is the preferred format and provides both the
 integer $N$ and its factorization in a two-component vector
 \kbd{[$N$, fa]}.
 
 When the group is fixed and many orders or discrete logarithms will be
 computed, it is much more efficient to initialize this data once and for all
 and pass it to the relevant functions, as in
 \bprog
 ? p = nextprime(10^30);
 ? v = [p-1, factor(p-1)]; \\ data for discrete log & order computations
 ? znorder(Mod(2,p), v)
 %3 = 500000000000000000000000000028
 ? g = znprimroot(p);
 ? znlog(2, g, v)
 %5 = 543038070904014908801878611374
 @eprog
 
 \subsec{Dirichlet characters}\label{se:dirichletchar}
 
 The finite abelian group $G = (\Z/N\Z)^*$ can be written $G = \oplus_{i\leq
 n} (\Z/d_i\Z) g_i$, with $d_n \mid \dots \mid d_2 \mid d_1$ (SNF condition),
 all $d_i > 0$, and $\prod_i d_i = \phi(N)$.
 
 The SNF condition makes the $d_i$ unique, but the generators $g_i$, of
 respective order $d_i$, are definitely not unique. The $\oplus$ notation
 means that all elements of $G$ can be written uniquely as $\prod_i g_i^{n_i}$
 where $n_i \in \Z/d_i\Z$. The $g_i$ are the so-called \tev{SNF generators}
 of $G$.
 
 \item a \tev{character} on the abelian group
 $\oplus (\Z/d_j\Z) g_j$
 is given by a row vector $\chi = [a_1,\ldots,a_n]$ of integers $0\leq a_i  <
 d_i$ such that $\chi(g_j) = e(a_j / d_j)$ for all $j$, with the standard
 notation $e(x) := \exp(2i\pi x)$.
 In other words,
 $\chi(\prod g_j^{n_j}) = e(\sum a_j n_j / d_j)$.
 
 This will be generalized to more general abelian groups in later sections
 (Hecke characters), but in the present case of $(\Z/N\Z)^*$, there is a useful
 alternate convention : namely, it is not necessary to impose the SNF
 condition and we can use Chinese remainders instead. If $N = \prod p^{e_p}$ is
 the factorization of $N$ into primes, the so-called \tev{Conrey generators}
 of $G$ are the generators of the $(\Z/p^{e_p}\Z)^*$ lifted to $(\Z/N\Z)^*$ by
 requesting that they be congruent to $1$ modulo $N/p^{e_p}$ (for $p$ odd we
 take the smallest positive primitive root mod $p^2$, and for $p = 2$
 we take $-1$ if
 $e_2 > 1$ and additionally $5$ if $e_2 > 2$). We can again write $G =
 \oplus_{i\leq n} (\Z/D_i\Z) G_i$, where again $\prod_i D_i = \phi(N)$. These
 generators don't satisfy the SNF condition in general since their orders are
 now $(p-1)p^{e_p-1}$ for $p$ odd; for $p = 2$, the generator $-1$ has order
 $2$ and $5$ has order $2^{e_2-2}$ $(e_2 > 2)$. Nevertheless, any $m\in
 (\Z/N\Z)^*$ can be uniquely decomposed as $\prod G_i^{m_i}$ for some $m_i$
 modulo $D_i$ and we can define a character by $\chi(G_j) = e(m_j / D_j)$ for
 all $j$.
 
 \item The \emph{column vector} of the $m_j$, $0 \leq m_j < D_j$ is called the
 \tev{Conrey logarithm} of $m$ (discrete logarithm in terms of the Conrey
 generators). Note that discrete logarithms in PARI/GP are always expressed as
 \typ{COL}s.
 
 \item The attached character is called the \tev{Conrey character}
 attached to $m$.
 
 To sum up a Dirichlet character can be defined by a \typ{INT} (the Conrey
 label $m$), a \typ{COL} (the Conrey logarithm of $m$, in terms of the Conrey
 generators) or a \typ{VEC} (in  terms of the SNF generators). The \typ{COL}
 format, i.e. Conrey logarithms, is the preferred (fastest) representation.
 
 Concretely, this works as follows:
 
 \kbd{G = znstar(N, 1)} initializes $(\Z/N\Z)^*$, which must be given as
 first arguments to all functions handling Dirichlet characters.
 
 \kbd{znconreychar} transforms \typ{INT} and \typ{COL} to a SNF character.
 
 \kbd{znconreylog} transforms \typ{INT} and \typ{VEC} to a Conrey logarithm.
 
 \kbd{znconreyexp} transforms \typ{VEC} and \typ{COL} to a Conrey label.
 
 Also available are \kbd{charconj},  \kbd{chardiv}, \kbd{charmul},
 \kbd{charker}, \kbd{chareval}, \kbd{charorder}, \kbd{zncharinduce},
 \kbd{znconreyconductor} (also computes the primitive character attached to
 the input character). The prefix \kbd{char} indicates that the function
 applies to all characters, the prefix \kbd{znchar} that it is specific to
 Dirichlet characters (on $(\Z/N\Z)^*$) and the prefix \kbd{znconrey} that it
 is specific to Conrey representation.

Function: _header_operators
Class: header
Section: operators
Doc: 
 \section{Standard monadic or dyadic operators}
 
 \subsec{Boolean operators}\sidx{Boolean operators}
 
 Any nonzero value is interpreted as \var{true} and any zero as \var{false}
 (this includes empty vectors or matrices). The standard boolean operators
 \kbd{||} (\idx{inclusive or}), \kbd{\&\&} (\idx{and})\sidx{or} and \kbd{!}
 in prefix notation (\idx{not}) are available.
 Their value is $1$ (true) or $0$ (false):
 \bprog
 ? a && b  \\ 1 iff a and b are nonzero
 ? a || b  \\ 1 iff a or b is nonzero
 ? !a      \\ 1 iff a is zero
 @eprog
 
 \subsec{Comparison}
 The standard real \idx{comparison operators} \kbd{<=}, \kbd{<}, \kbd{>=},
 \kbd{>}, are available in GP. The result is 1 if the comparison is true, 0
 if it is false. These operators allow to compare integers (\typ{INT}),
 rational (\typ{FRAC}) or real (\typ{REAL}) numbers,
 real quadratic numbers (\typ{QUAD} of positive discriminant) and infinity
 (\kbd{oo}, \typ{INFINITY}).
 
 By extension, two character strings (\typ{STR}) are compared using
 the standard lexicographic order. Comparing a string to an object of a
 different type raises an exception. See also the \tet{cmp} universal
 comparison function.
 
 \subsec{Equality}
 Two operators allow to test for equality: \kbd{==} (equality up to type
 coercion) and \kbd{===} (identity). The result is $1$ if equality is decided,
 else $0$.
 
 The operator \kbd{===} is strict: objects of different type or length are
 never identical, polynomials in different variables are never identical,
 even if constant. On the contrary, \kbd{==} is very liberal: $a~\kbd{==}~b$
 decides whether there is a natural map sending $a$ to the domain of $b$
 or sending $b$ to the domain of $a$, such that the comparison makes sense
 and equality holds. For instance
 \bprog
 ? 4 == Mod(1,3) \\ equal
 %1 = 1
 ? 4 === Mod(1,3) \\ but not identical
 %2 = 0
 
 ? 'x == 'y   \\ not equal (nonconstant and different variables)
 %3 = 0
 ? Pol(0,'x) == Pol(0,'y)  \\ equal (constant: ignore variable)
 %4 = 1
 ? Pol(0,'x) === Pol(0,'y)  \\ not identical
 %5 = 0
 
 ? 0 == Pol(0) \\ equal (not identical)
 %6 = 1
 ? [0] == 0     \\ equal (not identical)
 %7 = 1
 ? [0, 0] == 0  \\ equal (not identical)
 %8 = 1
 ? [0] == [0,0] \\ not equal
 %9 = 0
 @eprog\noindent In particular \kbd{==} is not transitive in general; it is
 transitive when used to compare objects known to have the same type. The
 operator \kbd{===} is transitive. The \kbd{==} operator allows two
 equivalent negated forms: \kbd{!=} or \kbd{<>}; there is no negated form for
 \kbd{===}.
 
 Do not mistake \kbd{=} for \kbd{==}: it is the assignment statement.
 
 \subseckbd{+$/$-} The expressions \kbd{+}$x$ and \kbd{-}$x$ refer
 to monadic operators: the first does nothing, the second negates $x$.
 
 The library syntax is \fun{GEN}{gneg}{GEN x} for \kbd{-}$x$.
 
 \subseckbd{+} The expression $x$ \kbd{+} $y$ is the \idx{sum} of $x$ and $y$.
 Addition between a scalar type $x$ and a \typ{COL} or \typ{MAT} $y$ returns
 respectively $[y[1] + x, y[2],\dots]$ and $y + x \text{Id}$. Other additions
 between a scalar type and a vector or a matrix, or between vector/matrices of
 incompatible sizes are forbidden.
 
 The library syntax is \fun{GEN}{gadd}{GEN x, GEN y}.
 
 \subseckbd{-} The expression $x$ \kbd{-} $y$ is the \idx{difference} of $x$
 and $y$. Subtraction between a scalar type $x$ and a \typ{COL} or \typ{MAT}
 $y$ returns respectively $[y[1] - x, y[2],\dots]$ and $y - x \text{Id}$.
 Other subtractions between a scalar type and a vector or a matrix, or
 between vector/matrices of incompatible sizes are forbidden.
 
 The library syntax is \fun{GEN}{gsub}{GEN x, GEN y} for $x$ \kbd{-} $y$.
 
 \subseckbd{*} The expression $x$ \kbd{*} $y$ is the \idx{product} of $x$
 and $y$. Among the prominent impossibilities are multiplication between
 vector/matrices of incompatible sizes, between a \typ{INTMOD} or \typ{PADIC}
 Restricted to scalars, \kbd{*} is commutative; because of vector and matrix
 operations, it is not commutative in general.
 
 Multiplication between two \typ{VEC}s or two \typ{COL}s is not
 allowed; to take the \idx{scalar product} of two vectors of the same length,
 transpose one of the vectors (using the operator \kbd{\til} or the function
 \kbd{mattranspose}, see \secref{se:linear_algebra}) and multiply a line vector
 by a column vector:
 \bprog
 ? a = [1,2,3];
 ? a * a
   ***   at top-level: a*a
   ***                  ^--
   *** _*_: forbidden multiplication t_VEC * t_VEC.
 ? a * a~
 %2 = 14
 @eprog
 
 If $x,y$ are binary quadratic forms, compose them; see also
 \kbd{qfbnucomp} and \kbd{qfbnupow}. If $x,y$ are \typ{VECSMALL} of the same
 length, understand them as permutations and compose them.
 
 The library syntax is \fun{GEN}{gmul}{GEN x, GEN y} for $x$ \kbd{*} $y$.
 Also available is \fun{GEN}{gsqr}{GEN x} for $x$ \kbd{*} $x$.
 
 \subseckbd{/} The expression $x$ \kbd{/} $y$ is the \idx{quotient} of $x$
 and $y$. In addition to the impossibilities for multiplication, note that if
 the divisor is a matrix, it must be an invertible square matrix, and in that
 case the result is $x*y^{-1}$. Furthermore note that the result is as exact
 as possible: in particular, division of two integers always gives a rational
 number (which may be an integer if the quotient is exact) and \emph{not} the
 Euclidean quotient (see $x$ \kbd{\bs} $y$ for that), and similarly the
 quotient of two polynomials is a rational function in general. To obtain the
 approximate real value of the quotient of two integers, add \kbd{0.} to the
 result; to obtain the approximate $p$-adic value of the quotient of two
 integers, add \kbd{O(p\pow k)} to the result; finally, to obtain the
 \idx{Taylor series} expansion of the quotient of two polynomials, add
 \kbd{O(X\pow k)} to the result or use the \kbd{taylor} function
 (see \secref{se:taylor}). \label{se:gdiv}
 
 The library syntax is \fun{GEN}{gdiv}{GEN x, GEN y} for $x$ \kbd{/} $y$.
 
 \subseckbd{\bs} The expression \kbd{$x$ \bs\ $y$} is the
 \idx{Euclidean quotient} of $x$ and $y$. If $y$ is a real scalar, this is
 defined as \kbd{floor($x$/$y$)} if $y > 0$, and \kbd{ceil($x$/$y$)} if
 $y < 0$ and the division is not exact. Hence the remainder
 \kbd{$x$ - ($x$\bs$y$)*$y$} is in $[0, |y|[$.
 
 Note that when $y$ is an integer and $x$ a polynomial, $y$ is first promoted
 to a polynomial of degree $0$. When $x$ is a vector or matrix, the operator
 is applied componentwise.
 
 The library syntax is \fun{GEN}{gdivent}{GEN x, GEN y}
 for $x$ \kbd{\bs} $y$.
 
 \subseckbd{\bs/} The expression $x$ \b{/} $y$ evaluates to the rounded
 \idx{Euclidean quotient} of $x$ and $y$. This is the same as \kbd{$x$ \bs\ $y$}
 except for scalar division: the quotient is such that the corresponding
 remainder is smallest in absolute value and in case of a tie the quotient
 closest to $+\infty$ is chosen (hence the remainder would belong to
 $[{-}|y|/2, |y|/2[$).
 
 When $x$ is a vector or matrix, the operator is applied componentwise.
 
 The library syntax is \fun{GEN}{gdivround}{GEN x, GEN y}
 for $x$ \b{/} $y$.
 
 \subseckbd{\%} The expression \kbd{$x$ \% $y$} evaluates to the modular
 \idx{Euclidean remainder} of $x$ and $y$, which we now define. When $x$ or $y$
 is a nonintegral real number, \kbd{$x$\%$y$} is defined as
 \kbd{$x$ - ($x$\bs$y$)*$y$}. Otherwise, if $y$ is an integer, this is
 the smallest
 nonnegative integer congruent to $x$ modulo $y$. (This actually coincides
 with the previous definition if and only if $x$ is an integer.) If $y$ is a
 polynomial, this is the polynomial of smallest degree congruent to
 $x$ modulo $y$. For instance:
 \bprog
 ? (1/2) % 3
 %1 = 2
 ? 0.5 % 3
 %2 = 0.5000000000000000000000000000
 ? (1/2) % 3.0
 %3 = 1/2
 @eprog
 Note that when $y$ is an integer and $x$ a polynomial, $y$ is first promoted
 to a polynomial of degree $0$. When $x$ is a vector or matrix, the operator
 is applied componentwise.
 
 The library syntax is \fun{GEN}{gmod}{GEN x, GEN y}
 for $x$ \kbd{\%} $y$.
 
 \subseckbd{op=} When \kbd{op} is a binary arithmetic operator among
 \kbd{+}, \kbd{-}, \kbd{\%}, \kbd{/}, \kbd{\bs} or \kbd{\bs/}, the construct
 $x \var{op}= y$ is a shortcut for $x = x \var{op} y$.
 \bprog
 ? v[1] += 10  \\ increment v[1] by 10
 ? a /= 2 \\ divide a by 2
 @eprog
 
 \subseckbd{++} \kbd{$x$++} is a shortcut for \kbd{$x$ = $x$ + 1}.
 
 \subseckbd{--} \kbd{$x$--} is a shortcut for \kbd{$x$ = $x$ - 1}.
 
 \subseckbd{\pow} The expression $x\hbox{\kbd{\pow}}n$ is \idx{powering}.
 
 \item If the exponent $n$ is an integer, then exact operations are performed
 using binary (left-shift) powering techniques. By definition, $x^0$ is
 (an empty product interpreted as) an exact $1$ in the underlying prime
 ring:
 \bprog
 ? 0.0 ^ 0
 %1 = 1
 ? (1 + O(2^3)) ^ 0
 %2 = 1
 ? (1 + O(x)) ^ 0
 %3 = 1
 ? Mod(2,4)^0
 %4 = Mod(1,4)
 ? Mod(x,x^2)^0
 %5 = Mod(1, x^2)
 @eprog\noindent
 If $x$ is a $p$-adic number, its precision will increase if $v_p(n) > 0$ and
 $n \neq 0$. Powering a binary quadratic form (type \typ{QFB}) returns a
 representative of the class, which is reduced if the input was.
 (In particular, \kbd{x \pow 1} returns $x$ itself, whether it is reduced or
 not.)
 
 PARI rewrites the multiplication $x * x$ of two \emph{identical}
 objects as $x^2$. Here, identical means the operands are reference the same
 chunk of memory; no equality test is performed. This is no longer true when
 more than two arguments are involved.
 \bprog
 ? a = 1 + O(2); b = a;
 ? a * a  \\ = a^2, precision increases
 %2 = 1 + O(2^3)
 ? a * b \\ not rewritten as a^2
 %3 = 1 + O(2)
 ? a*a*a \\ not rewritten as a^3
 %4 = 1 + O(2)
 @eprog
 
 \item If the exponent is a rational number $p/q$ the behaviour depends
 on~$x$. If $x$ is a complex number, return $\exp(n \log x)$ (principal
 branch), in an exact form if possible:
 \bprog
 ? 4^(1/2)  \\ 4 being a square, this is exact
 %1 = 2
 ? 2^(1/2)  \\ now inexact
 %2 = 1.4142135623730950488016887242096980786
 ? (-1/4)^(1/2) \\ exact again
 %3 = 1/2*I
 ? (-1)^(1/3)
 %4 = 0.500...+ 0.866...*I
 @eprog\noindent Note that even though $-1$ is an exact cube root of $-1$,
 it is not $\exp(\log(-1)/3)$; the latter is returned.
 
 Otherwise return a solution $y$ of $y^q = x^p$ if it exists; beware that
 this is defined up to $q$-th roots of 1 in the base field. Intmods modulo
 composite numbers are not supported.
 \bprog
 ? Mod(7,19)^(1/2)
 %1 = Mod(11, 19) \\ is any square root
 ? sqrt(Mod(7,19))
 %2 = Mod(8, 19)  \\ is the smallest square root
 ? Mod(1,4)^(1/2)
  ***   at top-level: Mod(1,4)^(1/2)
  ***                         ^------
  *** _^_: not a prime number in gpow: 4.
 @eprog
 
 \item If the exponent is a negative integer or rational number,
 an \idx{inverse} must be computed. For noninvertible \typ{INTMOD} $x$, this
 will fail and (for $n$ an integer) implicitly exhibit a factor of the modulus:
 \bprog
 ? Mod(4,6)^(-1)
   ***   at top-level: Mod(4,6)^(-1)
   ***                         ^-----
   *** _^_: impossible inverse modulo: Mod(2, 6).
 @eprog\noindent
 Here, a factor 2 is obtained directly. In general, take the gcd of the
 representative and the modulus. This is most useful when performing
 complicated operations modulo an integer $N$ whose factorization is
 unknown. Either the computation succeeds and all is well, or a factor $d$
 is discovered and the computation may be restarted modulo $d$ or $N/d$.
 
 For noninvertible \typ{POLMOD} $x$, the behavior is the same:
 \bprog
 ? Mod(x^2, x^3-x)^(-1)
   ***   at top-level: Mod(x^2,x^3-x)^(-1)
   ***                               ^-----
   *** _^_: impossible inverse in RgXQ_inv: Mod(x^2, x^3 - x).
 @eprog\noindent Note that the underlying algorihm (subresultant) assumes
 that the base ring is a domain:
 \bprog
 ? a = Mod(3*y^3+1, 4); b = y^6+y^5+y^4+y^3+y^2+y+1; c = Mod(a,b);
 ? c^(-1)
   ***   at top-level: Mod(a,b)^(-1)
   ***                         ^-----
   *** _^_: impossible inverse modulo: Mod(2, 4).
 @eprog\noindent
 In fact $c$ is invertible, but $\Z/4\Z$ is not a domain and the algorithm
 fails. It is possible for the algorithm to succeed in such situations
 and any returned result will be correct, but chances are that an error
 will occur first. In this specific case, one should work with $2$-adics.
 In general, one can also try the following approach
 \bprog
 ? inversemod(a, b) =
 { my(m, v = variable(b));
   m = polsylvestermatrix(polrecip(a), polrecip(b));
   m = matinverseimage(m, matid(#m)[,1]);
   Polrev(m[1..poldegree(b)], v);
 }
 ? inversemod(a,b)
 %2 = Mod(2,4)*y^5 + Mod(3,4)*y^3 + Mod(1,4)*y^2 + Mod(3,4)*y + Mod(2,4)
 @eprog\noindent
 This is not guaranteed to work either since \kbd{matinverseimage} must also
 invert pivots. See \secref{se:linear_algebra}.
 
 For a \typ{MAT} $x$, the matrix is expected to be square and invertible, except
 in the special case \kbd{x\pow(-1)} which returns a left inverse if one exists
 (rectangular $x$ with full column rank).
 \bprog
 ? x = Mat([1;2])
 %1 =
 [1]
 
 [2]
 
 ? x^(-1)
 %2 =
 [1 0]
 @eprog
 
 \item Finally, if the exponent $n$ is not an rational number, powering is
 treated as the transcendental function $\exp(n\log x)$, although it will be
 more precise than the latter when $n$ and $x$ are exact:
 \bprog
 ? s = 1/2 + 10^14 * I
 ? localprec(200); z = 2^s  \\ for reference
 ? exponent(2^s - z)
 %3 = -127  \\ perfect
 ? exponent(exp(s * log(2)) - z)
 %4 = -84 \\ not so good
 @eprog\noindent The second computation is less precise because $\log(2)$ is
 first computed to $38$ decimal digits, then multiplied by $s$, which has a
 huge imaginary part amplifying the error.
 
 In this case, $x \mapsto x^n$ is treated as a transcendental function and
 and in particular acts
 componentwise on vector or matrices, even square matrices ! (See
 \secref{se:trans}.) If $x$ is $0$ and $n$ is an inexact $0$, this will raise
 an exception:
 \bprog
 ? 4 ^ 1.0
 %1 = 4.0000000000000000000000000000000000000
 ? 0^ 0.0
  ***   at top-level: 0^0.0
  ***                  ^----
  *** _^_: domain error in gpow(0,n): n <= 0
 @eprog
 
 The library syntax is \fun{GEN}{gpow}{GEN x, GEN n, long prec}
 for $x\hbox{\kbd{\pow}}n$.

Function: _header_polynomials
Class: header
Section: polynomials
Doc: 
 \section{Polynomials and power series}
 
 We group here all functions which are specific to polynomials or power
 series. Many other functions which can be applied on these objects are
 described in the other sections. Also, some of the functions described here
 can be applied to other types.

Function: _header_programming/control
Class: header
Section: programming/control
Doc: 
 \section{Programming in GP: control statements}
 \sidx{programming}\label{se:programming}
 
   A number of control statements are available in GP. They are simpler and
 have a syntax slightly different from their C counterparts, but are quite
 powerful enough to write any kind of program. Some of them are specific to
 GP, since they are made for number theorists. As usual, $X$ will denote any
 simple variable name, and \var{seq} will always denote a sequence of
 expressions, including the empty sequence.
 
 \misctitle{Caveat} In constructs like
 \bprog
     for (X = a,b, seq)
 @eprog\noindent
 the variable \kbd{X} is lexically scoped to the loop, leading to possibly
 unexpected behavior:
 \bprog
     n = 5;
     for (n = 1, 10,
       if (something_nice(), break);
     );
     \\ @com at this point \kbd{n} is 5 !
 @eprog\noindent
 If the sequence \kbd{seq} modifies the loop index, then the loop
 is modified accordingly:
 \bprog
     ? for (n = 1, 10, n += 2; print(n))
     3
     6
     9
     12
 @eprog

Function: _header_programming/parallel
Class: header
Section: programming/parallel
Doc: 
 \section{Parallel programming}
 
 These function are only available if PARI was configured using
 \kbd{Configure --mt=\dots}. Two multithread interfaces are supported:
 
 \item POSIX threads
 
 \item Message passing interface (MPI)
 
 As a rule, POSIX threads are well-suited for single systems, while MPI is used
 by most clusters. However the parallel GP interface does not depend on the
 chosen multithread interface: a properly written GP program will work
 identically with both.

Function: _header_programming/specific
Class: header
Section: programming/specific
Doc: 
 \section{Programming in GP: other specific functions}
 \label{se:gp_program}
 
   In addition to the general PARI functions, it is necessary to have some
 functions which will be of use specifically for \kbd{gp}, though a few of these
 can be accessed under library mode. Before we start describing these, we recall
 the difference between \emph{strings} and \emph{keywords} (see
 \secref{se:strings}): the latter don't get expanded at all, and you can type
 them without any enclosing quotes. The former are dynamic objects, where
 everything outside quotes gets immediately expanded.

Function: _header_sums
Class: header
Section: sums
Doc: 
 \section{Sums, products, integrals and similar functions}
 \label{se:sums}
 
 Although the \kbd{gp} calculator is programmable, it is useful to have
 a number of preprogrammed loops, including sums, products, and a certain
 number of recursions. Also, a number of functions from numerical analysis
 like numerical integration and summation of series will be described here.
 
 One of the parameters in these loops must be the control variable, hence a
 simple variable name. In the descriptions, the letter $X$ will always denote
 any simple variable name, and represents the formal parameter used in the
 function. The expression to be summed, integrated, etc. is any legal PARI
 expression, including of course expressions using loops.
 
 \misctitle{Library mode}
 Since it is easier to program directly the loops in library mode, these
 functions are mainly useful for GP programming. On the other hand, numerical
 routines code a function (to be integrated, summed, etc.) with two parameters
 named
 \bprog
   GEN (*eval)(void*,GEN)
   void *E;  \\ context: eval(E, x) must evaluate your function at x.
 @eprog\noindent
 see the Libpari manual for details.
 
 \misctitle{Numerical integration}\sidx{numerical integration}
 The ``double exponential'' (DE) univariate
 integration method is implemented in \tet{intnum} and its variants. Romberg
 integration is still available under the name \tet{intnumromb}, but
 superseded. It is possible to compute numerically integrals to thousands of
 decimal places in reasonable time, as long as the integrand is regular. It is
 also reasonable to compute numerically integrals in several variables,
 although more than two becomes lengthy. The integration domain may be
 noncompact, and the integrand may have reasonable singularities at
 endpoints. To use \kbd{intnum}, you must split the integral into a sum
 of subintegrals where the function has no singularities except at the
 endpoints. Polynomials in logarithms are not considered singular, and
 neglecting these logs, singularities are assumed to be algebraic (asymptotic
 to $C(x-a)^{-\alpha}$ for some $\alpha > -1$ when $x$ is
 close to $a$), or to correspond to simple discontinuities of some (higher)
 derivative of the function. For instance, the point $0$ is a singularity of
 $\text{abs}(x)$.
 
 Assume the bitprecision is $b$, so we try to achieve an absolute error less
 than $2^{-b}$. DE methods use $O(b \log b)$ function evaluations and should
 work for both compact and non-compact intervals as long as the integrand is
 the restriction of an analytic function to a suitable domain and its behaviour
 at infinity is correctly described.
 When integrating regular functions on a \emph{compact} interval, away from
 poles of the integrand, Gauss-Legendre integration (\tet{intnumgauss})
 is the best choice, using $O(b)$ function evaluations. To integrate
 oscillating functions on non-compact interval, the slower but robust
 \tet{intnumosc} is available, performing Gaussian integration on intervals of
 length the half-period (or quasi-period) and using Sidi's $mW$ algorithm to
 extrapolate their sum. If poles are close to the integration interval,
 Gaussian integration may run into difficulties and it is then advisable to
 split the integral using \kbd{intnum} to get away from poles, then
 \kbd{intnumosc} for the remainder.
 
 For maximal efficiency, abscissas and integration
 weights can be precomputed, respectively using \tet{intnuminit} ($O(b^2)$)
 or \tet{intnumgaussinit} ($O(b^3)$).
 
 \misctitle{Numerical summation}\sidx{numerical summation}
 
 Many numerical summation methods are available to approximate
 $\sum_{n\geq n_0} f(n)$ at accuracy $2^{-b}$: the overall best choice should
 be \tet{sumnum}, which uses Euler-MacLaurin (and $O(b\log b)$ function
 evaluations); initialization time (\tet{sumnuminit}) is $O(b^3)$.
 Also available are
 
 \item Abel-Plana summation (\tet{sumnumap}),
 also $O(b\log b)$ function evaluations and $O(b^3)$ initialization
 (\tet{sumnumapinit}) with a larger implied constant;
 
 \item Lagrange summation (\tet{sumnumlagrange}) uses $O(b)$ evaluations
 but more brittle and the asymptotic behaviour of $f$ must be correctly
 indicated. Initialization (\tet{sumnumlagrangeinit}) can vary from $O(b^2)$
 to $O(b^3)$ depending on the asymptotic behaviour.
 
 \item Sidi summation (\tet{sumnumsidi}) uses $O(b)$ evaluations and should
 be more robust than Lagrange summation. No initialization is needed.
 
 \item Monien summation (\tet{sumnummonien}) uses $O(b/\log b)$ evaluations
 but is even more brittle than Lagrange and also has a $O(b^3)$ initialization
 (\kbd{summonieninit}).
 
 \item To sum rational functions, use \tet{sumnumrat}.
 
 All the function so far require $f$ to be be the restriction to integers
 of a regular function on the reals, and even on the complex numbers for
 Monien summation. The following algorithms allow functions defined
 only on the integers, under asumptions that are hard to verify. They are
 best used heuristically since they in fact are often valid when those
 asumptions do not hold, and for instance often yield a result for divergent
 series (e.g., Borel resummation).
 
 \item To sum alternating series, use \tet{sumalt}, which requires
 $O(b)$ function evaluations.
 
 \item To sum functions of a fixed sign, \tet{sumpos}
 uses van Wijngarten's trick to reduce to an alternating series,
 for a cost of $O(b\log b)$ function evaluations but beware that $f$ must be
 evaluated at large integers, of the order of $2^{b/\alpha}$ if we assume
 that $f(n) = O(1 / n^{\alpha+1})$ for some $\alpha > 0$.

Function: _header_transcendental
Class: header
Section: transcendental
Doc: 
 \section{Transcendental functions}\label{se:trans}
 
 Since the values of transcendental functions cannot be exactly represented,
 these functions will always return an inexact object: a real number,
 a complex number, a $p$-adic number or a power series.  All these objects
 have a certain finite precision.
 
 As a general rule, which of course in some cases may have exceptions,
 transcendental functions operate in the following way:
 
 \item If the argument is either a real number or an inexact complex number
 (like \kbd{1.0 + I} or \kbd{Pi*I} but not \kbd{2 - 3*I}), then the
 computation is done with the precision of the argument.
 In the example below, we see that changing the precision to $50$ digits does
 not matter, because $x$ only had a precision of $19$ digits.
 \bprog
 ? \p 15
    realprecision = 19 significant digits (15 digits displayed)
 ? x = Pi/4
 %1 = 0.785398163397448
 ? \p 50
    realprecision = 57 significant digits (50 digits displayed)
 ? sin(x)
 %2 = 0.7071067811865475244
 @eprog
 
 Note that even if the argument is real, the result may be complex
 (e.g.~$\text{acos}(2.0)$ or $\text{acosh}(0.0)$). See each individual
 function help for the definition of the branch cuts and choice of principal
 value.
 
 \item If the argument is either an integer, a rational, an exact complex
 number or a quadratic number, it is first converted to a real
 or complex number using the current \idx{precision}, which can be
 view and manipulated using the defaults \tet{realprecision} (in decimal
 digits) or \tet{realbitprecision} (in bits). This precision can be changed
 indifferently
 
 \item in decimal digits: use \b{p} or \kbd{default(realprecision,...)}.
 
 \item in bits: use \b{pb} or \kbd{default(realbitprecision,...)}.
 
 After this conversion, the computation proceeds as above for real or complex
 arguments.
 
 In library mode, the \kbd{realprecision} does not matter; instead the
 precision is taken from the \kbd{prec} parameter which every transcendental
 function has. As in \kbd{gp}, this \kbd{prec} is not used when the argument
 to a function is already inexact. Note that the argument \var{prec} stands
 for the length in words of a real number, including codewords. Hence we must
 have $\var{prec} \geq 3$. (Some functions allow a \kbd{bitprec} argument
 instead which allow finer granularity.)
 
 Some accuracies attainable on 32-bit machines cannot be attained
 on 64-bit machines for parity reasons. For example the default \kbd{gp} accuracy
 is 28 decimal digits on 32-bit machines, corresponding to \var{prec} having
 the value 5, but this cannot be attained on 64-bit machines.
 
 \item If the argument is a polmod (representing an algebraic number),
 then the function is evaluated for every possible complex embedding of that
 algebraic number.  A column vector of results is returned, with one component
 for each complex embedding.  Therefore, the number of components equals
 the degree of the \typ{POLMOD} modulus.
 
 \item If the argument is an intmod or a $p$-adic, at present only a
 few functions like \kbd{sqrt} (square root), \kbd{sqr} (square), \kbd{log},
 \kbd{exp}, powering, \kbd{teichmuller} (Teichm\"uller character) and
 \kbd{agm} (arithmetic-geometric mean) are implemented.
 
 Note that in the case of a $2$-adic number, $\kbd{sqr}(x)$ may not be
 identical to $x*x$: for example if $x = 1+O(2^5)$ and $y = 1+O(2^5)$ then
 $x*y = 1+O(2^5)$ while $\kbd{sqr}(x) = 1+O(2^6)$. Here, $x * x$ yields the
 same result as $\kbd{sqr}(x)$ since the two operands are known to be
 \emph{identical}. The same statement holds true for $p$-adics raised to the
 power $n$, where $v_p(n) > 0$.
 
 \misctitle{Remark} If we wanted to be strictly consistent with
 the PARI philosophy, we should have $x*y = (4 \mod 8)$ and $\kbd{sqr}(x) =
 (4 \mod 32)$ when both $x$ and $y$ are congruent to $2$ modulo $4$.
 However, since intmod is an exact object, PARI assumes that the modulus
 must not change, and the result is hence $(0\, \mod\, 4)$ in both cases. On
 the other hand, $p$-adics are not exact objects, hence are treated
 differently.
 
 \item If the argument is a polynomial, a power series or a rational function,
 it is, if necessary, first converted to a power series using the current
 series precision, held in the default \tet{seriesprecision}. This precision
 (the number of significant terms) can be changed using \b{ps} or
 \kbd{default(seriesprecision,...)}. Then the Taylor series expansion of the
 function around $X=0$ (where $X$ is the main variable) is computed to a
 number of terms depending on the number of terms of the argument and the
 function being computed.
 
 Under \kbd{gp} this again is transparent to the user. When programming in
 library mode, however, it is \emph{strongly} advised to perform an explicit
 conversion to a power series first, as in
 \bprog
   x = gtoser(x, gvar(x), seriesprec)
 @eprog\noindent
 where the number of significant terms \kbd{seriesprec} can be specified
 explicitly. If you do not do this, a global variable \kbd{precdl} is used
 instead, to convert polynomials and rational functions to a power series with
 a reasonable number of terms; tampering with the value of this global
 variable is \emph{deprecated} and strongly discouraged.
 
 \item If the argument is a vector or a matrix, the result is the
 componentwise evaluation of the function. In particular, transcendental
 functions on square matrices, which are not implemented in the present
 version \vers, will have a different name if they are implemented some day.

Function: _iferr_CATCH
Class: gp2c_internal
Description: 
  (0)               pari_CATCH(CATCH_ALL)
  (small)           pari_CATCH2(__iferr_old$1, CATCH_ALL)

Function: _iferr_CATCH_reset
Class: gp2c_internal
Description: 
  (0):void      pari_CATCH_reset()
  (small):void  pari_CATCH2_reset(__iferr_old$1)

Function: _iferr_ENDCATCH
Class: gp2c_internal
Description: 
  (0)        pari_ENDCATCH
  (small)    pari_ENDCATCH2(__iferr_old$1)

Function: _iferr_error
Class: gp2c_internal
Description: 
  ():error pari_err_last()

Function: _iferr_rethrow
Class: gp2c_internal
Description: 
  (error):void    pari_err(0, $1)

Function: _lerch_worker
Class: basic
Section: programming/internals
C-Name: lerch_worker
Prototype: GG
Help: _lerch_worker(E, t): worker for lerchzeta
Doc: auxiliary.

Function: _lfuninit_theta2_worker
Class: basic
Section: programming/internals
C-Name: lfuninit_theta2_worker
Prototype: LGGGGGG
Help: worker for lfuninit using theta2

Function: _lfuninit_worker
Class: basic
Section: programming/internals
C-Name: lfuninit_worker
Prototype: LGGGGGGGG
Help: worker for lfuninit

Function: _low_stack_lim
Class: gp2c_internal
Description: 
 (pari_sp,pari_sp):bool        low_stack($1, stack_lim($2, 1))

Function: _maxprime
Class: gp2c_internal
Description: 
 ():small                maxprime()

Function: _multi_if
Class: basic
Section: programming/internals
C-Name: ifpari_multi
Prototype: GE*
Help: internal variant of if() that allows more than 3 arguments.

Function: _ndec2nbits
Class: gp2c_internal
Description: 
 (small):small      ndec2nbits($1)

Function: _ndec2prec
Class: gp2c_internal
Description: 
 (small):small      ndec2prec($1)

Function: _nflist_A462_worker
Class: basic
Section: programming/internals
C-Name: nflist_A462_worker
Prototype: GGGGG
Help: nflist_A462_worker(P3, X, Xinf, listarch, GAL): auxiliary.
Doc: auxiliary

Function: _nflist_A46S46P_worker
Class: basic
Section: programming/internals
C-Name: nflist_A46S46P_worker
Prototype: GGGG
Help: nflist_A46S46P_worker(P3, Xinf, sqX, cards): auxiliary.
Doc: auxiliary

Function: _nflist_A4S4_worker
Class: basic
Section: programming/internals
C-Name: nflist_A4S4_worker
Prototype: GGGG
Help: nflist_A4S4_worker(P3, X, Xinf, cardsprec): auxiliary.
Doc: auxiliary

Function: _nflist_C32C4_worker
Class: basic
Section: programming/internals
C-Name: nflist_C32C4_worker
Prototype: GGGG
Help: nflist_C32C4_worker(P4, X, Xinf, GAL): auxiliary.
Doc: auxiliary

Function: _nflist_C32D4_worker
Class: basic
Section: programming/internals
C-Name: nflist_C32D4_worker
Prototype: GGGG
Help: nflist_C32D4_worker(P, X, Xinf, gs): auxiliary.
Doc: auxiliary

Function: _nflist_C3C3_worker
Class: basic
Section: programming/internals
C-Name: nflist_C3C3_worker
Prototype: GGGG
Help: nflist_C3C3_worker(gi, V3, V3D, X): auxiliary.
Doc: auxiliary

Function: _nflist_C3_worker
Class: basic
Section: programming/internals
C-Name: nflist_C3_worker
Prototype: GG
Help: nflist_C3_worker(gv, T): auxiliary.
Doc: auxiliary

Function: _nflist_C4vec_worker
Class: basic
Section: programming/internals
C-Name: nflist_C4vec_worker
Prototype: GGGG
Help: nflist_C4vec_worker(gm, X, Xinf, X2, gs): auxiliary.
Doc: auxiliary

Function: _nflist_C5_worker
Class: basic
Section: programming/internals
C-Name: nflist_C5_worker
Prototype: GG
Help: nflist_C5_worker(N, bnfC5): auxiliary.
Doc: auxiliary

Function: _nflist_C6_worker
Class: basic
Section: programming/internals
C-Name: nflist_C6_worker
Prototype: GGGGG
Help: nflist_C6_worker(P3, X, Xinf, M, T): auxiliary.
Doc: auxiliary

Function: _nflist_C9_worker
Class: basic
Section: programming/internals
C-Name: nflist_C9_worker
Prototype: GGG
Help: nflist_C9_worker(P, X, Xinf): auxiliary.
Doc: auxiliary

Function: _nflist_CL_worker
Class: basic
Section: programming/internals
C-Name: nflist_CL_worker
Prototype: GGG
Help: nflist_CL_worker(Fcond, bnf, ellprec): auxiliary.
Doc: auxiliary

Function: _nflist_D4_worker
Class: basic
Section: programming/internals
C-Name: nflist_D4_worker
Prototype: GGGG
Help: nflist_D4_worker(D, X, Xinf, listarch): auxiliary.
Doc: auxiliary

Function: _nflist_D612_worker
Class: basic
Section: programming/internals
C-Name: nflist_D612_worker
Prototype: GGGG
Help: nflist_D612_worker(P3, X, Xinf, X2, limd2s2): auxiliary.
Doc: auxiliary

Function: _nflist_D9_worker
Class: basic
Section: programming/internals
C-Name: nflist_D9_worker
Prototype: GGG
Help: nflist_D9_worker(P2, X, Xinf): auxiliary.
Doc: auxiliary

Function: _nflist_DL_worker
Class: basic
Section: programming/internals
C-Name: nflist_DL_worker
Prototype: GGGGGG
Help: nflist_DL_worker(P2, X1p, X0p, X, Xinf, ells): auxiliary.
Doc: auxiliary

Function: _nflist_Mgen_worker
Class: basic
Section: programming/internals
C-Name: nflist_Mgen_worker
Prototype: GGGG
Help: nflist_Mgen_worker(field, X, Xinf, ella): auxiliary.
Doc: auxiliary

Function: _nflist_S32_worker
Class: basic
Section: programming/internals
C-Name: nflist_S32_worker
Prototype: GGGGG
Help: nflist_S32_worker(all1, X, Xinf, V3, sprec): auxiliary.
Doc: auxiliary

Function: _nflist_S36_worker
Class: basic
Section: programming/internals
C-Name: nflist_S36_worker
Prototype: GGG
Help: nflist_S36_worker(pol, X, Xinf, X2): auxiliary.
Doc: auxiliary

Function: _nflist_S3C3_worker
Class: basic
Section: programming/internals
C-Name: nflist_S3C3_worker
Prototype: GGG
Help: nflist_S3C3_worker(D2, X, Xinf, X2): auxiliary.
Doc: auxiliary

Function: _nflist_S3I_worker
Class: basic
Section: programming/internals
C-Name: nflist_S3I_worker
Prototype: GG
Help: nflist_S3I_worker(ga, ALLCTS): auxiliary.
Doc: auxiliary

Function: _nflist_S3R_worker
Class: basic
Section: programming/internals
C-Name: nflist_S3R_worker
Prototype: GG
Help: nflist_S3R_worker(ga, ALLCTS): auxiliary.
Doc: auxiliary

Function: _nflist_S462_worker
Class: basic
Section: programming/internals
C-Name: nflist_S462_worker
Prototype: GGGGG
Help: nflist_S462_worker(P3, X, Xinf, listarch, GAL): auxiliary.
Doc: auxiliary

Function: _nflist_S46M_worker
Class: basic
Section: programming/internals
C-Name: nflist_S46M_worker
Prototype: GGGG
Help: nflist_S46M_worker(P3, X, Xinf, sprec): auxiliary.
Doc: auxiliary

Function: _nflist_V4_worker
Class: basic
Section: programming/internals
C-Name: nflist_V4_worker
Prototype: GGGG
Help: nflist_V4_worker(D1, X, Xinf, gs): auxiliary.
Doc: auxiliary

Function: _norange
Class: gp2c_internal
Description: 
 ():small    LONG_MAX

Function: _nxMV_polint_worker
Class: basic
Section: programming/internals
C-Name: nxMV_polint_center_tree_worker
Prototype: GGGGG
Help: used for parallel chinese
Doc: used for parallel chinese

Function: _parapply_slice_worker
Class: basic
Section: programming/internals
C-Name: parapply_slice_worker
Prototype: GG
Help: _parapply_slice_worker(v,C): return [C(x) | x<-v].

Function: _pareval_worker
Class: basic
Section: programming/internals
C-Name: pareval_worker
Prototype: G
Help: _pareval_worker(C): evaluate the closure C.

Function: _parfor_init
Class: gp2c_internal
Help: Initializes parameters for parfor.
Description: 
 (parfor, gen, gen, gen):void    parfor_init(&$1, $2, $3, $4)

Function: _parfor_next
Class: gp2c_internal
Help: Next value for parfor.
Description: 
 (parfor):gen    parfor_next(&$1)

Function: _parfor_stop
Class: gp2c_internal
Help: Stop function for parfor.
Description: 
 (parfor):void    parfor_stop(&$1)

Function: _parfor_worker
Class: basic
Section: programming/internals
C-Name: parfor_worker
Prototype: GG
Help: _parfor_worker(i,C): evaluate the closure C on i and return [i,C(i)]

Function: _parforeach_init
Class: gp2c_internal
Help: Initializes parameters for parforeach.
Description: 
 (parforeach,gen,gen):void    parforeach_init(&$1, $2, $3)

Function: _parforeach_next
Class: gp2c_internal
Help: Next value for parforeach.
Description: 
 (parforeach):gen    parforeach_next(&$1)

Function: _parforeach_stop
Class: gp2c_internal
Help: Stop function for parforeach.
Description: 
 (parforeach):void    parforeach_stop(&$1)

Function: _parforprime_init
Class: gp2c_internal
Help: Initializes parameters for parforprime.
Description: 
 (parforprime, gen, ?gen, gen):void    parforprime_init(&$1, $2, $3, $4)

Function: _parforprime_next
Class: gp2c_internal
Help: Next value for parforprime
Description: 
 (parforprime):gen    parforprime_next(&$1)

Function: _parforprime_stop
Class: gp2c_internal
Help: Stop function for parforprime.
Description: 
 (parforprime):void    parforprime_stop(&$1)

Function: _parforprimestep_init
Class: gp2c_internal
Help: Initializes parameters for parforprime.
Description: 
 (parforprime, gen, ?gen, gen, gen):void    parforprimestep_init(&$1, $2, $3, $4, $5)

Function: _parforvec_init
Class: gp2c_internal
Help: Initializes parameters for parforvec.
Description: 
 (parforvec,vec,closure,?small):void    parforvec_init(&$1, $2, $3, $4)

Function: _parforvec_next
Class: gp2c_internal
Help: Next value for parforvec.
Description: 
 (parforvec):gen    parforvec_next(&$1)

Function: _parforvec_stop
Class: gp2c_internal
Help: Stop function for parforvec.
Description: 
 (parforvec):void    parforvec_stop(&$1)

Function: _parselect_worker
Class: basic
Section: programming/internals
C-Name: parselect_worker
Prototype: GG
Help: _parselect_worker(d,C): evaluate the boolean closure C on d.

Function: _partmap_reverse_frac_worker
Class: basic
Section: programming/internals
C-Name: partmap_reverse_frac_worker
Prototype: GGGGGL
Help: worker for partmap_reverse_frac

Function: _parvector_worker
Class: basic
Section: programming/internals
C-Name: parvector_worker
Prototype: GG
Help: _parvector_worker(i,C): evaluate the closure C on i.

Function: _polclass_worker
Class: basic
Section: programming/internals
C-Name: polclass_worker
Prototype: GGG
Help: used by polclass
Doc: used by polclass

Function: _polint_worker
Class: basic
Section: programming/internals
C-Name: nmV_polint_center_tree_worker
Prototype: GGGGG
Help: used for parallel chinese
Doc: used for parallel chinese

Function: _polmodular_worker
Class: basic
Section: programming/internals
C-Name: polmodular_worker
Prototype: GUGGGGLGGGG
Help: used by polmodular
Doc: used by polmodular

Function: _primecertisvalid_ecpp_worker
Class: basic
Section: programming/internals
C-Name: primecertisvalid_ecpp_worker
Prototype: G
Help: worker for primecertisvalid

Function: _proto_code
Class: gp2c_internal
Help: Code for argument of a function
Description: 
 (var)          n
 (C!long)       L
 (C!ulong)      U
 (C!GEN)        G
 (C!char*)      s

Function: _proto_max_args
Class: gp2c_internal
Help: Max number of arguments supported by install.
Description: 
 (20)

Function: _proto_ret
Class: gp2c_internal
Help: Code for return value of functions
Description: 
 (C!void)       v
 (C!int)        i
 (C!long)       l
 (C!ulong)      u
 (C!GEN)

Function: _ramanujantau_worker
Class: basic
Section: programming/internals
C-Name: ramanujantau_worker
Prototype: GGGG
Help: worker for ramanujantau

Function: _safecoeff
Class: basic
Section: symbolic_operators
Help: safe version of x[a], x[,a] and x[a,b]. Must be lvalues.
Description: 
 (vecsmall,small):small         *safeel($1, $2)
 (list,small):gen:copy          *safelistel($1, $2)
 (gen,small):gen:copy           *safegel($1, $2)
 (gen,small,small):gen:copy     *safegcoeff($1, $2, $3)

Function: _stack_lim
Class: gp2c_internal
Description: 
 (pari_sp,small):pari_sp       stack_lim($1, $2)

Function: _strtoclosure
Class: gp2c_internal
Description: 
 (str):closure               strtofunction($1)
 (str,gen,...):closure       strtoclosure($1, ${nbarg 1 sub}, $3)

Function: _taugen_n_worker
Class: basic
Section: programming/internals
C-Name: taugen_n_worker
Prototype: GGG
Help: worker for ramanujantau

Function: _tovec
Class: gp2c_internal
Help: Create a vector holding the arguments (shallow)
Description: 
 ():vec                      cgetg(1, t_VEC)
 (gen):vec                   mkvec($1)
 (gen,gen):vec               mkvec2($1, $2)
 (gen,gen,gen):vec           mkvec3($1, $2, $3)
 (gen,gen,gen,gen):vec       mkvec4($1, $2, $3, $4)
 (gen,gen,gen,gen,gen):vec   mkvec5($1, $2, $3, $4, $5)
 (gen,...):vec               mkvecn($#, $2)

Function: _tovecprec
Class: gp2c_internal
Help: Create a vector holding the arguments and prec (shallow)
Description: 
 ():vec:prec                mkvecs($prec)
 (gen):vec:prec             mkvec2($1, stoi($prec))
 (gen,gen):vec:prec         mkvec3($1, $2, stoi($prec))
 (gen,gen,gen):vec:prec     mkvec4($1, $2, $3, stoi($prec))
 (gen,gen,gen,gen):vec:prec mkvec5($1, $2, $3, $4, stoi($prec))
 (gen,...):vec:prec         mkvecn(${nbarg 1 add}, $2, stoi($prec))

Function: _type_preorder
Class: gp2c_internal
Help: List of chains of type preorder.
Description: 
 (empty, void, bool, small, int, mp, gen)
 (empty, real, mp)
 (empty, bptr, small)
 (empty, bool, lg, small)
 (empty, bool, small_int, small)
 (empty, bool, usmall, small)
 (empty, void, negbool, bool)
 (empty, typ, str, genstr,gen)
 (empty, errtyp, str)
 (empty, vecsmall, gen)
 (empty, vecvecsmall, vec, gen)
 (empty, list, gen)
 (empty, closure, gen)
 (empty, error, gen)
 (empty, bnr, bnf, nf, vec)
 (empty, bnr, bnf, clgp, vec)
 (empty, ell, vec)
 (empty, prid, vec)
 (empty, gal, vec)
 (empty, var, pol, gen)
 (empty, Fp, Fq, gen)
 (empty, FpX, FqX, gen)

Function: _typedef
Class: gp2c_internal
Description: 
 (empty)        void
 (void)         void
 (negbool)      long
 (bool)         long
 (small_int)    int
 (usmall)       ulong
 (small)        long
 (int)          GEN
 (real)         GEN
 (mp)           GEN
 (lg)           long
 (vecsmall)     GEN
 (vec)          GEN
 (vecvecsmall)  GEN
 (list)         GEN
 (var)          long
 (pol)          GEN
 (gen)          GEN
 (closure)      GEN
 (error)        GEN
 (genstr)       GEN
 (str)          char*
 (bptr)         byteptr
 (forcomposite) forcomposite_t
 (forpart)      forpart_t
 (forperm)      forperm_t
 (forprime)     forprime_t
 (forsubset)    forsubset_t
 (forvec)       forvec_t
 (parfor)       parfor_t
 (parforeach)   parforeach_t
 (parforprime)  parforprime_t
 (parforvec)    parforvec_t
 (func_GG)      func_GG
 (pari_sp)      pari_sp
 (typ)          long
 (errtyp)       long
 (nf)           GEN
 (bnf)          GEN
 (bnr)          GEN
 (ell)          GEN
 (clgp)         GEN
 (prid)         GEN
 (gal)          GEN
 (Fp)           GEN
 (FpX)          GEN
 (Fq)           GEN
 (FqX)          GEN

Function: _u_forprime_init
Class: gp2c_internal
Help: Initialize forprime_t (ulong version).
Description: 
 (forprime,small,):void              u_forprime_init(&$1, $2, LONG_MAX);
 (forprime,small,small):void         u_forprime_init(&$1, $2, $3);

Function: _u_forprime_next
Class: gp2c_internal
Help: Compute the next prime (ulong version).
Description: 
 (forprime):small                   u_forprime_next(&$1)

Function: _void_if
Class: basic
Section: programming/internals
C-Name: ifpari_void
Prototype: vGDIDI
Help: internal variant of if() that does not return a value.

Function: _wrap_G
Class: gp2c_internal
C-Name: gp_call
Prototype: G
Description: 
  (gen):gen    $1

Function: _wrap_GG
Class: gp2c_internal
C-Name: gp_call2
Prototype: GG
Description: 
  (gen):gen    $1

Function: _wrap_Gp
Class: gp2c_internal
C-Name: gp_callprec
Prototype: Gp
Description: 
  (gen):gen    $1

Function: _wrap_bG
Class: gp2c_internal
C-Name: gp_callbool
Prototype: lG
Description: 
  (bool):bool   $1

Function: _wrap_vG
Class: gp2c_internal
C-Name: gp_callvoid
Prototype: lG
Description: 
  (void):small  0

Function: _||_
Class: basic
Section: symbolic_operators
C-Name: orpari
Prototype: GE
Help: a||b: boolean operator "or" (inclusive).
Description: 
 (bool, bool):bool:parens               $(1) || $(2)

Function: _~
Class: basic
Section: symbolic_operators
C-Name: gtrans
Prototype: G
Help: x~: transpose of x.
Description: 
 (vec):vec                        gtrans($1)
 (gen):gen                        gtrans($1)

Function: abs
Class: basic
Section: transcendental
C-Name: gabs
Prototype: Gp
Help: abs(x): absolute value (or modulus) of x.
Description: 
 (small):small    labs($1)
 (int):int        mpabs($1)
 (real):real      mpabs($1)
 (mp):mp          mpabs($1)
 (gen):gen:prec        gabs($1, $prec)
Doc: absolute value of $x$ (modulus if $x$ is complex).
 Rational functions are not allowed. Contrary to most transcendental
 functions, an exact argument is \emph{not} converted to a real number before
 applying \kbd{abs} and an exact result is returned if possible.
 \bprog
 ? abs(-1)
 %1 = 1
 ? abs(3/7 + 4/7*I)
 %2 = 5/7
 ? abs(1 + I)
 %3 = 1.414213562373095048801688724
 @eprog\noindent
 If $x$ is a polynomial, returns $-x$ if the leading coefficient is
 real and negative else returns $x$. For a power series, the constant
 coefficient is considered instead.

Function: acos
Class: basic
Section: transcendental
C-Name: gacos
Prototype: Gp
Help: acos(x): arc cosine of x.
Doc: principal branch of $\cos^{-1}(x) = -i \log (x + i\sqrt{1-x^2})$.
 In particular, $\Re(\text{acos}(x))\in [0,\pi]$ and if $x\in \R$ and $|x|>1$,
 then $\text{acos}(x)$ is complex. The branch cut is in two pieces:
 $]-\infty,-1]$ , continuous with quadrant II, and $[1,+\infty[$, continuous
 with quadrant IV. We have $\text{acos}(x) = \pi/2 - \text{asin}(x)$ for all
 $x$.

Function: acosh
Class: basic
Section: transcendental
C-Name: gacosh
Prototype: Gp
Help: acosh(x): inverse hyperbolic cosine of x.
Doc: principal branch of $\cosh^{-1}(x) = 2
  \log(\sqrt{(x+1)/2} + \sqrt{(x-1)/2})$. In particular,
 $\Re(\text{acosh}(x))\geq 0$ and
 $\Im(\text{acosh}(x))\in ]-\pi,\pi]$; if $x\in \R$ and $x<1$, then
 $\text{acosh}(x)$ is complex.

Function: addhelp
Class: basic
Section: programming/specific
C-Name: addhelp
Prototype: vrs
Help: addhelp(sym,str): add/change help message for the symbol sym.
Doc: changes the help message for the symbol \kbd{sym}. The string \var{str}
 is expanded on the spot and stored as the online help for \kbd{sym}. It is
 recommended to document global variables and user functions in this way,
 although \kbd{gp} will not protest if you don't.
 
 You can attach a help text to an alias, but it will never be
 shown: aliases are expanded by the \kbd{?} help operator and we get the help
 of the symbol the alias points to. Nothing prevents you from modifying the
 help of built-in PARI functions. But if you do, we would like to hear why you
 needed it!
 
 Without \tet{addhelp}, the standard help for user functions consists of its
 name and definition.
 \bprog
 gp> f(x) = x^2;
 gp> ?f
 f =
   (x)->x^2
 
 @eprog\noindent Once addhelp is applied to $f$, the function code is no
 longer included. It can still be consulted by typing the function name:
 \bprog
 gp> addhelp(f, "Square")
 gp> ?f
 Square
 
 gp> f
 %2 = (x)->x^2
 @eprog

Function: addprimes
Class: basic
Section: number_theoretical
C-Name: addprimes
Prototype: DG
Help: addprimes({x=[]}): add primes in the vector x to the prime table to
 be used in trial division. x may also be a single integer. Composite
 "primes" are NOT allowed.
Doc: adds the integers contained in the
 vector $x$ (or the single integer $x$) to a special table of
 ``user-defined primes'', and returns that table. Whenever \kbd{factor} is
 subsequently called, it will trial divide by the elements in this table.
 If $x$ is empty or omitted, just returns the current list of extra
 primes.
 \bprog
 ? addprimes(37975227936943673922808872755445627854565536638199)
 ? factor(15226050279225333605356183781326374297180681149613806\
          88657908494580122963258952897654000350692006139)
 %2 =
 [37975227936943673922808872755445627854565536638199 1]
 
 [40094690950920881030683735292761468389214899724061 1]
 ? ##
   ***   last result computed in 0 ms.
 @eprog
 
 The entries in $x$ must be primes: there is no internal check, even if
 the \tet{factor_proven} default is set. To remove primes from the list use
 \kbd{removeprimes}.

Function: agm
Class: basic
Section: transcendental
C-Name: agm
Prototype: GGp
Help: agm(x,y): arithmetic-geometric mean of x and y.
Doc: arithmetic-geometric mean of $x$ and $y$. In the
 case of complex or negative numbers, the optimal AGM is returned
 (the largest in absolute value over all choices of the signs of the square
 roots).  $p$-adic or power series arguments are also allowed. Note that
 a $p$-adic agm exists only if $x/y$ is congruent to 1 modulo $p$ (modulo
 16 for $p=2$). $x$ and $y$ cannot both be vectors or matrices.

Function: airy
Class: basic
Section: transcendental
C-Name: airy
Prototype: Gp
Help: airy(z): Airy [Ai,Bi] function of argument z.
Doc: airy $[Ai,Bi]$ functions of argument $z$.
 \bprog
 ? [A,B] = airy(1);
 ? A
 %2 = 0.13529241631288141552414742351546630617
 ? B
 %3 = 1.2074235949528712594363788170282869954
 @eprog\noindent

Function: alarm
Class: basic
Section: programming/specific
C-Name: gp_alarm
Prototype: D0,L,DE
Help: alarm({s = 0},{code}): if code is omitted, trigger an "e_ALARM"
 exception after s seconds (wall-clock time), cancelling any previously set
 alarm; stop a pending alarm if s = 0 or is omitted. Otherwise, evaluate code,
 aborting after s seconds.
Doc: if \var{code} is omitted, trigger an \var{e\_ALARM} exception after $s$
 seconds (wall-clock time), cancelling any previously set alarm; stop a pending
 alarm if $s = 0$ or is omitted.
 
 Otherwise, if $s$ is positive, the function evaluates \var{code},
 aborting after $s$ seconds. The return value is the value of \var{code} if
 it ran to completion before the alarm timeout, and a \typ{ERROR} object
 otherwise.
 \bprog
 ? p = nextprime(10^25); q = nextprime(10^26); N = p*q;
 ? E = alarm(1, factor(N));
 ? type(E)
 %3 = "t_ERROR"
 ? print(E)
 %4 = error("alarm interrupt after 964 ms.")
 ? alarm(10, factor(N));   \\ enough time
 %5 =
 [ 10000000000000000000000013 1]
 
 [100000000000000000000000067 1]
 @eprog\noindent Here is a more involved example: the function
 \kbd{timefact(N,sec)} below tries to factor $N$ and gives up after \var{sec}
 seconds, returning a partial factorization.
 \bprog
 \\ Time-bounded partial factorization
 default(factor_add_primes,1);
 timefact(N,sec)=
 {
   F = alarm(sec, factor(N));
   if (type(F) == "t_ERROR", factor(N, 2^24), F);
 }
 @eprog\noindent We either return the factorization directly, or replace the
 \typ{ERROR} result by a simple bounded factorization \kbd{factor(N, 2\pow 24)}.
 Note the \tet{factor_add_primes} trick: any prime larger than $2^{24}$
 discovered while attempting the initial factorization is stored and
 remembered. When the alarm rings, the subsequent bounded factorization finds
 it right away.
 
 \misctitle{Caveat} It is not possible to set a new alarm \emph{within}
 another \kbd{alarm} code: the new timer erases the parent one.
 
 \misctitle{Caveat2} In a parallel-enabled \kbd{gp}, if the \var{code}
 involves parallel subtasks, then \kbd{alarm} may not return right away: il
 will prevent new tasks from being launched but will not interrupt previously
 launched secondary threads. This avoids leaving the system in an
 inconsistent state.

Function: algadd
Class: basic
Section: algebras
C-Name: algadd
Prototype: GGG
Help: algadd(al,x,y): element x+y in al.
Doc: Given two elements $x$ and $y$ in \var{al}, computes their sum $x+y$ in
 the algebra~\var{al}.
 \bprog
 ? A = alginit(nfinit(y),[-1,1]);
 ? algadd(A,[1,0]~,[1,2]~)
 %2 = [2, 2]~
 @eprog
 
 Also accepts matrices with coefficients in \var{al}.

Function: algalgtobasis
Class: basic
Section: algebras
C-Name: algalgtobasis
Prototype: GG
Help: algalgtobasis(al,x): transforms the element x of the algebra al into a
 column vector on the integral basis of al.
Doc: Given an element \var{x} in the central simple algebra \var{al} output
 by \tet{alginit}, transforms it to a column vector on the integral basis of
 \var{al}. This is the inverse function of \tet{algbasistoalg}.
 \bprog
 ? A = alginit(nfinit(y^2-5),[2,y]);
 ? algalgtobasis(A,[y,1]~)
 %2 = [0, 2, 0, -1, 2, 0, 0, 0]~
 ? algbasistoalg(A,algalgtobasis(A,[y,1]~))
 %3 = [Mod(Mod(y, y^2 - 5), x^2 - 2), 1]~
 @eprog

Function: algaut
Class: basic
Section: algebras
C-Name: algaut
Prototype: mG
Help: algaut(al): the stored automorphism of the splitting field of the
 cyclic algebra al.
Doc: Given a cyclic algebra $\var{al} = (L/K,\sigma,b)$ output by
 \tet{alginit}, returns the automorphism $\sigma$.
 \bprog
 ? nf = nfinit(y);
 ? p = idealprimedec(nf,7)[1];
 ? p2 = idealprimedec(nf,11)[1];
 ? A = alginit(nf,[3,[[p,p2],[1/3,2/3]],[0]]);
 ? algaut(A)
 %5 = -1/3*x^2 + 1/3*x + 26/3
 @eprog

Function: algb
Class: basic
Section: algebras
C-Name: algb
Prototype: mG
Help: algb(al): the element b of the center of the cyclic algebra al used
 to define it.
Doc: Given a cyclic algebra $\var{al} = (L/K,\sigma,b)$ output by
 \tet{alginit}, returns the element $b\in K$.
 \bprog
 nf = nfinit(y);
 ? p = idealprimedec(nf,7)[1];
 ? p2 = idealprimedec(nf,11)[1];
 ? A = alginit(nf,[3,[[p,p2],[1/3,2/3]],[0]]);
 ? algb(A)
 %5 = Mod(-77, y)
 @eprog

Function: algbasis
Class: basic
Section: algebras
C-Name: algbasis
Prototype: mG
Help: algbasis(al): basis of the stored order of the central simple algebra al.
Doc: Given a central simple algebra \var{al} output by \tet{alginit}, returns
 a $\Z$-basis of the order~${\cal O}_0$ stored in \var{al} with respect to the
 natural order in \var{al}. It is a maximal order if one has been computed.
 \bprog
 A = alginit(nfinit(y), [-1,-1]);
 ? algbasis(A)
 %2 =
 [1 0 0 1/2]
 
 [0 1 0 1/2]
 
 [0 0 1 1/2]
 
 [0 0 0 1/2]
 @eprog

Function: algbasistoalg
Class: basic
Section: algebras
C-Name: algbasistoalg
Prototype: GG
Help: algbasistoalg(al,x): transforms the column vector x on the integral
 basis of al into an element of al in algebraic form.
Doc: Given an element \var{x} in the central simple algebra \var{al} output
 by \tet{alginit}, transforms it to its algebraic representation in \var{al}.
 This is the inverse function of \tet{algalgtobasis}.
 \bprog
 ? A = alginit(nfinit(y^2-5),[2,y]);
 ? z = algbasistoalg(A,[0,1,0,0,2,-3,0,0]~);
 ? liftall(z)
 %3 = [(-1/2*y - 2)*x + (-1/4*y + 5/4), -3/4*y + 7/4]~
 ? algalgtobasis(A,z)
 %4 = [0, 1, 0, 0, 2, -3, 0, 0]~
 @eprog

Function: algcenter
Class: basic
Section: algebras
C-Name: algcenter
Prototype: mG
Help: algcenter(al): center of the algebra al.
Doc: If \var{al} is a table algebra output by \tet{algtableinit}, returns a
 basis of the center of the algebra~\var{al} over its prime field ($\Q$ or
 $\F_p$). If \var{al} is a central simple algebra output by \tet{alginit},
 returns the center of~\var{al}, which is stored in \var{al}.
 
 A simple example: the $2\times 2$ upper triangular matrices over $\Q$,
 generated by $I_2$, $a = \kbd{[0,1;0,0]}$ and $b = \kbd{[0,0;0,1]}$,
 such that $a^2 = 0$, $ab = a$, $ba = 0$, $b^2 = b$: the diagonal matrices
 form the center.
 \bprog
 ? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
 ? A = algtableinit(mt);
 ? algcenter(A) \\ = (I_2)
 %3 =
 [1]
 
 [0]
 
 [0]
 @eprog
 
 An example in the central simple case:
 
 \bprog
 ? nf = nfinit(y^3-y+1);
 ? A = alginit(nf, [-1,-1]);
 ? algcenter(A).pol
 %3 = y^3 - y + 1
 @eprog

Function: algcentralproj
Class: basic
Section: algebras
C-Name: alg_centralproj
Prototype: GGD0,L,
Help: algcentralproj(al,z,{maps=0}): projections of the algebra al on the
 orthogonal central idempotents z[i].
Doc: Given a table algebra \var{al} output by \tet{algtableinit} and a
 \typ{VEC} $\var{z}=[z_1,\dots,z_n]$ of orthogonal central idempotents,
 returns a \typ{VEC} $[al_1,\dots,al_n]$ of algebras such that
 $al_i = z_i\, al$. If $\var{maps}=1$, each $al_i$ is a \typ{VEC}
 $[quo,proj,lift]$ where \var{quo} is the quotient algebra, \var{proj} is a
 \typ{MAT} representing the projection onto this quotient and \var{lift} is a
 \typ{MAT} representing a lift.
 
 A simple example: $\F_2\times \F_4$, generated by~$1=(1,1)$, $e=(1,0)$
 and~$x$ such that~$x^2+x+1=0$. We have~$e^2=e$, $x^2=x+1$ and~$ex=0$.
 \bprog
 ? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
 ? A = algtableinit(mt,2);
 ? e = [0,1,0]~;
 ? e2 = algsub(A,[1,0,0]~,e);
 ? [a,a2] = algcentralproj(A,[e,e2]);
 ? algdim(a)
 %6 = 1
 ? algdim(a2)
 %7 = 2
 @eprog

Function: algchar
Class: basic
Section: algebras
C-Name: algchar
Prototype: mG
Help: algchar(al): characteristic of the algebra al.
Doc: Given an algebra \var{al} output by \tet{alginit} or \tet{algtableinit},
 returns the characteristic of \var{al}.
 \bprog
 ? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
 ? A = algtableinit(mt,13);
 ? algchar(A)
 %3 = 13
 @eprog

Function: algcharpoly
Class: basic
Section: algebras
C-Name: algcharpoly
Prototype: GGDnD0,L,
Help: algcharpoly(al,b,{v='x},{abs=0}): (reduced) characteristic polynomial of b in
 al, with respect to the variable v.
Doc: Given an element $b$ in \var{al}, returns its characteristic polynomial
 as a polynomial in the variable $v$. If \var{al} is a table algebra output
 by \tet{algtableinit} or if $abs=1$, returns the absolute characteristic
 polynomial of \var{b}, which is an element of $\F_p[v]$ or~$\Q[v]$; if \var{al}
 is a central simple algebra output by \tet{alginit} and $abs=0$, returns the
 reduced characteristic polynomial of \var{b}, which is an element of~$K[v]$
 where~$K$ is the center of \var{al}.
 \bprog
 ? al = alginit(nfinit(y), [-1,-1]); \\ (-1,-1)_Q
 ? algcharpoly(al, [0,1]~)
 %2 = x^2 + 1
 ? algcharpoly(al, [0,1]~,,1)
 %3 = x^4 + 2*x^2 + 1
 ? nf = nfinit(y^2-5);
 ? al = alginit(nf,[-1,y]);
 ? a = [y,1+x]~*Mod(1,y^2-5)*Mod(1,x^2+1);
 ? P = lift(algcharpoly(al,a))
 %7 = x^2 - 2*y*x + (-2*y + 5)
 ? algcharpoly(al,a,,1)
 %8 = x^8 - 20*x^6 - 80*x^5 + 110*x^4 + 800*x^3 + 1500*x^2 - 400*x + 25
 ? lift(P*subst(P,y,-y)*Mod(1,y^2-5))^2
 %9 = x^8 - 20*x^6 - 80*x^5 + 110*x^4 + 800*x^3 + 1500*x^2 - 400*x + 25
 @eprog
 
 Also accepts a square matrix with coefficients in \var{al}.

Function: algdegree
Class: basic
Section: algebras
C-Name: algdegree
Prototype: lG
Help: algdegree(al): degree of the central simple algebra al.
Doc: Given a central simple algebra \var{al} output by \tet{alginit}, returns
 the degree of \var{al}.
 \bprog
 ? nf = nfinit(y^3-y+1);
 ? A = alginit(nf, [-1,-1]);
 ? algdegree(A)
 %3 = 2
 @eprog

Function: algdep
Class: basic
Section: linear_algebra
C-Name: algdep0
Prototype: GLD0,L,
Help: algdep(z,k,{flag=0}): algebraic relations up to degree k of z, using
 lindep([1,z,...,z^(k-1)], flag).
Doc: \sidx{algebraic dependence}
 $z$ being real/complex, or $p$-adic, finds a polynomial (in the variable
 \kbd{'x}) of degree at most
 $k$, with integer coefficients, having $z$ as approximate root. Note that the
 polynomial which is obtained is not necessarily the ``correct'' one. In fact
 it is not even guaranteed to be irreducible. One can check the closeness
 either by a polynomial evaluation (use \tet{subst}), or by computing the
 roots of the polynomial given by \kbd{algdep} (use \tet{polroots} or
 \tet{polrootspadic}).
 
 Internally, \tet{lindep}$([1,z,\ldots,z^k], \fl)$ is used. A nonzero value of
 $\fl$ may improve on the default behavior if the input number is known to a
 \emph{huge} accuracy, and you suspect the last bits are incorrect: if $\fl > 0$
 the computation is done with an accuracy of $\fl$ decimal  digits; to get
 meaningful results, the parameter $\fl$ should be smaller than the number of
 correct decimal digits in the input. But default values are usually
 sufficient, so try without $\fl$ first:
 \bprog
 ? \p200
 ? z = 2^(1/6)+3^(1/5);
 ? algdep(z, 30);      \\ right in 63ms
 ? algdep(z, 30, 100); \\ wrong in 39ms
 ? algdep(z, 30, 170); \\ right in 61ms
 ? algdep(z, 30, 200); \\ wrong in 146ms
 ? \p250
 ? z = 2^(1/6)+3^(1/5); \\ recompute to new, higher, accuracy !
 ? algdep(z, 30);      \\ right in 68ms
 ? algdep(z, 30, 200); \\ right in 68ms
 ? \p500
 ? algdep(2^(1/6)+3^(1/5), 30); \\ right in 138ms
 ? \p1000
 ? algdep(2^(1/6)+3^(1/5), 30); \\ right in 276s
 @eprog\noindent
 The changes in \kbd{realprecision} only affect the quality of the
 initial approximation to $2^{1/6} + 3^{1/5}$, \kbd{algdep} itself uses
 exact operations. The size of its operands depend on the accuracy of the
 input of course: a more accurate input means slower operations.
 
 Proceeding by increments of 5 digits of accuracy, \kbd{algdep} with default
 flag produces its first correct result at 195 digits, and from then on a
 steady stream of correct results:
 \bprog
   \\ assume T contains the correct result, for comparison
   forstep(d=100, 250, 5, \
     localprec(d);        \
     print(d, " ", algdep(2^(1/6)+3^(1/5),30) == T))
 @eprog\noindent
 This example is the test case studied in a 2000 paper by Borwein and
 Lisonek: Applications of integer relation algorithms, \emph{Discrete Math.},
 {\bf 217}, p.~65--82. The version of PARI tested there was 1.39, which
 succeeded reliably from precision 265 on, in about 1000 as much time as the
 current version (on slower hardware of course).
 
 Note that this function does not work if $z$ is a power series. The function
 \kbd{seralgdep} can be used in this case to find linear relations wich
 polynomial coefficients between powers of $z$.
Variant: Also available is \fun{GEN}{algdep}{GEN z, long k} ($\fl=0$).

Function: algdim
Class: basic
Section: algebras
C-Name: algdim
Prototype: lGD0,L,
Help: algdim(al,{abs=0}): dimension of the algebra al.
Doc: If \var{al} is a table algebra output by \tet{algtableinit} or if~$abs=1$,
 returns the dimension of \var{al} over its prime subfield ($\Q$ or $\F_p$).
 If~\var{al} is a central simple algebra output by \tet{alginit} and~$abs=0$,
 returns the dimension of \var{al} over its center.
 
 \bprog
 ? nf = nfinit(y^3-y+1);
 ? A = alginit(nf, [-1,-1]);
 ? algdim(A)
 %3 = 4
 ? algdim(A,1)
 %4 = 12
 @eprog

Function: algdisc
Class: basic
Section: algebras
C-Name: algdisc
Prototype: G
Help: algdisc(al): discriminant of the stored order of the algebra al.
Doc: Given a central simple algebra \var{al} output by \tet{alginit}, computes
 the discriminant of the order ${\cal O}_0$ stored in \var{al}, that is the
 determinant of the trace form $\rm{Tr} : {\cal O}_0\times {\cal O}_0 \to \Z$.
 \bprog
 ? nf = nfinit(y^2-5);
 ? A = alginit(nf, [-3,1-y]);
 ? [PR,h] = alghassef(A)
 %3 = [[[2, [2, 0]~, 1, 2, 1], [3, [3, 0]~, 1, 2, 1]], Vecsmall([0, 1])]
 ? n = algdegree(A);
 ? D = algdim(A,1);
 ? h = vector(#h, i, n - gcd(n,h[i]));
 ? n^D * nf.disc^(n^2) * idealnorm(nf, idealfactorback(nf,PR,h))^n
 %4 = 12960000
 ? algdisc(A)
 %5 = 12960000
 @eprog

Function: algdivl
Class: basic
Section: algebras
C-Name: algdivl
Prototype: GGG
Help: algdivl(al,x,y): element x\y in al.
Doc: Given two elements $x$ and $y$ in \var{al}, computes their left quotient
 $x\backslash y$ in the algebra \var{al}: an element $z$ such that $xz=y$ (such
 an element is not unique when $x$ is a zerodivisor). If~$x$ is invertible, this
 is the same as $x^{-1}y$. Assumes that $y$ is left divisible by $x$ (i.e. that
 $z$ exists). Also accepts matrices with coefficients in~\var{al}.

Function: algdivr
Class: basic
Section: algebras
C-Name: algdivr
Prototype: GGG
Help: algdivr(al,x,y): element x/y in al.
Doc: Given two elements $x$ and $y$ in \var{al}, returns $xy^{-1}$. Also accepts
 matrices with coefficients in \var{al}.

Function: alggroup
Class: basic
Section: algebras
C-Name: alggroup
Prototype: GDG
Help: alggroup(gal, {p=0}): constructs the group algebra of gal over Q (resp. Fp).
Doc: initializes the group algebra~$K[G]$ over~$K=\Q$ ($p$ omitted) or~$\F_p$
 where~$G$ is the underlying group of the \kbd{galoisinit} structure~\var{gal}.
 The input~\var{gal} is also allowed to be a \typ{VEC} of permutations that is
 closed under products.
 
 Example:
 \bprog
 ? K = nfsplitting(x^3-x+1);
 ? gal = galoisinit(K);
 ? al = alggroup(gal);
 ? algissemisimple(al)
 %4 = 1
 ? G = [Vecsmall([1,2,3]), Vecsmall([1,3,2])];
 ? al2 = alggroup(G, 2);
 ? algissemisimple(al2)
 %8 = 0
 @eprog

Function: alggroupcenter
Class: basic
Section: algebras
C-Name: alggroupcenter
Prototype: GDGD&
Help: alggroupcenter(gal,{p=0},{&cc}): constructs the center of the group
 algebra of gal over Q (resp. Fp), and sets cc to the conjugacy classes of gal.
Doc: initializes the center~$Z(K[G])$ of the group algebra~$K[G]$ over~$K=\Q$
 ($p = 0$ or omitted) or~$\F_p$ where~$G$ is the underlying group of the
 \kbd{galoisinit} structure~\var{gal}. The input~\var{gal} is also allowed to
 be a \typ{VEC} of permutations that is closed under products.
 Sets~\var{cc} to a \typ{VEC}~$[\var{elts},\var{conjclass},\var{rep},\var{flag}]$
 where~\var{elts} is a sorted \typ{VEC} containing the list of elements
 of~$G$, \var{conjclass} is a \typ{VECSMALL} of the same length as~\var{elts}
 containing the index of the conjugacy class of the corresponding element (an
 integer between $1$ and the number of conjugacy classes), and~\var{rep} is a
 \typ{VECSMALL} of length the number of conjugacy classes giving for each
 conjugacy class the index in~\var{elts} of a representative of this conjugacy
 class. Finally \var{flag} is $1$ if and only if the permutation
 representation of $G$ is transitive, in which case the $i$-th element
 of \var{elts} is characterized by $g[1] = i$; this is always the case
 when \var{gal} is a \kbd{galoisinit} structure. The basis of~$Z(K[G])$ as
 output consists of the indicator functions of the conjugacy classes in the
 ordering given by~\var{cc}. Example:
 \bprog
 ? K = nfsplitting(x^4+x+1);
 ? gal = galoisinit(K); \\ S4
 ? al = alggroupcenter(gal,,&cc);
 ? algiscommutative(al)
 %4 = 1
 ? #cc[3] \\ number of conjugacy classes of S4
 %5 = 5
 ? gal = [Vecsmall([1,2,3]),Vecsmall([1,3,2])]; \\ C2
 ? al = alggroupcenter(gal,,&cc);
 ? cc[3]
 %8 = Vecsmall([1, 2])
 ? cc[4]
 %9 = 0
 @eprog

Function: alghasse
Class: basic
Section: algebras
C-Name: alghasse
Prototype: GG
Help: alghasse(al,pl): the hasse invariant of the central simple algebra al at
 the place pl.
Doc: Given a central simple algebra \var{al} output by \tet{alginit} and a prime
 ideal or an integer between $1$ and $r_1+r_2$, returns a \typ{FRAC} $h$ : the
 local Hasse invariant of \var{al} at the place specified by \var{pl}.
 \bprog
 ? nf = nfinit(y^2-5);
 ? A = alginit(nf, [-1,y]);
 ? alghasse(A, 1)
 %3 = 1/2
 ? alghasse(A, 2)
 %4 = 0
 ? alghasse(A, idealprimedec(nf,2)[1])
 %5 = 1/2
 ? alghasse(A, idealprimedec(nf,5)[1])
 %6 = 0
 @eprog

Function: alghassef
Class: basic
Section: algebras
C-Name: alghassef
Prototype: mG
Help: alghassef(al): the hasse invariant of the central simple algebra al at finite places.
Doc: Given a central simple algebra \var{al} output by \tet{alginit}, returns
 a \typ{VEC} $[\kbd{PR}, h_f]$ describing the local Hasse invariants at the
 finite places of the center: \kbd{PR} is a \typ{VEC} of primes and $h_f$ is a
 \typ{VECSMALL} of integers modulo the degree $d$ of \var{al}. The Hasse
 invariant of~\var{al} at the primes outside~\kbd{PR} is~$0$, but~\kbd{PR} can
 include primes at which the Hasse invariant is~$0$.
 \bprog
 ? nf = nfinit(y^2-5);
 ? A = alginit(nf, [-1,2*y-1]);
 ? [PR,hf] = alghassef(A);
 ? PR
 %4 = [[19, [10, 2]~, 1, 1, [-8, 2; 2, -10]], [2, [2, 0]~, 1, 2, 1]]
 ? hf
 %5 = Vecsmall([1, 0])
 @eprog

Function: alghassei
Class: basic
Section: algebras
C-Name: alghassei
Prototype: mG
Help: alghassei(al): the hasse invariant of the central simple algebra al
 at infinite places.
Doc: Given a central simple algebra \var{al} output by \tet{alginit}, returns
 a \typ{VECSMALL} $h_i$ of $r_1$ integers modulo the degree $d$ of \var{al},
 where $r_1$ is the number of real places of the center: the local Hasse
 invariants of \var{al} at infinite places.
 \bprog
 ? nf = nfinit(y^2-5);
 ? A = alginit(nf, [-1,y]);
 ? alghassei(A)
 %3 = Vecsmall([1, 0])
 @eprog

Function: algindex
Class: basic
Section: algebras
C-Name: algindex
Prototype: lGDG
Help: algindex(al,{pl}): the index of the central simple algebra al. If pl is
 set, it should be a prime ideal of the center or an integer between 1 and
 r1+r2, and in that case return the local index at the place pl instead.
Doc: Returns the index of the central simple algebra~$A$ over~$K$ (as output by
 alginit), that is the degree~$e$ of the unique central division algebra~$D$
 over $K$ such that~$A$ is isomorphic to some matrix algebra~$M_k(D)$. If
 \var{pl} is set, it should be a prime ideal of~$K$ or an integer between~$1$
 and~$r_1+r_2$, and in that case return the local index at the place \var{pl}
 instead.
 
 \bprog
 ? nf = nfinit(y^2-5);
 ? A = alginit(nf, [-1,y]);
 ? algindex(A, 1)
 %3 = 2
 ? algindex(A, 2)
 %4 = 1
 ? algindex(A, idealprimedec(nf,2)[1])
 %5 = 2
 ? algindex(A, idealprimedec(nf,5)[1])
 %6 = 1
 ? algindex(A)
 %7 = 2
 @eprog

Function: alginit
Class: basic
Section: algebras
C-Name: alginit
Prototype: GGDnD1,L,
Help: alginit(B, C, {v}, {maxord = 1}): initializes the central simple algebra
 defined by data B, C. If maxord = 1, compute a maximal order.
Doc: initializes the central simple algebra defined by data $B$, $C$ and
 variable $v$, as follows.
 
 \item (multiplication table) $B$ is the base number field $K$ in \tet{nfinit}
 form, $C$ is a ``multiplication table'' over $K$.
 As a $K$-vector space, the algebra is generated by a basis
 $(e_1 = 1,\dots, e_n)$; the table is given as a \typ{VEC} of $n$ matrices in
 $M_n(K)$, giving the left multiplication by the basis elements~$e_i$, in the
 given basis.
 Assumes that $e_1= 1$, that the multiplication table is integral, and that
 $(\bigoplus_{i=1}^nK e_i,C)$ describes a central simple algebra over $K$.
 \bprog
 { mi = [0,-1,0, 0;
          1, 0,0, 0;
          0, 0,0,-1;
          0, 0,1, 0];
   mj = [0, 0,-1,0;
          0, 0, 0,1;
          1, 0, 0,0;
          0,-1, 0,0];
   mk = [0, 0, 0, -1;
          0, 0,-1, 0;
          0, 1, 0, 0;
          1, 0, 0, 0];
   A = alginit(nfinit(y), [matid(4), mi,mj,mk], , 0); }
 @eprog represents (in a complicated way) the quaternion algebra $(-1,-1)_\Q$.
 See below for a simpler solution.
 
 \item (cyclic algebra) $B$ is an \kbd{rnf} structure attached to a cyclic
 number field extension $L/K$ of degree $d$, $C$ is a \typ{VEC}
 \kbd{[sigma,b]} with 2 components: \kbd{sigma} is a \typ{POLMOD} representing
 an automorphism generating $\text{Gal}(L/K)$, $b$ is an element in $K^*$. This
 represents the cyclic algebra~$(L/K,\sigma,b)$. Currently the element $b$ has
 to be integral.
 \bprog
  ? Q = nfinit(y); T = polcyclo(5, 'x); F = rnfinit(Q, T);
  ? A = alginit(F, [Mod(x^2,T), 3]);
 @eprog defines the cyclic algebra $(L/\Q, \sigma, 3)$, where
 $L = \Q(\zeta_5)$ and $\sigma:\zeta\mapsto\zeta^2$ generates
 $\text{Gal}(L/\Q)$.
 
 \item (quaternion algebra, special case of the above) $B$ is an \kbd{nf}
 structure attached to a number field $K$, $C = [a,b]$ is a vector
 containing two elements of $K^*$ with $a$ not a square in $K$, returns the quaternion algebra $(a,b)_K$.
 The variable $v$ (\kbd{'x} by default) must have higher priority than the
 variable of $K$\kbd{.pol} and is used to represent elements in the splitting
 field $L = K[x]/(x^2-a)$.
 \bprog
  ? Q = nfinit(y); A = alginit(Q, [-1,-1]);  \\@com $(-1,-1)_\Q$
 @eprog
 
 \item (algebra/$K$ defined by local Hasse invariants)
 $B$ is an \kbd{nf} structure attached to a number field $K$,
 $C = [d, [\kbd{PR},h_f], h_i]$ is a triple
 containing an integer $d > 1$, a pair $[\kbd{PR}, h_f]$ describing the
 Hasse invariants at finite places, and $h_i$ the Hasse invariants
 at archimedean (real) places. A local Hasse invariant belongs to $(1/d)\Z/\Z
 \subset \Q/\Z$, and is given either as a \typ{FRAC} (lift to $(1/d)\Z$),
 a \typ{INT} or \typ{INTMOD} modulo $d$ (lift to $\Z/d\Z$); a whole vector
 of local invariants can also be given as a \typ{VECSMALL}, whose
 entries are handled as \typ{INT}s. \kbd{PR} is a list of prime ideals
 (\kbd{prid} structures), and $h_f$ is a vector of the same length giving the
 local invariants at those maximal ideals. The invariants at infinite real
 places are indexed by the real roots $K$\kbd{.roots}: if the Archimedean
 place $v$ is attached to the $j$-th root, the value of
 $h_v$ is given by $h_i[j]$, must be $0$ or $1/2$ (or~$d/2$ modulo~$d$), and
 can be nonzero only if~$d$ is even.
 
 By class field theory, provided the local invariants $h_v$ sum to $0$, up
 to Brauer equivalence, there is a unique central simple algebra over $K$
 with given local invariants and trivial invariant elsewhere. In particular,
 up to isomorphism, there is a unique such algebra $A$ of degree $d$.
 
 We realize $A$ as a cyclic algebra through class field theory. The variable $v$
 (\kbd{'x} by default) must have higher priority than the variable of
 $K$\kbd{.pol} and is used to represent elements in the (cyclic) splitting
 field extension $L/K$ for $A$.
 
 \bprog
  ? nf = nfinit(y^2+1);
  ? PR = idealprimedec(nf,5); #PR
  %2 = 2
  ? hi = [];
  ? hf = [PR, [1/3,-1/3]];
  ? A = alginit(nf, [3,hf,hi]);
  ? algsplittingfield(A).pol
  %6 = x^3 - 21*x + 7
 @eprog
 
 \item (matrix algebra, toy example) $B$ is an \kbd{nf} structure attached
 to a number field $K$, $C = d$ is a positive integer. Returns a cyclic
 algebra isomorphic to the matrix algebra $M_d(K)$.
 
 In all cases, this function computes a maximal order for the algebra by default,
 which may require a lot of time. Setting $maxord = 0$ prevents this computation.
 
 The pari object representing such an algebra $A$ is a \typ{VEC} with the
 following data:
 
  \item A splitting field $L$ of $A$ of the same degree over $K$ as $A$, in
 \kbd{rnfinit} format, accessed with \kbd{algsplittingfield}.
 
  \item The Hasse invariants at the real places of $K$, accessed with
 \kbd{alghassei}.
 
  \item The Hasse invariants of $A$ at the finite primes of $K$ that ramify in
 the natural order of $A$, accessed with \kbd{alghassef}.
 
  \item A basis of an order ${\cal O}_0$ expressed on the basis of the natural
 order, accessed with \kbd{algbasis}.
 
  \item A basis of the natural order expressed on the basis of ${\cal O}_0$,
 accessed with \kbd{alginvbasis}.
 
  \item The left multiplication table of ${\cal O}_0$ on the previous basis,
 accessed with \kbd{algmultable}.
 
  \item The characteristic of $A$ (always $0$), accessed with \kbd{algchar}.
 
  \item The absolute traces of the elements of the basis of ${\cal O}_0$.
 
  \item If $A$ was constructed as a cyclic algebra~$(L/K,\sigma,b)$ of degree
 $d$, a \typ{VEC} $[\sigma,\sigma^2,\dots,\sigma^{d-1}]$. The function
 \kbd{algaut} returns $\sigma$.
 
  \item If $A$ was constructed as a cyclic algebra~$(L/K,\sigma,b)$, the
 element $b$, accessed with \kbd{algb}.
 
  \item If $A$ was constructed with its multiplication table $mt$ over $K$,
 the \typ{VEC} of \typ{MAT} $mt$, accessed with \kbd{algrelmultable}.
 
  \item If $A$ was constructed with its multiplication table $mt$ over $K$,
 a \typ{VEC} with three components: a \typ{COL} representing an element of $A$
 generating the splitting field $L$ as a maximal subfield of $A$, a \typ{MAT}
 representing an $L$-basis ${\cal B}$ of $A$ expressed on the $\Z$-basis of
 ${\cal O}_0$, and a \typ{MAT} representing the $\Z$-basis of ${\cal O}_0$
 expressed on ${\cal B}$. This data is accessed with \kbd{algsplittingdata}.

Function: alginv
Class: basic
Section: algebras
C-Name: alginv
Prototype: GG
Help: alginv(al,x): element 1/x in al.
Doc: Given an element $x$ in \var{al}, computes its inverse $x^{-1}$ in the
 algebra \var{al}. Assumes that $x$ is invertible.
 \bprog
 ? A = alginit(nfinit(y), [-1,-1]);
 ? alginv(A,[1,1,0,0]~)
 %2 = [1/2, 1/2, 0, 0]~
 @eprog
 
 Also accepts matrices with coefficients in \var{al}.

Function: alginvbasis
Class: basic
Section: algebras
C-Name: alginvbasis
Prototype: mG
Help: alginvbasis(al): basis of the natural order of the central simple algebra
 al in terms of the stored order.
Doc: Given an central simple algebra \var{al} output by \tet{alginit}, returns
 a $\Z$-basis of the natural order in \var{al} with respect to the
 order~${\cal O}_0$ stored in \var{al}.
 \bprog
 A = alginit(nfinit(y), [-1,-1]);
 ? alginvbasis(A)
 %2 =
 [1 0 0 -1]
 
 [0 1 0 -1]
 
 [0 0 1 -1]
 
 [0 0 0  2]
 @eprog

Function: algisassociative
Class: basic
Section: algebras
C-Name: algisassociative
Prototype: iGD0,G,
Help: algisassociative(mt,p=0): true (1) if the multiplication table mt is
 suitable for algtableinit(mt,p), false (0) otherwise.
Doc: Returns 1 if the multiplication table \kbd{mt} is suitable for
 \kbd{algtableinit(mt,p)}, 0 otherwise. More precisely, \kbd{mt} should be
 a \typ{VEC} of $n$ matrices in $M_n(K)$, giving the left multiplications
 by the basis elements $e_1, \dots, e_n$ (structure constants).
 We check whether the first basis element $e_1$ is $1$ and $e_i(e_je_k) =
 (e_ie_j)e_k$ for all $i,j,k$.
 \bprog
  ? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
  ? algisassociative(mt)
  %2 = 1
 @eprog
 
 May be used to check a posteriori an algebra: we also allow \kbd{mt} as
 output by \tet{algtableinit} ($p$ is ignored in this case).

Function: algiscommutative
Class: basic
Section: algebras
C-Name: algiscommutative
Prototype: iG
Help: algiscommutative(al): test whether the algebra al is commutative.
Doc: \var{al} being a table algebra output by \tet{algtableinit} or a central
 simple algebra output by \tet{alginit}, tests whether the algebra \var{al} is
 commutative.
 \bprog
 ? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
 ? A = algtableinit(mt);
 ? algiscommutative(A)
 %3 = 0
 ? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
 ? A = algtableinit(mt,2);
 ? algiscommutative(A)
 %6 = 1
 @eprog

Function: algisdivision
Class: basic
Section: algebras
C-Name: algisdivision
Prototype: iGDG
Help: algisdivision(al,{pl}): tests whether the central simple algebra al is a
 division algebra. If pl is set, it should be a prime ideal of the center or an
 integer between 1 and r1+r2, and in that case tests whether al is locally a
 division algebra at the place pl instead.
Doc: Given a central simple algebra \var{al} output by \tet{alginit}, tests
 whether \var{al} is a division algebra. If \var{pl} is set, it should be a
 prime ideal of~$K$ or an integer between~$1$ and~$r_1+r_2$, and in that case
 tests whether \var{al} is locally a division algebra at the place \var{pl}
 instead.
 
 \bprog
 ? nf = nfinit(y^2-5);
 ? A = alginit(nf, [-1,y]);
 ? algisdivision(A, 1)
 %3 = 1
 ? algisdivision(A, 2)
 %4 = 0
 ? algisdivision(A, idealprimedec(nf,2)[1])
 %5 = 1
 ? algisdivision(A, idealprimedec(nf,5)[1])
 %6 = 0
 ? algisdivision(A)
 %7 = 1
 @eprog

Function: algisdivl
Class: basic
Section: algebras
C-Name: algisdivl
Prototype: iGGGD&
Help: algisdivl(al,x,y,{&z}): tests whether y is left divisible by x and sets z
 to the left quotient x\y.
Doc: Given two elements $x$ and $y$ in \var{al}, tests whether $y$ is left
 divisible by $x$, that is whether there exists~$z$ in \var{al} such
 that~$xz=y$, and sets $z$ to this element if it exists.
 \bprog
 ? A = alginit(nfinit(y), [-1,1]);
 ? algisdivl(A,[x+2,-x-2]~,[x,1]~)
 %2 = 0
 ? algisdivl(A,[x+2,-x-2]~,[-x,x]~,&z)
 %3 = 1
 ? z
 %4 = [Mod(-2/5*x - 1/5, x^2 + 1), 0]~
 @eprog
 
 Also accepts matrices with coefficients in \var{al}.

Function: algisinv
Class: basic
Section: algebras
C-Name: algisinv
Prototype: iGGD&
Help: algisinv(al,x,{&ix}): tests whether x is invertible and sets ix to the
 inverse of x.
Doc: Given an element $x$ in \var{al}, tests whether $x$ is invertible, and sets
 $ix$ to the inverse of $x$.
 \bprog
 ? A = alginit(nfinit(y), [-1,1]);
 ? algisinv(A,[-1,1]~)
 %2 = 0
 ? algisinv(A,[1,2]~,&ix)
 %3 = 1
 ? ix
 %4 = [Mod(Mod(-1/3, y), x^2 + 1), Mod(Mod(2/3, y), x^2 + 1)]~
 @eprog
 
 Also accepts matrices with coefficients in \var{al}.

Function: algisramified
Class: basic
Section: algebras
C-Name: algisramified
Prototype: iGDG
Help: algisramified(al,{pl}): tests whether the central simple algebra al is
 ramified, i.e. not isomorphic to a matrix ring over its center. If pl is set,
 it should be a prime ideal of the center or an integer between 1 and r1+r2, and
 in that case tests whether al is locally ramified at the place pl instead.
Doc: Given a central simple algebra \var{al} output by \tet{alginit}, tests
 whether \var{al} is ramified, i.e. not isomorphic to a matrix algebra over its
 center. If \var{pl} is set, it should be a prime ideal of~$K$ or an integer
 between~$1$ and~$r_1+r_2$, and in that case tests whether \var{al} is locally
 ramified at the place \var{pl} instead.
 
 \bprog
 ? nf = nfinit(y^2-5);
 ? A = alginit(nf, [-1,y]);
 ? algisramified(A, 1)
 %3 = 1
 ? algisramified(A, 2)
 %4 = 0
 ? algisramified(A, idealprimedec(nf,2)[1])
 %5 = 1
 ? algisramified(A, idealprimedec(nf,5)[1])
 %6 = 0
 ? algisramified(A)
 %7 = 1
 @eprog

Function: algissemisimple
Class: basic
Section: algebras
C-Name: algissemisimple
Prototype: iG
Help: algissemisimple(al): test whether the algebra al is semisimple.
Doc: \var{al} being a table algebra output by \tet{algtableinit} or a central
 simple algebra output by \tet{alginit}, tests whether the algebra \var{al} is
 semisimple.
 \bprog
 ? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
 ? A = algtableinit(mt);
 ? algissemisimple(A)
 %3 = 0
 ? m_i=[0,-1,0,0;1,0,0,0;0,0,0,-1;0,0,1,0]; \\ quaternion algebra (-1,-1)
 ? m_j=[0,0,-1,0;0,0,0,1;1,0,0,0;0,-1,0,0];
 ? m_k=[0,0,0,-1;0,0,-1,0;0,1,0,0;1,0,0,0];
 ? mt = [matid(4), m_i, m_j, m_k];
 ? A = algtableinit(mt);
 ? algissemisimple(A)
 %9 = 1
 @eprog

Function: algissimple
Class: basic
Section: algebras
C-Name: algissimple
Prototype: iGD0,L,
Help: algissimple(al, {ss = 0}): test whether the algebra al is simple.
Doc: \var{al} being a table algebra output by \tet{algtableinit} or a central
 simple algebra output by \tet{alginit}, tests whether the algebra \var{al} is
 simple. If $\var{ss}=1$, assumes that the algebra~\var{al} is semisimple
 without testing it.
 \bprog
 ? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
 ? A = algtableinit(mt); \\ matrices [*,*; 0,*]
 ? algissimple(A)
 %3 = 0
 ? algissimple(A,1) \\ incorrectly assume that A is semisimple
 %4 = 1
 ? m_i=[0,-1,0,0;1,0,0,0;0,0,0,-1;0,0,1,0];
 ? m_j=[0,0,-1,0;0,0,0,1;1,0,0,0;0,-1,0,0];
 ? m_k=[0,0,0,-1;0,0,b,0;0,1,0,0;1,0,0,0];
 ? mt = [matid(4), m_i, m_j, m_k];
 ? A = algtableinit(mt); \\ quaternion algebra (-1,-1)
 ? algissimple(A)
 %10 = 1
 ? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
 ? A = algtableinit(mt,2); \\ direct product F_4 x F_2
 ? algissimple(A)
 %13 = 0
 @eprog

Function: algissplit
Class: basic
Section: algebras
C-Name: algissplit
Prototype: iGDG
Help: algissplit(al,{pl}): tests whether the central simple algebra al is
 split, i.e. isomorphic to a matrix ring over its center. If pl is set, it
 should be a prime ideal of the center or an integer between 1 and r1+r2, and in
 that case tests whether al is locally split at the place pl instead.
Doc: Given a central simple algebra \var{al} output by \tet{alginit}, tests
 whether~\var{al} is split, i.e. isomorphic to a matrix algebra over its center.
 If \var{pl} is set, it should be a prime ideal of~$K$ or an integer between~$1$
 and~$r_1+r_2$, and in that case tests whether \var{al} is locally split at the
 place \var{pl} instead.
 
 \bprog
 ? nf = nfinit(y^2-5);
 ? A = alginit(nf, [-1,y]);
 ? algissplit(A, 1)
 %3 = 0
 ? algissplit(A, 2)
 %4 = 1
 ? algissplit(A, idealprimedec(nf,2)[1])
 %5 = 0
 ? algissplit(A, idealprimedec(nf,5)[1])
 %6 = 1
 ? algissplit(A)
 %7 = 0
 @eprog

Function: alglatadd
Class: basic
Section: algebras
C-Name: alglatadd
Prototype: GGGD&
Help: alglatadd(al,lat1,lat2,{&ptinter}): the sum of the lattices lat1
 and lat2. If ptinter is present, set it to the intersection of the lattices.
Doc: Given an algebra \var{al} and two lattices \var{lat1} and \var{lat2}
 in~\var{al}, computes the sum~$lat1 + lat2$. If \var{ptinter} is
 present, set it to the intersection~$lat1 \cap lat2$.
 \bprog
 ? al = alginit(nfinit(y^2+7), [-1,-1]);
 ? lat1 = alglathnf(al,[1,1,0,0,0,0,0,0]~);
 ? lat2 = alglathnf(al,[1,0,1,0,0,0,0,0]~);
 ? latsum = alglatadd(al,lat1,lat2,&latinter);
 ? matdet(latsum[1])
 %5 = 4
 ? matdet(latinter[1])
 %6 = 64
 @eprog

Function: alglatcontains
Class: basic
Section: algebras
C-Name: alglatcontains
Prototype: iGGGD&
Help: alglatcontains(al,lat,x,{&ptc}): tests whether the lattice lat contains the
 element x. If ptc is present, sets it to the coordinates of x on the basis of
 lat.
Doc: Given an algebra \var{al}, a lattice \var{lat} and \var{x} in~\var{al},
 tests whether~$x\in lat$. If~\var{ptc} is present, sets it to the~\typ{COL} of
 coordinates of~$x$ in the basis of~\var{lat}.
 \bprog
 ? al = alginit(nfinit(y^2+7), [-1,-1]);
 ? a1 = [1,-1,0,1,2,0,1,2]~;
 ? lat1 = alglathnf(al,a1);
 ? alglatcontains(al,lat1,a1,&c)
 %4 = 1
 ? c
 %5 = [-1, -2, -1, 1, 2, 0, 1, 1]~
 @eprog

Function: alglatelement
Class: basic
Section: algebras
C-Name: alglatelement
Prototype: GGG
Help: alglatelement(al,lat,c): returns the element of al whose coordinates on
 the Z-basis of lat are c.
Doc: Given an algebra \var{al}, a lattice \var{lat} and a~\typ{COL}~\var{c},
 returns the element of~\var{al} whose coordinates on the \Z-basis of~\var{lat}
 are given by~\var{c}.
 \bprog
 ? al = alginit(nfinit(y^2+7), [-1,-1]);
 ? a1 = [1,-1,0,1,2,0,1,2]~;
 ? lat1 = alglathnf(al,a1);
 ? c = [1..8]~;
 ? elt = alglatelement(al,lat1,c);
 ? alglatcontains(al,lat1,elt,&c2)
 %6 = 1
 ? c==c2
 %7 = 1
 @eprog

Function: alglathnf
Class: basic
Section: algebras
C-Name: alglathnf
Prototype: GGD0,G,
Help: alglathnf(al,m,{d=0}): the lattice generated by the columns of m, assuming
 that this lattice contains d times the integral basis of al.
Doc: Given an algebra \var{al} and a matrix \var{m} with columns representing
 elements of \var{al}, returns the lattice $L$ generated by the columns of
 \var{m}. If provided, \var{d} must be a rational number such that $L$ contains
 \var{d} times the natural basis of~\var{al}. The argument \var{m} is also
 allowed to be a \typ{VEC} of \typ{MAT}, in which case \var{m} is replaced by
 the concatenation of the matrices, or a \typ{COL}, in which case \var{m} is
 replaced by its left multiplication table as an element of \var{al}.
 \bprog
 ? al = alginit(nfinit(y^2+7), [-1,-1]);
 ? a = [1,1,-1/2,1,1/3,-1,1,1]~;
 ? mt = algtomatrix(al,a,1);
 ? lat = alglathnf(al,mt);
 ? lat[2]
 %5 = 1/6
 @eprog

Function: alglatindex
Class: basic
Section: algebras
C-Name: alglatindex
Prototype: GGG
Help: alglatindex(al,lat1,lat2): the generalized index (lat2:lat1).
Doc: Given an algebra~\var{al} and two lattices~\var{lat1} and~\var{lat2}
 in~\var{al}, computes the generalized index of~\var{lat1} relative
 to~\var{lat2}, i.e.~$|lat2/lat1\cap lat2|/|lat1/lat1\cap lat2|$.
 \bprog
 ? al = alginit(nfinit(y^2+7), [-1,-1]);
 ? lat1 = alglathnf(al,[1,1,0,0,0,0,0,0]~);
 ? lat2 = alglathnf(al,[1,0,1,0,0,0,0,0]~);
 ? alglatindex(al,lat1,lat2)
 %4 = 1
 ? lat1==lat2
 %5 = 0
 @eprog

Function: alglatinter
Class: basic
Section: algebras
C-Name: alglatinter
Prototype: GGGD&
Help: alglatinter(al,lat1,lat2,{&ptsum}): the intersection of the lattices lat1
 and lat2. If ptsum is present, sets it to the sum of the lattices.
Doc: Given an algebra \var{al} and two lattices \var{lat1} and \var{lat2}
 in~\var{al}, computes the intersection~$lat1\cap lat2$. If \var{ptsum} is
 present, sets it to the sum~$lat1 + lat2$.
 \bprog
 ? al = alginit(nfinit(y^2+7), [-1,-1]);
 ? lat1 = alglathnf(al,[1,1,0,0,0,0,0,0]~);
 ? lat2 = alglathnf(al,[1,0,1,0,0,0,0,0]~);
 ? latinter = alglatinter(al,lat1,lat2,&latsum);
 ? matdet(latsum[1])
 %5 = 4
 ? matdet(latinter[1])
 %6 = 64
 @eprog

Function: alglatlefttransporter
Class: basic
Section: algebras
C-Name: alglatlefttransporter
Prototype: GGG
Help: alglatlefttransporter(al,lat1,lat2): the set of x in al such that x*lat1
 is contained in lat2.
Doc: Given an algebra \var{al} and two lattices \var{lat1} and \var{lat2}
 in~\var{al}, computes the left transporter from \var{lat1} to~\var{lat2}, i.e.
 the set of~$x\in al$ such that~$x\cdot lat1 \subset lat2$.
 \bprog
 ? al = alginit(nfinit(y^2+7), [-1,-1]);
 ? lat1 = alglathnf(al,[1,-1,0,1,2,0,5,2]~);
 ? lat2 = alglathnf(al,[0,1,-2,-1,0,0,3,1]~);
 ? tr = alglatlefttransporter(al,lat1,lat2);
 ? a = alglatelement(al,tr,[0,0,0,0,0,0,1,0]~);
 ? alglatsubset(al,alglatmul(al,a,lat1),lat2)
 %6 = 1
 ? alglatsubset(al,alglatmul(al,lat1,a),lat2)
 %7 = 0
 @eprog

Function: alglatmul
Class: basic
Section: algebras
C-Name: alglatmul
Prototype: GGG
Help: alglatmul(al,lat1,lat2): the lattice generated by the products of elements
 of lat1 and lat2.
Doc: Given an algebra \var{al} and two lattices \var{lat1} and \var{lat2}
 in~\var{al}, computes the lattice generated by the products of elements
 of~\var{lat1} and~\var{lat2}.
 One of \var{lat1} and \var{lat2} is also allowed to be an element of~\var{al};
 in this case, computes the product of the element and the lattice.
 \bprog
 ? al = alginit(nfinit(y^2+7), [-1,-1]);
 ? a1 = [1,-1,0,1,2,0,1,2]~;
 ? a2 = [0,1,2,-1,0,0,3,1]~;
 ? lat1 = alglathnf(al,a1);
 ? lat2 = alglathnf(al,a2);
 ? lat3 = alglatmul(al,lat1,lat2);
 ? matdet(lat3[1])
 %7 = 29584
 ? lat3 == alglathnf(al, algmul(al,a1,a2))
 %8 = 0
 ? lat3 == alglatmul(al, lat1, a2)
 %9 = 0
 ? lat3 == alglatmul(al, a1, lat2)
 %10 = 0
 @eprog

Function: alglatrighttransporter
Class: basic
Section: algebras
C-Name: alglatrighttransporter
Prototype: GGG
Help: alglatrighttransporter(al,lat1,lat2): the set of x in al such that lat1*x
 is contained in lat2.
Doc: Given an algebra \var{al} and two lattices \var{lat1} and \var{lat2}
 in~\var{al}, computes the right transporter from \var{lat1} to~\var{lat2}, i.e.
 the set of~$x\in al$ such that~$lat1\cdot x \subset lat2$.
 \bprog
 ? al = alginit(nfinit(y^2+7), [-1,-1]);
 ? lat1 = alglathnf(al,matdiagonal([1,3,7,1,2,8,5,2]));
 ? lat2 = alglathnf(al,matdiagonal([5,3,8,1,9,8,7,1]));
 ? tr = alglatrighttransporter(al,lat1,lat2);
 ? a = alglatelement(al,tr,[0,0,0,0,0,0,0,1]~);
 ? alglatsubset(al,alglatmul(al,lat1,a),lat2)
 %6 = 1
 ? alglatsubset(al,alglatmul(al,a,lat1),lat2)
 %7 = 0
 @eprog

Function: alglatsubset
Class: basic
Section: algebras
C-Name: alglatsubset
Prototype: iGGGD&
Help: alglatsubset(al,lat1,lat2,{&ptindex}): tests whether lat1 is contained in
 lat2 and if true and ptindex is present, sets it to the index (lat2:lat1).
Doc: Given an algebra~\var{al} and two lattices~\var{lat1} and~\var{lat2}
 in~\var{al}, tests whether~$lat1\subset lat2$. If it is true and \var{ptindex}
 is present, sets it to the index of~\var{lat1} in~\var{lat2}.
 \bprog
 ? al = alginit(nfinit(y^2+7), [-1,-1]);
 ? lat1 = alglathnf(al,[1,1,0,0,0,0,0,0]~);
 ? lat2 = alglathnf(al,[1,0,1,0,0,0,0,0]~);
 ? alglatsubset(al,lat1,lat2)
 %4 = 0
 ? latsum = alglatadd(al,lat1,lat2);
 ? alglatsubset(al,lat1,latsum,&index)
 %6 = 1
 ? index
 %7 = 4
 @eprog

Function: algmakeintegral
Class: basic
Section: algebras
C-Name: algmakeintegral
Prototype: GD0,L,
Help: algmakeintegral(mt,{maps=0}): computes an integral multiplication table
 for an isomorphic algebra.
Doc: \var{mt} being a multiplication table over $\Q$ in the same format as the
 input of \tet{algtableinit}, computes an integral multiplication table
 \var{mt2} for an isomorphic algebra. When $\var{maps}=1$, returns a \typ{VEC}
 $[\var{mt2},\var{S},\var{T}]$ where \var{S} and \var{T} are matrices
 respectively representing the map from the algebra defined by \var{mt} to the
 one defined by \var{mt2} and its inverse.
 \bprog
 ? mt = [matid(2),[0,-1/4;1,0]];
 ? algtableinit(mt);
   ***   at top-level: algtableinit(mt)
   ***                 ^----------------
   *** algtableinit: domain error in algtableinit: denominator(mt) != 1
 ? mt2 = algmakeintegral(mt);
 ? al = algtableinit(mt2);
 ? algisassociative(al)
 %4 = 1
 ? [mt2, S, T] = algmakeintegral(mt,1);
 ? S
 %6 =
 [1   0]
 
 [0 1/4]
 ? T
 %7 =
 [1 0]
 
 [0 4]
 ? vector(#mt, i, S * (mt * T[,i]) * T) == mt2
 %8 = 1
 @eprog

Function: algmul
Class: basic
Section: algebras
C-Name: algmul
Prototype: GGG
Help: algmul(al,x,y): element x*y in al.
Doc: Given two elements $x$ and $y$ in \var{al}, computes their product $xy$
 in the algebra~\var{al}.
 \bprog
 ? A = alginit(nfinit(y), [-1,-1]);
 ? algmul(A,[1,1,0,0]~,[0,0,2,1]~)
 %2 = [2, 3, 5, -4]~
 @eprog
 
 Also accepts matrices with coefficients in \var{al}.

Function: algmultable
Class: basic
Section: algebras
C-Name: algmultable
Prototype: mG
Help: algmultable(al): multiplication table of al over its prime subfield.
Doc: 
 returns a multiplication table of \var{al} over its
 prime subfield ($\Q$ or $\F_p$), as a \typ{VEC} of \typ{MAT}: the left
 multiplication tables of basis elements. If \var{al} was output by
 \tet{algtableinit}, returns the multiplication table used to define \var{al}.
 If \var{al} was output by \tet{alginit}, returns the multiplication table of
 the order~${\cal O}_0$ stored in \var{al}.
 \bprog
 ? A = alginit(nfinit(y), [-1,-1]);
 ? M = algmultable(A);
 ? #M
 %3 = 4
 ? M[1]  \\ multiplication by e_1 = 1
 %4 =
 [1 0 0 0]
 
 [0 1 0 0]
 
 [0 0 1 0]
 
 [0 0 0 1]
 
 ? M[2]
 %5 =
 [0 -1  1  0]
 
 [1  0  1  1]
 
 [0  0  1  1]
 
 [0  0 -2 -1]
 @eprog

Function: algneg
Class: basic
Section: algebras
C-Name: algneg
Prototype: GG
Help: algneg(al,x): element -x in al.
Doc: Given an element $x$ in \var{al}, computes its opposite $-x$ in the
 algebra \var{al}.
 \bprog
 ? A = alginit(nfinit(y), [-1,-1]);
 ? algneg(A,[1,1,0,0]~)
 %2 = [-1, -1, 0, 0]~
 @eprog
 
 Also accepts matrices with coefficients in \var{al}.

Function: algnorm
Class: basic
Section: algebras
C-Name: algnorm
Prototype: GGD0,L,
Help: algnorm(al,x,{abs=0}): (reduced) norm of x.
Doc: Given an element \var{x} in \var{al}, computes its norm. If \var{al} is
 a table algebra output by \tet{algtableinit} or if $abs=1$, returns the
 absolute norm of \var{x}, which is an element of $\F_p$ of~$\Q$; if \var{al} is
 a central simple algebra output by \tet{alginit} and $abs=0$ (default), returns
 the reduced norm of \var{x}, which is an element of the center of \var{al}.
 \bprog
 ? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
 ? A = algtableinit(mt,19);
 ? algnorm(A,[0,-2,3]~)
 %3 = 18
 ? nf = nfinit(y^2-5);
 ? B = alginit(nf,[-1,y]);
 ? b = [x,1]~;
 ? n = algnorm(B,b)
 %7 = Mod(-y + 1, y^2 - 5)
 ? algnorm(B,b,1)
 %8 = 16
 ? nfeltnorm(nf,n)^algdegree(B)
 %9 = 16
 @eprog
 
 Also accepts a square matrix with coefficients in \var{al}.

Function: algpoleval
Class: basic
Section: algebras
C-Name: algpoleval
Prototype: GGG
Help: algpoleval(al,T,b): T in K[X] evaluate T(b) in al.
Doc: Given an element $b$ in \var{al} and a polynomial $T$ in $K[X]$,
 computes~$T(b)$ in~\var{al}. Also accepts as input a \typ{VEC}~$[b,mb]$
 where~$mb$ is the left multiplication table of~$b$.
 
 \bprog
 ? nf = nfinit(y^2-5);
 ? al = alginit(nf,[y,-1]);
 ? b = [1..8]~;
 ? pol = algcharpoly(al,b,,1);
 ? algpoleval(al,pol,b)==0
 %5 = 1
 ? mb = algtomatrix(al,b,1);
 ? algpoleval(al,pol,[b,mb])==0
 %7 = 1
 @eprog

Function: algpow
Class: basic
Section: algebras
C-Name: algpow
Prototype: GGG
Help: algpow(al,x,n): element x^n in al.
Doc: Given an element $x$ in \var{al} and an integer $n$, computes the
 power $x^n$ in the algebra \var{al}.
 \bprog
 ? A = alginit(nfinit(y), [-1,-1]);
 ? algpow(A,[1,1,0,0]~,7)
 %2 = [8, -8, 0, 0]~
 @eprog
 
 Also accepts a square matrix with coefficients in \var{al}.

Function: algprimesubalg
Class: basic
Section: algebras
C-Name: algprimesubalg
Prototype: G
Help: algprimesubalg(al): prime subalgebra of the positive characteristic,
 semisimple algebra al.
Doc: \var{al} being the output of \tet{algtableinit} representing a semisimple
 algebra of positive characteristic, returns a basis of the prime subalgebra
 of~\var{al}. The prime subalgebra of~\var{al} is the subalgebra fixed by the
 Frobenius automorphism of the center of \var{al}. It is abstractly isomorphic
 to a product of copies of $\F_p$.
 \bprog
 ? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
 ? A = algtableinit(mt,2);
 ? algprimesubalg(A)
 %3 =
 [1 0]
 
 [0 1]
 
 [0 0]
 @eprog

Function: algquotient
Class: basic
Section: algebras
C-Name: alg_quotient
Prototype: GGD0,L,
Help: algquotient(al,I,{maps=0}): quotient of the algebra al by the two-sided
 ideal I.
Doc: \var{al} being a table algebra output by \tet{algtableinit} and \var{I}
 being a basis of a two-sided ideal of \var{al} represented by a matrix,
 returns the quotient $\var{al}/\var{I}$. When $\var{maps}=1$, returns a
 \typ{VEC} $[\var{al}/\var{I},\var{proj},\var{lift}]$ where \var{proj} and
 \var{lift} are matrices respectively representing the projection map and a
 section of it.
 \bprog
 ? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
 ? A = algtableinit(mt,2);
 ? AQ = algquotient(A,[0;1;0]);
 ? algdim(AQ)
 %4 = 2
 @eprog

Function: algradical
Class: basic
Section: algebras
C-Name: algradical
Prototype: G
Help: algradical(al): Jacobson radical of the algebra al.
Doc: \var{al} being a table algebra output by \tet{algtableinit}, returns a
 basis of the Jacobson radical of the algebra \var{al} over its prime field
 ($\Q$ or $\F_p$).
 
 Here is an example with $A = \Q[x]/(x^2)$, with the basis~$(1,x)$:
 \bprog
 ? mt = [matid(2),[0,0;1,0]];
 ? A = algtableinit(mt);
 ? algradical(A) \\ = (x)
 %3 =
 [0]
 
 [1]
 @eprog
 
 Another one with $2\times 2$ upper triangular matrices over $\Q$, with basis
 $I_2$, $a = \kbd{[0,1;0,0]}$ and $b = \kbd{[0,0;0,1]}$, such that $a^2 =
 0$, $ab = a$, $ba = 0$, $b^2 = b$:
 \bprog
 ? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
 ? A = algtableinit(mt);
 ? algradical(A) \\ = (a)
 %6 =
 [0]
 
 [1]
 
 [0]
 @eprog

Function: algramifiedplaces
Class: basic
Section: algebras
C-Name: algramifiedplaces
Prototype: G
Help: algramifiedplaces(al): vector of the places of the center of al that
 ramify in al. Each place is described as an integer between 1 and r1 or as a
 prime ideal.
Doc: Given a central simple algebra \var{al} output by \tet{alginit}, returns a
 \typ{VEC} containing the list of places of the center of \var{al} that are
 ramified in \var{al}. Each place is described as an integer between~$1$
 and~$r_1$ or as a prime ideal.
 
 \bprog
 ? nf = nfinit(y^2-5);
 ? A = alginit(nf, [-1,y]);
 ? algramifiedplaces(A)
 %3 = [1, [2, [2, 0]~, 1, 2, 1]]
 @eprog

Function: algrandom
Class: basic
Section: algebras
C-Name: algrandom
Prototype: GG
Help: algrandom(al,b): random element in al with coefficients in [-b,b].
Doc: Given an algebra \var{al} and an integer \var{b}, returns a random
 element in \var{al} with coefficients in~$[-b,b]$.

Function: algrelmultable
Class: basic
Section: algebras
C-Name: algrelmultable
Prototype: mG
Help: algrelmultable(al): multiplication table of the central simple
 algebra al over its center.
Doc: Given a central simple algebra \var{al} output by \tet{alginit} defined by a multiplication table over its center (a number field), returns this multiplication table.
 \bprog
 ? nf = nfinit(y^3-5); a = y; b = y^2;
 ? {m_i = [0,a,0,0;
           1,0,0,0;
           0,0,0,a;
           0,0,1,0];}
 ? {m_j = [0, 0,b, 0;
           0, 0,0,-b;
           1, 0,0, 0;
           0,-1,0, 0];}
 ? {m_k = [0, 0,0,-a*b;
           0, 0,b,   0;
           0,-a,0,   0;
           1, 0,0,   0];}
 ? mt = [matid(4), m_i, m_j, m_k];
 ? A = alginit(nf,mt,'x);
 ? M = algrelmultable(A);
 ? M[2] == m_i
 %8 = 1
 ? M[3] == m_j
 %9 = 1
 ? M[4] == m_k
 %10 = 1
 @eprog

Function: algsimpledec
Class: basic
Section: algebras
C-Name: algsimpledec
Prototype: GD0,L,
Help: algsimpledec(al,{maps=0}): [J,dec] where J is the Jacobson radical of al
 and dec is the decomposition into simple algebras of the semisimple algebra
 al/J.
Doc: \var{al} being the output of \tet{algtableinit}, returns a \typ{VEC}
 $[J,[\var{al}_1,\var{al}_2,\dots,\var{al}_n]]$ where $J$ is a basis of the
 Jacobson radical of \var{al} and~$\var{al}/J$ is isomorphic to the direct
 product of the simple algebras~$\var{al}_i$. When $\var{maps}=1$,
 each~$\var{al}_i$ is replaced with a \typ{VEC}
 $[\var{al}_i,\var{proj}_i,\var{lift}_i]$ where $\var{proj}_i$ and~$\var{lift}_i$
 are matrices respectively representing the projection map~$\var{al} \to
 \var{al}_i$ and a section of it. Modulo~$J$, the images of the $\var{lift}_i$
 form a direct sum in~$\var{al}/J$, so that the images of~$1\in\var{al}_i$
 under~$\var{lift}_i$ are central primitive idempotents of~$\var{al}/J$. The
 factors are sorted by increasing dimension, then increasing dimension of the
 center. This ensures that the ordering of the isomorphism classes of the
 factors is deterministic over finite fields, but not necessarily over~$\Q$.

Function: algsplit
Class: basic
Section: algebras
C-Name: algsplit
Prototype: GDn
Help: algsplit(al,{v='x}): computes an isomorphism between al and M_d(F_q).
Doc: If \var{al} is a table algebra over~$\F_p$ output by \tet{algtableinit}
 that represents a simple algebra, computes an isomorphism between \var{al} and
 a matrix algebra~$M_d(\F_{p^n})$ where~$N = nd^2$ is the dimension of~\var{al}.
 Returns a \typ{VEC}~$[map,mapi]$, where:
 
 \item \var{map} is a \typ{VEC} of~$N$ matrices of size~$d\times d$ with
 \typ{FFELT} coefficients using the variable~\var{v}, representing the image of
 the basis of~\var{al} under the isomorphism.
 
 \item \var{mapi} is an~$N\times N$ matrix with \typ{INT} coefficients,
  representing the image in \var{al} by the inverse isomorphism of the
  basis~$(b_i)$ of~$M_d(\F_p[\alpha])$ (where~$\alpha$ has degree~$n$
  over~$\F_p$) defined as follows:
  let~$E_{i,j}$ be the matrix having all coefficients~$0$ except the~$(i,j)$-th
  coefficient equal to~$1$, and define
  $$b_{i_3+n(i_2+di_1)+1} = E_{i_1+1,i_2+1} \alpha^{i_3},$$
  where~$0\le i_1,i_2<d$ and~$0\le i_3<n$.
 
 Example:
 \bprog
 ? al0 = alginit(nfinit(y^2+7), [-1,-1]);
 ? al = algtableinit(algmultable(al0), 3); \\ isomorphic to M_2(F_9)
 ? [map,mapi] = algsplit(al, 'a);
 ? x = [1,2,1,0,0,0,0,0]~; fx = map*x
 %4 =
 [2*a 0]
 
 [  0 2]
 ? y = [0,0,0,0,1,0,0,1]~; fy = map*y
 %5 =
 [1   2*a]
 
 [2 a + 2]
 ? map*algmul(al,x,y) == fx*fy
 %6 = 1
 ? map*mapi[,6]
 %7 =
 [0 0]
 
 [a 0]
 @eprog
 
 \misctitle{Warning} If~\var{al} is not simple, \kbd{algsplit(al)} can trigger
 an error, but can also run into an infinite loop. Example:
 \bprog
 ? al = alginit(nfinit(y),[-1,-1]); \\ ramified at 2
 ? al2 = algtableinit(algmultable(al),2); \\ maximal order modulo 2
 ? algsplit(al2); \\ not semisimple, infinite loop
 @eprog

Function: algsplittingdata
Class: basic
Section: algebras
C-Name: algsplittingdata
Prototype: mG
Help: algsplittingdata(al): data stored in the central simple algebra al to
 compute a splitting of al over an extension.
Doc: Given a central simple algebra \var{al} output by \tet{alginit} defined
 by a multiplication table over its center~$K$ (a number field), returns data
 stored to compute a splitting of \var{al} over an extension. This data is a
 \typ{VEC} \kbd{[t,Lbas,Lbasinv]} with $3$ components:
 
  \item an element $t$ of \var{al} such that $L=K(t)$ is a maximal subfield
 of \var{al};
 
  \item a matrix \kbd{Lbas} expressing a $L$-basis of \var{al} (given an
 $L$-vector space structure by multiplication on the right) on the integral
 basis of \var{al};
 
  \item a matrix \kbd{Lbasinv} expressing the integral basis of \var{al} on
 the previous $L$-basis.
 
 \bprog
 ? nf = nfinit(y^3-5); a = y; b = y^2;
 ? {m_i = [0,a,0,0;
           1,0,0,0;
           0,0,0,a;
           0,0,1,0];}
 ? {m_j = [0, 0,b, 0;
           0, 0,0,-b;
           1, 0,0, 0;
           0,-1,0, 0];}
 ? {m_k = [0, 0,0,-a*b;
           0, 0,b,   0;
           0,-a,0,   0;
           1, 0,0,   0];}
 ? mt = [matid(4), m_i, m_j, m_k];
 ? A = alginit(nf,mt,'x);
 ? [t,Lb,Lbi] = algsplittingdata(A);
 ? t
 %8 = [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]~;
 ? matsize(Lb)
 %9 = [12, 2]
 ? matsize(Lbi)
 %10 = [2, 12]
 @eprog

Function: algsplittingfield
Class: basic
Section: algebras
C-Name: algsplittingfield
Prototype: mG
Help: algsplittingfield(al): the stored splitting field of the central simple
 algebra al.
Doc: Given a central simple algebra \var{al} output by \tet{alginit}, returns
 an \kbd{rnf} structure: the splitting field of \var{al} that is stored in
 \var{al}, as a relative extension of the center.
 \bprog
 nf = nfinit(y^3-5);
 a = y; b = y^2;
 {m_i = [0,a,0,0;
        1,0,0,0;
        0,0,0,a;
        0,0,1,0];}
 {m_j = [0, 0,b, 0;
        0, 0,0,-b;
        1, 0,0, 0;
        0,-1,0, 0];}
 {m_k = [0, 0,0,-a*b;
        0, 0,b,   0;
        0,-a,0,   0;
        1, 0,0,   0];}
 mt = [matid(4), m_i, m_j, m_k];
 A = alginit(nf,mt,'x);
 algsplittingfield(A).pol
 %8 = x^2 - y
 @eprog

Function: algsqr
Class: basic
Section: algebras
C-Name: algsqr
Prototype: GG
Help: algsqr(al,x): element x^2 in al.
Doc: Given an element $x$ in \var{al}, computes its square $x^2$ in the
 algebra \var{al}.
 \bprog
 ? A = alginit(nfinit(y), [-1,-1]);
 ? algsqr(A,[1,0,2,0]~)
 %2 = [-3, 0, 4, 0]~
 @eprog
 
 Also accepts a square matrix with coefficients in \var{al}.

Function: algsub
Class: basic
Section: algebras
C-Name: algsub
Prototype: GGG
Help: algsub(al,x,y): element x-y in al.
Doc: Given two elements $x$ and $y$ in \var{al}, computes their difference
 $x-y$ in the algebra \var{al}.
 \bprog
 ? A = alginit(nfinit(y), [-1,-1]);
 ? algsub(A,[1,1,0,0]~,[1,0,1,0]~)
 %2 = [0, 1, -1, 0]~
 @eprog
 
 Also accepts matrices with coefficients in \var{al}.

Function: algsubalg
Class: basic
Section: algebras
C-Name: algsubalg
Prototype: GG
Help: algsubalg(al,B): subalgebra of al with basis B.
Doc: \var{al} being a table algebra output by \tet{algtableinit} and \var{B}
 being a basis of a subalgebra of~\var{al} represented by a matrix, computes an
 algebra~\var{al2} isomorphic to \var{B}.
 
 Returns $[\var{al2},\var{B2}]$ where \var{B2} is a possibly different basis of
 the subalgebra \var{al2}, with respect to which the multiplication table of
 \var{al2} is defined.
 \bprog
 ? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
 ? A = algtableinit(mt,2);
 ? B = algsubalg(A,[1,0; 0,0; 0,1]);
 ? algdim(A)
 %4 = 3
 ? algdim(B[1])
 %5 = 2
 ? m = matcompanion(x^4+1);
 ? mt = [m^i | i <- [0..3]];
 ? al = algtableinit(mt);
 ? B = [1,0;0,0;0,1/2;0,0];
 ? al2 = algsubalg(al,B);
 ? algdim(al2[1])
 ? al2[2]
 %13 =
 [1 0]
 
 [0 0]
 
 [0 1]
 
 [0 0]
 @eprog

Function: algtableinit
Class: basic
Section: algebras
C-Name: algtableinit
Prototype: GDG
Help: algtableinit(mt, {p=0}): initializes the associative algebra
 over Q (resp. Fp) defined by the multiplication table mt.
Doc: initializes the associative algebra over $K = \Q$ ($p$ omitted) or $\F_p$
 defined by the multiplication table \var{mt}.
 As a $K$-vector space, the algebra is generated by a basis
 $(e_1 = 1, e_2, \dots, e_n)$; the table is given as a \typ{VEC} of $n$ matrices in
 $M_n(K)$, giving the left multiplication by the basis elements $e_i$, in the
 given basis.
 Assumes that $e_1=1$, that $K e_1\oplus \dots\oplus K e_n]$ describes an
 associative algebra over $K$, and in the case $K=\Q$ that the multiplication
 table is integral. If the algebra is already known to be central
 and simple, then the case $K = \F_p$ is useless, and one should use
 \tet{alginit} directly.
 
 The point of this function is to input a finite dimensional $K$-algebra, so
 as to later compute its radical, then to split the quotient algebra as a
 product of simple algebras over $K$.
 
 The pari object representing such an algebra $A$ is a \typ{VEC} with the
 following data:
 
  \item The characteristic of $A$, accessed with \kbd{algchar}.
 
  \item The multiplication table of $A$, accessed with \kbd{algmultable}.
 
  \item The traces of the elements of the basis.
 
 A simple example: the $2\times 2$ upper triangular matrices over $\Q$,
 generated by $I_2$, $a = \kbd{[0,1;0,0]}$ and $b = \kbd{[0,0;0,1]}$,
 such that $a^2 = 0$, $ab = a$, $ba = 0$, $b^2 = b$:
 \bprog
 ? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
 ? A = algtableinit(mt);
 ? algradical(A) \\ = (a)
 %6 =
 [0]
 
 [1]
 
 [0]
 ? algcenter(A) \\ = (I_2)
 %7 =
 [1]
 
 [0]
 
 [0]
 @eprog

Function: algtensor
Class: basic
Section: algebras
C-Name: algtensor
Prototype: GGD1,L,
Help: algtensor(al1,al2,{maxord=1}): tensor product of al1 and al2.
Doc: Given two algebras \var{al1} and \var{al2}, computes their tensor
 product. Computes a maximal order by default. Prevent this computation by
 setting $\var{maxord}=0$.
 
 Currently only implemented for cyclic algebras of coprime degree over the same
 center~$K$, and the tensor product is over~$K$.

Function: algtomatrix
Class: basic
Section: algebras
C-Name: algtomatrix
Prototype: GGD0,L,
Help: algtomatrix(al,x,{abs=1}): left multiplication table of x (table algebra
 or abs=1) or image of x under a splitting of al (CSA and abs=0).
Doc: Given an element \var{x} in \var{al}, returns the image of \var{x} under a
 homomorphism to a matrix algebra. If \var{al} is a table algebra output by
 \kbd{algtableinit} or if~$abs=1$, returns the left multiplication table on the
 integral basis; if \var{al} is a central simple algebra and~$abs=0$,
 returns~$\phi(x)$ where~$\phi : A\otimes_K L \to M_d(L)$ (where $d$ is the
 degree of the algebra and $L$ is an extension of $L$ with~$[L:K]=d$) is an
 isomorphism stored in~\var{al}. Also accepts a square matrix with coefficients
 in~\var{al}.
 
 \bprog
 ? A = alginit(nfinit(y), [-1,-1]);
 ? algtomatrix(A,[0,0,0,2]~)
 %2 =
 [Mod(x + 1, x^2 + 1) Mod(Mod(1, y)*x + Mod(-1, y), x^2 + 1)]
 
 [Mod(x + 1, x^2 + 1)                   Mod(-x + 1, x^2 + 1)]
 ? algtomatrix(A,[0,1,0,0]~,1)
 %2 =
 [0 -1  1  0]
 
 [1  0  1  1]
 
 [0  0  1  1]
 
 [0  0 -2 -1]
 ? algtomatrix(A,[0,x]~,1)
 %3 =
 [-1  0 0 -1]
 
 [-1  0 1  0]
 
 [-1 -1 0 -1]
 
 [ 2  0 0  1]
 @eprog
 
 Also accepts matrices with coefficients in \var{al}.

Function: algtrace
Class: basic
Section: algebras
C-Name: algtrace
Prototype: GGD0,L,
Help: algtrace(al,x,{abs=0}): (reduced) trace of x.
Doc: Given an element \var{x} in \var{al}, computes its trace. If \var{al} is
 a table algebra output by \tet{algtableinit} or if $abs=1$, returns the
 absolute trace of \var{x}, which is an element of $\F_p$ or~$\Q$; if \var{al}
 is the output of \tet{alginit} and $abs=0$ (default), returns the reduced trace
 of \var{x}, which is an element of the center of \var{al}.
 \bprog
 ? A = alginit(nfinit(y), [-1,-1]);
 ? algtrace(A,[5,0,0,1]~)
 %2 = 11
 ? algtrace(A,[5,0,0,1]~,1)
 %3 = 22
 ? nf = nfinit(y^2-5);
 ? A = alginit(nf,[-1,y]);
 ? a = [1+x+y,2*y]~*Mod(1,y^2-5)*Mod(1,x^2+1);
 ? t = algtrace(A,a)
 %7 = Mod(2*y + 2, y^2 - 5)
 ? algtrace(A,a,1)
 %8 = 8
 ? algdegree(A)*nfelttrace(nf,t)
 %9 = 8
 @eprog
 
 Also accepts a square matrix with coefficients in \var{al}.

Function: algtype
Class: basic
Section: algebras
C-Name: algtype
Prototype: lG
Help: algtype(al): type of the algebra al.
Doc: Given an algebra \var{al} output by \tet{alginit} or by \tet{algtableinit}, returns an integer indicating the type of algebra:
 
 \item $0$: not a valid algebra.
 
 \item $1$: table algebra output by \tet{algtableinit}.
 
 \item $2$: central simple algebra output by \tet{alginit} and represented by
 a multiplication table over its center.
 
 \item $3$: central simple algebra output by \tet{alginit} and represented by
 a cyclic algebra.
 \bprog
 ? algtype([])
 %1 = 0
 ? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
 ? A = algtableinit(mt,2);
 ? algtype(A)
 %4 = 1
 ? nf = nfinit(y^3-5);
 ?  a = y; b = y^2;
 ?  {m_i = [0,a,0,0;
            1,0,0,0;
            0,0,0,a;
            0,0,1,0];}
 ?  {m_j = [0, 0,b, 0;
            0, 0,0,-b;
            1, 0,0, 0;
            0,-1,0, 0];}
 ?  {m_k = [0, 0,0,-a*b;
            0, 0,b,   0;
            0,-a,0,   0;
            1, 0,0,   0];}
 ?  mt = [matid(4), m_i, m_j, m_k];
 ?  A = alginit(nf,mt,'x);
 ? algtype(A)
 %12 = 2
 ? A = alginit(nfinit(y), [-1,-1]);
 ? algtype(A)
 %14 = 3
 @eprog

Function: alias
Class: basic
Section: programming/specific
C-Name: alias0
Prototype: vrr
Help: alias(newsym,sym): defines the symbol newsym as an alias for the symbol
 sym.
Doc: defines the symbol \var{newsym} as an alias for the symbol \var{sym}:
 \bprog
 ? alias("det", "matdet");
 ? det([1,2;3,4])
 %1 = -2
 @eprog\noindent
 You are not restricted to ordinary functions, as in the above example:
 to alias (from/to) member functions, prefix them with `\kbd{\_.}';
 to alias operators, use their internal name, obtained by writing
 \kbd{\_} in lieu of the operators argument: for instance, \kbd{\_!} and
 \kbd{!\_} are the internal names of the factorial and the
 logical negation, respectively.
 \bprog
 ? alias("mod", "_.mod");
 ? alias("add", "_+_");
 ? alias("_.sin", "sin");
 ? mod(Mod(x,x^4+1))
 %2 = x^4 + 1
 ? add(4,6)
 %3 = 10
 ? Pi.sin
 %4 = 0.E-37
 @eprog
 Alias expansion is performed directly by the internal GP compiler.
 Note that since alias is performed at compilation-time, it does not
 require any run-time processing, however it only affects GP code
 compiled \emph{after} the alias command is evaluated. A slower but more
 flexible alternative is to use variables. Compare
 \bprog
 ? fun = sin;
 ? g(a,b) = intnum(t=a,b,fun(t));
 ? g(0, Pi)
 %3 = 2.0000000000000000000000000000000000000
 ? fun = cos;
 ? g(0, Pi)
 %5 = 1.8830410776607851098 E-39
 @eprog\noindent
 with
 \bprog
 ? alias(fun, sin);
 ? g(a,b) = intnum(t=a,b,fun(t));
 ? g(0,Pi)
 %2 = 2.0000000000000000000000000000000000000
 ? alias(fun, cos);  \\ Oops. Does not affect *previous* definition!
 ? g(0,Pi)
 %3 = 2.0000000000000000000000000000000000000
 ? g(a,b) = intnum(t=a,b,fun(t)); \\ Redefine, taking new alias into account
 ? g(0,Pi)
 %5 = 1.8830410776607851098 E-39
 @eprog
 
 A sample alias file \kbd{misc/gpalias} is provided with
 the standard distribution.

Function: allocatemem
Class: basic
Section: programming/specific
C-Name: gp_allocatemem
Prototype: vDG
Help: allocatemem({s=0}): allocates a new stack of s bytes. doubles the
 stack if s is omitted.
Doc: this special operation changes the stack size \emph{after}
 initialization. The argument $s$ must be a nonnegative integer.
 If $s > 0$, a new stack of at least $s$ bytes is allocated. We may allocate
 more than $s$ bytes if $s$ is way too small, or for alignment reasons: the
 current formula is $\max(16*\ceil{s/16}, 500032)$ bytes.
 
 If $s=0$, the size of the new stack is twice the size of the old one.
 
 This command is much more useful if \tet{parisizemax} is nonzero, and we
 describe this case first. With \kbd{parisizemax} enabled, there are three
 sizes of interest:
 
 \item a virtual stack size, \tet{parisizemax}, which is an absolute upper
 limit for the stack size; this is set by \kbd{default(parisizemax, ...)}.
 
 \item the desired typical stack size, \tet{parisize}, that will grow as
 needed, up to \tet{parisizemax}; this is set by \kbd{default(parisize, ...)}.
 
 \item the current stack size, which is less that \kbd{parisizemax},
 typically equal to \kbd{parisize} but possibly larger and increasing
 dynamically as needed; \kbd{allocatemem} allows to change that one
 explicitly.
 
 The \kbd{allocatemem} command forces stack
 usage to increase temporarily (up to \kbd{parisizemax} of course); for
 instance if you notice using \kbd{\bs gm2} that we seem to collect garbage a
 lot, e.g.
 \bprog
 ? \gm2
   debugmem = 2
 ? default(parisize,"32M")
  ***   Warning: new stack size = 32000000 (30.518 Mbytes).
 ? bnfinit('x^2+10^30-1)
  *** bnfinit: collecting garbage in hnffinal, i = 1.
  *** bnfinit: collecting garbage in hnffinal, i = 2.
  *** bnfinit: collecting garbage in hnffinal, i = 3.
 @eprog\noindent and so on for hundred of lines. Then, provided the
 \tet{breakloop} default is set, you can interrupt the computation, type
 \kbd{allocatemem(100*10\pow6)} at the break loop prompt, then let the
 computation go on by typing \kbd{<Enter>}. Back at the \kbd{gp} prompt,
 the desired stack size of \kbd{parisize} is restored. Note that changing either
 \kbd{parisize} or \kbd{parisizemax} at the break loop prompt would interrupt
 the computation, contrary to the above.
 
 In most cases, \kbd{parisize} will increase automatically (up to
 \kbd{parisizemax}) and there is no need to perform the above maneuvers.
 But that the garbage collector is sufficiently efficient that
 a given computation can still run without increasing the stack size,
 albeit very slowly due to the frequent garbage collections.
 
 \misctitle{Deprecated: when \kbd{parisizemax} is unset}
 This is currently still the default behavior in order not to break backward
 compatibility. The rest of this section documents the
 behavior of \kbd{allocatemem} in that (deprecated) situation: it becomes a
 synonym for \kbd{default(parisize,...)}. In that case, there is no
 notion of a virtual stack, and the stack size is always equal to
 \kbd{parisize}. If more memory is needed, the PARI stack overflows, aborting
 the computation.
 
 Thus, increasing \kbd{parisize} via \kbd{allocatemem} or
 \kbd{default(parisize,...)} before a big computation is important.
 Unfortunately, either must be typed at the \kbd{gp} prompt in
 interactive usage, or left by itself at the start of batch files.
 They cannot be used meaningfully in loop-like constructs, or as part of a
 larger expression sequence, e.g
 \bprog
    allocatemem(); x = 1;   \\@com This will not set \kbd{x}!
 @eprog\noindent
 In fact, all loops are immediately exited, user functions terminated, and
 the rest of the sequence following \kbd{allocatemem()} is silently
 discarded, as well as all pending sequences of instructions. We just go on
 reading the next instruction sequence from the file we are in (or from the
 user). In particular, we have the following possibly unexpected behavior: in
 \bprog
    read("file.gp"); x = 1
 @eprog\noindent were \kbd{file.gp} contains an \kbd{allocatemem} statement,
 the \kbd{x = 1} is never executed, since all pending instructions in the
 current sequence are discarded.
 
 The reason for these unfortunate side-effects is that, with
 \kbd{parisizemax} disabled, increasing the stack size physically
 moves the stack, so temporary objects created during the current expression
 evaluation are not correct anymore. (In particular byte-compiled expressions,
 which are allocated on the stack.) To avoid accessing obsolete pointers to
 the old stack, this routine ends by a \kbd{longjmp}.

Function: apply
Class: basic
Section: programming/specific
C-Name: apply0
Prototype: GG
Help: apply(f, A): apply function f to each entry in A.
Wrapper: (G)
Description: 
  (closure,gen):gen    genapply(${1 cookie}, ${1 wrapper}, $2)
Doc: Apply the \typ{CLOSURE} \kbd{f} to the entries of \kbd{A}.
 
 \item If \kbd{A} is a scalar, return \kbd{f(A)}.
 
 \item If \kbd{A} is a polynomial or power series $\sum a_i x^i$ ($+
 O(x^N)$), apply \kbd{f} on all coefficients and return $\sum f(a_i) x^i$ ($+
 O(x^N)$).
 
 \item If \kbd{A} is a vector or list $[a_1,\dots,a_n]$, return the vector
 or list $[f(a_1),\dots, f(a_n)]$. If \kbd{A} is a matrix, return the matrix
 whose entries are the $f(\kbd{A[i,j]})$.
 
 \bprog
 ? apply(x->x^2, [1,2,3,4])
 %1 = [1, 4, 9, 16]
 ? apply(x->x^2, [1,2;3,4])
 %2 =
 [1 4]
 
 [9 16]
 ? apply(x->x^2, 4*x^2 + 3*x+ 2)
 %3 = 16*x^2 + 9*x + 4
 ? apply(sign, 2 - 3* x + 4*x^2 + O(x^3))
 %4 = 1 - x + x^2 + O(x^3)
 @eprog\noindent Note that many functions already act componentwise on
 vectors or matrices, but they almost never act on lists; in this case,
 \kbd{apply} is a good solution:
 \bprog
 ? L = List([Mod(1,3), Mod(2,4)]);
 ? lift(L)
   ***   at top-level: lift(L)
   ***                 ^-------
   *** lift: incorrect type in lift.
 ? apply(lift, L);
 %2 = List([1, 2])
 @eprog
 \misctitle{Remark} For $v$ a \typ{VEC}, \typ{COL}, \typ{VECSMALL},
 \typ{LIST} or \typ{MAT}, the alternative set-notations
 \bprog
 [g(x) | x <- v, f(x)]
 [x | x <- v, f(x)]
 [g(x) | x <- v]
 @eprog\noindent
 are available as shortcuts for
 \bprog
 apply(g, select(f, Vec(v)))
 select(f, Vec(v))
 apply(g, Vec(v))
 @eprog\noindent respectively:
 \bprog
 ? L = List([Mod(1,3), Mod(2,4)]);
 ? [ lift(x) | x<-L ]
 %2 = [1, 2]
 @eprog
 
 \synt{genapply}{void *E, GEN (*fun)(void*,GEN), GEN a}.

Function: arg
Class: basic
Section: transcendental
C-Name: garg
Prototype: Gp
Help: arg(x): argument of x, such that -pi<arg(x)<=pi.
Doc: argument of the complex number $x$, such that $-\pi < \arg(x) \le \pi$.

Function: arity
Class: basic
Section: programming/specific
C-Name: arity0
Prototype: G
Help: arity(C): return the arity of the closure C.
Doc: return the arity of the closure $C$, i.e., the number of its arguments.
 \bprog
 ? f1(x,y=0)=x+y;
 ? arity(f1)
 %1 = 2
 ? f2(t,s[..])=print(t,":",s);
 ? arity(f2)
 %2 = 2
 @eprog\noindent Note that a variadic argument, such as $s$ in \kbd{f2} above,
 is counted as a single argument.

Function: asin
Class: basic
Section: transcendental
C-Name: gasin
Prototype: Gp
Help: asin(x): arc sine of x.
Doc: principal branch of $\sin^{-1}(x) = -i \log(ix + \sqrt{1 - x^2})$.
 In particular, $\Re(\text{asin}(x))\in [-\pi/2,\pi/2]$ and if $x\in \R$ and
 $|x|>1$ then $\text{asin}(x)$ is complex. The branch cut is in two pieces:
 $]-\infty,-1]$, continuous with quadrant II, and $[1,+\infty[$ continuous
 with quadrant IV. The function satisfies $i \text{asin}(x) =
 \text{asinh}(ix)$.

Function: asinh
Class: basic
Section: transcendental
C-Name: gasinh
Prototype: Gp
Help: asinh(x): inverse hyperbolic sine of x.
Doc: principal branch of $\sinh^{-1}(x) = \log(x + \sqrt{1+x^2})$. In
 particular $\Im(\text{asinh}(x))\in [-\pi/2,\pi/2]$.
 The branch cut is in two pieces: $]-i \infty ,-i]$, continuous with quadrant
 III and $[+i,+i \infty[$, continuous with quadrant I.

Function: asympnum
Class: basic
Section: sums
C-Name: asympnum0
Prototype: GDGp
Help: asympnum(expr,{alpha = 1}): asymptotic expansion of expr
 assuming it has rational coefficients with reasonable height; alpha is
 as in limitnum.
Doc: Asymptotic expansion of \var{expr}, corresponding to a sequence $u(n)$,
 assuming it has the shape
 $$u(n) \approx \sum_{i \geq 0} a_i n^{-i\alpha}$$
 with rational coefficients $a_i$ with reasonable height; the algorithm
 is heuristic and performs repeated calls to limitnum, with
 \kbd{alpha} as in \kbd{limitnum}. As in \kbd{limitnum}, $u(n)$ may be
 given either by a closure $n\mapsto u(n)$ or as a closure $N\mapsto
 [u(1),\dots,u(N)]$, the latter being often more efficient.
 \bprog
 ? f(n) = n! / (n^n*exp(-n)*sqrt(n));
 ? asympnum(f)
 %2 = []   \\ failure !
 ? localprec(57); l = limitnum(f)
 %3 = 2.5066282746310005024157652848110452530
 ? asympnum(n->f(n)/l) \\ normalize
 %4 =  [1, 1/12, 1/288, -139/51840, -571/2488320, 163879/209018880,
        5246819/75246796800]
 @eprog\noindent and we indeed get a few terms of Stirling's expansion. Note
 that it definitely helps to normalize with a limit computed to higher
 accuracy (as a rule of thumb, multiply the bit accuracy by $1.612$):
 \bprog
 ? l = limitnum(f)
 ? asympnum(n->f(n) / l) \\ failure again !!!
 %6 = []
 @eprog\noindent We treat again the example of the Motzkin numbers $M_n$ given
 in \kbd{limitnum}:
 \bprog
 \\ [M_k, M_{k*2}, ..., M_{k*N}] / (3^n / n^(3/2))
 ? vM(N, k = 1) =
 { my(q = k*N, V);
    if (q == 1, return ([1/3]));
    V = vector(q); V[1] = V[2] = 1;
    for(n = 2, q - 1,
      V[n+1] = ((2*n + 1)*V[n] + 3*(n - 1)*V[n-1]) / (n + 2));
    f = (n -> 3^n / n^(3/2));
    return (vector(N, n, V[n*k] / f(n*k)));
 }
 ? localprec(100); l = limitnum(n->vM(n,10)); \\ 3/sqrt(12*Pi)
 ? \p38
 ? asympnum(n->vM(n,10)/l)
 %2 = [1, -3/32, 101/10240, -1617/1638400, 505659/5242880000, ...]
 @eprog
 
 If \kbd{alpha} is not a rational number, loss of accuracy is
 expected, so it should be precomputed to double accuracy, say:
 \bprog
 ? \p38
 ? asympnum(n->log(1+1/n^Pi),Pi)
 %1 = [0, 1, -1/2, 1/3, -1/4, 1/5]
 ? localprec(76); a = Pi;
 ? asympnum(n->log(1+1/n^Pi), a) \\ more terms
 %3 = [0, 1, -1/2, 1/3, -1/4, 1/5, -1/6, 1/7, -1/8, 1/9, -1/10, 1/11, -1/12]
 ? asympnum(n->log(1+1/sqrt(n)),1/2) \\ many more terms
 %4 = 49
 @eprog The expression is evaluated for $n = 1, 2, \dots, N$
 for an $N = O(B)$ if the current bit accuracy is $B$. If it is not defined
 for one of these values, translate or rescale accordingly:
 \bprog
 ? asympnum(n->log(1-1/n))  \\ can't evaluate at n = 1 !
  ***   at top-level: asympnum(n->log(1-1/n))
  ***                 ^-----------------------
  ***   in function asympnum: log(1-1/n)
  ***                         ^----------
  *** log: domain error in log: argument = 0
 ? asympnum(n->-log(1-1/(2*n)))
 %5 = [0, 1/2, 1/8, 1/24, ...]
 ? asympnum(n->-log(1-1/(n+1)))
 %6 = [0, 1, -1/2, 1/3, -1/4, ...]
 @eprog\noindent
 
 \synt{asympnum}{void *E, GEN (*u)(void *,GEN,long), GEN alpha, long prec}, where \kbd{u(E, n, prec)} must return either $u(n)$ or $[u(1),\dots,u(n)]$
 in precision \kbd{prec}. Also available is
 \fun{GEN}{asympnum0}{GEN u, GEN alpha, long prec}, where $u$ is a closure
 as above or a vector of sufficient length.

Function: asympnumraw
Class: basic
Section: sums
C-Name: asympnumraw0
Prototype: GLDGp
Help: asympnumraw(expr,N,{alpha = 1}): N+1 first terms of asymptotic expansion
 of expr as floating point numbers; alpha is as in limitnum.
Doc: Return the $N+1$ first terms of asymptotic expansion of \var{expr},
 corresponding to a sequence $u(n)$, as floating point numbers. Assume
 that the expansion has the shape
 $$u(n) \approx \sum_{i \geq 0} a_i n^{-i\alpha}$$
 and return approximation of $[a_0, a_1,\dots, a_N]$.
 The algorithm is heuristic and performs repeated calls to limitnum, with
 \kbd{alpha} as in \kbd{limitnum}. As in \kbd{limitnum}, $u(n)$ may be
 given either by a closure $n\mapsto u(n)$ or as a closure $N\mapsto
 [u(1),\dots,u(N)]$, the latter being often more efficient. This function
 is related to, but  more flexible than, \kbd{asympnum}, which requires
 rational asymptotic expansions.
 \bprog
 ? f(n) = n! / (n^n*exp(-n)*sqrt(n));
 ? asympnum(f)
 %2 = []   \\ failure !
 ? v = asympnumraw(f, 10);
 ? v[1] - sqrt(2*Pi)
 %4 = 0.E-37
 ? bestappr(v / v[1], 2^60)
 %5 =  [1, 1/12, 1/288, -139/51840, -571/2488320, 163879/209018880,...]
 @eprog\noindent and we indeed get a few terms of Stirling's expansion (the
 first 9 terms are correct).
 If $u(n)$ has an asymptotic expansion in $n^{-\alpha}$ with $\alpha$ not an
 integer, the default $alpha=1$ is inaccurate:
 \bprog
 ? f(n) = (1+1/n^(7/2))^(n^(7/2));
 ? v1 = asympnumraw(f,10);
 ? v1[1] - exp(1)
 %8 = 4.62... E-12
 ? v2 = asympnumraw(f,10,7/2);
 ? v2[1] - exp(1)
 %7 0.E-37
 @eprog\noindent
 As in \kbd{asympnum}, if \kbd{alpha} is not a rational number,
 loss of accuracy is expected, so it should be precomputed to double
 accuracy, say.
 
 \synt{asympnumraw}{void *E, GEN (*u)(void *,GEN,long), long N, GEN alpha, long prec}, where \kbd{u(E, n, prec)} must return either $u(n)$ or
 $[u(1),\dots,u(n)]$ in precision \kbd{prec}.
 Also available is
 \fun{GEN}{asympnumraw0}{GEN u, GEN alpha, long prec} where $u$ is either
 a closure as above or a vector of sufficient length.

Function: atan
Class: basic
Section: transcendental
C-Name: gatan
Prototype: Gp
Help: atan(x): arc tangent of x.
Doc: principal branch of $\text{tan}^{-1}(x) = \log ((1+ix)/(1-ix)) /
 2i$. In particular the real part of $\text{atan}(x)$ belongs to
 $]-\pi/2,\pi/2[$.
 The branch cut is in two pieces:
 $]-i\infty,-i[$, continuous with quadrant IV, and $]i,+i \infty[$ continuous
 with quadrant II. The function satisfies $\text{atan}(x) =
 -i\text{atanh}(ix)$ for all $x\neq \pm i$.

Function: atanh
Class: basic
Section: transcendental
C-Name: gatanh
Prototype: Gp
Help: atanh(x): inverse hyperbolic tangent of x.
Doc: principal branch of $\text{tanh}^{-1}(x) = \log ((1+x)/(1-x)) / 2$. In
 particular the imaginary part of $\text{atanh}(x)$ belongs to
 $[-\pi/2,\pi/2]$; if $x\in \R$ and $|x|>1$ then $\text{atanh}(x)$ is complex.

Function: bernfrac
Class: basic
Section: combinatorics
C-Name: bernfrac
Prototype: L
Help: bernfrac(n): Bernoulli number B_n, as a rational number.
Doc: Bernoulli number\sidx{Bernoulli numbers} $B_n$,
 where $B_0=1$, $B_1=-1/2$, $B_2=1/6$,\dots, expressed as a rational number.
 The argument $n$ should be a nonnegative integer. The function \tet{bervec}
 creates a cache of successive Bernoulli numbers which greatly speeds up
 later calls to \kbd{bernfrac}:
 \bprog
 ? bernfrac(20000);
 time = 107 ms.
 ? bernvec(10000); \\ cache B_0, B_2, ..., B_20000
 time = 35,957 ms.
 ? bernfrac(20000); \\ now instantaneous
 ?
 @eprog

Function: bernpol
Class: basic
Section: combinatorics
C-Name: bernpol
Prototype: LDn
Help: bernpol(n, {v = 'x}): Bernoulli polynomial B_n, in variable v.
Doc: \idx{Bernoulli polynomial} $B_n$ in variable $v$.
 \bprog
 ? bernpol(1)
 %1 = x - 1/2
 ? bernpol(3)
 %2 = x^3 - 3/2*x^2 + 1/2*x
 @eprog

Function: bernreal
Class: basic
Section: combinatorics
C-Name: bernreal
Prototype: Lp
Help: bernreal(n): Bernoulli number B_n, as a real number with the current
 precision.
Doc: Bernoulli number\sidx{Bernoulli numbers}
 $B_n$, as \kbd{bernfrac}, but $B_n$ is returned as a real number
 (with the current precision). The argument $n$ should be a nonnegative
 integer. The function slows down as the precision increases:
 \bprog
 ? \p1000
 ? bernreal(200000);
 time = 5 ms.
 ? \p10000
 ? bernreal(200000);
 time = 18 ms.
 ? \p100000
 ? bernreal(200000);
 time = 84 ms.
 @eprog

Function: bernvec
Class: basic
Section: combinatorics
C-Name: bernvec
Prototype: L
Help: bernvec(n): returns a vector containing, as rational numbers,
 the Bernoulli numbers B_0, B_2, ..., B_{2n}.
Doc: returns a vector containing, as rational numbers,
 the \idx{Bernoulli numbers} $B_0$, $B_2$,\dots, $B_{2n}$:
 \bprog
 ? bernvec(5) \\ B_0, B_2..., B_10
 %1 = [1, 1/6, -1/30, 1/42, -1/30, 5/66]
 ? bernfrac(10)
 %2 = 5/66
 @eprog\noindent This routine uses a lot of memory but is much faster than
 repeated calls to \kbd{bernfrac}:
 \bprog
 ? forstep(n = 2, 10000, 2, bernfrac(n))
 time = 18,245 ms.
 ? bernvec(5000);
 time = 1,338 ms.
 @eprog\noindent The computed Bernoulli numbers are stored in an incremental
 cache which makes later calls to \kbd{bernfrac} and \kbd{bernreal}
 instantaneous in the cache range: re-running the same previous \kbd{bernfrac}s
 after the \kbd{bernvec} call gives:
 \bprog
 ? forstep(n = 2, 10000, 2, bernfrac(n))
 time = 1 ms.
 @eprog\noindent The time and space complexity of this function are
 $\tilde{O}(n^2)$; in the feasible range $n \leq 10^5$ (requires about two
 hours), the practical time complexity is closer to $\tilde{O}(n^{\log_2 6})$.

Function: besselh1
Class: basic
Section: transcendental
C-Name: hbessel1
Prototype: GGp
Help: besselh1(nu,x): H^1-bessel function of index nu and argument x.
Doc: $H^1$-Bessel function of index \var{nu} and argument $x$.

Function: besselh2
Class: basic
Section: transcendental
C-Name: hbessel2
Prototype: GGp
Help: besselh2(nu,x): H^2-bessel function of index nu and argument x.
Doc: $H^2$-Bessel function of index \var{nu} and argument $x$.

Function: besseli
Class: basic
Section: transcendental
C-Name: ibessel
Prototype: GGp
Help: besseli(nu,x): I-bessel function of index nu and argument x.
Doc: $I$-Bessel function of index \var{nu} and
 argument $x$. If $x$ converts to a power series, the initial factor
 $(x/2)^\nu/\Gamma(\nu+1)$ is omitted (since it cannot be represented in PARI
 when $\nu$ is not integral).

Function: besselj
Class: basic
Section: transcendental
C-Name: jbessel
Prototype: GGp
Help: besselj(nu,x): J-bessel function of index nu and argument x.
Doc: $J$-Bessel function of index \var{nu} and
 argument $x$. If $x$ converts to a power series, the initial factor
 $(x/2)^\nu/\Gamma(\nu+1)$ is omitted (since it cannot be represented in PARI
 when $\nu$ is not integral).

Function: besseljh
Class: basic
Section: transcendental
C-Name: jbesselh
Prototype: GGp
Help: besseljh(n,x): J-bessel function of index n+1/2 and argument x, where
 n is a nonnegative integer.
Doc: $J$-Bessel function of half integral index.
 More precisely, $\kbd{besseljh}(n,x)$ computes $J_{n+1/2}(x)$ where $n$
 must be of type integer, and $x$ is any element of $\C$. In the
 present version \vers, this function is not very accurate when $x$ is small.

Function: besseljzero
Class: basic
Section: transcendental
C-Name: besseljzero
Prototype: GD1,L,b
Help: besseljzero(nu,{k=1}): k-th zero of the J-bessel function
 of index nu.
Doc: $k$-th zero of the $J$-Bessel function of index \var{nu}, close
 to $\pi(\nu/2 + k - 1/4)$, usually noted $j_{\nu,k}$.
 \bprog
 ? besseljzero(0) \\ @com{first zero of $J_0$}
 %1 = 2.4048255576957727686216318793264546431
 ? besselj(0, %)
 %2 = 7.1951595399463653939930598011247182898 E-41
 ? besseljzero(0, 2) \\ @com{second zero}
 %3 = 5.5200781102863106495966041128130274252
 ? besseljzero(I) \\ @com{also works for complex orders, here $J_i$}
 %4 = 2.5377... + 1.4753...*I
 @eprog\noindent The function uses a Newton iteration due to Temme.
 If $\nu$ is real and nonnegative, the result is guaranteed and we really
 return the $k$-th positive zero of $J_\nu$. For general $\nu$, the result
 is not well defined, we just use Newton iteration with $\pi(\nu/2 + k - 1/4)$
 as a starting value. (N.B. Using this method for large real $\nu$ would give
 completely different results than the $j_{\nu,k}$ unless $k$ is large enough.)

Function: besselk
Class: basic
Section: transcendental
C-Name: kbessel
Prototype: GGp
Help: besselk(nu,x): K-bessel function of index nu and argument x.
Doc: $K$-Bessel function of index \var{nu} and argument $x$.

Function: besseln
Class: basic
Section: transcendental
C-Name: ybessel
Prototype: GGp
Obsolete: 2018-12-10
Help: besseln(nu,x): deprecated alias for bessely.
Doc: deprecated alias for \kbd{bessely}.

Function: bessely
Class: basic
Section: transcendental
C-Name: ybessel
Prototype: GGp
Help: bessely(nu,x): Y-bessel function of index nu and argument x.
Doc: $Y$-Bessel function of index \var{nu} and argument $x$.

Function: besselyzero
Class: basic
Section: transcendental
C-Name: besselyzero
Prototype: GD1,L,b
Help: besselyzero(nu,{k=1}): k-th zero of the Y-bessel function
 of index nu.
Doc: $k$-th zero of the $Y$-Bessel function of index \var{nu}, close
 to $\pi(\nu/2 + k - 3/4)$, usually noted $y_{\nu,k}$.
 \bprog
 ? besselyzero(0) \\ @com{first zero of $Y_0$}
 %1 = 0.89357696627916752158488710205833824123
 ? bessely(0, %)
 %2 = 1.8708573650996561952 E-39
 ? besselyzero(0, 2) \\ @com{second zero}
 %3 = 3.9576784193148578683756771869174012814
 ? besselyzero(I) \\ @com{also works for complex orders, here $Y_i$}
 %4 = 1.03930... + 1.3266...*I
 @eprog\noindent The function uses a Newton iteration due to Temme.
 If $\nu$ is real and nonnegative, the result is guaranteed and we really
 return the $k$-th positive zero of $Y_\nu$. For general $\nu$, the result
 is not well defined, we just use Newton iteration with $\pi(\nu/2 + k - 3/4)$
 as a starting value. (N.B. Using this method for large real $\nu$ would give
 completely different results than the $y_{\nu,k}$ unless $k$ is large enough.)

Function: bestappr
Class: basic
Section: number_theoretical
C-Name: bestappr
Prototype: GDG
Help: bestappr(x, {B}): return a rational approximation to x, whose
 denominator is limited by B, if present. This function applies to reals,
 intmods, p-adics, and rationals of course. Otherwise it applies recursively
 to all components.
Doc: using variants of the extended Euclidean algorithm, returns a rational
 approximation $a/b$ to $x$, whose denominator is limited
 by $B$, if present. If $B$ is omitted, returns the best approximation
 affordable given the input accuracy; if you are looking for true rational
 numbers, presumably approximated to sufficient accuracy, you should first
 try that option. Otherwise, $B$ must be a positive real scalar (impose
 $0 < b \leq B$).
 
 \item If $x$ is a \typ{REAL} or a \typ{FRAC}, this function uses continued
 fractions.
 \bprog
 ? bestappr(Pi, 100)
 %1 = 22/7
 ? bestappr(0.1428571428571428571428571429)
 %2 = 1/7
 ? bestappr([Pi, sqrt(2) + 'x], 10^3)
 %3 = [355/113, x + 1393/985]
 @eprog
 By definition, $a/b$ is the best rational approximation to $x$ if
 $|b x - a| < |v x - u|$ for all integers $(u,v)$ with $0 < v \leq B$.
 (Which implies that $n/d$ is a convergent of the continued fraction of $x$.)
 
 \item If $x$ is a \typ{INTMOD} modulo $N$ or a \typ{PADIC} of precision $N =
 p^k$, this function performs rational modular reconstruction modulo $N$. The
 routine then returns the unique rational number $a/b$ in coprime integers
 $|a| < N/2B$ and $b\leq B$ which is congruent to $x$ modulo $N$. Omitting
 $B$ amounts to choosing it of the order of $\sqrt{N/2}$. If rational
 reconstruction is not possible (no suitable $a/b$ exists), returns $[]$.
 \bprog
 ? bestappr(Mod(18526731858, 11^10))
 %1 = 1/7
 ? bestappr(Mod(18526731858, 11^20))
 %2 = []
 ? bestappr(3 + 5 + 3*5^2 + 5^3 + 3*5^4 + 5^5 + 3*5^6 + O(5^7))
 %2 = -1/3
 @eprog\noindent In most concrete uses, $B$ is a prime power and we performed
 Hensel lifting to obtain $x$.
 
 The function applies recursively to components of complex objects
 (polynomials, vectors, \dots). If rational reconstruction fails for even a
 single entry, returns $[]$.

Function: bestapprPade
Class: basic
Section: number_theoretical
C-Name: bestapprPade
Prototype: GD-1,L,
Help: bestapprPade(x, {B}): returns a rational function approximation to x.
 This function applies to series, polmods, and rational functions of course.
 Otherwise it applies recursively to all components.
Doc: using variants of the extended Euclidean algorithm (Pad\'{e}
 approximants), returns a rational
 function approximation $a/b$ to $x$, whose denominator is limited
 by $B$, if present. If $B$ is omitted, return the best approximation
 affordable given the input accuracy; if you are looking for true rational
 functions, presumably approximated to sufficient accuracy, you should first
 try that option. Otherwise, $B$ must be a nonnegative real
 (impose $0 \leq \text{degree}(b) \leq B$).
 
 \item If $x$ is a \typ{POLMOD} modulo $N$ this function performs rational
 modular reconstruction modulo $N$. The routine then returns the unique
 rational function $a/b$ in coprime polynomials, with $\text{degree}(b)\leq B$
 and $\text{degree}(a)$ minimal, which is congruent to $x$ modulo $N$.
 Omitting $B$ amounts to choosing it equal to the floor of
 $\text{degree}(N) / 2$. If rational reconstruction is not possible (no
 suitable $a/b$ exists), returns $[]$.
 \bprog
 ? T = Mod(x^3 + x^2 + x + 3, x^4 - 2);
 ? bestapprPade(T)
 %2 = (2*x - 1)/(x - 1)
 ? U = Mod(1 + x + x^2 + x^3 + x^5, x^9);
 ? bestapprPade(U)  \\ internally chooses B = 4
 %3 = []
 ? bestapprPade(U, 5) \\ with B = 5, a solution exists
 %4 = (2*x^4 + x^3 - x - 1)/(-x^5 + x^3 + x^2 - 1)
 @eprog
 
 \item If $x$ is a \typ{SER}, we implicitly
 convert the input to a \typ{POLMOD} modulo $N = t^k$ where $k$ is the
 series absolute precision.
 \bprog
 ? T = 1 + t + t^2 + t^3 + t^4 + t^5 + t^6 + O(t^7); \\ mod t^7
 ? bestapprPade(T)
 %1 = 1/(-t + 1)
 @eprog
 \item If $x$ is a \typ{RFRAC}, we implicitly convert the input to a
 \typ{POLMOD} modulo $N = t^k$ where $k = 2B + 1$. If $B$ was omitted,
 we return $x$:
 \bprog
 ? T = (4*t^2 + 2*t + 3)/(t+1)^10;
 ? bestapprPade(T,1)
 %2 = [] \\ impossible
 ? bestapprPade(T,2)
 %3 = 27/(337*t^2 + 84*t + 9)
 ? bestapprPade(T,3)
 %4 = (4253*t - 3345)/(-39007*t^3 - 28519*t^2 - 8989*t - 1115)
 @eprog\noindent
 The function applies recursively to components of complex objects
 (polynomials, vectors, \dots). If rational reconstruction fails for even a
 single entry, return $[]$.

Function: bestapprnf
Class: basic
Section: linear_algebra
C-Name: bestapprnf
Prototype: GGDGp
Help: bestapprnf(V,T,{rootT}): T being an integral polynomial
 and V being a scalar, vector, or matrix, return a reasonable
 approximation of V with polmods modulo T. The rootT argument,
 if present, must be an element of polroots(T), i.e. a root of T fixing a
 complex embedding of Q[x]/(T).
Doc: $T$ being an integral polynomial and $V$ being a scalar, vector, or
 matrix with complex coefficients, return a reasonable approximation of $V$
 with polmods modulo $T$. $T$ can also be any number field structure, in which
 case the minimal polynomial attached to the structure (\kbd{$T$}.pol) is
 used. The \var{rootT} argument, if present, must be an element of
 \kbd{polroots($T$)} (or \kbd{$T$}.pol), i.e.~a complex root of $T$ fixing an embedding of
 $\Q[x]/(T)$ into $\C$.
 \bprog
 ? bestapprnf(sqrt(5), polcyclo(5))
 %1 = Mod(-2*x^3 - 2*x^2 - 1, x^4 + x^3 + x^2 + x + 1)
 ? bestapprnf(sqrt(5), polcyclo(5), exp(4*I*Pi/5))
 %2 = Mod(2*x^3 + 2*x^2 + 1, x^4 + x^3 + x^2 + x + 1)
 @eprog\noindent When the output has huge rational coefficients, try to
 increase the working \kbd{realbitprecision}: if the answer does not
 stabilize, consider that the reconstruction failed.
 Beware that if $T$ is not Galois over $\Q$, some embeddings
 may not allow to reconstruct $V$:
 \bprog
 ? T = x^3-2; vT = polroots(T); z = 3*2^(1/3)+1;
 ? bestapprnf(z, T, vT[1])
 %2 = Mod(3*x + 1, x^3 - 2)
 ? bestapprnf(z, T, vT[2])
 %3 = 4213714286230872/186454048314072  \\ close to 3*2^(1/3) + 1
 @eprog

Function: bezout
Class: basic
Section: number_theoretical
C-Name: gcdext0
Prototype: GG
Obsolete: 2013-04-03
Help: bezout(x,y): deprecated alias for gcdext.
Doc: deprecated alias for \kbd{gcdext}

Function: bezoutres
Class: basic
Section: polynomials
C-Name: polresultantext0
Prototype: GGDn
Obsolete: 2015-01-13
Help: bezoutres(A,B,{v}): deprecated alias for polresultantext.
Doc: deprecated alias for \kbd{polresultantext}

Function: bigomega
Class: basic
Section: number_theoretical
C-Name: bigomega
Prototype: lG
Help: bigomega(x): number of prime divisors of x, counted with multiplicity.
Doc: number of prime divisors of the integer $|x|$ counted with
 multiplicity:
 \bprog
 ? factor(392)
 %1 =
 [2 3]
 
 [7 2]
 
 ? bigomega(392)
 %2 = 5;  \\ = 3+2
 ? omega(392)
 %3 = 2;  \\ without multiplicity
 @eprog

Function: binary
Class: basic
Section: conversions
C-Name: binaire
Prototype: G
Help: binary(x): gives the vector formed by the binary digits of x (x
 integer).
Doc: outputs the vector of the binary digits of $|x|$. Here $x$ can be an
 integer, a real number (in which case the result has two components, one for
 the integer part, one for the fractional part) or a vector/matrix.
 \bprog
 ? binary(10)
 %1 = [1, 0, 1, 0]
 
 ? binary(3.14)
 %2 = [[1, 1], [0, 0, 1, 0, 0, 0, [...]]
 
 ? binary([1,2])
 %3 = [[1], [1, 0]]
 @eprog\noindent For integer $x\ge1$, the number of bits is
 $\kbd{logint}(x,2) + 1$. By convention, $0$ has no digits:
 \bprog
 ? binary(0)
 %4 = []
 @eprog

Function: binomial
Class: basic
Section: combinatorics
C-Name: binomial0
Prototype: GDG
Help: binomial(x,{k}): binomial coefficient x*(x-1)...*(x-k+1)/k! defined for
 k in Z and any x. If k is omitted and x an integer, return the vector
 [binomial(x,0),...,binomial(x,x)].
Doc: \idx{binomial coefficient} $\binom{x}{k}$.
 Here $k$ must be an integer, but $x$ can be any PARI object.
 \bprog
 ? binomial(4,2)
 %1 = 6
 ? n = 4; vector(n+1, k, binomial(n,k-1))
 %2 = [1, 4, 6, 4, 1]
 @eprog\noindent The argument $k$ may be omitted if $x = n$ is a
 nonnegative integer; in this case, return the vector with $n+1$
 components whose $k+1$-th entry is \kbd{binomial}$(n,k)$
 \bprog
 ? binomial(4)
 %3 = [1, 4, 6, 4, 1]
 @eprog

Function: bitand
Class: basic
Section: conversions
C-Name: gbitand
Prototype: GG
Help: bitand(x,y): bitwise "and" of two integers x and y. Negative numbers
 behave as if modulo big power of 2.
Description: 
 (small, small):small:parens        $(1)&$(2)
 (gen, gen):int        gbitand($1, $2)
Doc: 
 bitwise \tet{and}
 \sidx{bitwise and}of two integers $x$ and $y$, that is the integer
 $$\sum_i (x_i~\kbd{and}~y_i) 2^i$$
 
 Negative numbers behave $2$-adically, i.e.~the result is the $2$-adic limit
 of \kbd{bitand}$(x_n,y_n)$, where $x_n$ and $y_n$ are nonnegative integers
 tending to $x$ and $y$ respectively. (The result is an ordinary integer,
 possibly negative.)
 
 \bprog
 ? bitand(5, 3)
 %1 = 1
 ? bitand(-5, 3)
 %2 = 3
 ? bitand(-5, -3)
 %3 = -7
 @eprog
Variant: Also available is
 \fun{GEN}{ibitand}{GEN x, GEN y}, which returns the bitwise \emph{and}
 of $|x|$ and $|y|$, two integers.

Function: bitneg
Class: basic
Section: conversions
C-Name: gbitneg
Prototype: GD-1,L,
Help: bitneg(x,{n=-1}): bitwise negation of an integers x truncated to n
 bits. n=-1 means represent infinite sequences of bit 1 as negative numbers.
 Negative numbers behave as if modulo big power of 2.
Doc: 
 \idx{bitwise negation} of an integer $x$,
 truncated to $n$ bits, $n\geq 0$, that is the integer
 $$\sum_{i=0}^{n-1} \kbd{not}(x_i) 2^i.$$
 The special case $n=-1$ means no truncation: an infinite sequence of
 leading $1$ is then represented as a negative number.
 
 See \secref{se:bitand} for the behavior for negative arguments.

Function: bitnegimply
Class: basic
Section: conversions
C-Name: gbitnegimply
Prototype: GG
Help: bitnegimply(x,y): bitwise "negated imply" of two integers x and y,
 in other words, x BITAND BITNEG(y). Negative numbers behave as if modulo big
 power of 2.
Description: 
 (small, small):small:parens        $(1)&~$(2)
 (gen, gen):int        gbitnegimply($1, $2)
Doc: 
 bitwise negated imply of two integers $x$ and
 $y$ (or \kbd{not} $(x \Rightarrow y)$), that is the integer $$\sum
 (x_i~\kbd{and not}(y_i)) 2^i$$
 
 See \secref{se:bitand} for the behavior for negative arguments.
Variant: Also available is
 \fun{GEN}{ibitnegimply}{GEN x, GEN y}, which returns the bitwise negated
 imply of $|x|$ and $|y|$, two integers.

Function: bitor
Class: basic
Section: conversions
C-Name: gbitor
Prototype: GG
Help: bitor(x,y): bitwise "or" of two integers x and y. Negative numbers
 behave as if modulo big power of 2.
Description: 
 (small, small):small:parens        $(1)|$(2)
 (gen, gen):int        gbitor($1, $2)
Doc: 
 \sidx{bitwise inclusive or}bitwise (inclusive)
 \tet{or} of two integers $x$ and $y$, that is the integer $$\sum
 (x_i~\kbd{or}~y_i) 2^i$$
 
 See \secref{se:bitand} for the behavior for negative arguments.
Variant: Also available is
 \fun{GEN}{ibitor}{GEN x, GEN y}, which returns the bitwise \emph{or}
 of $|x|$ and $|y|$, two integers.

Function: bitprecision
Class: basic
Section: conversions
C-Name: bitprecision00
Prototype: GDG
Help: bitprecision(x,{n}): if n is present and positive, return x at precision
 n bits. If n is omitted, return real precision of object x in bits.
Doc: the function behaves differently according to whether $n$ is
 present or not. If $n$ is missing, the function returns
 the (floating point) precision in bits of the PARI object $x$.
 
 If $x$ is an exact object, the function returns \kbd{+oo}.
 \bprog
 ? bitprecision(exp(1e-100))
 %1 = 512                 \\ 512 bits
 ? bitprecision( [ exp(1e-100), 0.5 ] )
 %2 = 128                 \\ minimal accuracy among components
 ? bitprecision(2 + x)
 %3 = +oo                  \\ exact object
 @eprog\noindent Use \kbd{getlocalbitprec()} to retrieve the
 working bit precision (as modified by possible \kbd{localbitprec}
 statements).
 
 If $n$ is present and positive, the function creates a new object equal to $x$
 with the new bit-precision roughly $n$. In fact, the smallest multiple of 64
 (resp.~32 on a 32-bit machine) larger than or equal to $n$.
 
 For $x$ a vector or a matrix, the operation is
 done componentwise; for series and polynomials, the operation is done
 coefficientwise. For real $x$, $n$ is the number of desired significant
 \emph{bits}. If $n$ is smaller than the precision of $x$, $x$ is truncated,
 otherwise $x$ is extended with zeros. For exact or non-floating-point types,
 no change.
 \bprog
 ? bitprecision(Pi, 10)    \\ actually 64 bits ~ 19 decimal digits
 %1 = 3.141592653589793239
 ? bitprecision(1, 10)
 %2 = 1
 ? bitprecision(1 + O(x), 10)
 %3 = 1 + O(x)
 ? bitprecision(2 + O(3^5), 10)
 %4 = 2 + O(3^5)
 @eprog\noindent

Function: bittest
Class: basic
Section: conversions
C-Name: gbittest
Prototype: GL
Help: bittest(x,n): gives bit number n (coefficient of 2^n) of the integer x.
 Negative numbers behave as if modulo big power of 2.
Description: 
 (small, small):bool:parens     ($(1)>>$(2))&1
 (int, small):bool              bittest($1, $2)
 (gen, small):gen               gbittest($1, $2)
Doc: 
 outputs the $n^{\text{th}}$ bit of $x$ starting
 from the right (i.e.~the coefficient of $2^n$ in the binary expansion of $x$).
 The result is 0 or 1. For $x\ge1$, the highest 1-bit is at $n =
 \kbd{logint}(x)$ (and bigger $n$ gives $0$).
 \bprog
 ? bittest(7, 0)
 %1 = 1 \\ the bit 0 is 1
 ? bittest(7, 2)
 %2 = 1 \\ the bit 2 is 1
 ? bittest(7, 3)
 %3 = 0 \\ the bit 3 is 0
 @eprog\noindent
 See \secref{se:bitand} for the behavior at negative arguments.
Variant: For a \typ{INT} $x$, the variant \fun{long}{bittest}{GEN x, long n} is
 generally easier to use, and if furthermore $n\ge 0$ the low-level function
 \fun{ulong}{int_bit}{GEN x, long n} returns \kbd{bittest(abs(x),n)}.

Function: bitxor
Class: basic
Section: conversions
C-Name: gbitxor
Prototype: GG
Help: bitxor(x,y): bitwise "exclusive or" of two integers x and y.
 Negative numbers behave as if modulo big power of 2.
Description: 
 (small, small):small:parens        $(1)^$(2)
 (gen, gen):int        gbitxor($1, $2)
Doc: 
 bitwise (exclusive) \tet{or}
 \sidx{bitwise exclusive or}of two integers $x$ and $y$, that is the integer
 $$\sum (x_i~\kbd{xor}~y_i) 2^i$$
 
 See \secref{se:bitand} for the behavior for negative arguments.
Variant: Also available is
 \fun{GEN}{ibitxor}{GEN x, GEN y}, which returns the bitwise \emph{xor}
 of $|x|$ and $|y|$, two integers.

Function: bnfcertify
Class: basic
Section: number_fields
C-Name: bnfcertify0
Prototype: lGD0,L,
Help: bnfcertify(bnf,{flag = 0}): certify the correctness (i.e. remove the GRH) of the bnf data output by bnfinit. If flag is present, only certify that the class group is a quotient of the one computed in bnf (much simpler in general).
Doc: $\var{bnf}$ being as output by
 \kbd{bnfinit}, checks whether the result is correct, i.e.~whether it is
 possible to remove the assumption of the Generalized Riemann
 Hypothesis\sidx{GRH}. It is correct if and only if the answer is 1. If it is
 incorrect, the program may output some error message, or loop indefinitely.
 You can check its progress by increasing the debug level. The \var{bnf}
 structure must contain the fundamental units:
 \bprog
 ? K = bnfinit(x^3+2^2^3+1); bnfcertify(K)
   ***   at top-level: K=bnfinit(x^3+2^2^3+1);bnfcertify(K)
   ***                                        ^-------------
   *** bnfcertify: precision too low in makeunits [use bnfinit(,1)].
 ? K = bnfinit(x^3+2^2^3+1, 1); \\ include units
 ? bnfcertify(K)
 %3 = 1
 @eprog
 
 If flag is present, only certify that the class group is a quotient of the
 one computed in bnf (much simpler in general); likewise, the computed units
 may form a subgroup of the full unit group. In this variant, the units are
 no longer needed:
 \bprog
 ? K = bnfinit(x^3+2^2^3+1); bnfcertify(K, 1)
 %4 = 1
 @eprog
Variant: Also available is  \fun{GEN}{bnfcertify}{GEN bnf} ($\fl=0$).

Function: bnfdecodemodule
Class: basic
Section: number_fields
C-Name: decodemodule
Prototype: GG
Help: bnfdecodemodule(nf,m): given a coded module m as in bnrdisclist,
 gives the true module.
Doc: if $m$ is a module as output in the
 first component of an extension given by \kbd{bnrdisclist}, outputs the
 true module.
 \bprog
 ? K = bnfinit(x^2+23); L = bnrdisclist(K, 10); s = L[2]
 %1 = [[[Vecsmall([8]), Vecsmall([1])], [[0, 0, 0]]],
       [[Vecsmall([9]), Vecsmall([1])], [[0, 0, 0]]]]
 ? bnfdecodemodule(K, s[1][1])
 %2 =
 [2 0]
 
 [0 1]
 ? bnfdecodemodule(K,s[2][1])
 %3 =
 [2 1]
 
 [0 1]
 @eprog

Function: bnfinit
Class: basic
Section: number_fields
C-Name: bnfinit0
Prototype: GD0,L,DGp
Help: bnfinit(P,{flag=0},{tech=[]}): compute the necessary data for future
 use in ideal and unit group computations, including fundamental units if
 they are not too large. flag and tech are both optional. flag can be any of
 0: default, 1: include all data in algebraic form (compact units).
 See manual for details about tech.
Description: 
 (gen):bnf:prec           Buchall($1, 0, $prec)
 (gen, 0):bnf:prec        Buchall($1, 0, $prec)
 (gen, 1):bnf:prec        Buchall($1, nf_FORCE, $prec)
 (gen, ?small, ?gen):bnf:prec        bnfinit0($1, $2, $3, $prec)
Doc: initializes a
 \kbd{bnf} structure. Used in programs such as \kbd{bnfisprincipal},
 \kbd{bnfisunit} or \kbd{bnfnarrow}. By default, the results are conditional
 on the GRH, see \ref{se:GRHbnf}. The result is a
 10-component vector \var{bnf}.
 
 This implements \idx{Buchmann}'s sub-exponential algorithm for computing the
 class group, the regulator and a system of \idx{fundamental units} of the
 general algebraic number field $K$ defined by the irreducible polynomial $P$
 with integer coefficients. The meaning of \fl is as follows:
 
 \item $\fl = 0$ (default). This is the historical behavior, kept for
 compatibility reasons and speed. It has severe drawbacks but is likely to be
 a little faster than the alternative, twice faster say, so only use it if
 speed is paramount, you obtain a useful speed gain for the fields
 under consideration, and you are only interested in the field invariants
 such as the classgroup structure or its regulator. The computations involve
 exact algebraic numbers which are replaced by floating point embeddings for
 the sake of speed. If the precision is insufficient, \kbd{gp} may not be able
 to compute fundamental units, nor to solve some discrete logarithm problems.
 It \emph{may} be possible to increase the precision of the \kbd{bnf}
 structure using \kbd{nfnewprec} but this may fail, in particular when
 fundamental units are large. In short, the resulting \kbd{bnf}
 structure is correct and contains useful information but later
 function calls to \kbd{bnfisprincpal} or \kbd{bnrclassfield} may fail.
 
 When $\fl=1$, we keep an exact algebraic version of all floating point data
 and this allows to guarantee that functions using the structure will always
 succeed, as well as to compute the fundamental units exactly. The units are
 computed in compact form, as a product of small $S$-units, possibly with
 huge exponents. This flag also allows \kbd{bnfisprincipal} to compute
 generators of principal ideals in factored form as well. Be warned that
 expanding such products explicitly can take a very long time, but they can
 easily be mapped to floating point or $\ell$-adic embeddings of bounded
 accuracy, or to $K^*/(K^*)^\ell$, and this is enough for applications. In
 short, this flag should be used by default, unless you have a very good
 reason for it, for instance building massive tables of class numbers, and
 you do not care about units or the effect large units would have on your
 computation.
 
 $\var{tech}$ is a technical vector (empty by default, see \ref{se:GRHbnf}).
 Careful use of this parameter may speed up your computations,
 but it is mostly obsolete and you should leave it alone.
 
 \smallskip
 
 The components of a \var{bnf} are technical.
 In fact: \emph{never access a component directly, always use
 a proper member function.} However, for the sake of completeness and internal
 documentation, their description is as follows. We use the notations
 explained in the book by H. Cohen, \emph{A Course in Computational Algebraic
 Number Theory}, Graduate Texts in Maths \key{138}, Springer-Verlag, 1993,
 Section 6.5, and subsection 6.5.5 in particular.
 
 $\var{bnf}[1]$ contains the matrix $W$, i.e.~the matrix in Hermite normal
 form giving relations for the class group on prime ideal generators
 $(\goth{p}_i)_{1\le i\le r}$.
 
 $\var{bnf}[2]$ contains the matrix $B$, i.e.~the matrix containing the
 expressions of the prime ideal factorbase in terms of the $\goth{p}_i$.
 It is an $r\times c$ matrix.
 
 $\var{bnf}[3]$ contains the complex logarithmic embeddings of the system of
 fundamental units which has been found. It is an $(r_1+r_2)\times(r_1+r_2-1)$
 matrix.
 
 $\var{bnf}[4]$ contains the matrix $M''_C$ of Archimedean components of the
 relations of the matrix $(W|B)$.
 
 $\var{bnf}[5]$ contains the prime factor base, i.e.~the list of prime
 ideals used in finding the relations.
 
 $\var{bnf}[6]$ contains a dummy $0$.
 
 $\var{bnf}[7]$ or \kbd{\var{bnf}.nf} is equal to the number field data
 $\var{nf}$ as would be given by \kbd{nfinit}.
 
 $\var{bnf}[8]$ is a vector containing the classgroup \kbd{\var{bnf}.clgp}
 as a finite abelian group, the regulator \kbd{\var{bnf}.reg},
 the number of roots of unity and a generator \kbd{\var{bnf}.tu}, the
 fundamental units \emph{in expanded form} \kbd{\var{bnf}.fu}. If the
 fundamental units were omitted in the \var{bnf}, \kbd{\var{bnf}.fu} returns
 the sentinel value $0$. If $\fl = 1$, this vector contain also algebraic
 data corresponding to the fundamental units and to the discrete logarithm
 problem (see \kbd{bnfisprincipal}). In particular, if $\fl = 1$ we may
 \emph{only} know the units in factored form: the first call to
 \kbd{\var{bnf}.fu} expands them, which may be very costly, then caches the
 result.
 
 $\var{bnf}[9]$ is a vector used in \tet{bnfisprincipal} only
 and obtained as follows. Let $D = U W V$ obtained by applying the
 \idx{Smith normal form} algorithm to the matrix $W$ (= $\var{bnf}[1]$) and
 let $U_r$ be the reduction of $U$ modulo $D$. The first elements of the
 factorbase are given (in terms of \kbd{bnf.gen}) by the columns of $U_r$,
 with Archimedean component $g_a$; let also $GD_a$ be the Archimedean
 components of the generators of the (principal) ideals defined by the
 \kbd{bnf.gen[i]\pow bnf.cyc[i]}. Then $\var{bnf}[9]=[U_r, g_a, GD_a]$,
 followed by technical exact components which allow to recompute $g_a$ and
 $GD_a$ to higher accuracy.
 
 $\var{bnf}[10]$ is by default unused and set equal to 0. This field is used
 to store further information about the field as it becomes available, which
 is rarely needed, hence would be too expensive to compute during the initial
 \kbd{bnfinit} call. For instance, the generators of the principal ideals
 \kbd{bnf.gen[i]\pow bnf.cyc[i]} (during a call to \tet{bnrisprincipal}), or
 those corresponding to the relations in $W$ and $B$ (when the \kbd{bnf}
 internal precision needs to be increased).
Variant: 
 Also available is \fun{GEN}{Buchall}{GEN P, long flag, long prec},
 corresponding to \kbd{tech = NULL}, where
 \kbd{flag} is either $0$ (default) or \tet{nf_FORCE} (include all data in
 algebraic form). The function
 \fun{GEN}{Buchall_param}{GEN P, double c1, double c2, long nrpid, long flag, long prec} gives direct access to the technical parameters.

Function: bnfisintnorm
Class: basic
Section: number_fields
C-Name: bnfisintnorm
Prototype: GG
Help: bnfisintnorm(bnf,x): compute a complete system of solutions (modulo
 units of positive norm) of the absolute norm equation N(a)=x, where a
 belongs to the maximal order of big number field bnf (if bnf is not
 certified, this depends on GRH).
Doc: computes a complete system of
 solutions (modulo units of positive norm) of the absolute norm equation
 $\Norm(a)=x$,
 where $a$ is an integer in $\var{bnf}$. If $\var{bnf}$ has not been certified,
 the correctness of the result depends on the validity of \idx{GRH}.
 
 See also \tet{bnfisnorm}.
Variant: The function \fun{GEN}{bnfisintnormabs}{GEN bnf, GEN a},
 where \kbd{bnf} is a true \var{bnf} structure,
 returns a complete system of solutions modulo units of the absolute norm
 equation $|\Norm(x)| = |a|$. As fast as \kbd{bnfisintnorm}, but solves
 the two equations $\Norm(x) = \pm a$ simultaneously.

Function: bnfisnorm
Class: basic
Section: number_fields
C-Name: bnfisnorm
Prototype: GGD1,L,
Help: bnfisnorm(bnf,x,{flag=1}): tries to tell whether x (in Q) is the norm
 of some fractional y (in bnf). Returns a vector [a,b] where x=Norm(a)*b.
 Looks for a solution which is a S-unit, with S a certain list of primes (in
 bnf) containing (among others) all primes dividing x. If bnf is known to be
 Galois, you may set flag=0 (in this case, x is a norm iff b=1). If flag is
 nonzero the program adds to S all the primes: dividing flag if flag<0, or
 less than flag if flag>0. The answer is guaranteed (i.e x norm iff b=1)
 under GRH, if S contains all primes less than 12.log(disc(Bnf))^2, where
 Bnf is the Galois closure of bnf.
Doc: tries to tell whether the
 rational number $x$ is the norm of some element y in $\var{bnf}$. Returns a
 vector $[a,b]$ where $x=Norm(a)*b$. Looks for a solution which is an $S$-unit,
 with $S$ a certain set of prime ideals containing (among others) all primes
 dividing $x$. If $\var{bnf}$ is known to be \idx{Galois}, you may set $\fl=0$
 (in this case, $x$ is a norm iff $b=1$). If $\fl$ is nonzero the program adds
 to $S$ the following prime ideals, depending on the sign of $\fl$. If $\fl>0$,
 the ideals of norm less than $\fl$. And if $\fl<0$ the ideals dividing $\fl$.
 
 Assuming \idx{GRH}, the answer is guaranteed (i.e.~$x$ is a norm iff $b=1$),
 if $S$ contains all primes less than $12\log(\disc(\var{Bnf}))^2$, where
 $\var{Bnf}$ is the Galois closure of $\var{bnf}$.
 
 See also \tet{bnfisintnorm}.

Function: bnfisprincipal
Class: basic
Section: number_fields
C-Name: bnfisprincipal0
Prototype: GGD1,L,
Help: bnfisprincipal(bnf,x,{flag=1}): bnf being output by bnfinit, gives
 [e,t], where e is the vector of exponents on the class group generators and
 t is the generator of the resulting principal ideal. In particular x is
 principal if and only if e is the zero vector. flag is optional, whose
 binary digits mean 1: output [e,t] (only e if unset); 2: increase precision
 until t can be computed (do not insist if unset); 4: return t in
 factored form (compact representation).
Doc: $\var{bnf}$ being the \sidx{principal ideal}
 number field data output by \kbd{bnfinit}, and $x$ being an ideal, this
 function tests whether the ideal is principal or not. The result is more
 complete than a simple true/false answer and solves a general discrete
 logarithm problem. Assume the class group is $\oplus (\Z/d_i\Z)g_i$
 (where the generators $g_i$ and their orders $d_i$ are respectively given by
 \kbd{bnf.gen} and \kbd{bnf.cyc}). The routine returns a row vector $[e,t]$,
 where $e$ is a vector of exponents $0 \leq e_i < d_i$, and $t$ is a number
 field element such that
 $$ x = (t) \prod_i  g_i^{e_i}.$$
 For \emph{given} $g_i$ (i.e. for a given \kbd{bnf}), the $e_i$ are unique,
 and $t$ is unique modulo units.
 
 In particular, $x$ is principal if and only if $e$ is the zero vector. Note
 that the empty vector, which is returned when the class number is $1$, is
 considered to be a zero vector (of dimension $0$).
 \bprog
 ? K = bnfinit(y^2+23);
 ? K.cyc
 %2 = [3]
 ? K.gen
 %3 = [[2, 0; 0, 1]]          \\ a prime ideal above 2
 ? P = idealprimedec(K,3)[1]; \\ a prime ideal above 3
 ? v = bnfisprincipal(K, P)
 %5 = [[2]~, [3/4, 1/4]~]
 ? idealmul(K, v[2], idealfactorback(K, K.gen, v[1]))
 %6 =
 [3 0]
 
 [0 1]
 ? % == idealhnf(K, P)
 %7 = 1
 @eprog
 
 \noindent The binary digits of \fl mean:
 
 \item $1$: If set, outputs $[e,t]$ as explained above, otherwise returns
 only $e$, which is easier to compute. The following idiom only tests
 whether an ideal is principal:
 \bprog
   is_principal(bnf, x) = !bnfisprincipal(bnf,x,0);
 @eprog
 
 \item $2$: It may not be possible to recover $t$, given the initial accuracy
 to which the \kbd{bnf} structure was computed. In that case, a warning is
 printed and $t$ is set equal to the empty vector \kbd{[]\til}. If this bit is
 set, increase the precision and recompute needed quantities until $t$ can be
 computed. Warning: setting this may induce \emph{lengthy} computations, and
 the result may be too large to be physically representable in any case.
 You should consider using flag $4$ instead.
 
 \item $4$: Return $t$ in factored form (compact representation),
 as a small product of $S$-units for a small set of finite places $S$,
 possibly with huge exponents. This kind of result can be cheaply mapped to
 $K^*/(K^*)^\ell$ or to $\C$ or $\Q_p$ to bounded accuracy and this is usually
 enough for applications. Explicitly expanding such a compact representation
 is possible using \kbd{nffactorback} but may be \emph{very} costly.
 The algorithm is guaranteed to succeed if the \kbd{bnf} was computed using
 \kbd{bnfinit(,1)}. If not, the algorithm may fail to compute a huge
 generator in this case (and replace it by \kbd{[]\til}). This is orders of
 magnitude faster than flag $2$ when the generators are indeed large.
Variant: Instead of the above hardcoded numerical flags, one should
 rather use an or-ed combination of the symbolic flags \tet{nf_GEN} (include
 generators, possibly a place holder if too difficult), \tet{nf_GENMAT}
 (include generators in compact form) and
 \tet{nf_FORCE} (insist on finding the generators, a no-op if \tet{nf_GENMAT}
 is included).

Function: bnfissunit
Class: basic
Section: number_fields
C-Name: bnfissunit
Prototype: GGG
Obsolete: 2020-01-15
Help: bnfissunit(bnf,sfu,x): this function is obsolete, use bnfisunit.
Doc: this function is obsolete, use \kbd{bnfisunit}.

Function: bnfisunit
Class: basic
Section: number_fields
C-Name: bnfisunit0
Prototype: GGDG
Help: bnfisunit(bnf,x, {U}): bnf being output by bnfinit, give
 the column vector of exponents of x on the fundamental units and the roots
 of unity if x is a unit, the empty vector otherwise. If U is present,
 as given by bnfunits, decompose x on the attached S-units generators.
Doc: \var{bnf} being the number field data
 output by \kbd{bnfinit} and $x$ being an algebraic number (type integer,
 rational or polmod), this outputs the decomposition of $x$ on the fundamental
 units and the roots of unity if $x$ is a unit, the empty vector otherwise.
 More precisely, if $u_1$,\dots,$u_r$ are the fundamental units, and $\zeta$
 is the generator of the group of roots of unity (\kbd{bnf.tu}), the output is
 a vector $[x_1,\dots,x_r,x_{r+1}]$ such that $x=u_1^{x_1}\cdots
 u_r^{x_r}\cdot\zeta^{x_{r+1}}$. The $x_i$ are integers but the last one
 ($i = r+1$) is only defined modulo the order $w$ of $\zeta$ and is guaranteed
 to be in $[0,w[$.
 
 Note that \var{bnf} need not contain the fundamental units explicitly: it may
 contain the placeholder $0$ instead:
 \bprog
 ? setrand(1); bnf = bnfinit(x^2-x-100000);
 ? bnf.fu
 %2 = 0
 ? u = [119836165644250789990462835950022871665178127611316131167, \
        379554884019013781006303254896369154068336082609238336]~;
 ? bnfisunit(bnf, u)
 %3 = [-1, 0]~
 @eprog\noindent The given $u$ is $1/u_1$, where $u_1$ is the fundamental
 unit implicitly stored in \var{bnf}. In this case, $u_1$ was not computed
 and stored in algebraic form since the default accuracy was too low. Re-run
 the \kbd{bnfinit} command at \kbd{\bs g1} or higher to see such diagnostics.
 
 This function allows $x$ to be given in factored form, but it then assumes
 that $x$ is an actual unit. (Because it is general too costly to check
 whether this is the case.)
 \bprog
 ? { v = [2, 85; 5, -71; 13, -162; 17, -76; 23, -37; 29, -104; [224, 1]~, -66;
 [-86, 1]~, 86; [-241, 1]~, -20; [44, 1]~, 30; [124, 1]~, 11; [125, -1]~, -11;
 [-214, 1]~, 33; [-213, -1]~, -33; [189, 1]~, 74; [190, -1]~, 104;
 [-168, 1]~, 2; [-167, -1]~, -8]; }
 ? bnfisunit(bnf,v)
 %5 = [1, 0]~
 @eprog\noindent Note that $v$ is the fundamental unit of \kbd{bnf} given in
 compact (factored) form.
 
 If the argument \kbd{U} is present, as output by \kbd{bnfunits(bnf, S)},
 then the function decomposes $x$ on the $S$-units generators given in
 \kbd{U[1]}.
 \bprog
  ? bnf = bnfinit(x^4 - x^3 + 4*x^2 + 3*x + 9, 1);
  ? bnf.sign
  %2 = [0, 2]
  ? S = idealprimedec(bnf,5); #S
  %3 = 2
  ? US = bnfunits(bnf,S);
  ? g = US[1]; #g  \\ #S = #g, four S-units generators, in factored form
  %5 = 4
  ? g[1]
  %6 = [[6, -3, -2, -2]~ 1]
  ? g[2]
  %7 =
  [[-1, 1/2, -1/2, -1/2]~ 1]
 
  [      [4, -2, -1, -1]~ 1]
  ? [nffactorback(bnf, x) | x <- g]
  %8 = [[6, -3, -2, -2]~, [-5, 5, 0, 0]~, [-1, 1, -1, 0]~,
        [1, -1, 0, 0]~]
 
  ? u = [10,-40,24,11]~;
  ? a = bnfisunit(bnf, u, US)
  %9 = [2, 0, 1, 4]~
  ? nffactorback(bnf, g, a) \\ prod_i g[i]^a[i] still in factored form
  %10 =
  [[6, -3, -2, -2]~  2]
 
  [ [0, 0, -1, -1]~  1]
 
  [ [2, -1, -1, 0]~ -2]
 
  [   [1, 1, 0, 0]~  2]
 
  [  [-1, 1, 1, 1]~ -1]
 
  [  [1, -1, 0, 0]~  4]
 
  ? nffactorback(bnf,%)  \\ u = prod_i g[i]^a[i]
  %11 = [10, -40, 24, 11]~
 @eprog
Variant: Also available is \fun{GEN}{bnfisunit}{GEN bnf, GEN x} for $U =
 \kbd{NULL}$.

Function: bnflog
Class: basic
Section: number_fields
C-Name: bnflog
Prototype: GG
Help: bnflog(bnf, l): let bnf be attached to a number field F and let l be
 a prime number. Return the logarithmic l-class group Cl~_F.
Doc: let \var{bnf} be a \var{bnf} structure attached to the number field $F$ and let $l$ be
 a prime number (hereafter denoted $\ell$ for typographical reasons). Return
 the logarithmic $\ell$-class group $\widetilde{Cl}_F$
 of $F$. This is an abelian group, conjecturally finite (known to be finite
 if $F/\Q$ is abelian). The function returns if and only if
 the group is indeed finite (otherwise it would run into an infinite loop).
 Let $S = \{ \goth{p}_1,\dots, \goth{p}_k\}$ be the set of $\ell$-adic places
 (maximal ideals containing $\ell$).
 The function returns $[D, G(\ell), G']$, where
 
 \item $D$ is the vector of elementary divisors for $\widetilde{Cl}_F$.
 
 \item $G(\ell)$ is the vector of elementary divisors for
 the (conjecturally finite) abelian group
 $$\widetilde{\Cl}(\ell) =
 \{ \goth{a} = \sum_{i \leq k} a_i \goth{p}_i :~\deg_F \goth{a} = 0\},$$
 where the $\goth{p}_i$ are the $\ell$-adic places of $F$; this is a
 subgroup of $\widetilde{\Cl}$.
 
 \item $G'$ is the vector of elementary divisors for the $\ell$-Sylow $Cl'$
 of the $S$-class group of $F$; the group $\widetilde{\Cl}$ maps to $Cl'$
 with a simple co-kernel.

Function: bnflogdegree
Class: basic
Section: number_fields
C-Name: bnflogdegree
Prototype: GGG
Help: bnflogdegree(nf, A, l): let A be an ideal, return exp(deg_F A)
 the exponential of the l-adic logarithmic degree.
Doc: Let \var{nf} be a \var{nf} structure attached to a number field $F$,
 and let $l$ be a prime number (hereafter
 denoted $\ell$). The
 $\ell$-adified group of id\`{e}les of $F$ quotiented by
 the group of logarithmic units is identified to the $\ell$-group
 of logarithmic divisors $\oplus \Z_\ell [\goth{p}]$, generated by the
 maximal ideals of $F$.
 
 The \emph{degree} map $\deg_F$ is additive with values in $\Z_\ell$,
 defined by $\deg_F \goth{p} = \tilde{f}_{\goth{p}} \deg_\ell p$,
 where the integer $\tilde{f}_{\goth{p}}$ is as in \tet{bnflogef} and $\deg_\ell p$
 is $\log_\ell p$ for $p\neq \ell$, $\log_\ell (1 + \ell)$ for
 $p = \ell\neq 2$ and $\log_\ell (1 + 2^2)$ for $p = \ell = 2$.
 
 Let $A = \prod \goth{p}^{n_{\goth{p}}}$ be an ideal and let $\tilde{A} =
 \sum n_\goth{p} [\goth{p}]$ be the attached logarithmic divisor. Return the
 exponential of the $\ell$-adic logarithmic degree $\deg_F A$, which is a
 natural number.

Function: bnflogef
Class: basic
Section: number_fields
C-Name: bnflogef
Prototype: GG
Help: bnflogef(nf,pr): return [e~, f~] the logarithmic ramification and
 residue degrees for the maximal ideal pr.
Doc: let \var{nf} be a \var{nf} structure attached to a number field $F$
 and let \var{pr} be a \var{prid} structure attached to a
 maximal ideal $\goth{p} / p$. Return
 $[\tilde{e}(F_\goth{p} / \Q_p), \tilde{f}(F_\goth{p} / \Q_p)]$
 the logarithmic ramification and residue degrees. Let $\Q_p^c/\Q_p$ be the
 cyclotomic $\Z_p$-extension, then
 $\tilde{e} = [F_\goth{p} \colon F_\goth{p} \cap \Q_p^c]$ and
 $\tilde{f} = [F_\goth{p} \cap \Q_p^c \colon \Q_p]$. Note that
 $\tilde{e}\tilde{f} = e(\goth{p}/p) f(\goth{p}/p)$, where $e(\goth{p}/p)$ and $f(\goth{p}/p)$ denote the
 usual ramification and residue degrees.
 \bprog
 ? F = nfinit(y^6 - 3*y^5 + 5*y^3 - 3*y + 1);
 ? bnflogef(F, idealprimedec(F,2)[1])
 %2 = [6, 1]
 ? bnflogef(F, idealprimedec(F,5)[1])
 %3 = [1, 2]
 @eprog

Function: bnfnarrow
Class: basic
Section: number_fields
C-Name: bnfnarrow
Prototype: G
Help: bnfnarrow(bnf): given a big number field as output by bnfinit, gives
 as a 3-component vector the structure of the narrow class group.
Doc: \var{bnf} being as output by
 \kbd{bnfinit}, computes the narrow class group of \var{bnf}. The output is
 a 3-component row vector $v$ analogous to the corresponding class group
 component \kbd{\var{bnf}.clgp}: the first component
 is the narrow class number \kbd{$v$.no}, the second component is a vector
 containing the SNF\sidx{Smith normal form} cyclic components \kbd{$v$.cyc} of
 the narrow class group, and the third is a vector giving the generators of
 the corresponding \kbd{$v$.gen} cyclic groups. Note that this function is a
 special case of \kbd{bnrinit}; the \var{bnf} need not contain fundamental
 units.

Function: bnfsignunit
Class: basic
Section: number_fields
C-Name: signunits
Prototype: G
Help: bnfsignunit(bnf): matrix of signs of the real embeddings of the system
 of fundamental units found by bnfinit.
Doc: $\var{bnf}$ being as output by
 \kbd{bnfinit}, this computes an $r_1\times(r_1+r_2-1)$ matrix having $\pm1$
 components, giving the signs of the real embeddings of the fundamental units.
 The following functions compute generators for the totally positive units:
 \bprog
 /* exponents of totally positive units generators on K.tu, K.fu */
 tpuexpo(K)=
 { my(M, S = bnfsignunit(K), [m,n] = matsize(S));
   \\ m = K.r1, n = r1+r2-1
   S = matrix(m,n, i,j, if (S[i,j] < 0, 1,0));
   S = concat(vectorv(m,i,1), S);   \\ add sign(-1)
   M = matkermod(S, 2);
   if (M, mathnfmodid(M, 2), 2*matid(n+1))
 }
 
 /* totally positive fundamental units of bnf K */
 tpu(K)=
 { my(ex = tpuexpo(K)[,^1]); \\ remove ex[,1], corresponds to 1 or -1
   my(v = concat(K.tu[2], K.fu));
   [ nffactorback(K, v, c) | c <- ex];
 }
 @eprog

Function: bnfsunit
Class: basic
Section: number_fields
C-Name: bnfsunit
Prototype: GGp
Help: bnfsunit(bnf,S): compute the fundamental S-units of the number field
 bnf output by bnfinit, S being a list of prime ideals. res[1] contains the
 S-units, res[5] the S-classgroup.
Doc: computes the fundamental $S$-units of the
 number field $\var{bnf}$ (output by \kbd{bnfinit}), where $S$ is a list of
 prime ideals (output by \kbd{idealprimedec}). The output is a vector $v$ with
 6 components.
 
 $v[1]$ gives a minimal system of (integral) generators of the $S$-unit group
 modulo the unit group.
 
 $v[2]$ contains technical data needed by \kbd{bnfissunit}.
 
 $v[3]$ is an obsoleted component, now the empty vector.
 
 $v[4]$ is the $S$-regulator (this is the product of the regulator, the
 $S$-class number and the natural logarithms of the norms of the ideals
 in $S$).
 
 $v[5]$ gives the $S$-class group structure, in the usual abelian group
 format: a vector whose three components give in order the $S$-class number,
 the cyclic components and the generators.
 
 $v[6]$ is a copy of $S$.
Variant: Also available is
 \fun{GEN}{sunits_mod_units}{GEN bnf, GEN S} which returns only $v[1]$.

Function: bnfunits
Class: basic
Section: number_fields
C-Name: bnfunits
Prototype: GDG
Help: bnfunits(bnf,{S}): return the fundamental units of the number field
 bnf output by bnfinit; if S is present and is a list of prime ideals, compute
 fundamental S-units instead. The first component of the result contains the
 S-units, followed by fundamental units, followed by the torsion unit.
 The result may be used as an optional argument to bnfisunit.
Doc: return the fundamental units of the number field
 bnf output by bnfinit; if $S$ is present and is a list of prime ideals,
 compute fundamental $S$-units instead. The first component of the result
 contains independent integral $S$-units generators: first nonunits, then
 $r_1+r_2-1$ fundamental units, then the torsion unit. The result may be used
 as an optional argument to bnfisunit. The units are given in compact form:
 no expensive computation is attempted if the \var{bnf} does not already
 contain units.
 
 \bprog
  ? bnf = bnfinit(x^4 - x^3 + 4*x^2 + 3*x + 9, 1);
  ? bnf.sign   \\ r1 + r2 - 1 = 1
  %2 = [0, 2]
  ? U = bnfunits(bnf); u = U[1];
  ? #u \\ r1 + r2 = 2 units
  %5 = 2;
  ? u[1] \\ fundamental unit as factorization matrix
  %6 =
  [[0, 0, -1, -1]~  1]
 
  [[2, -1, -1, 0]~ -2]
 
  [  [1, 1, 0, 0]~  2]
 
  [ [-1, 1, 1, 1]~ -1]
  ? u[2] \\ torsion unit as factorization matrix
  %7 =
  [[1, -1, 0, 0]~ 1]
  ? [nffactorback(bnf, z) | z <- u]  \\ same units in expanded form
  %8 = [[-1, 1, -1, 0]~, [1, -1, 0, 0]~]
  @eprog
 
  Now an example involving $S$-units for a nontrivial $S$:
  \bprog
  ? S = idealprimedec(bnf,5); #S
  %9 = 2
  ? US = bnfunits(bnf, S); uS = US[1];
  ? g = [nffactorback(bnf, z) | z <- uS] \\ now 4 units
  %11 = [[6, -3, -2, -2]~, [-5, 5, 0, 0]~, [-1, 1, -1, 0]~, [1, -1, 0, 0]~]
  ? bnfisunit(bnf,[10,-40,24,11]~)
  %12 = []~  \\ not a unit
  ? e = bnfisunit(bnf, [10,-40,24,11]~, US)
  %13 = [2, 0, 1, 4]~  \\ ...but an S-unit
  ? nffactorback(bnf, g, e)
  %14 = [10, -40, 24, 11]~
  ? nffactorback(bnf, uS, e) \\ in factored form
  %15 =
  [[6, -3, -2, -2]~  2]
 
  [ [0, 0, -1, -1]~  1]
 
  [ [2, -1, -1, 0]~ -2]
 
  [   [1, 1, 0, 0]~  2]
 
  [  [-1, 1, 1, 1]~ -1]
 
  [  [1, -1, 0, 0]~  4]
  @eprog\noindent Note that in more complicated cases, any \kbd{nffactorback}
  fully expanding an element in factored form could be \emph{very} expensive.
  On the other hand, the final example expands a factorization whose components
  are themselves in factored form, hence the result is a factored form:
  this is a cheap operation.

Function: bnrL1
Class: basic
Section: number_fields
C-Name: bnrL1
Prototype: GDGD0,L,p
Help: bnrL1(bnr, {H}, {flag=0}): bnr being output by bnrinit and
 H being a square matrix defining a congruence subgroup of bnr (the
 trivial subgroup if omitted), for each character of bnr trivial on this
 subgroup, compute L(1, chi) (or equivalently the first nonzero term c(chi)
 of the expansion at s = 0). The binary digits of flag mean 1: if 0 then
 compute the term c(chi) and return [r(chi), c(chi)] where r(chi) is the
 order of L(s, chi) at s = 0, or if 1 then compute the value at s = 1 (and in
 this case, only for nontrivial characters), 2: if 0 then compute the value
 of the primitive L-function attached to chi, if 1 then compute the value
 of the L-function L_S(s, chi) where S is the set of places dividing the
 modulus of bnr (and the infinite places), 3: return also the characters.
Doc: let \var{bnr} be the number field data output by \kbd{bnrinit} and
 \var{H} be a square matrix defining a congruence subgroup of the
 ray class group corresponding to \var{bnr} (the trivial congruence subgroup
 if omitted). This function returns, for each \idx{character} $\chi$ of the ray
 class group which is trivial on $H$, the value at $s = 1$ (or $s = 0$) of the
 abelian $L$-function attached to $\chi$. For the value at $s = 0$, the
 function returns in fact for each $\chi$ a vector $[r_\chi, c_\chi]$ where
 $$L(s, \chi) = c \cdot s^r + O(s^{r + 1})$$
 \noindent near $0$.
 
 The argument \fl\ is optional, its binary digits
 mean 1: compute at $s = 0$ if unset or $s = 1$ if set, 2: compute the
 primitive $L$-function attached to $\chi$ if unset or the $L$-function
 with Euler factors at prime ideals dividing the modulus of \var{bnr} removed
 if set (that is $L_S(s, \chi)$, where $S$ is the
 set of infinite places of the number field together with the finite prime
 ideals dividing the modulus of \var{bnr}), 3: return also the character if
 set.
 \bprog
 K = bnfinit(x^2-229);
 bnr = bnrinit(K,1);
 bnrL1(bnr)
 @eprog\noindent
 returns the order and the first nonzero term of $L(s, \chi)$ at $s = 0$
 where $\chi$ runs through the characters of the class group of
 $K = \Q(\sqrt{229})$. Then
 \bprog
 bnr2 = bnrinit(K,2);
 bnrL1(bnr2,,2)
 @eprog\noindent
 returns the order and the first nonzero terms of $L_S(s, \chi)$ at $s = 0$
 where $\chi$ runs through the characters of the class group of $K$ and $S$ is
 the set of infinite places of $K$ together with the finite prime $2$. Note
 that the ray class group modulo $2$ is in fact the class group, so
 \kbd{bnrL1(bnr2,0)} returns the same answer as \kbd{bnrL1(bnr,0)}.
 
 This function will fail with the message
 \bprog
  *** bnrL1: overflow in zeta_get_N0 [need too many primes].
 @eprog\noindent if the approximate functional equation requires us to sum
 too many terms (if the discriminant of $K$ is too large).

Function: bnrchar
Class: basic
Section: number_fields
C-Name: bnrchar
Prototype: GGDG
Help: bnrchar(G,g,{v}): returns all characters chi on G such that
 chi(g[i]) = e(v[i]); if v is omitted, returns all characters that are
 trivial on the g[i].
Doc: returns all characters $\chi$ on $G$ such that
 $\chi(g_i) = e(v_i)$, where $e(x) = \exp(2i\pi x)$. $G$ is allowed to be a
 \var{bnr} struct (representing a ray class group) or a \var{znstar}
 (representing $(\Z/N\Z)^*$). If $v$ is omitted,
 returns all characters that are trivial on the $g_i$. Else the vectors $g$
 and $v$ must have the same length, the $g_i$ must be elements of $G$, and
 each $v_i$ is a rational number whose denominator must divide the order of
 $g_i$ in $G$.
 
 For convenience, the vector of the $g_i$
 can be replaced by a matrix whose columns give their discrete logarithm
 in $G$, for instance as given by \kbd{bnrisprincipal} if $G$ is a \var{bnr};
 in this particular case, $G$ can be any finite abelian group
 given by a vector of elementary divisors.
 
 \bprog
 ? G = bnrinit(bnfinit(x), [160,[1]], 1); /* (Z/160Z)^* */
 ? G.cyc
 %2 = [8, 4, 2]
 ? g = G.gen;
 ? bnrchar(G, g, [1/2,0,0])
 %4 = [[4, 0, 0]]  \\ a unique character
 ? bnrchar(G, [g[1],g[3]]) \\ all characters trivial on g[1] and g[3]
 %5 = [[0, 1, 0], [0, 2, 0], [0, 3, 0], [0, 0, 0]]
 ? bnrchar(G, [1,0,0;0,1,0;0,0,2])
 %6 = [[0, 0, 1], [0, 0, 0]]  \\ characters trivial on given subgroup
 
 ? G = znstar(75, 1);
 ? bnrchar(G, [2, 7], [11/20, 1/4])
 %8 = [[1, 1]] \\ Dirichlet char: chi(2) = e(11/20), chi(7) = e(1/4)
 @eprog

Function: bnrclassfield
Class: basic
Section: number_fields
C-Name: bnrclassfield
Prototype: GDGD0,L,p
Help: bnrclassfield(bnr,{subgp},{flag=0}): bnr being as output by bnrinit,
 find a relative equation for the class field corresponding to the congruence
 subgroup described by (bnr,subgp). If flag=0, return a vector of polynomials
 such that the compositum of the corresponding fields is the class field; if
 flag=1 return a single relative polynomial; if flag=2 return a single
 absolute polynomial.
Doc: \var{bnr} being as output by \kbd{bnrinit}, returns a relative equation
 for the class field corresponding to the congruence group defined by
 $(\var{bnr},\var{subgp})$ (the full ray class field if \var{subgp} is
 omitted). The subgroup can also be a \typ{INT}~$n$,
 meaning~$n \cdot \text{Cl}_f$. The function also handles a vector of
 subgroup, e.g, from \tet{subgrouplist} and returns the vector of individual
 results in this case.
 
 If $\fl=0$, returns a vector of polynomials such that the compositum of the
 corresponding fields is the class field; if $\fl=1$ returns a single
 polynomial; if $\fl=2$ returns a single absolute polynomial.
 
 \bprog
 ? bnf = bnfinit(y^3+14*y-1); bnf.cyc
 %1 = [4, 2]
 ? pol = bnrclassfield(bnf,,1) \\ Hilbert class field
 %2 = x^8 - 2*x^7 + ... + Mod(11*y^2 - 82*y + 116, y^3 + 14*y - 1)
 ? rnfdisc(bnf,pol)[1]
 %3 = 1
 ? bnr = bnrinit(bnf,3*5*7); bnr.cyc
 %4 = [24, 12, 12, 2]
 ? bnrclassfield(bnr,2) \\ maximal 2-elementary subextension
 %5 = [x^2 + (-21*y - 105), x^2 + (-5*y - 25), x^2 + (-y - 5), x^2 + (-y - 1)]
 \\ quadratic extensions of maximal conductor
 ? bnrclassfield(bnr, subgrouplist(bnr,[2]))
 %6 = [[x^2 - 105], [x^2 + (-105*y^2 - 1260)], [x^2 + (-105*y - 525)],
       [x^2 + (-105*y - 105)]]
 ? #bnrclassfield(bnr,subgrouplist(bnr,[2],1)) \\ all quadratic extensions
 %7 = 15
 @eprog\noindent When the subgroup contains $n \text{Cl}_f$, where $n$ is fixed,
 it is advised to directly compute the \kbd{bnr} modulo $n$ to avoid expensive
 discrete logarithms:
 \bprog
 ? bnf = bnfinit(y^2-5); p = 1594287814679644276013;
 ? bnr = bnrinit(bnf,p); \\ very slow
 time = 24,146 ms.
 ? bnrclassfield(bnr, 2) \\ ... even though the result is trivial
 %3 = [x^2 - 1594287814679644276013]
 ? bnr2 = bnrinit(bnf,p,,2); \\ now fast
 time = 1 ms.
 ? bnrclassfield(bnr2, 2)
 %5 = [x^2 - 1594287814679644276013]
 @eprog\noindent This will save a lot of time when the modulus contains a
 maximal ideal whose residue field is large.

Function: bnrclassno
Class: basic
Section: number_fields
C-Name: bnrclassno0
Prototype: GDGDG
Help: bnrclassno(A,{B},{C}): relative degree of the class field defined by
 A,B,C. [A,{B},{C}] is of type [bnr], [bnr,subgroup], [bnf,modulus],
 or [bnf,modulus,subgroup].
 Faster than bnrinit if only the ray class number is wanted.
Doc: 
  let $A$, $B$, $C$ define a class field $L$ over a ground field $K$
 (of type \kbd{[\var{bnr}]},
 \kbd{[\var{bnr}, \var{subgroup}]},
 or \kbd{[\var{bnf}, \var{modulus}]},
 or \kbd{[\var{bnf}, \var{modulus},\var{subgroup}]},
 \secref{se:CFT}); this function returns the relative degree $[L:K]$.
 
 In particular if $A$ is a \var{bnf} (with units), and $B$ a modulus,
 this function returns the corresponding ray class number modulo $B$.
 One can input the attached \var{bid} (with generators if the subgroup
 $C$ is non trivial) for $B$ instead of the module itself, saving some time.
 
 This function is faster than \kbd{bnrinit} and should be used if only the
 ray class number is desired. See \tet{bnrclassnolist} if you need ray class
 numbers for all moduli less than some bound.
Variant: Also available is
 \fun{GEN}{bnrclassno}{GEN bnf,GEN f} to compute the ray class number
 modulo~$f$.

Function: bnrclassnolist
Class: basic
Section: number_fields
C-Name: bnrclassnolist
Prototype: GG
Help: bnrclassnolist(bnf,list): if list is as output by ideallist or
 similar, gives list of corresponding ray class numbers.
Doc: $\var{bnf}$ being as
 output by \kbd{bnfinit}, and \var{list} being a list of moduli (with units) as
 output by \kbd{ideallist} or \kbd{ideallistarch}, outputs the list of the
 class numbers of the corresponding ray class groups. To compute a single
 class number, \tet{bnrclassno} is more efficient.
 
 \bprog
 ? bnf = bnfinit(x^2 - 2);
 ? L = ideallist(bnf, 100, 2);
 ? H = bnrclassnolist(bnf, L);
 ? H[98]
 %4 = [1, 3, 1]
 ? l = L[1][98]; ids = vector(#l, i, l[i].mod[1])
 %5 = [[98, 88; 0, 1], [14, 0; 0, 7], [98, 10; 0, 1]]
 @eprog
 The weird \kbd{l[i].mod[1]}, is the first component of \kbd{l[i].mod}, i.e.
 the finite part of the conductor. (This is cosmetic: since by construction
 the Archimedean part is trivial, I do not want to see it). This tells us that
 the ray class groups modulo the ideals of norm 98 (printed as \kbd{\%5}) have
 respectively order $1$, $3$ and $1$. Indeed, we may check directly:
 \bprog
 ? bnrclassno(bnf, ids[2])
 %6 = 3
 @eprog

Function: bnrcompositum
Class: basic
Section: number_fields
C-Name: bnrcompositum
Prototype: GG
Help: bnrcompositum(A,B): compositum [bnr,H] of the two abelian extensions
 given by A = [bnr1,H1] and B = [bnr2,H2], where bnr1 and bnr2 are attached
 to the same base field.
Doc: given two abelian extensions $A = \kbd{[bnr1, H1]}$ and
 $B = \kbd{[bnr2, H2]}$, where \kbd{bnr1} and \kbd{bnr2} are two \kbd{bnr}
 structures attached to the same base field, return their compositum
 as \kbd{[bnr, H]}. The modulus attached to \kbd{bnr} need not be the
 conductor of the compositum.
 \bprog
 ? Q = bnfinit(y);
 ? bnr1 = bnrinit(Q, [7, [1]]); bnr1.cyc
 %2 = [6]
 ? bnr2 = bnrinit(Q, [13, [1]]); bnr2.cyc
 %3 = [12]
 ? H1 = Mat(2); bnrclassfield(bnr1, H1)
 %4 = [x^2 + 7]
 ? H2 = Mat(2); bnrclassfield(bnr2, H2)
 %5 = [x^2 - 13]
 ? [bnr,H] = bnrcompositum([bnr1, H1], [bnr2,H2]);
 ? bnrclassfield(bnr,H)
 %7 = [x^2 - 13, x^2 + 7]
 @eprog

Function: bnrconductor
Class: basic
Section: number_fields
C-Name: bnrconductor0
Prototype: GDGDGD0,L,
Help: bnrconductor(A,{B},{C},{flag=0}): conductor f of the subfield of
 the ray class field given by A,B,C. flag is optional and
 can be 0: default, 1: returns [f, Cl_f, H], H subgroup of the ray class
 group modulo f defining the extension, 2: returns [f, bnr(f), H].
Doc: conductor $f$ of the subfield of a ray class field as defined by $[A,B,C]$
 (of type \kbd{[\var{bnr}]},
 \kbd{[\var{bnr}, \var{subgroup}]},
 \kbd{[\var{bnf}, \var{modulus}]} or
 \kbd{[\var{bnf}, \var{modulus}, \var{subgroup}]},
 \secref{se:CFT})
 
 If $\fl = 0$, returns $f$.
 
 If $\fl = 1$, returns $[f, Cl_f, H]$, where $Cl_f$ is the ray class group
 modulo $f$, as a finite abelian group; finally $H$ is the subgroup of $Cl_f$
 defining the extension.
 
 If $\fl = 2$, returns $[f, \var{bnr}(f), H]$, as above except $Cl_f$ is
 replaced by a \kbd{bnr} structure, as output by $\tet{bnrinit}(,f)$, without
 generators unless the input contained a \var{bnr} with generators.
 
 In place of a subgroup $H$, this function also accepts a character
 \kbd{chi}  $=(a_j)$, expressed as usual in terms of the generators
 \kbd{bnr.gen}: $\chi(g_j) = \exp(2i\pi a_j / d_j)$, where $g_j$ has
 order $d_j = \kbd{bnr.cyc[j]}$. In which case, the function returns
 respectively
 
 If $\fl = 0$, the conductor $f$ of $\text{Ker} \chi$.
 
 If $\fl = 1$, $[f, Cl_f, \chi_f]$, where $\chi_f$ is $\chi$ expressed
 on the minimal ray class group, whose modulus is the conductor.
 
 If $\fl = 2$, $[f, \var{bnr}(f), \chi_f]$.
 
 \misctitle{Note} Using this function with $\fl \neq 0$ is usually a
 bad idea and kept for compatibility and convenience only: $\fl = 1$ has
 always been useless, since it is no faster than $\fl = 2$ and returns less
 information; $\fl = 2$ is mostly OK with two subtle drawbacks:
 
 $\bullet$ it returns the full \var{bnr} attached to the full ray class
 group, whereas in applications we only need $Cl_f$ modulo $N$-th powers,
 where $N$ is any multiple of the exponent of $Cl_f/H$. Computing directly the
 conductor, then calling \kbd{bnrinit} with optional argument $N$ avoids this
 problem.
 
 $\bullet$ computing the \var{bnr} needs only be done once for each
 conductor, which is not possible using this function.
 
 For maximal efficiency, the recommended procedure is as follows. Starting
 from data (character or congruence subgroups) attached to a modulus $m$,
 we can first compute the conductors using this function with default $\fl =
 0$. Then for all data with a common conductor $f \mid m$, compute (once!) the
 \var{bnr} attached to $f$ using \kbd{bnrinit} (modulo $N$-th powers for
 a suitable $N$!) and finally map original data to the new \var{bnr} using
 \kbd{bnrmap}.
Variant: 
 Also available are \fun{GEN}{bnrconductor}{GEN bnr, GEN H, long flag}
 and \fun{GEN}{bnrconductormod}{GEN bnr, GEN H, long flag, GEN cycmod}
 which returns ray class groups modulo \kbd{cycmod}-th powers.

Function: bnrconductorofchar
Class: basic
Section: number_fields
C-Name: bnrconductorofchar
Prototype: GG
Obsolete: 2015-11-11
Help: bnrconductorofchar(bnr,chi): this function is obsolete, use bnrconductor.
Doc: This function is obsolete, use \tev{bnrconductor}.

Function: bnrdisc
Class: basic
Section: number_fields
C-Name: bnrdisc0
Prototype: GDGDGD0,L,
Help: bnrdisc(A,{B},{C},{flag=0}): absolute or relative [N,R1,discf] of
 the field defined by A,B,C. [A,{B},{C}] is of type [bnr],
 [bnr,subgroup], [bnf, modulus] or [bnf,modulus,subgroup], where bnf is as
 output by bnfinit, bnr by bnrinit, and
 subgroup is the HNF matrix of a subgroup of the corresponding ray class
 group (if omitted, the trivial subgroup). flag is optional whose binary
 digits mean 1: give relative data; 2: return 0 if modulus is not the
 conductor.
Doc: $A$, $B$, $C$ defining a class field $L$ over a ground field $K$
 (of type \kbd{[\var{bnr}]},
 \kbd{[\var{bnr}, \var{subgroup}]},
 \kbd{[\var{bnr}, \var{character}]},
 \kbd{[\var{bnf}, \var{modulus}]} or
 \kbd{[\var{bnf}, \var{modulus}, \var{subgroup}]},
 \secref{se:CFT}), outputs data $[N,r_1,D]$ giving the discriminant and
 signature of $L$, depending on the binary digits of \fl:
 
 \item 1: if this bit is unset, output absolute data related to $L/\Q$:
 $N$ is the absolute degree $[L:\Q]$, $r_1$ the number of real places of $L$,
 and $D$ the discriminant of $L/\Q$. Otherwise, output relative data for $L/K$:
 $N$ is the relative degree $[L:K]$, $r_1$ is the number of real places of $K$
 unramified in $L$ (so that the number of real places of $L$ is equal to $r_1$
 times $N$), and $D$ is the relative discriminant ideal of $L/K$.
 
 \item 2: if this bit is set and if the modulus is not the conductor of $L$,
 only return 0.

Function: bnrdisclist
Class: basic
Section: number_fields
C-Name: bnrdisclist0
Prototype: GGDG
Help: bnrdisclist(bnf,bound,{arch}): list of discriminants of
 ray class fields of all conductors up to norm bound.
 The ramified Archimedean places are given by arch; all possible values are
 taken if arch is omitted. Supports the alternative syntax
 bnrdisclist(bnf,list), where list is as output by ideallist or ideallistarch
 (with units).
Doc: $\var{bnf}$ being as output by \kbd{bnfinit} (with units), computes a
 list of discriminants of Abelian extensions of the number field by increasing
 modulus norm up to bound \var{bound}. The ramified Archimedean places are
 given by \var{arch}; all possible values are taken if \var{arch} is omitted.
 
 The alternative syntax $\kbd{bnrdisclist}(\var{bnf},\var{list})$ is
 supported, where \var{list} is as output by \kbd{ideallist} or
 \kbd{ideallistarch} (with units), in which case \var{arch} is disregarded.
 
 The output $v$ is a vector, where $v[k]$ is itself a vector $w$, whose length
 is the number of ideals of norm $k$.
 
 \item We consider first the case where \var{arch} was specified. Each
 component of $w$ corresponds to an ideal $m$ of norm $k$, and
 gives invariants attached to the ray class field $L$ of $\var{bnf}$ of
 conductor $[m, \var{arch}]$. Namely, each contains a vector $[m,d,r,D]$ with
 the following meaning: $m$ is the prime ideal factorization of the modulus,
 $d = [L:\Q]$ is the absolute degree of $L$, $r$ is the number of real places
 of $L$, and $D$ is the factorization of its absolute discriminant. We set $d
 = r = D = 0$ if $m$ is not the finite part of a conductor.
 
 \item If \var{arch} was omitted, all $t = 2^{r_1}$ possible values are taken
 and a component of $w$ has the form
 $[m, [[d_1,r_1,D_1], \dots, [d_t,r_t,D_t]]]$,
 where $m$ is the finite part of the conductor as above, and
 $[d_i,r_i,D_i]$ are the invariants of the ray class field of conductor
 $[m,v_i]$, where $v_i$ is the $i$-th Archimedean component, ordered by
 inverse lexicographic order; so $v_1 = [0,\dots,0]$, $v_2 = [1,0\dots,0]$,
 etc. Again, we set $d_i = r_i = D_i = 0$ if $[m,v_i]$ is not a conductor.
 
 Finally, each prime ideal $pr = [p,\alpha,e,f,\beta]$ in the prime
 factorization $m$ is coded as the integer $p\cdot n^2+(f-1)\cdot n+(j-1)$,
 where $n$ is the degree of the base field and $j$ is such that
 
 \kbd{pr = idealprimedec(\var{nf},p)[j]}.
 
 \noindent $m$ can be decoded using \tet{bnfdecodemodule}.
 
 Note that to compute such data for a single field, either \tet{bnrclassno}
 or \tet{bnrdisc} are (much) more efficient.

Function: bnrgaloisapply
Class: basic
Section: number_fields
C-Name: bnrgaloisapply
Prototype: GGG
Help: bnrgaloisapply(bnr, mat, H): apply the automorphism given by its matrix
 mat to the congruence subgroup H given as a HNF matrix. The matrix mat can be
 computed with bnrgaloismatrix.
Doc: apply the automorphism given by its matrix \var{mat} to the congruence
 subgroup $H$ given as a HNF matrix.
 The matrix \var{mat} can be computed with \tet{bnrgaloismatrix}.

Function: bnrgaloismatrix
Class: basic
Section: number_fields
C-Name: bnrgaloismatrix
Prototype: GG
Help: bnrgaloismatrix(bnr,aut): return the matrix of the action of the
 automorphism aut of the base field bnf.nf on the generators of the ray class
 field bnr.gen; aut can be given as a polynomial, or a vector of automorphisms
 or a galois group as output by galoisinit, in which case a vector of matrices
 is returned (in the later case, only for the generators aut.gen).
Doc: return the matrix of the action of the automorphism \var{aut} of the base
 field \kbd{bnf.nf} on the generators of the ray class field \kbd{bnr.gen}.
 The automorphism
 \var{aut} can be given as a polynomial, an algebraic number, or a vector of
 automorphisms and must stabilize the modulus \kbd{bnr.mod}. We also
 allow a Galois group as output by \kbd{galoisinit}, in which case a
 vector of matrices is returned corresponding to the generators
 \kbd{aut.gen}.
 Note: This function only makes sense when the ray class field attached to
 \var{bnr} is Galois, which is not checked.
 
 The generators \kbd{bnr.gen} need not be explicitly computed in the input
 \var{bnr}, which saves time: the result is well defined in this case also.
 
 \bprog
 ? K = bnfinit(a^4-3*a^2+253009); B = bnrinit(K,9); B.cyc
 %1 = [8400, 12, 6, 3]
 ? G = nfgaloisconj(K)
 %2 = [-a, a, -1/503*a^3 + 3/503*a, 1/503*a^3 - 3/503*a]~
 ? bnrgaloismatrix(B, G[2])  \\ G[2] = Id ...
 %3 =
 [1 0 0 0]
 
 [0 1 0 0]
 
 [0 0 1 0]
 
 [0 0 0 1]
 ? bnrgaloismatrix(B, G[3]) \\ automorphism of order 2
 %4 =
 [799 0 0 2800]
 
 [  0 7 0    4]
 
 [  4 0 5    2]
 
 [  0 0 0    2]
 ? M = %^2; for (i=1, #B.cyc, M[i,] %= B.cyc[i]); M
 %5 =  \\ acts on ray class group as automorphism of order 2
 [1 0 0 0]
 
 [0 1 0 0]
 
 [0 0 1 0]
 
 [0 0 0 1]
 @eprog
 
 See \kbd{bnrisgalois} for further examples.
Variant: When $aut$ is a polynomial or an algebraic number,
 \fun{GEN}{bnrautmatrix}{GEN bnr, GEN aut} is available.

Function: bnrinit
Class: basic
Section: number_fields
C-Name: bnrinitmod
Prototype: GGD0,L,DG
Help: bnrinit(bnf,f,{flag=0},{cycmod}): given a bnf as output by
 bnfinit and a modulus f, initializes data
 linked to the ray class group structure corresponding to this module. flag
 is optional, and can be 0: default, 1: compute also the generators. If
 the positive integer cycmod is present, only compute the ray class group
 modulo cycmod-th powers.
Description: 
 (gen,gen,?small):bnr       bnrinit0($1, $2, $3)
Doc: $\var{bnf}$ is as
 output by \kbd{bnfinit} (including fundamental units), $f$ is a modulus,
 initializes data linked to the ray class group structure corresponding to
 this module, a so-called \kbd{bnr} structure. One can input the attached
 \var{bid} with generators for $f$ instead of the module itself, saving some
 time. (As in \tet{idealstar}, the finite part of the conductor may be given
 by a factorization into prime ideals, as produced by \tet{idealfactor}.)
 
 If the positive integer \kbd{cycmod} is present, only compute the ray class
 group modulo \kbd{cycmod}, which may save a lot of time when some maximal
 ideals in $f$ have a huge residue field. In applications, we are given
 a congruence subgroup $H$ and study the class field attached to
 $\text{Cl}_f/H$. If that finite Abelian group has an exponent which divides
 \kbd{cycmod}, then we have changed nothing theoretically, while trivializing
 expensive discrete logs in residue fields (since computations can be
 made modulo \kbd{cycmod}-th powers). This is useful in \kbd{bnrclassfield},
 for instance when computing $p$-elementary extensions.
 
 The following member functions are available
 on the result: \kbd{.bnf} is the underlying \var{bnf},
 \kbd{.mod} the modulus, \kbd{.bid} the \kbd{bid} structure attached to the
 modulus; finally, \kbd{.clgp}, \kbd{.no}, \kbd{.cyc}, \kbd{.gen} refer to the
 ray class group (as a finite abelian group), its cardinality, its elementary
 divisors, its generators (only computed if $\fl = 1$).
 
 The last group of functions are different from the members of the underlying
 \var{bnf}, which refer to the class group; use \kbd{\var{bnr}.bnf.\var{xxx}}
 to access these, e.g.~\kbd{\var{bnr}.bnf.cyc} to get the cyclic decomposition
 of the class group.
 
 They are also different from the members of the underlying \var{bid}, which
 refer to $(\Z_K/f)^*$; use \kbd{\var{bnr}.bid.\var{xxx}} to access these,
 e.g.~\kbd{\var{bnr}.bid.no} to get $\phi(f)$.
 
 If $\fl=0$ (default), the generators of the ray class group are not
 explicitly computed, which saves time. Hence \kbd{\var{bnr}.gen} would
 produce an error. Note that implicit generators are still fixed and stored
 in the \var{bnr} (and guaranteed to be the same for fixed \var{bnf} and
 \var{bid} inputs), in terms of \kbd{bnr.bnf.gen} and \kbd{bnr.bid.gen}.
 The computation which is not performed is the expansion of such products
 in the ray class group so as to fix eplicit ideal representatives.
 
 If $\fl=1$, as the default, except that generators are computed.
Variant: Instead of the above hardcoded  numerical flags,  one should rather use
 \fun{GEN}{Buchraymod}{GEN bnf, GEN module, long flag, GEN cycmod}
 where an omitted \kbd{cycmod} is coded as \kbd{NULL} and flag is an or-ed
 combination of \kbd{nf\_GEN} (include generators) and \kbd{nf\_INIT} (if
 omitted, return just the cardinality of the ray class group and its structure),
 possibly 0. Or simply
   \fun{GEN}{Buchray}{GEN bnf, GEN module, long flag}
 when \kbd{cycmod} is \kbd{NULL}.

Function: bnrisconductor
Class: basic
Section: number_fields
C-Name: bnrisconductor0
Prototype: lGDGDG
Help: bnrisconductor(A,{B},{C}): returns 1 if the modulus is the
 conductor of the subfield of the ray class field given by A,B,C (see
 bnrdisc), and 0 otherwise. Slightly faster than bnrconductor if this is the
 only desired result.
Doc: fast variant of \kbd{bnrconductor}$(A,B,C)$; $A$, $B$, $C$ represent
 an extension of the base field, given by class field theory
 (see~\secref{se:CFT}). Outputs 1 if this modulus is the conductor, and 0
 otherwise. This is slightly faster than \kbd{bnrconductor} when the
 character or subgroup is not primitive.

Function: bnrisgalois
Class: basic
Section: number_fields
C-Name: bnrisgalois
Prototype: lGGG
Help: bnrisgalois(bnr, gal, H): check whether the class field attached to
 the subgroup H is Galois over the subfield of bnr.nf fixed by the Galois
 group gal, which can be given as output by galoisinit, or as a matrix or a
 vector of matrices as output by bnrgaloismatrix. The ray class field
 attached to bnr need to be Galois, which is not checked.
Doc: check whether the class field attached to the subgroup $H$ is Galois
 over the subfield of \kbd{bnr.nf} fixed by the group \var{gal}, which can be
 given as output by \tet{galoisinit}, or as a matrix or a vector of matrices as
 output by \kbd{bnrgaloismatrix}, the second option being preferable, since it
 saves the recomputation of the matrices.  Note: The function assumes that the
 ray class field attached to \var{bnr} is Galois, which is not checked.
 
 In the following example, we lists the congruence subgroups of subextension of
 degree at most $3$ of the ray class field of conductor $9$ which are Galois
 over the rationals.
 
 \bprog
 ? K = bnfinit(a^4-3*a^2+253009); B = bnrinit(K,9); G = galoisinit(K);
 ? [H | H<-subgrouplist(B,3), bnrisgalois(B,G,H)];
 time = 160 ms.
 ? M = bnrgaloismatrix(B,G);
 ? [H | H<-subgrouplist(B,3), bnrisgalois(B,M,H)]
 time = 1 ms.
 @eprog
 The second computation is much faster since \kbd{bnrgaloismatrix(B,G)} is
 computed only once.

Function: bnrisprincipal
Class: basic
Section: number_fields
C-Name: bnrisprincipal
Prototype: GGD1,L,
Help: bnrisprincipal(bnr,x,{flag=1}): bnr being output by bnrinit and x
 being an ideal coprime to bnr.mod, returns [v,alpha], where v is the vector
 of exponents on the ray class group generators and alpha is the generator of
 the resulting principal ideal. If (optional) flag is set to 0, output only v.
Doc: let \var{bnr} be the ray class group data output by
 \kbd{bnrinit}$(,,1)$ and let $x$ be an ideal in any form, coprime
 to the modulus $f = \kbd{bnr.mod}$. Solves the discrete logarithm problem
 in the ray class group, with respect to the generators \kbd{bnr.gen},
 in a way similar to \tet{bnfisprincipal}. If $x$ is not coprime to the
 modulus of \var{bnr} the result is undefined. Note that \var{bnr} need not
 contain the ray class group generators, i.e.~it may be created with
 \kbd{bnrinit}$(,,0)$; in that case, although \kbd{bnr.gen} is undefined, we
 can still fix natural generators for the ray class group (in terms of the
 generators in \kbd{bnr.bnf.gen} and \kbd{bnr.bid.gen}) and compute with
 respect to them.
 
 The binary digits of $\fl$ (default $\fl = 1$) mean:
 
 \item $1$: If set returns a 2-component vector $[e,\alpha]$ where $e$
 is the vector of components of $x$ on the ray class group generators,
 $\alpha$ is an element congruent to $1~\text{mod}^* f$ such that
 $x = \alpha \prod_i g_i^{e_i}$. If unset, returns only $e$.
 
 \item $4$: If set, returns $[e,\alpha]$ where $\alpha$ is given in factored
 form (compact representation). This is orders of magnitude faster.
 
 \bprog
 ? K = bnfinit(x^2 - 30); bnr = bnrinit(K, [4, [1,1]]);
 ? bnr.clgp \\ ray class group is isomorphic to Z/4 x Z/2 x Z/2
 %2 = [16, [4, 2, 2]]
 ? P = idealprimedec(K, 3)[1]; \\ the ramified prime ideal above 3
 ? bnrisprincipal(bnr,P) \\ bnr.gen undefined !
 %5 = [[3, 0, 0]~, 9]
 ? bnrisprincipal(bnr,P, 0) \\ omit principal part
 %5 = [3, 0, 0]~
 ? bnr = bnrinit(bnr, bnr.bid, 1); \\ include explicit generators
 ? bnrisprincipal(bnr,P) \\ ... alpha is different !
 %7 = [[3, 0, 0]~, 1/128625]
 @eprog It may be surprising that the generator $\alpha$ is different
 although the underlying \var{bnf} and \var{bid} are the same. This defines
 unique generators for the ray class group as ideal \emph{classes}, whether
 we use \kbd{bnrinit(,0)} or \kbd{bnrinit(,1)}. But the actual ideal
 representatives (implicit if the flag is $0$, computed and stored in the
 \var{bnr} if the flag is $1$) are in general different and this is what
 happens here. Indeed, the implicit generators are naturally expressed
 in terms of \kbd{bnr.bnf.gen} and \kbd{bnr.bid.gen} and \emph{then}
 expanded and simplified (in the same ideal class) so that we obtain ideal
 representatives for \kbd{bnr.gen} which are as simple as possible.
 And indeed the quotient of the two $\alpha$ found is $1$ modulo the
 conductor (and positive at the infinite places it contains), and this is the
 only guaranteed property.
 
 Beware that, when \kbd{bnr} is generated using \kbd{bnrinit(, cycmod)}, the
 results are given in $\text{Cl}_f$ modulo \kbd{cycmod}-th powers:
 \bprog
 ? bnr2 = bnrinit(K, bnr.mod,, 2);  \\ modulo squares
 ? bnr2.clgp
 %9 = [8, [2, 2, 2]]  \\ bnr.clgp tensored by Z/2Z
 ? bnrisprincipal(bnr2,P, 0)
 %10 = [1, 0, 0]~
 @eprog
Variant: Instead of hardcoded  numerical flags,  one should rather use
 \fun{GEN}{isprincipalray}{GEN bnr, GEN x} for $\kbd{flag} = 0$, and if you
 want generators:
 \bprog
   bnrisprincipal(bnr, x, nf_GEN)
 @eprog
 Also available is
 \fun{GEN}{bnrisprincipalmod}{GEN bnr, GEN x, GEN mod, long flag}
 that returns the discrete logarithm of~$x$ modulo the~\typ{INT}
 \kbd{mod}; the value~$\kbd{mod = NULL}$ is treated as~$0$ (full discrete
 logarithm), and~$\kbd{flag}=1$ is not allowed if~\kbd{mod} is set.

Function: bnrmap
Class: basic
Section: number_fields
C-Name: bnrmap
Prototype: GG
Help: bnrmap(A, B): if A and B are bnr structures for the same bnf attached
 to moduli mA and mB with mB | mA, return the canonical surjection from
 A to B. Alternatively, if A is a map from bnrmap and B is a congruence
 subgroup or ray class character modulo mA, return the corresponding object on
 Cl(mB).
Doc: This function has two different uses:
 
 \item if $A$ and $B$ are \var{bnr} structures for the same \var{bnf} attached
 to moduli $m_A$ and $m_B$ with $m_B \mid m_A$, return the canonical surjection
 from $A$ to $B$, i.e. from the ray class group moodulo $m_A$ to the ray
 class group modulo $m_B$. The map is coded by a triple
 $[M,\var{cyc}_A,\var{cyc}_B]$:
 $M$ gives the image of the fixed ray class group generators of $A$ in
 terms of the ones in $B$, $\var{cyc}_A$ and $\var{cyc}_B$ are the cyclic
 structures \kbd{A.cyc} and \kbd{B.cyc} respectively. Note that this function
 does \emph{not} need $A$ or $B$ to contain explicit generators for the ray
 class groups: they may be created using \kbd{bnrinit(,0)}.
 
 If $B$ is only known modulo $N$-th powers (from \kbd{bnrinit(,N)}), the result
 is correct provided $N$ is a multiple of the exponent of $A$.
 
 \item if $A$ is a projection map as above and $B$ is either a congruence
 subgroup $H$, or a ray class character $\chi$, or a discrete logarithm
 (from \kbd{bnrisprincipal})  modulo $m_A$ whose conductor
 divides $m_B$, return the image of the subgroup (resp. the character, the
 discrete logarighm) as defined modulo $m_B$. The main use of this variant is
 to compute the primitive subgroup or character attached to a \var{bnr} modulo
 their conductor. This is more efficient than \tet{bnrconductor} in two
 respects: the \var{bnr} attached to the conductor need only be computed once
 and, most importantly, the ray class group can be computed modulo $N$-th
 powers, where $N$ is a multiple of the exponent of $\text{Cl}_{m_A} / H$ (resp.
 of the order of $\chi$). Whereas \kbd{bnrconductor} is specified to return a
 \var{bnr} attached to the full ray class group, which may lead to untractable
 discrete logarithms in the full ray class group instead of a tiny quotient.

Function: bnrrootnumber
Class: basic
Section: number_fields
C-Name: bnrrootnumber
Prototype: GGD0,L,p
Help: bnrrootnumber(bnr,chi,{flag=0}): returns the so-called Artin Root
 Number, i.e. the constant W appearing in the functional equation of the
 Hecke L-function attached to chi. Set flag = 1 if the character is known
 to be primitive.
Doc: if $\chi=\var{chi}$ is a
 \idx{character} over \var{bnr}, not necessarily primitive, let
 $L(s,\chi) = \sum_{id} \chi(id) N(id)^{-s}$ be the attached
 \idx{Artin L-function}. Returns the so-called \idx{Artin root number}, i.e.~the
 complex number $W(\chi)$ of modulus 1 such that
 %
 $$\Lambda(1-s,\chi) = W(\chi) \Lambda(s,\overline{\chi})$$
 %
 \noindent where $\Lambda(s,\chi) = A(\chi)^{s/2}\gamma_\chi(s) L(s,\chi)$ is
 the enlarged L-function attached to $L$.
 
 You can set $\fl=1$ if the character is known to be primitive. Example:
 \bprog
 bnf = bnfinit(x^2 - x - 57);
 bnr = bnrinit(bnf, [7,[1,1]]);
 bnrrootnumber(bnr, [2,1])
 @eprog\noindent
 returns the root number of the character $\chi$ of
 $\Cl_{7\infty_1\infty_2}(\Q(\sqrt{229}))$ defined by $\chi(g_1^ag_2^b)
 = \zeta_1^{2a}\zeta_2^b$. Here $g_1, g_2$ are the generators of the
 ray-class group given by \kbd{bnr.gen} and $\zeta_1 = e^{2i\pi/N_1},
 \zeta_2 = e^{2i\pi/N_2}$ where $N_1, N_2$ are the orders of $g_1$ and
 $g_2$ respectively ($N_1=6$ and $N_2=3$ as \kbd{bnr.cyc} readily tells us).

Function: bnrstark
Class: basic
Section: number_fields
C-Name: bnrstark
Prototype: GDGp
Help: bnrstark(bnr,{subgroup}): bnr being as output by
 bnrinit, finds a relative equation for the class field corresponding to
 the module in bnr and the given congruence subgroup (the trivial subgroup if
 omitted) using Stark's units. The ground field and the class field must be
 totally real.
Doc: \var{bnr} being as output by \kbd{bnrinit}, finds a relative equation
 for the class field corresponding to the modulus in \var{bnr} and the given
 congruence subgroup (as usual, omit $\var{subgroup}$ if you want the whole ray
 class group).
 
 The main variable of \var{bnr} must not be $x$, and the ground field and the
 class field must be totally real. When the base field is $\Q$, the vastly
 simpler \tet{galoissubcyclo} is used instead. Here is an example:
 \bprog
 bnf = bnfinit(y^2 - 3);
 bnr = bnrinit(bnf, 5);
 bnrstark(bnr)
 @eprog\noindent
 returns the ray class field of $\Q(\sqrt{3})$ modulo $5$. Usually, one wants
 to apply to the result one of
 \bprog
 rnfpolredbest(bnf, pol)    \\@com compute a reduced relative polynomial
 rnfpolredbest(bnf, pol, 2) \\@com compute a reduced absolute polynomial
 @eprog
 
 The routine uses \idx{Stark units} and needs to find a suitable auxiliary
 conductor, which may not exist when the class field is not cyclic over the
 base. In this case \kbd{bnrstark} is allowed to return a vector of
 polynomials defining \emph{independent} relative extensions, whose compositum
 is the requested class field. We decided that it was useful to keep the
 extra information thus made available, hence the user has to take the
 compositum herself, see \kbd{nfcompositum}.
 
 Even if it exists, the auxiliary conductor may be so large that later
 computations become unfeasible. (And of course, Stark's conjecture may simply
 be wrong.) In case of difficulties, try \tet{bnrclassfield}:
 \bprog
 ? bnr = bnrinit(bnfinit(y^8-12*y^6+36*y^4-36*y^2+9,1), 2);
 ? bnrstark(bnr)
   ***   at top-level: bnrstark(bnr)
   ***                 ^-------------
   *** bnrstark: need 3919350809720744 coefficients in initzeta.
   *** Computation impossible.
 ? bnrclassfield(bnr)
 time = 20 ms.
 %2 = [x^2 + (-2/3*y^6 + 7*y^4 - 14*y^2 + 3)]
 @eprog

Function: break
Class: basic
Section: programming/control
C-Name: break0
Prototype: D1,L,
Help: break({n=1}): interrupt execution of current instruction sequence, and
 exit from the n innermost enclosing loops.
Doc: interrupts execution of current \var{seq}, and
 immediately exits from the $n$ innermost enclosing loops, within the
 current function call (or the top level loop); the integer $n$ must be
 positive. If $n$ is greater than the number of enclosing loops, all
 enclosing loops are exited.

Function: breakpoint
Class: gp
Section: programming/control
C-Name: pari_breakpoint
Prototype: v
Help: breakpoint(): interrupt the program and enter the breakloop. The program
 continues when the breakloop is exited.
Doc: Interrupt the program and enter the breakloop. The program continues when
 the breakloop is exited.
 \bprog
 ? f(N,x)=my(z=x^2+1);breakpoint();gcd(N,z^2+1-z);
 ? f(221,3)
   ***   at top-level: f(221,3)
   ***                 ^--------
   ***   in function f: my(z=x^2+1);breakpoint();gcd(N,z
   ***                              ^--------------------
   ***   Break loop: type <Return> to continue; 'break' to go back to GP
 break> z
 10
 break>
 %2 = 13
 @eprog

Function: call
Class: basic
Section: programming/specific
C-Name: call0
Prototype: GG
Help: call(f, A): A being a vector, evaluates f(A[1],...,A[#A]).
Doc: $A=[a_1,\dots, a_n]$ being a vector and $f$ being a function, returns the
 evaluation of $f(a_1,\dots,a_n)$.
 $f$ can also be the name of a built-in GP function.
 If $\# A =1$, \tet{call}($f,A$) = \tet{apply}($f,A$)[1].
 If $f$ is variadic, the variadic arguments must grouped in a vector in
 the last component of $A$.
 
 This function is useful
 
 \item when writing a variadic function, to call another one:
 \bprog
 fprintf(file,format,args[..]) = write(file,call(strprintf,[format,args]))
 @eprog
 
 \item when dealing with function arguments with unspecified arity
 
 The function below implements a global memoization interface:
 \bprog
 memo=Map();
 memoize(f,A[..])=
 {
   my(res);
   if(!mapisdefined(memo, [f,A], &res),
     res = call(f,A);
     mapput(memo,[f,A],res));
  res;
 }
 @eprog
 for example:
 \bprog
 ? memoize(factor,2^128+1)
 %3 = [59649589127497217,1;5704689200685129054721,1]
 ? ##
   ***   last result computed in 76 ms.
 ? memoize(factor,2^128+1)
 %4 = [59649589127497217,1;5704689200685129054721,1]
 ? ##
   ***   last result computed in 0 ms.
 ? memoize(ffinit,3,3)
 %5 = Mod(1,3)*x^3+Mod(1,3)*x^2+Mod(1,3)*x+Mod(2,3)
 ? fibo(n)=if(n==0,0,n==1,1,memoize(fibo,n-2)+memoize(fibo,n-1));
 ? fibo(100)
 %7 = 354224848179261915075
 @eprog
 
 \item to call operators through their internal names without using
 \kbd{alias}
 \bprog
 matnbelts(M) = call("_*_",matsize(M))
 @eprog

Function: ceil
Class: basic
Section: conversions
C-Name: gceil
Prototype: G
Help: ceil(x): ceiling of x = smallest integer >= x.
Description: 
 (small):small:parens   $1
 (int):int:copy:parens  $1
 (real):int             ceilr($1)
 (mp):int               mpceil($1)
 (gen):gen              gceil($1)
Doc: 
 ceiling of $x$. When $x$ is in $\R$, the result is the
 smallest integer greater than or equal to $x$. Applied to a rational
 function, $\kbd{ceil}(x)$ returns the Euclidean quotient of the numerator by
 the denominator.

Function: centerlift
Class: basic
Section: conversions
C-Name: centerlift0
Prototype: GDn
Help: centerlift(x,{v}): centered lift of x. Same as lift except for
 intmod and padic components.
Description: 
 (pol):pol        centerlift($1)
 (vec):vec        centerlift($1)
 (gen):gen        centerlift($1)
 (pol, var):pol        centerlift0($1, $2)
 (vec, var):vec        centerlift0($1, $2)
 (gen, var):gen        centerlift0($1, $2)
Doc: Same as \tet{lift}, except that \typ{INTMOD} and \typ{PADIC} components
 are lifted using centered residues:
 
 \item for a \typ{INTMOD} $x\in \Z/n\Z$, the lift $y$ is such that
 $-n/2<y\le n/2$.
 
 \item  a \typ{PADIC} $x$ is lifted in the same way as above (modulo
 $p^\kbd{padicprec(x)}$) if its valuation $v$ is nonnegative; if not, returns
 the fraction $p^v$ \kbd{centerlift}$(x p^{-v})$; in particular, rational
 reconstruction is not attempted. Use \tet{bestappr} for this.
 
 For backward compatibility, \kbd{centerlift(x,'v)} is allowed as an alias
 for \kbd{lift(x,'v)}.
 
 \synt{centerlift}{GEN x}.

Function: characteristic
Class: basic
Section: conversions
C-Name: characteristic
Prototype: mG
Help: characteristic(x): characteristic of the base ring over which x is
 defined.
Doc: 
 returns the characteristic of the base ring over which $x$ is defined (as
 defined by \typ{INTMOD} and \typ{FFELT} components). The function raises an
 exception if incompatible primes arise from \typ{FFELT} and \typ{PADIC}
 components.
 \bprog
 ? characteristic(Mod(1,24)*x + Mod(1,18)*y)
 %1 = 6
 @eprog

Function: charconj
Class: basic
Section: number_theoretical
C-Name: charconj0
Prototype: GG
Help: charconj(cyc,chi): given a finite abelian group (by its elementary
 divisors cyc) and a character chi, return the conjugate character.
Doc: let \var{cyc} represent a finite abelian group by its elementary
 divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
 \mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
 allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
 on this group is given by a row vector $\chi = [a_1,\ldots,a_n]$ such that
 $\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
 the generator (of order $d_j$) of the $j$-th cyclic component.
 
 This function returns the conjugate character.
 \bprog
 ? cyc = [15,5]; chi = [1,1];
 ? charconj(cyc, chi)
 %2 = [14, 4]
 ? bnf = bnfinit(x^2+23);
 ? bnf.cyc
 %4 = [3]
 ? charconj(bnf, [1])
 %5 = [2]
 @eprog\noindent For Dirichlet characters (when \kbd{cyc} is
 \kbd{znstar(q,1)}), characters in Conrey representation are available,
 see \secref{se:dirichletchar} or \kbd{??character}:
 \bprog
 ? G = znstar(16, 1);  \\ (Z/16Z)^*
 ? charconj(G, 3)  \\ Conrey label
 %2 = [1, 1]~
 ? znconreyexp(G, %)
 %3 = 11 \\ attached Conrey label; indeed 11 = 3^(-1) mod 16
 ? chi = znconreylog(G, 3);
 ? charconj(G, chi)  \\ Conrey logarithm
 %5 = [1, 1]~
 @eprog
Variant: Also available is
 \fun{GEN}{charconj}{GEN cyc, GEN chi}, when \kbd{cyc} is known to
 be a vector of elementary divisors and \kbd{chi} a compatible character
 (no checks).

Function: chardiv
Class: basic
Section: number_theoretical
C-Name: chardiv0
Prototype: GGG
Help: chardiv(cyc, a,b): given a finite abelian group (by its elementary
 divisors cyc) and two characters a and b, return the character a/b.
Doc: let \var{cyc} represent a finite abelian group by its elementary
 divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
 \mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
 allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
 on this group is given by a row vector $a = [a_1,\ldots,a_n]$ such that
 $\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
 the generator (of order $d_j$) of the $j$-th cyclic component.
 
 Given two characters $a$ and $b$, return the character
 $a / b = a \overline{b}$.
 \bprog
 ? cyc = [15,5]; a = [1,1]; b =  [2,4];
 ? chardiv(cyc, a,b)
 %2 = [14, 2]
 ? bnf = bnfinit(x^2+23);
 ? bnf.cyc
 %4 = [3]
 ? chardiv(bnf, [1], [2])
 %5 = [2]
 @eprog\noindent For Dirichlet characters on  $(\Z/N\Z)^*$, additional
 representations are available (Conrey labels, Conrey logarithm),
 see \secref{se:dirichletchar} or \kbd{??character}.
 If the two characters are in the same format, the
 result is given in the same format, otherwise a Conrey logarithm is used.
 \bprog
 ? G = znstar(100, 1);
 ? G.cyc
 %2 = [20, 2]
 ? a = [10, 1]; \\ usual representation for characters
 ? b = 7; \\ Conrey label;
 ? c = znconreylog(G, 11); \\ Conrey log
 ? chardiv(G, b,b)
 %6 = 1   \\ Conrey label
 ? chardiv(G, a,b)
 %7 = [0, 5]~  \\ Conrey log
 ? chardiv(G, a,c)
 %7 = [0, 14]~   \\ Conrey log
 @eprog
Variant: Also available is
 \fun{GEN}{chardiv}{GEN cyc, GEN a, GEN b}, when \kbd{cyc} is known to
 be a vector of elementary divisors and $a, b$ are compatible characters
 (no checks).

Function: chareval
Class: basic
Section: number_theoretical
C-Name: chareval
Prototype: GGGDG
Help: chareval(G, chi, x, {z}): given an abelian group structure affording
 a discrete logarithm method, e.g. G = znstar(N,1) or a bnr structure,
 let x be an element of G and let chi be a character of G. This function
 returns the value of chi at x, where the encoding depends on the optional
 argument z; if z is omitted, we fix a canonical o-th root of 1, zeta_o,
 where o is the character order and return the rational number c/o where
 chi(x) = (zeta_o)^c.
Doc: 
 Let $G$ be an abelian group structure affording a discrete logarithm
 method, e.g $G = \kbd{znstar}(N, 1)$ for $(\Z/N\Z)^*$ or a \kbd{bnr}
 structure, let $x$ be an element of $G$ and let \var{chi} be a character of
 $G$ (see the note below for details). This function returns the value of
 \var{chi} at~$x$.
 
 \misctitle{Note on characters}
 Let $K$ be some field. If $G$ is an abelian group,
 let $\chi: G \to K^*$ be a character of finite order and let $o$ be a
 multiple of the character order such that $\chi(n) = \zeta^{c(n)}$ for some
 fixed $\zeta\in K^*$ of multiplicative order $o$ and a unique morphism $c: G
 \to (\Z/o\Z,+)$. Our usual convention is to write
 $$G = (\Z/o_1\Z) g_1 \oplus \cdots \oplus (\Z/o_d\Z) g_d$$
 for some generators $(g_i)$ of respective order $d_i$, where the group has
 exponent $o := \text{lcm}_i o_i$. Since $\zeta^o = 1$, the vector $(c_i)$ in
 $\prod (\Z/o_i\Z)$ defines a character $\chi$ on $G$ via $\chi(g_i) =
 \zeta^{c_i (o/o_i)}$ for all $i$. Classical Dirichlet characters have values
 in $K = \C$ and we can take $\zeta = \exp(2i\pi/o)$.
 
 \misctitle{Note on Dirichlet characters}
 In the special case where \var{bid} is attached to $G = (\Z/q\Z)^*$
 (as per \kbd{G = znstar(q,1)}), the Dirichlet
 character \var{chi} can be written in one of the usual 3 formats: a \typ{VEC}
 in terms of \kbd{bid.gen} as above, a \typ{COL} in terms of the Conrey
 generators, or a \typ{INT} (Conrey label);
 see \secref{se:dirichletchar} or \kbd{??character}.
 
 The character value is encoded as follows, depending on the optional
 argument $z$:
 
 \item If $z$ is omitted: return the rational number $c(x)/o$ for $x$ coprime
 to $q$, where we normalize $0\leq c(x) < o$. If $x$ can not be mapped to the
 group (e.g. $x$ is not coprime to the conductor of a Dirichlet or Hecke
 character) we return the sentinel value $-1$.
 
 \item If $z$ is an integer $o$, then we assume that $o$ is a multiple of the
 character order and we return the integer $c(x)$ when $x$ belongs
 to the group, and the sentinel value $-1$ otherwise.
 
 \item $z$ can be of the form $[\var{zeta}, o]$, where \var{zeta}
 is an $o$-th root of $1$ and $o$ is a multiple of the character order.
 We return $\zeta^{c(x)}$ if $x$ belongs to the group, and the sentinel
 value $0$ otherwise. (Note that this coincides  with the usual extension
 of Dirichlet characters to $\Z$, or of Hecke characters to general ideals.)
 
 \item Finally, $z$ can be of the form $[\var{vzeta}, o]$, where
 \var{vzeta} is a vector of powers $\zeta^0, \dots, \zeta^{o-1}$
 of some $o$-th root of $1$ and $o$ is a multiple of the character order.
 As above, we return $\zeta^{c(x)}$ after a table lookup. Or the sentinel
 value $0$.

Function: chargalois
Class: basic
Section: number_theoretical
C-Name: chargalois
Prototype: GDG
Help: chargalois(cyc,{ORD}): let cyc represent a finite abelian group G
 by its elementary divisors cyc, return a list of representatives for the
 Galois orbits of characters of G. If ORD is present, select characters
 depending on their orders: if ORD is a t_INT, restrict to orders less than
 this bound; if ORD is a t_VEC or t_VECSMALL, restrict to orders in the list.
Doc: Let \var{cyc} represent a finite abelian group by its elementary divisors
 (any object which has a \kbd{.cyc} method is also allowed, i.e. the output of
 \kbd{znstar} or \kbd{bnrinit}). Return a list of representatives for the
 Galois orbits of complex characters of $G$.
 If \kbd{ORD} is present, select characters depending on their orders:
 
 \item if \kbd{ORD} is a \typ{INT}, restrict to orders less than this
 bound;
 
 \item if \kbd{ORD} is a \typ{VEC} or \typ{VECSMALL}, restrict to orders in
 the list.
 
 \bprog
 ? G = znstar(96);
 ? #chargalois(G) \\ 16 orbits of characters mod 96
 %2 = 16
 ? #chargalois(G,4) \\ order less than 4
 %3 = 12
 ? chargalois(G,[1,4]) \\ order 1 or 4; 5 orbits
 %4 = [[0, 0, 0], [2, 0, 0], [2, 1, 0], [2, 0, 1], [2, 1, 1]]
 @eprog\noindent
 Given a character $\chi$, of order $n$ (\kbd{charorder(G,chi)}), the
 elements in its orbit are the $\phi(n)$ characters $\chi^i$, $(i,n)=1$.

Function: charker
Class: basic
Section: number_theoretical
C-Name: charker0
Prototype: GG
Help: charker(cyc,chi): given a finite abelian group (by its elementary
 divisors cyc) and a character chi, return its kernel.
Doc: let \var{cyc} represent a finite abelian group by its elementary
 divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
 \mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
 allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
 on this group is given by a row vector $\chi = [a_1,\ldots,a_n]$ such that
 $\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
 the generator (of order $d_j$) of the $j$-th cyclic component.
 
 This function returns the kernel of $\chi$, as a matrix $K$ in HNF which is a
 left-divisor of \kbd{matdiagonal(d)}. Its columns express in terms of
 the $g_j$ the generators of the subgroup. The determinant of $K$ is the
 kernel index.
 \bprog
 ? cyc = [15,5]; chi = [1,1];
 ? charker(cyc, chi)
 %2 =
 [15 12]
 
 [ 0  1]
 
 ? bnf = bnfinit(x^2+23);
 ? bnf.cyc
 %4 = [3]
 ? charker(bnf, [1])
 %5 =
 [3]
 @eprog\noindent Note that for Dirichlet characters (when \kbd{cyc} is
 \kbd{znstar(q, 1)}), characters in Conrey representation are available,
 see \secref{se:dirichletchar} or \kbd{??character}.
 \bprog
 ? G = znstar(8, 1);  \\ (Z/8Z)^*
 ? charker(G, 1) \\ Conrey label for trivial character
 %2 =
 [1 0]
 
 [0 1]
 @eprog
Variant: Also available is
 \fun{GEN}{charker}{GEN cyc, GEN chi}, when \kbd{cyc} is known to
 be a vector of elementary divisors and \kbd{chi} a compatible character
 (no checks).

Function: charmul
Class: basic
Section: number_theoretical
C-Name: charmul0
Prototype: GGG
Help: charmul(cyc, a,b): given a finite abelian group (by its elementary
 divisors cyc) and two characters a and b, return the product character
 ab.
Doc: let \var{cyc} represent a finite abelian group by its elementary
 divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
 \mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
 allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
 on this group is given by a row vector $a = [a_1,\ldots,a_n]$ such that
 $\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
 the generator (of order $d_j$) of the $j$-th cyclic component.
 
 Given two characters $a$ and $b$, return the product character $ab$.
 \bprog
 ? cyc = [15,5]; a = [1,1]; b =  [2,4];
 ? charmul(cyc, a,b)
 %2 = [3, 0]
 ? bnf = bnfinit(x^2+23);
 ? bnf.cyc
 %4 = [3]
 ? charmul(bnf, [1], [2])
 %5 = [0]
 @eprog\noindent For Dirichlet characters on  $(\Z/N\Z)^*$, additional
 representations are available (Conrey labels, Conrey logarithm), see
 \secref{se:dirichletchar} or \kbd{??character}. If the two characters are in
 the same format, their
 product is given in the same format, otherwise a Conrey logarithm is used.
 \bprog
 ? G = znstar(100, 1);
 ? G.cyc
 %2 = [20, 2]
 ? a = [10, 1]; \\ usual representation for characters
 ? b = 7; \\ Conrey label;
 ? c = znconreylog(G, 11); \\ Conrey log
 ? charmul(G, b,b)
 %6 = 49   \\ Conrey label
 ? charmul(G, a,b)
 %7 = [0, 15]~  \\ Conrey log
 ? charmul(G, a,c)
 %7 = [0, 6]~   \\ Conrey log
 @eprog
Variant: Also available is
 \fun{GEN}{charmul}{GEN cyc, GEN a, GEN b}, when \kbd{cyc} is known to
 be a vector of elementary divisors and $a, b$ are compatible characters
 (no checks).

Function: charorder
Class: basic
Section: number_theoretical
C-Name: charorder0
Prototype: GG
Help: charorder(cyc,chi): given a finite abelian group (by its elementary
 divisors cyc) and a character chi, return the order of chi.
Doc: let \var{cyc} represent a finite abelian group by its elementary
 divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
 \mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
 allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
 on this group is given by a row vector $\chi = [a_1,\ldots,a_n]$ such that
 $\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
 the generator (of order $d_j$) of the $j$-th cyclic component.
 
 This function returns the order of the character \kbd{chi}.
 \bprog
 ? cyc = [15,5]; chi = [1,1];
 ? charorder(cyc, chi)
 %2 = 15
 ? bnf = bnfinit(x^2+23);
 ? bnf.cyc
 %4 = [3]
 ? charorder(bnf, [1])
 %5 = 3
 @eprog\noindent For Dirichlet characters (when \kbd{cyc} is
 \kbd{znstar(q, 1)}), characters in Conrey representation are available,
 see \secref{se:dirichletchar} or \kbd{??character}:
 \bprog
 ? G = znstar(100, 1); \\ (Z/100Z)^*
 ? charorder(G, 7)   \\ Conrey label
 %2 = 4
 @eprog
Variant: Also available is
 \fun{GEN}{charorder}{GEN cyc, GEN chi}, when \kbd{cyc} is known to
 be a vector of elementary divisors and \kbd{chi} a compatible character
 (no checks).

Function: charpoly
Class: basic
Section: linear_algebra
C-Name: charpoly0
Prototype: GDnD5,L,
Help: charpoly(A,{v='x},{flag=5}): det(v*Id-A)=characteristic polynomial of
 the matrix or polmod A. flag is optional and ignored unless A is a matrix;
 it may be set to 0 (Le Verrier), 1 (Lagrange interpolation),
 2 (Hessenberg form), 3 (Berkowitz), 4 (modular) if A is integral,
 or 5 (default, choose best method).
 Algorithms 0 (Le Verrier) and 1 (Lagrange) assume that n! is invertible,
 where n is the dimension of the matrix.
Doc: 
 \idx{characteristic polynomial}
 of $A$ with respect to the variable $v$, i.e.~determinant of $v*I-A$ if $A$
 is a square matrix.
 \bprog
 ? charpoly([1,2;3,4]);
 %1 = x^2 - 5*x - 2
 ? charpoly([1,2;3,4],, 't)
 %2 = t^2 - 5*t - 2
 @eprog\noindent
 If $A$ is not a square matrix, the function returns the characteristic
 polynomial of the map ``multiplication by $A$'' if $A$ is a scalar:
 \bprog
 ? charpoly(Mod(x+2, x^3-2))
 %1 = x^3 - 6*x^2 + 12*x - 10
 ? charpoly(I)
 %2 = x^2 + 1
 ? charpoly(quadgen(5))
 %3 = x^2 - x - 1
 ? charpoly(ffgen(ffinit(2,4)))
 %4 = Mod(1, 2)*x^4 + Mod(1, 2)*x^3 + Mod(1, 2)*x^2 + Mod(1, 2)*x + Mod(1, 2)
 @eprog
 
 The value of $\fl$ is only significant for matrices, and we advise to stick
 to the default value. Let $n$ be the dimension of $A$.
 
 If $\fl=0$, same method (Le Verrier's) as for computing the adjoint matrix,
 i.e.~using the traces of the powers of $A$. Assumes that $n!$ is
 invertible; uses $O(n^4)$ scalar operations.
 
 If $\fl=1$, uses Lagrange interpolation which is usually the slowest method.
 Assumes that $n!$ is invertible; uses $O(n^4)$ scalar operations.
 
 If $\fl=2$, uses the Hessenberg form. Assumes that the base ring is a field.
 Uses $O(n^3)$ scalar operations, but suffers from coefficient explosion
 unless the base field is finite or $\R$.
 
 If $\fl=3$, uses Berkowitz's division free algorithm, valid over any
 ring (commutative, with unit). Uses $O(n^4)$ scalar operations.
 
 If $\fl=4$, $x$ must be integral. Uses a modular algorithm: Hessenberg form
 for various small primes, then Chinese remainders.
 
 If $\fl=5$ (default), uses the ``best'' method given $x$.
 This means we use Berkowitz unless the base ring is $\Z$ (use $\fl=4$)
 or a field where coefficient explosion does not occur,
 e.g.~a finite field or the reals (use $\fl=2$).
Variant: Also available are
 \fun{GEN}{charpoly}{GEN x, long v} ($\fl=5$),
 \fun{GEN}{caract}{GEN A, long v} ($\fl=1$),
 \fun{GEN}{carhess}{GEN A, long v} ($\fl=2$),
 \fun{GEN}{carberkowitz}{GEN A, long v} ($\fl=3$) and
 \fun{GEN}{caradj}{GEN A, long v, GEN *pt}. In this
 last case, if \var{pt} is not \kbd{NULL}, \kbd{*pt} receives the address of
 the adjoint matrix of $A$ (see \tet{matadjoint}), so both can be obtained at
 once.

Function: charpow
Class: basic
Section: number_theoretical
C-Name: charpow0
Prototype: GGG
Help: charpow(cyc, a,n): given a finite abelian group (by its elementary
 divisors cyc) a character a and an integer n return the character a^n.
Doc: let \var{cyc} represent a finite abelian group by its elementary
 divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
 \mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
 allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
 on this group is given by a row vector $a = [a_1,\ldots,a_n]$ such that
 $\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
 the generator (of order $d_j$) of the $j$-th cyclic component.
 
 Given $n\in \Z$ and a character $a$, return the character $a^n$.
 \bprog
 ? cyc = [15,5]; a = [1,1];
 ? charpow(cyc, a, 3)
 %2 = [3, 3]
 ? charpow(cyc, a, 5)
 %2 = [5, 0]
 ? bnf = bnfinit(x^2+23);
 ? bnf.cyc
 %4 = [3]
 ? charpow(bnf, [1], 3)
 %5 = [0]
 @eprog\noindent For Dirichlet characters on  $(\Z/N\Z)^*$, additional
 representations are available (Conrey labels, Conrey logarithm), see
 \secref{se:dirichletchar} or \kbd{??character} and the output uses the
 same format as the input.
 \bprog
 ? G = znstar(100, 1);
 ? G.cyc
 %2 = [20, 2]
 ? a = [10, 1]; \\ standard representation for characters
 ? b = 7; \\ Conrey label;
 ? c = znconreylog(G, 11); \\ Conrey log
 ? charpow(G, a,3)
 %6 = [10, 1]   \\ standard representation
 ? charpow(G, b,3)
 %7 = 43   \\ Conrey label
 ? charpow(G, c,3)
 %8 = [1, 8]~  \\ Conrey log
 @eprog
Variant: Also available is
 \fun{GEN}{charpow}{GEN cyc, GEN a, GEN n}, when \kbd{cyc} is known to
 be a vector of elementary divisors (no check).

Function: chinese
Class: basic
Section: number_theoretical
C-Name: chinese
Prototype: GDG
Help: chinese(x,{y}): x,y being both intmods (or polmods) computes z in the
 same residue classes as x and y.
Description: 
 (gen):gen      chinese1($1)
 (gen, gen):gen chinese($1, $2)
Doc: if $x$ and $y$ are both intmods or both polmods, creates (with the same
 type) a $z$ in the same residue class as $x$ and in the same residue class as
 $y$, if it is possible.
 \bprog
 ? chinese(Mod(1,2), Mod(2,3))
 %1 = Mod(5, 6)
 ? chinese(Mod(x,x^2-1), Mod(x+1,x^2+1))
 %2 = Mod(-1/2*x^2 + x + 1/2, x^4 - 1)
 @eprog\noindent
 This function also allows vector and matrix arguments, in which case the
 operation is recursively applied to each component of the vector or matrix.
 \bprog
 ? chinese([Mod(1,2),Mod(1,3)], [Mod(1,5),Mod(2,7)])
 %3 = [Mod(1, 10), Mod(16, 21)]
 @eprog\noindent
 For polynomial arguments in the same variable, the function is applied to each
 coefficient; if the polynomials have different degrees, the high degree terms
 are copied verbatim in the result, as if the missing high degree terms in the
 polynomial of lowest degree had been \kbd{Mod(0,1)}. Since the latter
 behavior is usually \emph{not} the desired one, we propose to convert the
 polynomials to vectors of the same length first:
 \bprog
  ? P = x+1; Q = x^2+2*x+1;
  ? chinese(P*Mod(1,2), Q*Mod(1,3))
  %4 = Mod(1, 3)*x^2 + Mod(5, 6)*x + Mod(3, 6)
  ? chinese(Vec(P,3)*Mod(1,2), Vec(Q,3)*Mod(1,3))
  %5 = [Mod(1, 6), Mod(5, 6), Mod(4, 6)]
  ? Pol(%)
  %6 = Mod(1, 6)*x^2 + Mod(5, 6)*x + Mod(4, 6)
 @eprog
 
 If $y$ is omitted, and $x$ is a vector, \kbd{chinese} is applied recursively
 to the components of $x$, yielding a residue belonging to the same class as all
 components of $x$.
 
 Finally $\kbd{chinese}(x,x) = x$ regardless of the type of $x$; this allows
 vector arguments to contain other data, so long as they are identical in both
 vectors.
Variant: \fun{GEN}{chinese1}{GEN x} is also available.

Function: clone
Class: gp2c
Description: 
 (small):small:parens             $1
 (int):int                        gclone($1)
 (real):real                      gclone($1)
 (mp):mp                          gclone($1)
 (vecsmall):vecsmall              gclone($1)
 (vec):vec                        gclone($1)
 (pol):pol                        gclone($1)
 (list):list                      gclone($1)
 (closure):closure                gclone($1)
 (genstr):genstr                  gclone($1)
 (gen):gen                        gclone($1)

Function: cmp
Class: basic
Section: operators
C-Name: cmp_universal
Prototype: iGG
Help: cmp(x,y): compare two arbitrary objects x and y (1 if x>y, 0 if x=y, -1
 if x<y). The function is used to implement sets, and has no useful
 mathematical meaning.
Doc: gives the result of a comparison between arbitrary objects $x$ and $y$
 (as $-1$, $0$ or $1$). The underlying order relation is transitive,
 the function returns $0$ if and only if $x~\kbd{===}~y$. It has no
 mathematical meaning but satisfies the following properties when comparing
 entries of the same type:
 
 \item two \typ{INT}s compare as usual (i.e. \kbd{cmp}$(x,y) < 0$ if and only
 if $x < y$);
 
 \item two \typ{VECSMALL}s of the same length compare lexicographically;
 
 \item two \typ{STR}s compare lexicographically.
 
 In case all components are equal up to the smallest length of the operands,
 the more complex is considered to be larger. More precisely, the longest is
 the largest; when lengths are equal, we have matrix $>$ vector $>$ scalar.
 For example:
 \bprog
 ? cmp(1, 2)
 %1 = -1
 ? cmp(2, 1)
 %2 = 1
 ? cmp(1, 1.0)   \\ note that 1 == 1.0, but (1===1.0) is false.
 %3 = -1
 ? cmp(x + Pi, [])
 %4 = -1
 @eprog\noindent This function is mostly useful to handle sorted lists or
 vectors of arbitrary objects. For instance, if $v$ is a vector, the
 construction \kbd{vecsort(v, cmp)} is equivalent to \kbd{Set(v)}.

Function: component
Class: basic
Section: conversions
C-Name: compo
Prototype: GL
Help: component(x,n): the n'th component of the internal representation of
 x. For vectors or matrices, it is simpler to use x[]. For list objects such
 as nf, bnf, bnr or ell, it is much easier to use member functions starting
 with ".".
Description: 
 (error,small):gen     err_get_compo($1, $2)
 (gen,small):gen       compo($1,$2)
Doc: extracts the $n^{\text{th}}$-component of $x$. This is to be understood
 as follows: every PARI type has one or two initial \idx{code words}. The
 components are counted, starting at 1, after these code words. In particular
 if $x$ is a vector, this is indeed the $n^{\text{th}}$-component of $x$, if
 $x$ is a matrix, the $n^{\text{th}}$ column, if $x$ is a polynomial, the
 $n^{\text{th}}$ coefficient (i.e.~of degree $n-1$), and for power series,
 the $n^{\text{th}}$ significant coefficient.
 
 For polynomials and power series, one should rather use \tet{polcoef}, and
 for vectors and matrices, the \kbd{[$\,$]} operator. Namely, if $x$ is a
 vector, then \tet{x[n]} represents the $n^{\text{th}}$ component of $x$. If
 $x$ is a matrix, \tet{x[m,n]} represents the coefficient of row \kbd{m} and
 column \kbd{n} of the matrix, \tet{x[m,]} represents the $m^{\text{th}}$
 \emph{row} of $x$, and \tet{x[,n]} represents the $n^{\text{th}}$
 \emph{column} of $x$.
 
 Using of this function requires detailed knowledge of the structure of the
 different PARI types, and thus it should almost never be used directly.
 Some useful exceptions:
 \bprog
     ? x = 3 + O(3^5);
     ? component(x, 2)
     %2 = 81   \\ p^(p-adic accuracy)
     ? component(x, 1)
     %3 = 3    \\ p
     ? q = Qfb(1,2,3);
     ? component(q, 1)
     %5 = 1
 @eprog

Function: concat
Class: basic
Section: linear_algebra
C-Name: gconcat
Prototype: GDG
Help: concat(x,{y}): concatenation of x and y, which can be scalars, vectors
 or matrices, or lists (in this last case, both x and y have to be lists). If
 y is omitted, x has to be a list or row vector and its elements are
 concatenated.
Description: 
 (vecvecsmall,vecvecsmall):vecvecsmall gconcat($1, $2)
 (vecvecsmall):vecsmall                gconcat1($1)
 (mp,mp):vec           gconcat($1, $2)
 (vec,mp):vec          gconcat($1, $2)
 (mp,vec):vec          gconcat($1, $2)
 (vec,vec):vec         gconcat($1, $2)
 (list,list):list      gconcat($1, $2)
 (genstr,gen):genstr   gconcat($1, $2)
 (gen,genstr):genstr   gconcat($1, $2)
 (gen):gen             gconcat1($1)
 (gen,):gen            gconcat1($1)
 (gen,gen):gen         gconcat($1, $2)
Doc: concatenation of $x$ and $y$. If $x$ or $y$ is
 not a vector or matrix, it is considered as a one-dimensional vector. All
 types are allowed for $x$ and $y$, but the sizes must be compatible. Note
 that matrices are concatenated horizontally, i.e.~the number of rows stays
 the same. Using transpositions, one can concatenate them vertically,
 but it is often simpler to use \tet{matconcat}.
 \bprog
 ? x = matid(2); y = 2*matid(2);
 ? concat(x,y)
 %2 =
 [1 0 2 0]
 
 [0 1 0 2]
 ? concat(x~,y~)~
 %3 =
 [1 0]
 
 [0 1]
 
 [2 0]
 
 [0 2]
 ? matconcat([x;y])
 %4 =
 [1 0]
 
 [0 1]
 
 [2 0]
 
 [0 2]
 @eprog\noindent
 To concatenate vectors sideways (i.e.~to obtain a two-row or two-column
 matrix), use \tet{Mat} instead, or \tet{matconcat}:
 \bprog
 ? x = [1,2];
 ? y = [3,4];
 ? concat(x,y)
 %3 = [1, 2, 3, 4]
 
 ? Mat([x,y]~)
 %4 =
 [1 2]
 
 [3 4]
 ? matconcat([x;y])
 %5 =
 [1 2]
 
 [3 4]
 @eprog
 Concatenating a row vector to a matrix having the same number of columns will
 add the row to the matrix (top row if the vector is $x$, i.e.~comes first, and
 bottom row otherwise).
 
 The empty matrix \kbd{[;]} is considered to have a number of rows compatible
 with any operation, in particular concatenation. (Note that this is
 \emph{not} the case for empty vectors \kbd{[~]} or \kbd{[~]\til}.)
 
 If $y$ is omitted, $x$ has to be a row vector or a list, in which case its
 elements are concatenated, from left to right, using the above rules.
 \bprog
 ? concat([1,2], [3,4])
 %1 = [1, 2, 3, 4]
 ? a = [[1,2]~, [3,4]~]; concat(a)
 %2 =
 [1 3]
 
 [2 4]
 
 ? concat([1,2; 3,4], [5,6]~)
 %3 =
 [1 2 5]
 
 [3 4 6]
 ? concat([%, [7,8]~, [1,2,3,4]])
 %5 =
 [1 2 5 7]
 
 [3 4 6 8]
 
 [1 2 3 4]
 @eprog
Variant: \fun{GEN}{gconcat1}{GEN x} is a shortcut for \kbd{gconcat(x,NULL)}.

Function: conj
Class: basic
Section: conversions
C-Name: gconj
Prototype: G
Help: conj(x): the algebraic conjugate of x.
Doc: 
 conjugate of $x$. The meaning of this
 is clear, except that for real quadratic numbers, it means conjugation in the
 real quadratic field. This function has no effect on integers, reals,
 intmods, fractions or $p$-adics. The only forbidden type is polmod
 (see \kbd{conjvec} for this).

Function: conjvec
Class: basic
Section: conversions
C-Name: conjvec
Prototype: Gp
Help: conjvec(z): conjugate vector of the algebraic number z.
Doc: 
 conjugate vector representation of $z$. If $z$ is a
 polmod, equal to \kbd{Mod}$(a,T)$, this gives a vector of length
 $\text{degree}(T)$ containing:
 
 \item the complex embeddings of $z$ if $T$ has rational coefficients,
 i.e.~the $a(r[i])$ where $r = \kbd{polroots}(T)$;
 
 \item the conjugates of $z$ if $T$ has some intmod coefficients;
 
 \noindent if $z$ is a finite field element, the result is the vector of
 conjugates $[z,z^p,z^{p^2},\ldots,z^{p^{n-1}}]$ where $n=\text{degree}(T)$.
 
 \noindent If $z$ is an integer or a rational number, the result is~$z$. If
 $z$ is a (row or column) vector, the result is a matrix whose columns are
 the conjugate vectors of the individual elements of $z$.

Function: content
Class: basic
Section: number_theoretical
C-Name: content0
Prototype: GDG
Help: content(x,{D}): gcd of all the components of x, when this makes sense.
Doc: computes the gcd of all the coefficients of $x$,
 when this gcd makes sense. This is the natural definition
 if $x$ is a polynomial (and by extension a power series) or a
 vector/matrix. This is in general a weaker notion than the \emph{ideal}
 generated by the coefficients:
 \bprog
 ? content(2*x+y)
 %1 = 1            \\ = gcd(2,y) over Q[y]
 @eprog
 
 If $x$ is a scalar, this simply returns the absolute value of $x$ if $x$ is
 rational (\typ{INT} or \typ{FRAC}), and either $1$ (inexact input) or $x$
 (exact input) otherwise; the result should be identical to \kbd{gcd(x, 0)}.
 
 The content of a rational function is the ratio of the contents of the
 numerator and the denominator. In recursive structures, if a
 matrix or vector \emph{coefficient} $x$ appears, the gcd is taken
 not with $x$, but with its content:
 \bprog
 ? content([ [2], 4*matid(3) ])
 %1 = 2
 @eprog\noindent The content of a \typ{VECSMALL} is computed assuming the
 entries are signed integers.
 
 The optional argument $D$ allows to control over which ring we compute
 and get a more predictable behaviour:
 
 \item $1$: we only consider the underlying $\Q$-structure and the
 denominator is a (positive) rational number
 
 \item a simple variable, say \kbd{'x}: all entries are considered as
 rational functions in $K(x)$ for some field $K$ and the content is an
 element of $K$.
 
 \bprog
 ? f = x + 1/y + 1/2;
 ? content(f) \\ as a t_POL in x
 %2 = 1/(2*y)
 ? content(f, 1) \\ Q-content
 %3 = 1/2
 ? content(f, y) \\ as a rational function in y
 %4 = 1/2
 ? g = x^2*y + y^2*x;
 ? content(g, x)
 %6 = y
 ? content(g, y)
 %7 = x
 @eprog

Function: contfrac
Class: basic
Section: number_theoretical
C-Name: contfrac0
Prototype: GDGD0,L,
Help: contfrac(x,{b},{nmax}): continued fraction expansion of x (x
 rational,real or rational function). b and nmax are both optional, where b
 is the vector of numerators of the continued fraction, and nmax is a bound
 for the number of terms in the continued fraction expansion.
Doc: returns the row vector whose components are the partial quotients of the
 \idx{continued fraction} expansion of $x$. In other words, a result
 $[a_0,\dots,a_n]$ means that $x \approx a_0+1/(a_1+\dots+1/a_n)$. The
 output is normalized so that $a_n \neq 1$ (unless we also have $n = 0$).
 
 The number of partial quotients $n+1$ is limited by \kbd{nmax}. If
 \kbd{nmax} is omitted, the expansion stops at the last significant partial
 quotient.
 \bprog
 ? \p19
   realprecision = 19 significant digits
 ? contfrac(Pi)
 %1 = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2]
 ? contfrac(Pi,, 3)  \\ n = 2
 %2 = [3, 7, 15]
 @eprog\noindent
 $x$ can also be a rational function or a power series.
 
 If a vector $b$ is supplied, the numerators are equal to the coefficients
 of $b$, instead of all equal to $1$ as above; more precisely, $x \approx
 (1/b_0)(a_0+b_1/(a_1+\dots+b_n/a_n))$; for a numerical continued fraction
 ($x$ real), the $a_i$ are integers, as large as possible; if $x$ is a
 rational function, they are polynomials with $\deg a_i = \deg b_i + 1$.
 The length of the result is then equal to the length of $b$, unless the next
 partial quotient cannot be reliably computed, in which case the expansion
 stops. This happens when a partial remainder is equal to zero (or too small
 compared to the available significant digits for $x$ a \typ{REAL}).
 
 A direct implementation of the numerical continued fraction
 \kbd{contfrac(x,b)} described above would be
 \bprog
 \\ "greedy" generalized continued fraction
 cf(x, b) =
 { my( a= vector(#b), t );
 
   x *= b[1];
   for (i = 1, #b,
     a[i] = floor(x);
     t = x - a[i]; if (!t || i == #b, break);
     x = b[i+1] / t;
   ); a;
 }
 @eprog\noindent There is some degree of freedom when choosing the $a_i$; the
 program above can easily be modified to derive variants of the standard
 algorithm. In the same vein, although no builtin
 function implements the related \idx{Engel expansion} (a special kind of
 \idx{Egyptian fraction} decomposition: $x = 1/a_1 + 1/(a_1a_2) + \dots$ ),
 it can be obtained as follows:
 \bprog
 \\ n terms of the Engel expansion of x
 engel(x, n = 10) =
 { my( u = x, a = vector(n) );
   for (k = 1, n,
     a[k] = ceil(1/u);
     u = u*a[k] - 1;
     if (!u, break);
   ); a
 }
 @eprog
 
 \misctitle{Obsolete hack} (don't use this): if $b$ is an integer, \var{nmax}
 is ignored and the command is understood as \kbd{contfrac($x,, b$)}.
Variant: Also available are \fun{GEN}{gboundcf}{GEN x, long nmax},
 \fun{GEN}{gcf}{GEN x} and \fun{GEN}{gcf2}{GEN b, GEN x}.

Function: contfraceval
Class: basic
Section: sums
C-Name: contfraceval
Prototype: GGD-1,L,
Help: contfraceval(CF,t,{lim=-1}): given a continued fraction CF from
 contfracinit, evaluate the first lim terms of the continued fraction at t
 (all terms if lim is negative or omitted).
Doc: Given a continued fraction \kbd{CF} output by \kbd{contfracinit}, evaluate
 the first \kbd{lim} terms of the continued fraction at \kbd{t} (all
 terms if \kbd{lim} is negative or omitted; if positive, \kbd{lim} must be
 less than or equal to the length of \kbd{CF}.

Function: contfracinit
Class: basic
Section: sums
C-Name: contfracinit
Prototype: GD-1,L,
Help: contfracinit(M,{lim = -1}): given M representing the power
 series S = sum_{n>=0} M[n+1]z^n, transform it into a continued fraction
 suitable for evaluation.
Doc: Given $M$ representing the power series $S=\sum_{n\ge0} M[n+1]z^n$,
 transform it into a continued fraction in Euler form, using the
 quotient-difference algorithm; restrict to
 $n\leq \kbd{lim}$ if latter is nonnegative. $M$ can be a vector, a power
 series, a polynomial; if the limiting parameter \kbd{lim} is present, a
 rational function is also allowed (and converted to a power series of that
 accuracy).
 
 The result is a 2-component vector $[A,B]$ such that
 $S = M[1] / (1+A[1]z+B[1]z^2/(1+A[2]z+B[2]z^2/(1+\dots 1/(1+A[lim/2]z))))$.
 Does not work if any coefficient of $M$ vanishes, nor for series for
 which certain partial denominators vanish.
Variant: Also available is
 \fun{GEN}{quodif}{GEN M, long n}
 which returns the standard continued fraction, as a vector $C$ such that
 $S = c[1] / (1 + c[2]z / (1+c[3]z/(1+\dots...c[lim]z)))$.

Function: contfracpnqn
Class: basic
Section: number_theoretical
C-Name: contfracpnqn
Prototype: GD-1,L,
Help: contfracpnqn(x, {n=-1}): [p_n,p_{n-1}; q_n,q_{n-1}] corresponding to the
 continued fraction x. If n >= 0 is present, returns all convergents from
 p_0/q_0 up to p_n/q_n.
Doc: when $x$ is a vector or a one-row matrix, $x$
 is considered as the list of partial quotients $[a_0,a_1,\dots,a_n]$ of a
 rational number, and the result is the 2 by 2 matrix
 $[p_n,p_{n-1};q_n,q_{n-1}]$ in the standard notation of continued fractions,
 so $p_n/q_n=a_0+1/(a_1+\dots+1/a_n)$. If $x$ is a matrix with two rows
 $[b_0,b_1,\dots,b_n]$ and $[a_0,a_1,\dots,a_n]$, this is then considered as a
 generalized continued fraction and we have similarly
 $p_n/q_n=(1/b_0)(a_0+b_1/(a_1+\dots+b_n/a_n))$. Note that in this case one
 usually has $b_0=1$.
 
 If $n \geq 0$ is present, returns all convergents from $p_0/q_0$ up to
 $p_n/q_n$. (All convergents if $x$ is too small to compute the $n+1$
 requested convergents.)
 \bprog
 ? a = contfrac(Pi,10)
 %1 = [3, 7, 15, 1, 292, 1, 1, 1, 3]
 ? allpnqn(x) = contfracpnqn(x,#x) \\ all convergents
 ? allpnqn(a)
 %3 =
 [3 22 333 355 103993 104348 208341 312689 1146408]
 
 [1  7 106 113  33102  33215  66317  99532  364913]
 ? contfracpnqn(a) \\ last two convergents
 %4 =
 [1146408 312689]
 
 [ 364913  99532]
 
 ? contfracpnqn(a,3) \\ first three convergents
 %5 =
 [3 22 333 355]
 
 [1  7 106 113]
 @eprog
Variant: also available is \fun{GEN}{pnqn}{GEN x} for $n = -1$.

Function: copy
Class: gp2c
Description: 
 (small):small:parens             $1
 (int):int                        icopy($1)
 (real):real                      gcopy($1)
 (mp):mp                          gcopy($1)
 (vecsmall):vecsmall              gcopy($1)
 (vec):vec                        gcopy($1)
 (pol):pol                        gcopy($1)
 (list):list                      listinit($1)
 (gen):gen                        gcopy($1)

Function: core
Class: basic
Section: number_theoretical
C-Name: core0
Prototype: GD0,L,
Help: core(n,{flag=0}): unique squarefree integer d
 dividing n such that n/d is a square. If (optional) flag is nonzero, output
 the two-component row vector [d,f], where d is the unique squarefree integer
 dividing n such that n/d=f^2 is a square.
Doc: if $n$ is an integer written as
 $n=df^2$ with $d$ squarefree, returns $d$. If $\fl$ is nonzero,
 returns the two-element row vector $[d,f]$. By convention, we write $0 = 0
 \times 1^2$, so \kbd{core(0, 1)} returns $[0,1]$.
Variant: Also available are \fun{GEN}{core}{GEN n} ($\fl = 0$) and
 \fun{GEN}{core2}{GEN n} ($\fl = 1$)

Function: coredisc
Class: basic
Section: number_theoretical
C-Name: coredisc0
Prototype: GD0,L,
Help: coredisc(n,{flag=0}): discriminant of the quadratic field Q(sqrt(n)).
 If (optional) flag is nonzero, output a two-component row vector [d,f],
 where d is the discriminant of the quadratic field Q(sqrt(n)) and n=df^2. f
 may be a half integer.
Doc: a \emph{fundamental discriminant} is an integer of the form $t\equiv 1
 \mod 4$ or $4t \equiv 8,12 \mod 16$, with $t$ squarefree (i.e.~$1$ or the
 discriminant of a quadratic number field). Given a nonzero integer
 $n$, this routine returns the (unique) fundamental discriminant $d$
 such that $n=df^2$, $f$ a positive rational number. If $\fl$ is nonzero,
 returns the two-element row vector $[d,f]$. If $n$ is congruent to
 0 or 1 modulo 4, $f$ is an integer, and a half-integer otherwise.
 
 By convention, \kbd{coredisc(0, 1))} returns $[0,1]$.
 
 Note that \tet{quaddisc}$(n)$ returns the same value as \kbd{coredisc}$(n)$,
 and also works with rational inputs $n\in\Q^*$.
Variant: Also available are \fun{GEN}{coredisc}{GEN n} ($\fl = 0$) and
 \fun{GEN}{coredisc2}{GEN n} ($\fl = 1$)

Function: cos
Class: basic
Section: transcendental
C-Name: gcos
Prototype: Gp
Help: cos(x): cosine of x.
Description: 
 (real):real         mpcos($1)
 (mp):real:prec      gcos($1, $prec)
 (gen):gen:prec      gcos($1, $prec)
Doc: cosine of $x$.
 Note that, for real $x$, cosine and sine can be obtained simultaneously as
 \bprog
 cs(x) = my(z = exp(I*x)); [real(z), imag(z)];
 @eprog and for general complex $x$ as
 \bprog
 cs2(x) = my(z = exp(I*x), u = 1/z); [(z+u)/2, (z-u)/2];
 @eprog Note that the latter function suffers from catastrophic cancellation
 when $z^2 \approx \pm1$.

Function: cosh
Class: basic
Section: transcendental
C-Name: gcosh
Prototype: Gp
Help: cosh(x): hyperbolic cosine of x.
Description: 
 (mp):real:prec      gcosh($1, $prec)
 (gen):gen:prec      gcosh($1, $prec)
Doc: hyperbolic cosine of $x$.

Function: cotan
Class: basic
Section: transcendental
C-Name: gcotan
Prototype: Gp
Help: cotan(x): cotangent of x.
Description: 
 (mp):real:prec      gcotan($1, $prec)
 (gen):gen:prec      gcotan($1, $prec)
Doc: cotangent of $x$.

Function: cotanh
Class: basic
Section: transcendental
C-Name: gcotanh
Prototype: Gp
Help: cotanh(x): hyperbolic cotangent of x.
Description: 
 (mp):real:prec      gcotanh($1, $prec)
 (gen):gen:prec      gcotanh($1, $prec)
Doc: hyperbolic cotangent of $x$.

Function: dbg_down
Class: gp
Section: programming/control
C-Name: dbg_down
Prototype: vD1,L,
Help: dbg_down({n=1}): (break loop) go down n frames. Cancel a previous dbg_up.
Doc: (In the break loop) go down n frames. This allows to cancel a previous
 call to \kbd{dbg\_up}.
 \bprog
 ? x = 0;
 ? g(x) = x-3;
 ? f(x) = 1 / g(x+1);
 ? for (x = 1, 5, f(x+1))
    ***   at top-level: for(x=1,5,f(x+1))
    ***                           ^-------
    ***   in function f: 1/g(x+1)
    ***                   ^-------
    *** _/_: impossible inverse in gdiv: 0.
    ***   Break loop: type 'break' to go back to GP prompt
 break> dbg_up(3) \\ go up 3 frames
   ***   at top-level: for(x=1,5,f(x+1))
   ***                 ^-----------------
 break> x
 0
 break> dbg_down()
   ***   at top-level: for(x=1,5,f(x+1))
   ***                           ^-------
 break> x
 1
 break> dbg_down()
   ***   at top-level: for(x=1,5,f(x+1))
   ***                           ^-------
 break> x
 1
 break> dbg_down()
   ***   at top-level: for(x=1,5,f(x+1))
   ***                           ^-------
   ***   in function f: 1/g(x+1)
   ***                   ^-------
 break> x
 2
 @eprog\noindent The above example shows that the notion of GP frame is
 finer than the usual stack of function calls (as given for instance by the
 GDB \kbd{backtrace} command): GP frames are attached to variable scopes
 and there are frames attached to control flow instructions such as a
 \kbd{for} loop above.

Function: dbg_err
Class: gp
Section: programming/control
C-Name: dbg_err
Prototype: 
Help: dbg_err(): (break loop) return the error data of the current error, if any.
Doc: In the break loop, return the error data of the current error, if any.
 See \tet{iferr} for details about error data.  Compare:
 \bprog
 ? iferr(1/(Mod(2,12019)^(6!)-1),E,Vec(E))
 %1 = ["e_INV", "Fp_inv", Mod(119, 12019)]
 ? 1/(Mod(2,12019)^(6!)-1)
   ***   at top-level: 1/(Mod(2,12019)^(6!)-
   ***                  ^--------------------
   *** _/_: impossible inverse in Fp_inv: Mod(119, 12019).
   ***   Break loop: type 'break' to go back to GP prompt
 break> Vec(dbg_err())
 ["e_INV", "Fp_inv", Mod(119, 12019)]
 @eprog

Function: dbg_up
Class: gp
Section: programming/control
C-Name: dbg_up
Prototype: vD1,L,
Help: dbg_up({n=1}): (break loop) go up n frames, which allows to inspect data
 of the parent function.
Doc: (In the break loop) go up n frames, which allows to inspect data of the
 parent function. To cancel a \tet{dbg_up} call, use \tet{dbg_down}.
 \bprog
 ? x = 0;
 ? g(x) = x-3;
 ? f(x) = 1 / g(x+1);
 ? for (x = 1, 5, f(x+1))
    ***   at top-level: for(x=1,5,f(x+1))
    ***                           ^-------
    ***   in function f: 1/g(x+1)
    ***                   ^-------
    *** _/_: impossible inverse in gdiv: 0.
    ***   Break loop: type 'break' to go back to GP prompt
  break> x
  2
  break> dbg_up()
    ***   at top-level: for(x=1,5,f(x+1))
    ***                           ^-------
  break> x
  1
  break> dbg_up()
    ***   at top-level: for(x=1,5,f(x+1))
    ***                           ^-------
  break> x
  1
  break> dbg_up()
    ***   at top-level: for(x=1,5,f(x+1))
    ***                 ^-----------------
  break> x
  0
  break> dbg_down()    \\ back up once
    ***   at top-level: for(x=1,5,f(x+1))
    ***                           ^-------
  break> x
  1
 @eprog\noindent The above example shows that the notion of GP frame is
 finer than the usual stack of function calls (as given for instance by the
 GDB \kbd{backtrace} command): GP frames are attached to variable scopes
 and there are frames attached to control flow instructions such as a
 \kbd{for} loop above.

Function: dbg_x
Class: basic
Section: programming/control
C-Name: dbgGEN
Prototype: vGD-1,L,
Help: dbg_x(A,{n}): print inner structure of A, complete if n is omitted, up to
 level n otherwise. Intended for debugging.
Doc: Print the inner structure of \kbd{A}, complete if \kbd{n} is omitted, up
 to level \kbd{n} otherwise. This is useful for debugging. This is similar to
 \b{x} but does not require \kbd{A} to be an history entry. In particular,
 it can be used in the break loop.

Function: default
Class: basic
Section: programming/specific
C-Name: default0
Prototype: DrDs
Help: default({key},{val}): returns the current value of the
 default key. If val is present, set opt to val first. If no argument is
 given, print a list of all defaults as well as their values.
Description: 
 ("realprecision"):small:prec              getrealprecision()
 ("realprecision",small):small:prec        setrealprecision($2, &$prec)
 ("seriesprecision"):small                 precdl
 ("seriesprecision",small):small:parens    precdl = $2
 ("debug"):small                           DEBUGLEVEL
 ("debug",small):small:parens              DEBUGLEVEL = $2
 ("debugmem"):small                        DEBUGMEM
 ("debugmem",small):small:parens           DEBUGMEM = $2
 ("debugfiles"):small                      DEBUGFILES
 ("debugfiles",small):small:parens         DEBUGFILES = $2
 ("factor_add_primes"):small               factor_add_primes
 ("factor_add_primes",small):small         factor_add_primes = $2
 ("factor_proven"):small                   factor_proven
 ("factor_proven",small):small             factor_proven = $2
 ("new_galois_format"):small               new_galois_format
 ("new_galois_format",small):small         new_galois_format = $2
Doc: returns the default corresponding to keyword \var{key}. If \var{val} is
 present, sets the default to \var{val} first (which is subject to string
 expansion first). Typing \kbd{default()} (or \b{d}) yields the complete
 default list as well as their current values. See \secref{se:defaults} for an
 introduction to GP defaults, \secref{se:gp_defaults} for a
 list of available defaults, and \secref{se:meta} for some shortcut
 alternatives. Note that the shortcuts are meant for interactive use and
 usually display more information than \kbd{default}.

Function: denominator
Class: basic
Section: conversions
C-Name: denominator
Prototype: GDG
Help: denominator(f,{D}): denominator of f.
Doc: 
 denominator of $f$. The meaning of this is clear when $f$ is a rational number
 or function. If $f$ is an integer or a polynomial, it is treated as a rational
 number or function, respectively, and the result is equal to $1$. For
 polynomials, you probably want to use
 \bprog
 denominator( content(f) )
 @eprog\noindent instead. As for modular objects, \typ{INTMOD} and \typ{PADIC}
 have denominator $1$, and the denominator of a \typ{POLMOD} is the
 denominator of its lift.
 
 If $f$ is a recursive structure, for instance a vector or matrix, the lcm
 of the denominators of its components (a common denominator) is computed.
 This also applies for \typ{COMPLEX}s and \typ{QUAD}s.
 
 \misctitle{Warning} Multivariate objects are created according to variable
 priorities, with possibly surprising side effects ($x/y$ is a polynomial, but
 $y/x$ is a rational function). See \secref{se:priority}.
 
 The optional argument $D$ allows to control over which ring we compute the
 denominator and get a more predictable behaviour:
 
 \item $1$: we only consider the underlying $\Q$-structure and the
 denominator is a (positive) rational integer
 
 \item a simple variable, say \kbd{'x}: all entries as rational functions
 in $K(x)$ and the denominator is a polynomial in $x$.
 
 \bprog
 ? f = x + 1/y + 1/2;
 ? denominator(f) \\ a t_POL in x
 %2 = 1
 ? denominator(f, 1) \\ Q-denominator
 %3 = 2
 ? denominator(f, x) \\ as a t_POL in x, seen above
 %4 = 1
 ? denominator(f, y) \\ as a rational function in y
 %5 = 2*y
 @eprog
Variant: Also available are
 \fun{GEN}{denom}{GEN x}  which implements the not very useful default
 behaviour ($D$ is \kbd{NULL}) and \fun{GEN}{Q_denom}{GEN x} ($D = 1$).

Function: deriv
Class: basic
Section: polynomials
C-Name: deriv
Prototype: GDn
Help: deriv(x,{v}): derivative of x with respect to v, or to the main
 variable of x if v is omitted.
Doc: derivative of $x$ with respect to the main
 variable if $v$ is omitted, and with respect to $v$ otherwise. The derivative
 of a scalar type is zero, and the derivative of a vector or matrix is done
 componentwise. One can use $x'$ as a shortcut if the derivative is with
 respect to the main variable of $x$; and also use $x''$, etc., for multiple
 derivatives altough \kbd{derivn} is often preferrable.
 
 By definition, the main variable of a \typ{POLMOD} is the main variable among
 the coefficients from its two polynomial components (representative and
 modulus); in other words, assuming a polmod represents an element of
 $R[X]/(T(X))$, the variable $X$ is a mute variable and the derivative is
 taken with respect to the main variable used in the base ring $R$.
 
 \bprog
 ? f = (x/y)^5;
 ? deriv(f)
 %2 = 5/y^5*x^4
 ? f'
 %3 = 5/y^5*x^4
 ? deriv(f, 'x) \\ same since 'x is the main variable
 %4 = 5/y^5*x^4
 ? deriv(f, 'y)
 %5 = -5/y^6*x^5
 @eprog
 
 This function also operates on closures, in which case the variable
 must be omitted. It returns a closure performing a numerical
 differentiation as per \kbd{derivnum}:
 \bprog
 ? f(x) = x^2;
 ? g = deriv(f)
 ? g(1)
 %3 = 2.0000000000000000000000000000000000000
 ? f(x) = sin(exp(x));
 ? deriv(f)(0)
 %5 = 0.54030230586813971740093660744297660373
 ? cos(1)
 %6 = 0.54030230586813971740093660744297660373
 @eprog

Function: derivn
Class: basic
Section: polynomials
C-Name: derivn
Prototype: GLDn
Help: derivn(x,n,{v}): n-th derivative of x with respect to v, or to the main
 variable of x if v is omitted.
Doc: 
 $n$-th derivative of $x$ with respect to the main
 variable if $v$ is omitted, and with respect to $v$ otherwise; the integer
 $n$ must be nonnegative. The derivative
 of a scalar type is zero, and the derivative of a vector or matrix is done
 componentwise. One can use $x'$, $x''$, etc., as a shortcut if the
 derivative is with respect to the main variable of $x$.
 
 By definition, the main variable of a \typ{POLMOD} is the main variable among
 the coefficients from its two polynomial components (representative and
 modulus); in other words, assuming a polmod represents an element of
 $R[X]/(T(X))$, the variable $X$ is a mute variable and the derivative is
 taken with respect to the main variable used in the base ring $R$.
 
 \bprog
 ? f = (x/y)^5;
 ? derivn(f, 2)
 %2 = 20/y^5*x^3
 ? f''
 %3 = 20/y^5*x^3
 ? derivn(f, 2, 'x) \\ same since 'x is the main variable
 %4 = 20/y^5*x^3
 ? derivn(f, 2, 'y)
 %5 = 30/y^7*x^5
 @eprog
 
 This function also operates on closures, in which case the variable
 must be omitted. It returns a closure performing a numerical
 differentiation as per \kbd{derivnum}:
 \bprog
 ? f(x) = x^10;
 ? g = derivn(f, 5)
 ? g(1)
 %3 = 30240.000000000000000000000000000000000
 
 ? derivn(zeta, 2)(0)
 %4 = -2.0063564559085848512101000267299604382
 ? zeta''(0)
 %5 = -2.0063564559085848512101000267299604382
 @eprog

Function: derivnum
Class: basic
Section: sums
C-Name: derivnum0
Prototype: V=GEDGp
Help: derivnum(X=a,expr,{ind=1}): numerical derivation of expr with respect to
 X at X = a. The order of derivation is given by parameter 'ind', which can
 be a vector.
Wrapper: (,Gp)
Description: 
  (gen,gen):gen:prec derivnum(${2 cookie}, ${2 wrapper}, $1, $prec)
  (gen,gen,gen):gen:prec derivfunk(${2 cookie}, ${2 wrapper}, $1, $3, $prec)
Doc: numerical derivation of \var{expr} with respect to $X$ at $X=a$. The
 order of derivation is 1 by default.
 
 \bprog
 ? derivnum(x=0, sin(exp(x))) - cos(1)
 %1 = 0.E-38
 @eprog
 A clumsier approach, which would not work in library mode, is
 \bprog
 ? f(x) = sin(exp(x))
 ? f'(0) - cos(1)
 %2 = 0.E-38
 @eprog
 
 \item When $a$ is a numerical type (integer, rational number, real number or
 \typ{COMPLEX} of such), performs numerical derivation.
 
 \item When $a$ is a (polynomial, rational function or) power series, compute
 \kbd{derivnum(t=a,f)} as $f'(a) = (f(a))'/a'$:
 \bprog
 ? derivnum(x = 1 + t, sqrt(x))
 %1 = 1/2 - 1/4*t + 3/16*t^2 - 5/32*t^3 + ... + O(t^16)
 ? derivnum(x = 1/(1 + t), sqrt(x))
 %2 = 1/2 + 1/4*t - 1/16*t^2 + 1/32*t^3 + ... + O(t^16)
 ? derivnum(x = 1 + t + O(t^17), sqrt(x))
 %3 = 1/2 - 1/4*t + 3/16*t^2 - 5/32*t^3 + ... + O(t^16)
 @eprog
 
 If the parameter \var{ind} is present, it can be
 
 \item a nonnegative integer $m$, in which case we return $f^{(m)}(x)$;
 
 \item or a vector of orders, in which case we return the vector of
 derivatives.
 
 \bprog
 ? derivnum(x = 0, exp(sin(x)), 16) \\ 16-th derivative
 %1 = -52635599.000000000000000000000000000000
 
 ? round( derivnum(x = 0, exp(sin(x)), [0..13]) )  \\ 0-13-th derivatives
 %2 = [1, 1, 1, 0, -3, -8, -3, 56, 217, 64, -2951, -12672, 5973, 309376]
 @eprog
 
 \synt{derivfunk}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN ind, long prec}.
 Also available is
 \fun{GEN}{derivfun}{void *E, GEN (*eval)(void *, GEN), GEN a, long prec}.
 If $a$ is a numerical type (\typ{INT}, \typ{FRAC}, \typ{REAL} or
 \typ{COMPLEX} of such, we have
 \fun{GEN}{derivnumk}{void *E, GEN (*eval)(void *, GEN, long), GEN a, GEN ind, long prec}
 and
 \fun{GEN}{derivnum}{void *E, GEN (*eval)(void *, GEN, long prec), GEN a, long prec}

Function: diffop
Class: basic
Section: polynomials
C-Name: diffop0
Prototype: GGGD1,L,
Help: diffop(x,v,d,{n=1}): apply the differential operator D to x, where D is defined
 by D(v[i])=d[i], where v is a vector of variable names. D is 0 for variables
 outside of v unless they appear as modulus of a POLMOD. If the optional parameter n
 is given, return D^n(x) instead.
Description: 
 (gen,gen,gen,?1):gen    diffop($1, $2, $3)
 (gen,gen,gen,small):gen diffop0($1, $2, $3, $4)
Doc: 
 Let $v$ be a vector of variables, and $d$ a vector of the same length,
 return the image of $x$ by the $n$-power ($1$ if n is not given) of the
 differential operator $D$ that assumes the value \kbd{d[i]} on the variable
 \kbd{v[i]}. The value of $D$ on a scalar type is zero, and $D$ applies
 componentwise to a vector or matrix. When applied to a \typ{POLMOD}, if no
 value is provided for the variable of the modulus, such value is derived
 using the implicit function theorem.
 
 \misctitle{Examples}
 This function can be used to differentiate formal expressions:
 if $E=\exp(X^2)$ then we have $E'=2*X*E$. We derivate $X*exp(X^2)$
 as follows:
 \bprog
 ? diffop(E*X,[X,E],[1,2*X*E])
 %1 = (2*X^2 + 1)*E
 @eprog
 Let \kbd{Sin} and \kbd{Cos} be two function such that
 $\kbd{Sin}^2+\kbd{Cos}^2=1$ and $\kbd{Cos}'=-\kbd{Sin}$. We can differentiate
 $\kbd{Sin}/\kbd{Cos}$ as follows,
 PARI inferring the value of $\kbd{Sin}'$ from the equation:
 \bprog
 ? diffop(Mod('Sin/'Cos,'Sin^2+'Cos^2-1),['Cos],[-'Sin])
 %1 = Mod(1/Cos^2, Sin^2 + (Cos^2 - 1))
 @eprog
 Compute the Bell polynomials (both complete and partial) via the Faa di Bruno
 formula:
 \bprog
 Bell(k,n=-1)=
 { my(x, v, dv, var = i->eval(Str("X",i)));
 
   v = vector(k, i, if (i==1, 'E, var(i-1)));
   dv = vector(k, i, if (i==1, 'X*var(1)*'E, var(i)));
   x = diffop('E,v,dv,k) / 'E;
   if (n < 0, subst(x,'X,1), polcoef(x,n,'X));
 }
 @eprog
Variant: 
 For $n=1$, the function \fun{GEN}{diffop}{GEN x, GEN v, GEN d} is also
 available.

Function: digits
Class: basic
Section: conversions
C-Name: digits
Prototype: GDG
Help: digits(x,{b}): gives the vector formed by the digits of x in base b.
Doc: 
 outputs the vector of the digits of $|x|$ in base $b$, where $x$ and $b$ are
 integers ($b = 10$ by default), from most significant down to least
 significant. For $x\ge1$, the number of digits is
 $\kbd{logint}(x,b) + 1$. See \kbd{fromdigits} for the reverse operation.
 
 We also allow $x$ an integral $p$-adic in which case $b$ should be omitted
 or equal to $p$. Digits are still ordered from most significant to least
 significant in the $p$-adic sense (meaning we start from $x$ mod $p$);
 trailing zeros are truncated.
 \bprog
 ? digits(1230)
 %1 = [1, 2, 3, 0]
 
 ? digits(10, 2) \\ base 2
 %2 = [1, 0, 1, 0]
 @eprog\noindent By convention, $0$ has no digits:
 \bprog
 ? digits(0)
 %3 = []
 ? 1105 + O(5^5)
 %4 = 5 + 4*5^2 + 3*5^3 + O(5^5)
 ? digits(%)
 %5 = [0, 1, 4, 3]
 @eprog

Function: dilog
Class: basic
Section: transcendental
C-Name: dilog
Prototype: Gp
Help: dilog(x): dilogarithm of x.
Doc: principal branch of the dilogarithm of $x$,
 i.e.~analytic continuation of the power series
 $\text{Li}_2(x)=\sum_{n\ge1}x^n/n^2$.

Function: dirdiv
Class: basic
Section: number_theoretical
C-Name: dirdiv
Prototype: GG
Help: dirdiv(x,y): division of the Dirichlet series x by the Dirichlet
 series y.
Doc: $x$ and $y$ being vectors of perhaps different
 lengths but with $y[1]\neq 0$ considered as \idx{Dirichlet series}, computes
 the quotient of $x$ by $y$, again as a vector.

Function: direuler
Class: basic
Section: number_theoretical
C-Name: direuler0
Prototype: V=GGEDG
Help: direuler(p=a,b,expr,{c}): Dirichlet Euler product of expression expr
 from p=a to p=b, limited to b terms. Expr should be a polynomial or rational
 function in p and X, and X is understood to mean p^(-s). If c is present,
 output only the first c terms.
Wrapper: (,,G)
Description: 
  (gen,gen,closure,?gen):gen direuler(${3 cookie}, ${3 wrapper}, $1, $2, $4)
Doc: computes the \idx{Dirichlet series} attached to the
 \idx{Euler product} of expression \var{expr} as $p$ ranges through the primes
 from $a$
 to $b$. \var{expr} must be a polynomial or rational function in another
 variable than $p$ (say $X$) and $\var{expr}(X)$ is understood as the local
 factor $\var{expr}(p^{-s})$.
 
 The series is output as a vector of coefficients. If $c$ is omitted, output
 the first $b$ coefficients of the series; otherwise, output the first $c$
 coefficients. The following command computes the \teb{sigma} function,
 attached to $\zeta(s)\zeta(s-1)$:
 \bprog
 ? direuler(p=2, 10, 1/((1-X)*(1-p*X)))
 %1 = [1, 3, 4, 7, 6, 12, 8, 15, 13, 18]
 
 ? direuler(p=2, 10, 1/((1-X)*(1-p*X)), 5) \\ fewer terms
 %2 = [1, 3, 4, 7, 6]
 @eprog\noindent Setting $c < b$ is useless (the same effect would be
 achieved by setting $b = c)$. If $c > b$, the computed coefficients are
 ``missing'' Euler factors:
 \bprog
 ? direuler(p=2, 10, 1/((1-X)*(1-p*X)), 15) \\ more terms, no longer = sigma !
 %3 = [1, 3, 4, 7, 6, 12, 8, 15, 13, 18, 0, 28, 0, 24, 24]
 @eprog
 
 \synt{direuler}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN b}

Function: dirmul
Class: basic
Section: number_theoretical
C-Name: dirmul
Prototype: GG
Help: dirmul(x,y): multiplication of the Dirichlet series x by the Dirichlet
 series y.
Doc: $x$ and $y$ being vectors of perhaps different lengths representing
 the \idx{Dirichlet series} $\sum_n x_n n^{-s}$ and $\sum_n y_n n^{-s}$,
 computes the product of $x$ by $y$, again as a vector.
 \bprog
 ? dirmul(vector(10,n,1), vector(10,n,moebius(n)))
 %1 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
 @eprog\noindent
 The product
 length is the minimum of $\kbd{\#}x\kbd{*}v(y)$ and $\kbd{\#}y\kbd{*}v(x)$,
 where $v(x)$ is the index of the first nonzero coefficient.
 \bprog
 ? dirmul([0,1], [0,1]);
 %2 = [0, 0, 0, 1]
 @eprog

Function: dirpowers
Class: basic
Section: linear_algebra
C-Name: dirpowers
Prototype: LGp
Help: dirpowers(n,x): return the vector [1^x,2^x,...,n^x].
Doc: for nonnegative $n$ and complex number $x$, return the vector with $n$
 components $[1^x,2^x,\dots,n^x]$.
 \bprog
 ? dirpowers(5, 2)
 %1 = [1, 4, 9, 16, 25]
 ? dirpowers(5, 1/2)
 %2 = [1, 1.414..., 1.732..., 2.000..., 2.236...]
 @eprog\noindent When $n \le 0$, the function returns the empty vector \kbd{[]}.

Function: dirpowerssum
Class: basic
Section: number_theoretical
C-Name: dirpowerssum0
Prototype: GGDGp
Help: dirpowerssum(N,x,{f}): return f(1)1^x + f(2)2^x + ... + f(N)N^x, where
 f is a completely multiplicative function (= 1 if omitted)
Doc: for positive integer $N$ and complex number $x$, return the sum
 $f(1)1^x + f(2)2^x + \dots + f(N)N^x$, where $f$ is a completely
 multiplicative function. If $f$ is omitted, return
 $1^x + \dots + N^x$. When $N \le 0$, the function returns $0$.
 
 Unlike variants using \kbd{dirpowers(N,x)}, this function uses $O(\sqrt{N})$
 memory instead of $O(N)$. And it is faster for large $N$. The return value
 is usually a floating point number, but it will be exact if the result
 is an integer. On the other hand, rational numbers, are converted to
 floating point approximations, since they are likely to blow up for large $N$.
 \bprog
 ? dirpowers(5, 2)
 %1 = [1, 4, 9, 16, 25]
 ? vecsum(%)
 %2 = 55
 ? dirpowerssum(5, 2)
 %3 = 55
 ? dirpowerssum(5, -2)
 %4 = 1.4636111111111111111111111111111111111
 ? \p200
 ? s = 1/2 + I * sqrt(3); N = 10^7;
 ? dirpowerssum(N, s);
 time = 11,425 ms.
 ? vecsum(dirpowers(N, s))
 time = 19,365 ms.
 ? dirpowerssum(N, s, n->kronecker(-23,n))
 time = 10,981 ms.
 
 @eprog\noindent The \kbd{dirpowerssum} commands work with default stack size,
 the \kbd{dirpowers} one requires a stacksize of at least 5GB.
 
 \synt{dirpowerssumfun}{ulong N, GEN x, void *E, GEN (*f)(void*, ulong, long), long prec}. When $f = \kbd{NULL}$, one may use
 \fun{GEN}{dirpowerssum}{ulong N, GEN x, long prec}.

Function: dirzetak
Class: basic
Section: number_fields
C-Name: dirzetak
Prototype: GG
Help: dirzetak(nf,b): Dirichlet series of the Dedekind zeta function of the
 number field nf up to the bound b-1.
Doc: gives as a vector the first $b$
 coefficients of the \idx{Dedekind} zeta function of the number field $\var{nf}$
 considered as a \idx{Dirichlet series}.

Function: divisors
Class: basic
Section: number_theoretical
C-Name: divisors0
Prototype: GD0,L,
Help: divisors(x,{flag=0}): gives a vector formed by the divisors of x in
 increasing order. If flag = 1, return pairs [d, factor(d)].
Description: 
 (gen,?0):vec     divisors($1)
 (gen,1):vec      divisors_factored($1)
Doc: creates a row vector whose components are the
 divisors of $x$. The factorization of $x$ (as output by \tet{factor}) can
 be used instead. If $\fl = 1$, return pairs $[d, \kbd{factor}(d)]$.
 
 By definition, these divisors are the products of the irreducible
 factors of $n$, as produced by \kbd{factor(n)}, raised to appropriate
 powers (no negative exponent may occur in the factorization). If $n$ is
 an integer, they are the positive divisors, in increasing order.
 
 \bprog
 ? divisors(12)
 %1 = [1, 2, 3, 4, 6, 12]
 ? divisors(12, 1) \\ include their factorization
 %2 = [[1, matrix(0,2)], [2, Mat([2, 1])], [3, Mat([3, 1])],
       [4, Mat([2, 2])], [6, [2, 1; 3, 1]], [12, [2, 2; 3, 1]]]
 
 ? divisors(x^4 + 2*x^3 + x^2) \\ also works for polynomials
 %3 = [1, x, x^2, x + 1, x^2 + x, x^3 + x^2, x^2 + 2*x + 1,
       x^3 + 2*x^2 + x, x^4 + 2*x^3 + x^2]
 @eprog
 
 This function requires a lot of memory if $x$ has many divisors. The
 following idiom runs through all divisors using very little memory, in no
 particular order this time:
 \bprog
 F = factor(x); P = F[,1]; E = F[,2];
 forvec(e = vectorv(#E,i,[0,E[i]]), d = factorback(P,e); ...)
 @eprog If the factorization of $d$ is also desired, then $[P,e]$ almost
 provides it but not quite: $e$ may contain $0$ exponents, which are not
 allowed in factorizations. These must be sieved out as in:
 \bprog
 ? tofact(P,E) = matreduce(Mat([P,E]));
 ? tofact([2,3,5,7]~, [4,0,2,0]~)
 %4 =
 [2 4]
 
 [5 2]
 @eprog We can then run the above loop with \kbd{tofact(P,e)} instead of,
 or together with, \kbd{factorback}.
Variant: The functions \fun{GEN}{divisors}{GEN N} ($\fl = 0$) and
 \fun{GEN}{divisors_factored}{GEN N} ($\fl = 1$) are also available.

Function: divisorslenstra
Class: basic
Section: number_theoretical
C-Name: divisorslenstra
Prototype: GGG
Help: divisorslenstra(N, r, s): finds all divisors d of N such that d = r
 (mod s). Assume that (r,s) = 1 and s^3 > N.
Doc: Given three integers $N > s > r \geq 0$ such that $(r,s) = 1$
 and $s^3 > N$, find all divisors $d$ of $N$ such that $d \equiv r \pmod{s}$.
 There are at most $11$ such divisors (Lenstra).
 \bprog
 ? N = 245784; r = 19; s = 65 ;
 ? divisorslenstra(N, r, s)
 %2 = [19, 84, 539, 1254, 3724, 245784]
 ? [ d | d <- divisors(N), d % s == r]
 %3 = [19, 84, 539, 1254, 3724, 245784]
 @eprog\noindent When the preconditions are not met, the result is undefined:
 \bprog
 ? N = 4484075232; r = 7; s = 1303; s^3 > N
 %4 = 0
 ? divisorslenstra(N, r, s)
 ? [ d | d <- divisors(N), d % s == r ]
 %6 = [7, 2613, 9128, 19552, 264516, 3407352, 344928864]
 @eprog\noindent (Divisors were missing but $s^3 < N$.)

Function: divrem
Class: basic
Section: operators
C-Name: divrem
Prototype: GGDn
Help: divrem(x,y,{v}): euclidean division of x by y giving as a
 2-dimensional column vector the quotient and the remainder, with respect to
 v (to main variable if v is omitted).
Doc: creates a column vector with two components, the first being the Euclidean
 quotient (\kbd{$x$ \bs\ $y$}), the second the Euclidean remainder
 (\kbd{$x$ - ($x$\bs$y$)*$y$}), of the division of $x$ by $y$. This avoids the
 need to do two divisions if one needs both the quotient and the remainder.
 If $v$ is present, and $x$, $y$ are multivariate
 polynomials, divide with respect to the variable $v$.
 
 Beware that \kbd{divrem($x$,$y$)[2]} is in general not the same as
 \kbd{$x$ \% $y$}; no GP operator corresponds to it:
 \bprog
 ? divrem(1/2, 3)[2]
 %1 = 1/2
 ? (1/2) % 3
 %2 = 2
 ? divrem(Mod(2,9), 3)[2]
  ***   at top-level: divrem(Mod(2,9),3)[2
  ***                 ^--------------------
  ***   forbidden division t_INTMOD \ t_INT.
 ? Mod(2,9) % 6
 %3 = Mod(2,3)
 @eprog
Variant: Also available is \fun{GEN}{gdiventres}{GEN x, GEN y} when $v$ is
 not needed.

Function: eint1
Class: basic
Section: transcendental
C-Name: veceint1
Prototype: GDGp
Help: eint1(x,{n}): exponential integral E1(x). If n is present and x > 0,
 computes the vector of the first n values of the exponential integral E1(n x).
Doc: exponential integral $\int_x^\infty \dfrac{e^{-t}}{t}\,dt =
 \kbd{incgam}(0, x)$, where the latter expression extends the function
 definition from real $x > 0$ to all complex $x \neq 0$.
 
 If $n$ is present, we must have $x > 0$; the function returns the
 $n$-dimensional vector $[\kbd{eint1}(x),\dots,\kbd{eint1}(nx)]$. Contrary to
 other transcendental functions, and to the default case ($n$ omitted), the
 values are correct up to a bounded \emph{absolute}, rather than relative,
 error $10^{-n}$, where $n$ is \kbd{precision}$(x)$ if $x$ is a \typ{REAL}
 and defaults to \kbd{realprecision} otherwise. (In the most important
 application, to the computation of $L$-functions via approximate functional
 equations, those values appear as weights in long sums and small individual
 relative errors are less useful than controlling the absolute error.) This is
 faster than repeatedly calling \kbd{eint1($i$ * x)}, but less precise.
Variant: Also available is \fun{GEN}{eint1}{GEN x, long prec}.

Function: ell2cover
Class: basic
Section: elliptic_curves
C-Name: ell2cover
Prototype: Gp
Help: ell2cover(E): if E is an elliptic curve over Q, return a basis of the set
 of everywhere locally soluble 2-covers of the curve E. For each cover a pair
 [R,P] is returned where y^2-R(x) is a quartic curve and P belongs to E(k), where
 k = Q(x)[y] / (y^2-R(x)).
Doc: if $E$ is an elliptic curve over $\Q$, return a basis of the set of
 everywhere locally soluble $2$-covers of the curve $E$.
 For each cover a pair $[R,P]$ is returned where $y^2-R(x)$ is a quartic curve
 and $P$ is a point on $E(k)$, where $k = \Q(x)[y] / (y^2-R(x))$.
 $E$ can also be given as the output of \kbd{ellrankinit(E)},
 or as a pair $[e, f]$, where $e$ is an elliptic curve given by
 \kbd{ellrankinit} and $f$ is a quadratic twist of $e$. We then look for
 points on $f$.
 \bprog
 ? E = ellinit([-25,4]);
 ? C = ell2cover(E); #C
 %2 = 2
 ? [R,P] = C[1]; R
 %3 = 64*x^4+480*x^2-128*x+100
 ? P[1]
 %4 = -320/y^2*x^4 + 256/y^2*x^3 + 800/y^2*x^2 - 320/y^2*x - 436/y^2
 ? ellisoncurve(E, Mod(P, y^2-R))
 %5 = 1
 ? H = hyperellratpoints(R,10)
 %6 = [[0,10], [0,-10], [1/5,242/25], [1/5,-242/25], [2/5,282/25],
       [2/5,-282/25]]
 ? A = substvec(P,[x,y],H[1])
 %7 = [-109/25, 686/125]
 @eprog

Function: ellE
Class: basic
Section: transcendental
C-Name: ellE
Prototype: Gp
Help: ellE(k): Complete elliptic integral of the second kind for the
 complex parameter k using the agm.
Doc: Complete elliptic integral of the second kind
 $$E(k)=\int_0^{\pi/2}(1-k^2\sin(t)^2)^{1/2}\,dt$$ for the
 complex parameter $k$ using the agm.
 
 In particular, the perimeter of an ellipse of semi-major and semi-minor axes
 $a$ and $b$ is given by
 \bprog
   e = sqrt(1 - (b/a)^2); \\ eccentricity
   4 * a * ellE(e)  \\ perimeter
 @eprog

Function: ellK
Class: basic
Section: transcendental
C-Name: ellK
Prototype: Gp
Help: ellK(k): Complete elliptic integral of the first kind for the
 complex parameter k using the agm.
Doc: Complete elliptic integral of the first kind
 $$K(k)=\int_0^{\pi/2}(1-k^2\sin(t)^2)^{-1/2}\,dt$$ for the
 complex parameter $k$ using the agm.

Function: ellL1
Class: basic
Section: elliptic_curves
C-Name: ellL1_bitprec
Prototype: GD0,L,b
Help: ellL1(E, {r = 0}): returns the value at s=1 of the derivative of order r of the L-function of the elliptic curve E.
Doc: returns the value at $s=1$ of the derivative of order $r$ of the
 $L$-function of the elliptic curve $E/\Q$.
 \bprog
 ? E = ellinit("11a1"); \\ order of vanishing is 0
 ? ellL1(E)
 %2 = 0.2538418608559106843377589233
 ? E = ellinit("389a1");  \\ order of vanishing is 2
 ? ellL1(E)
 %4 = -5.384067311837218089235032414 E-29
 ? ellL1(E, 1)
 %5 = 0
 ? ellL1(E, 2)
 %6 = 1.518633000576853540460385214
 @eprog\noindent
 The main use of this function, after computing at \emph{low} accuracy the
 order of vanishing using \tet{ellanalyticrank}, is to compute the
 leading term at \emph{high} accuracy to check (or use) the Birch and
 Swinnerton-Dyer conjecture:
 \bprog
 ? \p18
   realprecision = 18 significant digits
 ? E = ellinit("5077a1"); ellanalyticrank(E)
 time = 8 ms.
 %1 = [3, 10.3910994007158041]
 ? \p200
   realprecision = 202 significant digits (200 digits displayed)
 ? ellL1(E, 3)
 time = 104 ms.
 %3 = 10.3910994007158041387518505103609170697263563756570092797@com$[\dots]$
 @eprog\noindent Analogous and more general functionalities for $E$
 defined over general number fields are available through \kbd{lfun}.

Function: elladd
Class: basic
Section: elliptic_curves
C-Name: elladd
Prototype: GGG
Help: elladd(E,z1,z2): sum of the points z1 and z2 on elliptic curve E.
Doc: 
 sum of the points $z1$ and $z2$ on the
 elliptic curve corresponding to $E$.

Function: ellak
Class: basic
Section: elliptic_curves
C-Name: akell
Prototype: GG
Help: ellak(E,n): computes the n-th Fourier coefficient of the L-function of
 the elliptic curve E (assumes E is an integral model).
Doc: 
 computes the coefficient $a_n$ of the $L$-function of the elliptic curve
 $E/\Q$, i.e.~coefficients of a newform of weight 2 by the modularity theorem
 (\idx{Taniyama-Shimura-Weil conjecture}). $E$ must be an \kbd{ell} structure
 over $\Q$ as output by \kbd{ellinit}. $E$ must be given by an integral model,
 not necessarily minimal, although a minimal model will make the function
 faster.
 \bprog
 ? E = ellinit([1,-1,0,4,3]);
 ? ellak(E, 10)
 %2 = -3
 ? e = ellchangecurve(E, [1/5,0,0,0]); \\ made not minimal at 5
 ? ellak(e, 10) \\ wasteful but works
 %3 = -3
 ? E = ellminimalmodel(e); \\ now minimal
 ? ellak(E, 5)
 %5 = -3
 @eprog\noindent If the model is not minimal at a number of bad primes, then
 the function will be slower on those $n$ divisible by the bad primes.
 The speed should be comparable for other $n$:
 \bprog
 ? for(i=1,10^6, ellak(E,5))
 time = 699 ms.
 ? for(i=1,10^6, ellak(e,5)) \\ 5 is bad, markedly slower
 time = 1,079 ms.
 
 ? for(i=1,10^5,ellak(E,5*i))
 time = 1,477 ms.
 ? for(i=1,10^5,ellak(e,5*i)) \\ still slower but not so much on average
 time = 1,569 ms.
 @eprog

Function: ellan
Class: basic
Section: elliptic_curves
C-Name: ellan
Prototype: GL
Help: ellan(E,n): computes the first n Fourier coefficients of the
 L-function of the elliptic curve E defined over a number field
 (n<2^24 on a 32-bit machine).
Doc: computes the vector of the first $n$ Fourier coefficients $a_k$
 corresponding to the elliptic curve $E$ defined over a number field.
 If $E$ is defined over $\Q$, the curve may be given by an
 arbitrary model, not necessarily minimal,
 although a minimal model will make the function faster. Over a more general
 number field, the model must be locally minimal at all primes above $2$
 and $3$.
Variant: Also available is \fun{GEN}{ellanQ_zv}{GEN e, long n}, which
 returns a \typ{VECSMALL} instead of a \typ{VEC}, saving on memory.

Function: ellanalyticrank
Class: basic
Section: elliptic_curves
C-Name: ellanalyticrank_bitprec
Prototype: GDGb
Help: ellanalyticrank(E, {eps}): returns the order of vanishing at s=1
 of the L-function of the elliptic curve E and the value of the first
 nonzero derivative. To determine this order, it is assumed that any
 value less than eps is zero. If no value of eps is given, 2^(-bitprecision/2)
 is used.
Doc: returns the order of vanishing at $s=1$ of the $L$-function of the
 elliptic curve $E/\Q$ and the value of the first nonzero derivative. To
 determine this order, it is assumed that any value less than \kbd{eps} is
 zero. If \kbd{eps} is omitted, $2^{-b/2}$ is used, where $b$
 is the current bit precision.
 \bprog
 ? E = ellinit("11a1"); \\ rank 0
 ? ellanalyticrank(E)
 %2 = [0, 0.2538418608559106843377589233]
 ? E = ellinit("37a1"); \\ rank 1
 ? ellanalyticrank(E)
 %4 = [1, 0.3059997738340523018204836835]
 ? E = ellinit("389a1"); \\ rank 2
 ? ellanalyticrank(E)
 %6 = [2, 1.518633000576853540460385214]
 ? E = ellinit("5077a1"); \\ rank 3
 ? ellanalyticrank(E)
 %8 = [3, 10.39109940071580413875185035]
 @eprog\noindent Analogous and more general functionalities for $E$
 defined over general number fields are available through \kbd{lfun}
 and \kbd{lfunorderzero}.

Function: ellap
Class: basic
Section: elliptic_curves
C-Name: ellap
Prototype: GDG
Help: ellap(E,{p}): given an elliptic curve E defined over
 a finite field Fq, return the trace of Frobenius a_p = q+1-#E(Fq); for other
 fields of definition K, p must define a finite residue field,
 (p prime for K = Qp or Q; p a maximal ideal for K a number field),
 return the order of the (nonsingular) reduction of E.
Doc: 
 Let \kbd{E} be an \kbd{ell} structure as output by \kbd{ellinit}, attached
 to an elliptic curve $E/K$. If the field $K = \F_q$ is finite, return the
 trace of Frobenius $t$, defined by the equation $\#E(\F_q) = q+1 - t$.
 
 For other fields of definition and $p$ defining a finite residue field
 $\F_q$, return the trace of Frobenius for the reduction of $E$: the argument
 $p$ is best left omitted if $K = \Q_\ell$ (else we must have $p = \ell$) and
 must be a prime number ($K = \Q$) or prime ideal ($K$ a general number field)
 with residue field $\F_q$ otherwise. The equation need not be minimal
 or even integral at $p$; of course, a minimal model will be more efficient.
 
 For a number field $K$, the trace of Frobenius is the $a_p$
 coefficient in the Euler product defining the curve $L$-series, whence
 the function name:
 $$L(E/K,s) = \prod_{\text{bad}\ p} (1-a_p (Np)^{-s})^{-1}
              \prod_{\text{good}\ p} (1-a_p (Np)^{-s} + (Np)^{1-2s})^{-1}. $$
 
 When the characteristic of the finite field is large, the availability of
 the \kbd{seadata} package will speed up the computation.
 
 \bprog
 ? E = ellinit([0,1]);  \\ y^2 = x^3 + 0.x + 1, defined over Q
 ? ellap(E, 7) \\ 7 necessary here
 %2 = -4       \\ #E(F_7) = 7+1-(-4) = 12
 ? ellcard(E, 7)
 %3 = 12       \\ OK
 
 ? E = ellinit([0,1], 11);  \\ defined over F_11
 ? ellap(E)       \\ no need to repeat 11
 %4 = 0
 ? ellap(E, 11)   \\ ... but it also works
 %5 = 0
 ? ellgroup(E, 13) \\ ouch, inconsistent input!
    ***   at top-level: ellap(E,13)
    ***                 ^-----------
    *** ellap: inconsistent moduli in Rg_to_Fp:
      11
      13
 ? a = ffgen(ffinit(11,3), 'a); \\ defines F_q := F_{11^3}
 ? E = ellinit([a+1,a]);  \\ y^2 = x^3 + (a+1)x + a, defined over F_q
 ? ellap(E)
 %8 = -3
 @eprog
 
 If the curve is defined over a more general number field than $\Q$,
 the maximal ideal $p$ must be explicitly given in \kbd{idealprimedec}
 format. There is no assumption of local minimality at $p$.
 \bprog
 ? K = nfinit(a^2+1); E = ellinit([1+a,0,1,0,0], K);
 ? fa = idealfactor(K, E.disc)
 %2 =
 [  [5, [-2, 1]~, 1, 1, [2, -1; 1, 2]] 1]
 
 [[13, [5, 1]~, 1, 1, [-5, -1; 1, -5]] 2]
 ? ellap(E, fa[1,1])
 %3 = -1 \\ nonsplit multiplicative reduction
 ? ellap(E, fa[2,1])
 %4 = 1  \\ split multiplicative reduction
 ? P17 = idealprimedec(K,17)[1];
 ? ellap(E, P17)
 %6 = 6  \\ good reduction
 ? E2 = ellchangecurve(E, [17,0,0,0]);
 ? ellap(E2, P17)
 %8 = 6  \\ same, starting from a nonminimal model
 
 ? P3 = idealprimedec(K,3)[1];
 ? ellap(E, P3)  \\ OK: E is minimal at P3
 %10 = -2
 ? E3 = ellchangecurve(E, [3,0,0,0]);
 ? ellap(E3, P3) \\ not integral at P3
  ***   at top-level: ellap(E3,P3)
  ***                 ^------------
  *** ellap: impossible inverse in Rg_to_ff: Mod(0, 3).
 @eprog
 
 \misctitle{Algorithms used} If $E/\F_q$ has CM by a principal imaginary
 quadratic order we use a fast explicit formula (involving essentially
 Kronecker symbols and Cornacchia's algorithm), in $O(\log q)^2$ bit
 operations.
 Otherwise, we use Shanks-Mestre's baby-step/giant-step method, which runs in
 time $\tilde{O}(q^{1/4})$ using $\tilde{O}(q^{1/4})$ storage, hence becomes
 unreasonable when $q$ has about 30~digits. Above this range, the \tet{SEA}
 algorithm becomes available, heuristically in $\tilde{O}(\log q)^4$, and
 primes of the order of 200~digits become feasible.  In small
 characteristic we use Mestre's (p=2), Kohel's (p=3,5,7,13), Satoh-Harley
 (all in $\tilde{O}(p^{2}\*n^2)$) or Kedlaya's (in $\tilde{O}(p\*n^3)$)
 algorithms.

Function: ellbil
Class: basic
Section: elliptic_curves
C-Name: bilhell
Prototype: GGGp
Obsolete: 2014-05-21
Help: ellbil(E,z1,z2): deprecated alias for ellheight(E,P,Q).
Doc: deprecated alias for \kbd{ellheight(E,P,Q)}.

Function: ellbsd
Class: basic
Section: elliptic_curves
C-Name: ellbsd
Prototype: Gp
Help: ellbsd(E): E being an elliptic curve over a number field,
 returns a real number c such that the BSD conjecture predicts that
 lfun(E,1,r)/r! = c*R*S where r is the rank, R is the regulator and S is the
 cardinal of the Tate-Shafarevich group.
Doc: 
 The object $E$ being an elliptic curve over a number field, returns a real
 number $c$ such that the BSD conjecture predicts that
 $L_{E}^{(r)}(1)/r! = c\*R\*S$ where $r$ is the rank, $R$ the regulator and
 $S$ the cardinal of the Tate-Shafarevich group.
 
 \bprog
 ? e = ellinit([0,-1,1,-10,-20]); \\ rank 0
 ? ellbsd(e)
 %2 = 0.25384186085591068433775892335090946105
 ? lfun(e,1)
 %3 = 0.25384186085591068433775892335090946104
 ? e = ellinit([0,0,1,-1,0]); \\ rank 1
 ? P = ellheegner(e);
 ? ellbsd(e)*ellheight(e,P)
 %6 = 0.30599977383405230182048368332167647445
 ? lfun(e,1,1)
 %7 = 0.30599977383405230182048368332167647445
 ? e = ellinit([1+a,0,1,0,0],nfinit(a^2+1)); \\ rank 0
 ? ellbsd(e)
 %9 = 0.42521832235345764503001271536611593310
 ? lfun(e,1)
 %10 = 0.42521832235345764503001271536611593309
 @eprog

Function: ellcard
Class: basic
Section: elliptic_curves
C-Name: ellcard
Prototype: GDG
Help: ellcard(E,{p}): given an elliptic curve E defined over
 a finite field Fq, return the order of the group E(Fq); for other fields
 of definition K, p must define a finite residue field,
 (p prime for K = Qp or Q; p a maximal ideal for K a number field),
 return the order of the (nonsingular) reduction of E.
Doc: Let \kbd{E} be an \kbd{ell} structure as output by \kbd{ellinit}, attached
 to an elliptic curve $E/K$. If $K = \F_q$ is finite, return the order of the
 group $E(\F_q)$.
 \bprog
 ? E = ellinit([-3,1], 5); ellcard(E)
 %1 = 7
 ? t = ffgen(3^5,'t); E = ellinit([t,t^2+1]); ellcard(E)
 %2 = 217
 @eprog\noindent
 For other fields of definition and $p$ defining a finite residue field
 $\F_q$, return the order of the reduction of $E$: the argument $p$ is best
 left omitted if $K = \Q_\ell$ (else we must have $p = \ell$) and must be a
 prime number ($K = \Q$) or prime ideal ($K$ a general number field) with
 residue field $\F_q$ otherwise. The equation need not be minimal
 or even integral at $p$; of course, a minimal model will be more efficient.
 The function considers the group of nonsingular points of the reduction
 of a minimal model of the curve at $p$, so also makes sense when the curve
 has bad reduction.
 \bprog
 ? E = ellinit([-3,1]);
 ? factor(E.disc)
 %2 =
 [2 4]
 
 [3 4]
 ? ellcard(E, 5)  \\ as above !
 %3 = 7
 ? ellcard(E, 2) \\ additive reduction
 %4 = 2
 @eprog
 
 When the characteristic of the finite field is large, the availability of
 the \kbd{seadata} package will speed the computation. See also \tet{ellap}
 for the list of implemented algorithms.
Variant: Also available is \fun{GEN}{ellcard}{GEN E, GEN p} where $p$ is not
 \kbd{NULL}.

Function: ellchangecurve
Class: basic
Section: elliptic_curves
C-Name: ellchangecurve
Prototype: GG
Help: ellchangecurve(E,v): change data on elliptic curve according to
 v=[u,r,s,t].
Description: 
 (gen, gen):ell        ellchangecurve($1, $2)
Doc: 
 changes the data for the elliptic curve $E$
 by changing the coordinates using the vector \kbd{v=[u,r,s,t]}, i.e.~if $x'$
 and $y'$ are the new coordinates, then $x=u^2x'+r$, $y=u^3y'+su^2x'+t$.
 $E$ must be an \kbd{ell} structure as output by \kbd{ellinit}. The special
 case $v = 1$ is also used instead of $[1,0,0,0]$ to denote the
 trivial coordinate change.

Function: ellchangepoint
Class: basic
Section: elliptic_curves
C-Name: ellchangepoint
Prototype: GG
Help: ellchangepoint(x,v): change data on point or vector of points x on an
 elliptic curve according to v=[u,r,s,t].
Doc: 
 changes the coordinates of the point or
 vector of points $x$ using the vector \kbd{v=[u,r,s,t]}, i.e.~if $x'$ and
 $y'$ are the new coordinates, then $x=u^2x'+r$, $y=u^3y'+su^2x'+t$ (see also
 \kbd{ellchangecurve}).
 \bprog
 ? E0 = ellinit([1,1]); P0 = [0,1]; v = [1,2,3,4];
 ? E = ellchangecurve(E0, v);
 ? P = ellchangepoint(P0,v)
 %3 = [-2, 3]
 ? ellisoncurve(E, P)
 %4 = 1
 ? ellchangepointinv(P,v)
 %5 = [0, 1]
 @eprog
Variant: The reciprocal function \fun{GEN}{ellchangepointinv}{GEN x, GEN ch}
 inverts the coordinate change.

Function: ellchangepointinv
Class: basic
Section: elliptic_curves
C-Name: ellchangepointinv
Prototype: GG
Help: ellchangepointinv(x,v): change data on point or vector of points x on an
 elliptic curve according to v=[u,r,s,t], inverse of ellchangepoint.
Doc: 
 changes the coordinates of the point or vector of points $x$ using
 the inverse of the isomorphism attached to \kbd{v=[u,r,s,t]},
 i.e.~if $x'$ and $y'$ are the old coordinates, then $x=u^2x'+r$,
 $y=u^3y'+su^2x'+t$ (inverse of \kbd{ellchangepoint}).
 \bprog
 ? E0 = ellinit([1,1]); P0 = [0,1]; v = [1,2,3,4];
 ? E = ellchangecurve(E0, v);
 ? P = ellchangepoint(P0,v)
 %3 = [-2, 3]
 ? ellisoncurve(E, P)
 %4 = 1
 ? ellchangepointinv(P,v)
 %5 = [0, 1]  \\ we get back P0
 @eprog

Function: ellconvertname
Class: basic
Section: elliptic_curves
C-Name: ellconvertname
Prototype: G
Help: ellconvertname(name): convert an elliptic curve name (as found in
 the elldata database) from a string to a triplet [conductor, isogeny class,
 index]. It will also convert a triplet back to a curve name.
Doc: 
 converts an elliptic curve name, as found in the \tet{elldata} database,
 from a string to a triplet $[\var{conductor}, \var{isogeny class},
 \var{index}]$. It will also convert a triplet back to a curve name.
 Examples:
 \bprog
 ? ellconvertname("123b1")
 %1 = [123, 1, 1]
 ? ellconvertname(%)
 %2 = "123b1"
 @eprog

Function: elldivpol
Class: basic
Section: elliptic_curves
C-Name: elldivpol
Prototype: GLDn
Help: elldivpol(E,n,{v='x}): n-division polynomial f_n for the curve E in the
 variable v.
Doc: $n$-division polynomial $f_n$ for the curve $E$ in the
 variable $v$. In standard notation, for any affine point $P = (X,Y)$ on the
 curve and any integer $n \geq 0$, we have
 $$[n]P = (\phi_n(P)\psi_n(P) : \omega_n(P) : \psi_n(P)^3)$$
 for some polynomials $\phi_n,\omega_n,\psi_n$ in
 $\Z[a_1,a_2,a_3,a_4,a_6][X,Y]$. We have $f_n(X) = \psi_n(X)$ for $n$ odd, and
 $f_n(X) = \psi_n(X,Y) (2Y + a_1X+a_3)$ for $n$ even. We have
 $$ f_0 = 0,\quad f_1  = 1,\quad f_2 = 4X^3 + b_2X^2 + 2b_4 X + b_6,
  \quad f_3 = 3 X^4 + b_2 X^3 + 3b_4 X^2 + 3 b_6 X + b8, $$
 $$ f_4 = f_2(2X^6 + b_2 X^5 + 5b_4 X^4 + 10 b_6 X^3 + 10 b_8 X^2 +
 (b_2b_8-b_4b_6)X + (b_8b_4 - b_6^2)), \dots $$
 When $n$ is odd, the roots of $f_n$ are the $X$-coordinates of the affine
 points in the $n$-torsion subgroup $E[n]$; when $n$ is even, the roots
 of $f_n$ are the $X$-coordinates of the affine points in $E[n]\setminus
 E[2]$ when $n > 2$, resp.~in $E[2]$ when $n = 2$.
 For $n < 0$, we define $f_n := - f_{-n}$.

Function: elleisnum
Class: basic
Section: elliptic_curves
C-Name: elleisnum
Prototype: GLD0,L,p
Help: elleisnum(w,k,{flag=0}): k being an even positive integer, computes the
 numerical value of the Eisenstein series of weight k at the lattice
 w, as given by ellperiods. When flag is nonzero and k=4 or 6, this gives the
 elliptic invariants g2 or g3 with the correct normalization.
Doc: $k$ being an even positive integer, computes the numerical value of the
 Eisenstein series of weight $k$ at the lattice $w$, as given by
 \tet{ellperiods}, namely
 $$
 (2i \pi/\omega_2)^k
 \Big(1 + 2/\zeta(1-k) \sum_{n\geq 1} n^{k-1}q^n / (1-q^n)\Big),
 $$
 where $q = \exp(2i\pi \tau)$ and $\tau:=\omega_1/\omega_2$ belongs to the
 complex upper half-plane. It is also possible to directly input $w =
 [\omega_1,\omega_2]$, or an elliptic curve $E$ as given by \kbd{ellinit}.
 \bprog
 ? w = ellperiods([1,I]);
 ? elleisnum(w, 4)
 %2 = 2268.8726415508062275167367584190557607
 ? elleisnum(w, 6)
 %3 = -3.977978632282564763 E-33
 ? E = ellinit([1, 0]);
 ? elleisnum(E, 4)
 %5 = -48.000000000000000000000000000000000000
 @eprog
 
 When \fl\ is nonzero and $k=4$ or 6, returns the elliptic invariants $g_2$
 or $g_3$, such that
 $$y^2 = 4x^3 - g_2 x - g_3$$
 is a Weierstrass equation for $E$.
 \bprog
 ? g2 = elleisnum(E, 4, 1)
 %6 = -4.0000000000000000000000000000000000000
 ? g3 = elleisnum(E, 6, 1)  \\ ~ 0
 %7 = 0.E-114 - 3.909948178422242682 E-57*I
 @eprog

Function: elleta
Class: basic
Section: elliptic_curves
C-Name: elleta
Prototype: Gp
Help: elleta(w): w=[w1,w2], returns the vector [eta1,eta2] of quasi-periods
 attached to [w1,w2].
Doc: returns the quasi-periods $[\eta_1,\eta_2]$
 attached to the lattice basis $\var{w} = [\omega_1, \omega_2]$.
 Alternatively, \var{w} can be an elliptic curve $E$ as output by
 \kbd{ellinit}, in which case, the quasi periods attached to the period
 lattice basis \kbd{$E$.omega} (namely, \kbd{$E$.eta}) are returned.
 \bprog
 ? elleta([1, I])
 %1 = [3.141592653589793238462643383, 9.424777960769379715387930149*I]
 @eprog

Function: ellformaldifferential
Class: basic
Section: elliptic_curves
C-Name: ellformaldifferential
Prototype: GDPDn
Help: ellformaldifferential(E, {n=seriesprecision}, {t = 'x}) : E elliptic curve,
 n integer. Returns n terms of the power series [f, g] such that
 omega = dx/(2y+a_1x+a_3) = f(t) dt and eta = x(t) * omega = g(t) dt in the
 local parameter t=-x/y.
Doc: Let $\omega := dx / (2y+a_1x+a_3)$ be the invariant differential form
 attached to the model $E$ of some elliptic curve (\kbd{ellinit} form),
 and $\eta := x(t)\omega$. Return $n$ terms (\tet{seriesprecision} by default)
 of $f(t),g(t)$ two power series in the formal parameter $t=-x/y$ such that
 $\omega = f(t) dt$, $\eta = g(t) dt$:
  $$f(t) = 1+a_1 t + (a_1^2 + a_2) t^2 + \dots,\quad
    g(t) = t^{-2} +\dots $$
  \bprog
  ? E = ellinit([-1,1/4]); [f,g] = ellformaldifferential(E,7,'t);
  ? f
  %2 = 1 - 2*t^4 + 3/4*t^6 + O(t^7)
  ? g
  %3 = t^-2 - t^2 + 1/2*t^4 + O(t^5)
 @eprog

Function: ellformalexp
Class: basic
Section: elliptic_curves
C-Name: ellformalexp
Prototype: GDPDn
Help: ellformalexp(E, {n = seriesprecision}, {z = 'x}) : E elliptic curve,
 returns n terms of the formal elliptic exponential on E as a series in z.
Doc: The elliptic formal exponential \kbd{Exp} attached to $E$ is the
 isomorphism from the formal additive law to the formal group of $E$. It is
 normalized so as to be the inverse of the elliptic logarithm (see
 \tet{ellformallog}): $\kbd{Exp} \circ L = \Id$. Return $n$ terms of this
 power series:
 \bprog
 ? E=ellinit([-1,1/4]); Exp = ellformalexp(E,10,'z)
 %1 = z + 2/5*z^5 - 3/28*z^7 + 2/15*z^9 + O(z^11)
 ? L = ellformallog(E,10,'t);
 ? subst(Exp,z,L)
 %3 = t + O(t^11)
 @eprog

Function: ellformallog
Class: basic
Section: elliptic_curves
C-Name: ellformallog
Prototype: GDPDn
Help: ellformallog(E, {n = seriesprecision}, {v = 'x}): E elliptic curve,
 returns n terms of the elliptic logarithm as a series of t =-x/y.
Doc: The formal elliptic logarithm is a series $L$ in $t K[[t]]$
 such that $d L = \omega = dx / (2y + a_1x + a_3)$, the canonical invariant
 differential attached to the model $E$. It gives an isomorphism
 from the formal group of $E$ to the additive formal group.
 \bprog
 ? E = ellinit([-1,1/4]); L = ellformallog(E, 9, 't)
 %1 = t - 2/5*t^5 + 3/28*t^7 + 2/3*t^9 + O(t^10)
 ? [f,g] = ellformaldifferential(E,8,'t);
 ? L' - f
 %3 = O(t^8)
 @eprog

Function: ellformalpoint
Class: basic
Section: elliptic_curves
C-Name: ellformalpoint
Prototype: GDPDn
Help: ellformalpoint(E, {n = seriesprecision}, {v = 'x}): E elliptic curve,
 n integer; return the coordinates [x(t), y(t)] on the elliptic curve as a
 formal expansion in the formal parameter t = -x/y.
Doc: If $E$ is an elliptic curve, return the coordinates $x(t), y(t)$ in the
 formal group of the elliptic curve $E$ in the formal parameter $t = -x/y$
 at $\infty$:
 $$ x = t^{-2} -a_1 t^{-1} - a_2 - a_3 t + \dots $$
 $$ y = - t^{-3} -a_1 t^{-2} - a_2t^{-1} -a_3 + \dots $$
 Return $n$ terms (\tet{seriesprecision} by default) of these two power
 series, whose coefficients are in $\Z[a_1,a_2,a_3,a_4,a_6]$.
 \bprog
 ? E = ellinit([0,0,1,-1,0]); [x,y] = ellformalpoint(E,8,'t);
 ? x
 %2 = t^-2 - t + t^2 - t^4 + 2*t^5 + O(t^6)
 ? y
 %3 = -t^-3 + 1 - t + t^3 - 2*t^4 + O(t^5)
 ? E = ellinit([0,1/2]); ellformalpoint(E,7)
 %4 = [x^-2 - 1/2*x^4 + O(x^5), -x^-3 + 1/2*x^3 + O(x^4)]
 @eprog

Function: ellformalw
Class: basic
Section: elliptic_curves
C-Name: ellformalw
Prototype: GDPDn
Help: ellformalw(E, {n = seriesprecision}, {t = 'x}): E elliptic curve,
 n integer; returns n terms of the formal expansion of w = -1/y in the formal
 parameter t = -x/y.
Doc: Return the formal power series $w$ attached to the elliptic curve $E$,
 in the variable $t$:
 $$ w(t) = t^3(1 + a_1 t + (a_2 + a_1^2) t^2 + \cdots + O(t^{n})),$$
 which is the formal expansion of $-1/y$ in the formal parameter $t := -x/y$
 at $\infty$ (take $n = \tet{seriesprecision}$ if $n$ is omitted). The
 coefficients of $w$ belong to $\Z[a_1,a_2,a_3,a_4,a_6]$.
 \bprog
 ? E=ellinit([3,2,-4,-2,5]); ellformalw(E, 5, 't)
 %1 = t^3 + 3*t^4 + 11*t^5 + 35*t^6 + 101*t^7 + O(t^8)
 @eprog

Function: ellfromeqn
Class: basic
Section: elliptic_curves
C-Name: ellfromeqn
Prototype: G
Help: ellfromeqn(P): given a genus 1 plane curve, defined by the affine
 equation f(x,y) = 0, return the coefficients [a1,a2,a3,a4,a6] of a
 Weierstrass equation for its Jacobian.
 This allows to recover a Weierstrass model for an elliptic curve given by a
 general plane cubic or by a binary quartic or biquadratic model.
Doc: 
 Given a genus $1$ plane curve, defined by the affine equation $f(x,y) = 0$,
 return the coefficients $[a_1,a_2,a_3,a_4,a_6]$ of a Weierstrass equation
 for its Jacobian. This allows to recover a Weierstrass model for an elliptic
 curve given by a general plane cubic or by a binary quartic or biquadratic
 model. The function implements the $f \mapsto f^*$ formulae of Artin, Tate
 and Villegas (Advances in Math. 198 (2005), pp. 366--382).
 
 In the example below, the function is used to convert between twisted Edwards
 coordinates and Weierstrass coordinates.
 \bprog
 ? e = ellfromeqn(a*x^2+y^2 - (1+d*x^2*y^2))
 %1 = [0, -a - d, 0, -4*d*a, 4*d*a^2 + 4*d^2*a]
 ? E = ellinit(ellfromeqn(y^2-x^2 - 1 +(121665/121666*x^2*y^2)),2^255-19);
 ? isprime(ellcard(E) / 8)
 %3 = 1
 @eprog
 
 The elliptic curve attached to the sum of two cubes is given by
 \bprog
 ? ellfromeqn(x^3+y^3 - a)
 %1 = [0, 0, -9*a, 0, -27*a^2]
 @eprog
 
 \misctitle{Congruent number problem}
 Let $n$ be an integer, if $a^2+b^2=c^2$ and $a\*b=2\*n$,
 then by substituting $b$ by $2\*n/a$ in the first equation,
 we get $((a^2+(2\*n/a)^2)-c^2)\*a^2 = 0$.
 We set $x=a$, $y=a\*c$.
 \bprog
 ? En = ellfromeqn((x^2 + (2*n/x)^2 - (y/x)^2)*x^2)
 %1 = [0, 0, 0, -16*n^2, 0]
 @eprog
 For example $23$ is congruent since the curve has a point of infinite order,
 namely:
 \bprog
 ? ellheegner( ellinit(subst(En, n, 23)) )
 %2 = [168100/289, 68053440/4913]
 @eprog

Function: ellfromj
Class: basic
Section: elliptic_curves
C-Name: ellfromj
Prototype: G
Help: ellfromj(j): returns the coefficients [a1,a2,a3,a4,a6] of a fixed
 elliptic curve with j-invariant j.
Doc: returns the coefficients $[a_1,a_2,a_3,a_4,a_6]$ of a fixed elliptic curve
 with $j$-invariant $j$. The given model is arbitrary; for instance, over the
 rationals, it is in general not minimal nor even integral.
 \bprog
 ? v = ellfromj(1/2)
 %1 = [0, 0, 0, 10365/4, 11937025/4]
 ? E = ellminimalmodel(ellinit(v)); E[1..5]
 %2 = [0, 0, 0, 41460, 190992400]
 ? F = ellminimalmodel(elltwist(E, 24)); F[1..5]
 %3 = [1, 0, 0, 72, 13822]
 ? [E.disc, F.disc]
 %4 = [-15763098924417024000, -82484842750]
 @eprog\noindent For rational $j$, the following program returns the integral
 curve of minimal discriminant and given $j$ invariant:
 \bprog
 ellfromjminimal(j)=
 { my(E = ellinit(ellfromj(j)));
   my(D = ellminimaltwist(E));
 
   ellminimalmodel(elltwist(E,D));
 }
 ? e = ellfromjminimal(1/2); e.disc
 %1 = -82484842750
 @eprog Using $\fl = 1$ in \kbd{ellminimaltwist} would instead return the
 curve of minimal conductor. For instance, if $j = 1728$, this would return a
 different curve (of conductor $32$ instead of $64$).

Function: ellgenerators
Class: basic
Section: elliptic_curves
C-Name: ellgenerators
Prototype: G
Help: ellgenerators(E): if E is an elliptic curve over the rationals,
 return the generators of the Mordell-Weil group attached to the curve.
 This relies on the curve being referenced in the elldata database.
 If E is an elliptic curve over a finite field Fq as output by ellinit(),
 return a minimal set of generators for the group E(Fq).
Doc: 
 If $E$ is an elliptic curve over the rationals, return a $\Z$-basis of the
 free part of the \idx{Mordell-Weil group} attached to $E$.  This relies on
 the \tet{elldata} database being installed and referencing the curve, and so
 is only available for curves over $\Z$ of small conductors.
 If $E$ is an elliptic curve over a finite field $\F_q$ as output by
 \tet{ellinit}, return a minimal set of generators for the group $E(\F_q)$.
 
 \misctitle{Caution} When the group is not cyclic, of shape $\Z/d_1\Z \times
 \Z/d_2\Z$ with $d_2\mid d_1$, the points $[P,Q]$ returned by ellgenerators
 need not have order $d_1$ and $d_2$: it is true that
 $P$ has order $d_1$, but we only know that $Q$ is a generator of
 $E(\F_q)/<P>$ and that the Weil pairing $w(P,Q)$ has order $d_2$,
 see \kbd{??ellgroup}.
 If you need generators $[P,R]$ with $R$ of order $d_2$, find
 $x$ such that $R = Q-[x]P$ has order $d_2$ by solving
 the discrete logarithm problem $[d_2]Q = [x]([d_2]P)$ in a cyclic group of
 order $d_1/d_2$. This will be very expensive if $d_1/d_2$ has a large
 prime factor.

Function: ellglobalred
Class: basic
Section: elliptic_curves
C-Name: ellglobalred
Prototype: G
Help: ellglobalred(E): E being an elliptic curve over a number field,
 returns [N, v, c, faN, L], where N is the conductor of E,
 c is the product of the local Tamagawa numbers c_p, faN is the
 factorization of N and L[i] is elllocalred(E, faN[i,1]); v is an obsolete
 field.
Description: 
 (gen):gen        ellglobalred($1)
Doc: let $E$ be an \kbd{ell} structure as output by \kbd{ellinit} attached
 to an elliptic curve defined over a number field. This function calculates
 the arithmetic conductor and the global \idx{Tamagawa number} $c$.
 The result $[N,v,c,F,L]$ is slightly different if $E$ is defined
 over $\Q$ (domain $D = 1$ in \kbd{ellinit}) or over a number field
 (domain $D$ is a number field structure, including \kbd{nfinit(x)}
 representing $\Q$ !):
 
 \item $N$ is the arithmetic conductor of the curve,
 
 \item $v$ is an obsolete field, left in place for backward compatibility.
 If $E$ is defined over $\Q$, $v$ gives the coordinate change for $E$ to the
 standard minimal integral model (\tet{ellminimalmodel} provides it in a
 cheaper way); if $E$ is defined over another number field, $v$ gives a
 coordinate change to an integral model (\tet{ellintegralmodel} provides it
 in a cheaper way).
 
 \item $c$ is the product of the local Tamagawa numbers $c_p$, a quantity
 which enters in the \idx{Birch and Swinnerton-Dyer conjecture},
 
 \item $F$ is the factorization of $N$,
 
 \item $L$ is a vector, whose $i$-th entry contains the local data
 at the $i$-th prime ideal divisor of $N$, i.e.
 \kbd{L[i] = elllocalred(E,F[i,1])}. If $E$ is defined over $\Q$, the local
 coordinate change has been deleted and replaced by a 0; if $E$ is defined
 over another number field the local coordinate change to a local minimal
 model is given relative to the integral model afforded by $v$ (so either
 start from an integral model so that $v$ be trivial, or apply $v$ first).

Function: ellgroup
Class: basic
Section: elliptic_curves
C-Name: ellgroup0
Prototype: GDGD0,L,
Help: ellgroup(E,{p},{flag}): given an elliptic curve E defined over
 a finite field Fq, return the structure of the group E(Fq); for other fields
 of definition K, p must define a finite residue field
 (p prime for K = Qp or Q; p a maximal ideal for K a number field) and we
 return the structure of the (nonsingular) reduction of E.
 If flag is 1, return also generators, the curve equation must be minimal at p.
Doc: 
 Let \kbd{E} be an \kbd{ell} structure as output by \kbd{ellinit}, attached
 to an elliptic curve $E/K$. We first describle the function when the field
 $K = \F_q$ is finite, it computes the structure of the finite abelian group
 $E(\F_q)$:
 
 \item if $\fl = 0$, return the structure $[]$ (trivial group) or $[d_1]$
 (nontrivial cyclic group) or $[d_1,d_2]$ (noncyclic group) of
 $E(\F_q) \sim \Z/d_1\Z \times \Z/d_2\Z$, with $d_2\mid d_1$.
 
 \item if $\fl = 1$, return a triple $[h,\var{cyc},\var{gen}]$, where
 $h$ is the curve cardinality, \var{cyc} gives the group structure as a
 product of cyclic groups (as per $\fl = 0$). More precisely, if $d_2 > 1$,
 the output is $[d_1d_2, [d_1,d_2], [P,Q]]$ where $P$ is
 of order $d_1$ and $[P,Q]$ generates the curve.
 \misctitle{Caution} It is not guaranteed that $Q$ has order $d_2$, which in
 the worst case requires an expensive discrete log computation. Only that
 \kbd{ellweilpairing}$(E, P, Q, d_1)$ has order $d_2$.
 
 For other fields of definition and $p$ defining a finite residue field
 $\F_q$, return the structure of the reduction of $E$: the argument
 $p$ is best left omitted if $K = \Q_\ell$ (else we must have $p = \ell$) and
 must be a prime number ($K = \Q$) or prime ideal ($K$ a general number field)
 with residue field $\F_q$ otherwise. The curve is allowed to have bad
 reduction at $p$ and in this case we consider the (cyclic) group of
 nonsingular points for the reduction of a minimal model at $p$.
 
 If $\fl = 0$, the equation not be minimal or even integral at $p$; of course,
 a minimal model will be more efficient.
 
 If $\fl = 1$, the requested generators depend on the model, which must then
 be minimal at $p$, otherwise an exception is thrown. Use
 \kbd{ellintegralmodel} and/or \kbd{ellocalred} first to reduce to this case.
 
 \bprog
 ? E = ellinit([0,1]);  \\ y^2 = x^3 + 0.x + 1, defined over Q
 ? ellgroup(E, 7)
 %2 = [6, 2] \\ Z/6 x Z/2, noncyclic
 ? E = ellinit([0,1] * Mod(1,11));  \\ defined over F_11
 ? ellgroup(E)   \\ no need to repeat 11
 %4 = [12]
 ? ellgroup(E, 11)   \\ ... but it also works
 %5 = [12]
 ? ellgroup(E, 13) \\ ouch, inconsistent input!
    ***   at top-level: ellgroup(E,13)
    ***                 ^--------------
    *** ellgroup: inconsistent moduli in Rg_to_Fp:
      11
      13
 ? ellgroup(E, 7, 1)
 %6 = [12, [6, 2], [[Mod(2, 7), Mod(4, 7)], [Mod(4, 7), Mod(4, 7)]]]
 @eprog\noindent
 Let us now consider curves of bad reduction, in this case we return the
 structure of the (cyclic) group of nonsingular points, satisfying
 $\#E_{ns}(\F_p) = p - a_p$:
 \bprog
 ? E = ellinit([0,5]);
 ? ellgroup(E, 5, 1)
 %2 = [5, [5], [[Mod(4, 5), Mod(2, 5)]]]
 ? ellap(E, 5)
 %3 = 0 \\ additive reduction at 5
 ? E = ellinit([0,-1,0,35,0]);
 ? ellgroup(E, 5, 1)
 %5 = [4, [4], [[Mod(2, 5), Mod(2, 5)]]]
 ? ellap(E, 5)
 %6 = 1 \\ split multiplicative reduction at 5
 ? ellgroup(E, 7, 1)
 %7 = [8, [8], [[Mod(3, 7), Mod(5, 7)]]]
 ? ellap(E, 7)
 %8 = -1 \\ nonsplit multiplicative reduction at 7
 @eprog
Variant: Also available is \fun{GEN}{ellgroup}{GEN E, GEN p}, corresponding
 to \fl = 0.

Function: ellheegner
Class: basic
Section: elliptic_curves
C-Name: ellheegner
Prototype: G
Help: ellheegner(E): return a rational nontorsion point on the elliptic curve E
 assumed to be of rank 1.
Doc: Let $E$ be an elliptic curve over the rationals, assumed to be of
 (analytic) rank $1$. This returns a nontorsion rational point on the curve,
 whose canonical height is equal to the product of the elliptic regulator by the
 analytic Sha.
 
 This uses the Heegner point method, described in Cohen GTM 239; the complexity
 is proportional to the product of the square root of the conductor and the
 height of the point (thus, it is preferable to apply it to strong Weil curves).
 \bprog
 ? E = ellinit([-157^2,0]);
 ? u = ellheegner(E); print(u[1], "\n", u[2])
 69648970982596494254458225/166136231668185267540804
 538962435089604615078004307258785218335/67716816556077455999228495435742408
 ? ellheegner(ellinit([0,1]))         \\ E has rank 0 !
  ***   at top-level: ellheegner(E=ellinit
  ***                 ^--------------------
  *** ellheegner: The curve has even analytic rank.
 @eprog

Function: ellheight
Class: basic
Section: elliptic_curves
C-Name: ellheight0
Prototype: GDGDGp
Help: ellheight(E,{P},{Q}): Faltings height of the curve E, resp. canonical
 height of the point P on elliptic curve E, resp. the value of the attached
 bilinear form at (P,Q).
Doc: Let $E$ be an elliptic curve defined over $K = \Q$ or a number field,
 as output by \kbd{ellinit}; it needs not be given by a minimal model
 although the computation will be faster if it is.
 
 \item Without arguments $P,Q$, returns the Faltings height of the curve $E$
 using Deligne normalization. For a rational curve, the normalization is such
 that the function returns \kbd{-(1/2)*log(ellminimalmodel(E).area)}.
 
 \item If the argument $P \in E(K)$ is present, returns the global
 N\'eron-Tate height $h(P)$ of the point, using the normalization in
 Cremona's \emph{Algorithms for modular elliptic curves}.
 
 \item If the argument $Q \in E(K)$ is also present, computes the value of
 the bilinear form $(h(P+Q)-h(P-Q)) / 4$.
Variant: Also available is \fun{GEN}{ellheight}{GEN E, GEN P, long prec}
 ($Q$ omitted).

Function: ellheightmatrix
Class: basic
Section: elliptic_curves
C-Name: ellheightmatrix
Prototype: GGp
Help: ellheightmatrix(E,x): gives the height matrix for vector of points x
 on elliptic curve E.
Doc: $x$ being a vector of points, this
 function outputs the Gram matrix of $x$ with respect to the N\'eron-Tate
 height, in other words, the $(i,j)$ component of the matrix is equal to
 \kbd{ellheight($E$,x[$i$],x[$j$])}. The rank of this matrix, at least in some
 approximate sense, gives the rank of the set of points, and if $x$ is a
 basis of the \idx{Mordell-Weil group} of $E$, its determinant is equal to
 the regulator of $E$. Note our height normalization follows Cremona's
 \emph{Algorithms for modular elliptic curves}: this matrix should be divided
 by 2 to be in accordance with, e.g., Silverman's normalizations.

Function: ellidentify
Class: basic
Section: elliptic_curves
C-Name: ellidentify
Prototype: G
Help: ellidentify(E): look up the elliptic curve E in the elldata database and
 return [[N, M, ...], C] where N is the name of the curve in Cremona's
 database, M the minimal model and C the change of coordinates (see
 ellchangecurve).
Doc: look up the elliptic curve $E$, defined by an arbitrary model over $\Q$,
 in the \tet{elldata} database.
 Return \kbd{[[N, M, G], C]}  where $N$ is the curve name in Cremona's
 elliptic curve database, $M$ is the minimal model, $G$ is a $\Z$-basis of
 the free part of the \idx{Mordell-Weil group} $E(\Q)$ and $C$ is the
 change of coordinates from $E$ to $M$, suitable for \kbd{ellchangecurve}.

Function: ellinit
Class: basic
Section: elliptic_curves
C-Name: ellinit
Prototype: GDGp
Help: ellinit(x,{D=1}): let x be a vector [a1,a2,a3,a4,a6], or [a4,a6] if
 a1=a2=a3=0, defining the curve Y^2 + a1.XY + a3.Y = X^3 + a2.X^2 + a4.X +
 a6; x can also be a string, in which case the curve with matching name is
 retrieved from the elldata database, if available. This function initializes
 an elliptic curve over the domain D (inferred from coefficients if omitted).
Description: 
 (gen, gen, small):ell:prec  ellinit($1, $2, $prec)
Doc: 
 initialize an \tet{ell} structure, attached to the elliptic curve $E$.
 $E$ is either
 
 \item a $5$-component vector $[a_1,a_2,a_3,a_4,a_6]$ defining the elliptic
 curve with Weierstrass equation
 $$ Y^2 + a_1 XY + a_3 Y = X^3 + a_2 X^2 + a_4 X + a_6, $$
 
 \item a $2$-component vector $[a_4,a_6]$ defining the elliptic
 curve with short Weierstrass equation
 $$ Y^2 = X^3 + a_4 X + a_6, $$
 
 \item a single-component vector $[j]$ giving the $j$-invariant for the curve,
 with the same coefficients as given by \kbd{ellfromj}.
 
 \item a character string in Cremona's notation, e.g. \kbd{"11a1"}, in which
 case the curve is retrieved from the \tet{elldata} database if available.
 
 The optional argument $D$ describes the domain over which the curve is
 defined:
 
 \item the \typ{INT} $1$ (default): the field of rational numbers $\Q$.
 
 \item a \typ{INT} $p$, where $p$ is a prime number: the prime finite field
 $\F_p$.
 
 \item an \typ{INTMOD} \kbd{Mod(a, p)}, where $p$ is a prime number: the
 prime finite field $\F_p$.
 
 \item a \typ{FFELT}, as returned by \tet{ffgen}: the corresponding finite
 field $\F_q$.
 
 \item a \typ{PADIC}, $O(p^n)$: the field $\Q_p$, where $p$-adic quantities
 will be computed to a relative accuracy of $n$ digits. We advise to input a
 model defined over $\Q$ for such curves. In any case, if you input an
 approximate model with \typ{PADIC} coefficients, it will be replaced by a lift
 to $\Q$ (an exact model ``close'' to the one that was input) and all quantities
 will then be computed in terms of this lifted model, at the given accuracy.
 
 \item a \typ{REAL} $x$: the field $\C$ of complex numbers, where floating
 point quantities are by default computed to a relative accuracy of
 \kbd{precision}$(x)$. If no such argument is given, the value of
 \kbd{realprecision} at the time \kbd{ellinit} is called will be used.
 
 \item a number field $K$, given by a \kbd{nf} or \kbd{bnf} structure; a
 \kbd{bnf} is required for \kbd{ellminimalmodel}.
 
 \item a prime ideal $\goth{p}$, given by a \kbd{prid} structure; valid if
 $x$ is a curve defined over a number field $K$ and the equation is integral
 and minimal at $\goth{p}$.
 
 This argument $D$ is indicative: the curve coefficients are checked for
 compatibility, possibly changing $D$; for instance if $D = 1$ and
 an \typ{INTMOD} is found. If inconsistencies are detected, an error is
 raised:
 \bprog
 ? ellinit([1 + O(5), 1], O(7));
  ***   at top-level: ellinit([1+O(5),1],O
  ***                 ^--------------------
  *** ellinit: inconsistent moduli in ellinit: 7 != 5
 @eprog\noindent If the curve coefficients are too general to fit any of the
 above domain categories, only basic operations, such as point addition, will
 be supported later.
 
 If the curve (seen over the domain $D$) is singular, fail and return an
 empty vector $[]$.
 \bprog
 ? E = ellinit([0,0,0,0,1]); \\ y^2 = x^3 + 1, over Q
 ? E = ellinit([0,1]);       \\ the same curve, short form
 ? E = ellinit("36a1");      \\ sill the same curve, Cremona's notations
 ? E = ellinit([0]);         \\ a curve of j-invariant 0
 ? E = ellinit([0,1], 2)     \\ over F2: singular curve
 %4 = []
 ? E = ellinit(['a4,'a6] * Mod(1,5));  \\ over F_5[a4,a6], basic support !
 @eprog\noindent Note that the given curve of $j$-invariant $0$ happens
 to be \kbd{36a1} but a priori any model for an arbitrary twist could have
 been returned. See \kbd{ellfromj}.
 
 The result of \tet{ellinit} is an \tev{ell} structure. It contains at least
 the following information in its components:
 %
 $$ a_1,a_2,a_3,a_4,a_6,b_2,b_4,b_6,b_8,c_4,c_6,\Delta,j.$$
 %
 All are accessible via member functions. In particular, the discriminant is
 \kbd{$E$.disc}, and the $j$-invariant is \kbd{$E$.j}.
 \bprog
 ? E = ellinit([a4, a6]);
 ? E.disc
 %2 = -64*a4^3 - 432*a6^2
 ? E.j
 %3 = -6912*a4^3/(-4*a4^3 - 27*a6^2)
 @eprog
 Further components contain domain-specific data, which are in general dynamic:
 only computed when needed, and then cached in the structure.
 \bprog
 ? E = ellinit([2,3], 10^60+7);  \\ E over F_p, p large
 ? ellap(E)
 time = 4,440 ms.
 %2 = -1376268269510579884904540406082
 ? ellcard(E);  \\ now instantaneous !
 time = 0 ms.
 ? ellgenerators(E);
 time = 5,965 ms.
 ? ellgenerators(E); \\ second time instantaneous
 time = 0 ms.
 @eprog
 See the description of member functions related to elliptic curves at the
 beginning of this section.

Function: ellintegralmodel
Class: basic
Section: elliptic_curves
C-Name: ellintegralmodel
Prototype: GD&
Help: ellintegralmodel(E,{&v}): given an elliptic curve E defined
 over a number field or Qp, returns an integral model. If v is present,
 sets the variable v to the corresponding change of variable.
Doc: Let $E$ be an \kbd{ell} structure over a number field $K$ or $\Q_p$.
 This function returns an integral model. If $v$ is present, sets
 $v = [u,0,0,0]$ to the corresponding change of variable: the return value is
 identical to that of \kbd{ellchangecurve(E, v)}.
 \bprog
 ? e = ellinit([1/17,1/42]);
 ? e = ellintegralmodel(e,&v);
 ? e[1..5]
 %3 = [0, 0, 0, 15287762448, 3154568630095008]
 ? v
 %4 = [1/714, 0, 0, 0]
 @eprog

Function: ellisdivisible
Class: basic
Section: elliptic_curves
C-Name: ellisdivisible
Prototype: lGGGD&
Help: ellisdivisible(E,P,n,{&Q}): given E/K and P in E(K),
 checks whether P = [n]R for some R in E(K) and sets Q to one such R if so;
 the integer n >= 0 may be given as ellxn(E,n).
Doc: given $E/K$ a number field and $P$ in $E(K)$
 return $1$ if $P = [n]R$ for some $R$ in $E(K)$ and set $Q$ to one such $R$;
 and return $0$ otherwise.
 
 \bprog
 ? K = nfinit(polcyclo(11,t));
 ? E = ellinit([0,-1,1,0,0], K);
 ? P = [0,0];
 ? ellorder(E,P)
 %4 = 5
 ? ellisdivisible(E,P,5, &Q)
 %5 = 1
 ? lift(Q)
 %6 = [-t^7-t^6-t^5-t^4+1, -t^9-2*t^8-2*t^7-3*t^6-3*t^5-2*t^4-2*t^3-t^2-1]
 ? ellorder(E, Q)
 %7 = 25
 @eprog\noindent We use a fast multimodular algorithm over $\Q$ whose
 complexity is essentially independent of $n$ (polynomial in $\log n$).
 Over number fields, we compute roots of division polynomials and the
 algebraic complexity of the underlying algorithm is in $O(p^4)$, where $p$ is
 the largest prime divisor of $n$. The integer $n \geq 0$ may be given as
 \kbd{ellxn(E,n)}, if many points need to be tested; this provides a modest
 speedup over number fields but is likely to slow down the algorithm over
 $\Q$.

Function: ellisogeny
Class: basic
Section: elliptic_curves
C-Name: ellisogeny
Prototype: GGD0,L,DnDn
Help: ellisogeny(E, G, {only_image = 0}, {x = 'x}, {y = 'y}): compute the image
 and isogeny corresponding to the quotient of E by the subgroup G.
Doc: 
 Given an elliptic curve $E$, a finite subgroup $G$ of $E$ is given either
 as a generating point $P$ (for a cyclic $G$) or as a polynomial whose roots
 vanish on the $x$-coordinates of the nonzero elements of $G$ (general case
 and more efficient if available). This function returns the
 $[a_1,a_2,a_3,a_4,a_6]$ invariants of the quotient elliptic curve $E/G$ and
 (if \var{only\_image} is zero (the default)) a vector of rational
 functions $[f, g, h]$ such that the isogeny $E \to E/G$ is given by $(x,y)
 \mapsto (f(x)/h(x)^2, g(x,y)/h(x)^3)$.
 \bprog
 ? E = ellinit([0,1]);
 ? elltors(E)
 %2 = [6, [6], [[2, 3]]]
 ? ellisogeny(E, [2,3], 1)  \\ Weierstrass model for E/<P>
 %3 = [0, 0, 0, -135, -594]
 ? ellisogeny(E,[-1,0])
 %4 = [[0,0,0,-15,22], [x^3+2*x^2+4*x+3, y*x^3+3*y*x^2-2*y, x+1]]
 @eprog

Function: ellisogenyapply
Class: basic
Section: elliptic_curves
C-Name: ellisogenyapply
Prototype: GG
Help: ellisogenyapply(f, g): given an isogeny f and g either a point P (in the
 domain of f) or an isogeny, apply f to g: return the image of P under f or
 the composite isogeny f o g.
Doc: 
 Given an isogeny of elliptic curves $f:E'\to E$ (being the result of a call
 to \tet{ellisogeny}), apply $f$ to $g$:
 
 \item if $g$ is a point $P$ in the domain of $f$, return the image $f(P)$;
 
 \item if $g:E''\to E'$ is a compatible isogeny, return the composite
 isogeny $f \circ g:  E''\to E$.
 
 \bprog
 ? one = ffgen(101, 't)^0;
 ? E = ellinit([6, 53, 85, 32, 34] * one);
 ? P = [84, 71] * one;
 ? ellorder(E, P)
 %4 = 5
 ? [F, f] = ellisogeny(E, P);  \\ f: E->F = E/<P>
 ? ellisogenyapply(f, P)
 %6 = [0]
 ? F = ellinit(F);
 ? Q = [89, 44] * one;
 ? ellorder(F, Q)
 %9 = 2
 ? [G, g] = ellisogeny(F, Q); \\  g: F->G = F/<Q>
 ? gof = ellisogenyapply(g, f); \\ gof: E -> G
 @eprog

Function: ellisomat
Class: basic
Section: elliptic_curves
C-Name: ellisomat
Prototype: GD0,L,D0,L,
Help: ellisomat(E, {p=0}, {fl=0}): E being an elliptic curve over a number
 field K, return a list of representatives of the isomorphism classes of
 elliptic curves defined over K and K-isogenous to E, with the corresponding
 isogenies from E and their dual, and the matrix of the isogeny degrees between
 the curves. If the flag fl is 1, the isogenies are not computed, which saves
 time. If p is set, it must be a prime number: in this case only isogenies of
 degree a power of p are considered.
Doc: 
 Given an elliptic curve $E$ defined over a number field $K$, compute
 representatives of the isomorphism classes of elliptic curves defined over
 $K$ and $K$-isogenous to $E$. We assume that $E$ does not have CM over $K$
 (otherwise that set would be infinite).
 For any such curve $E_i$, let $f_i: E \to E_i$ be a rational isogeny
 of minimal degree and let $g_i: E_i \to E$ be the dual isogeny; and let $M$
 be the matrix such that $M_{i,j}$ is the minimal degree for an isogeny $E_i
 \to E_j$.
 
 The function returns a vector $[L,M]$ where $L$ is a list of triples
 $[E_i, f_i, g_i]$ ($\fl  = 0$), or simply the list of $E_i$ ($\fl = 1$,
 which saves time). The curves $E_i$ are given in $[a_4,a_6]$ form and the
 first curve $E_1$ is isomorphic to $E$ by $f_1$.
 
 If $p$ is set, it must be a prime number; in this which case only isogenies of
 degree a power of $p$ are considered.
 
 Over a number field, the possible isogeny degrees are determined by
 Billerey algorithm.
 \bprog
 ? E = ellinit("14a1");
 ? [L,M] = ellisomat(E);
 ? LE = apply(x->x[1], L)  \\ list of curves
 %3 = [[215/48,-5291/864],[-675/16,6831/32],[-8185/48,-742643/864],
      [-1705/48,-57707/864],[-13635/16,306207/32],[-131065/48,-47449331/864]]
 ? L[2][2]  \\ isogeny f_2
 %4 = [x^3+3/4*x^2+19/2*x-311/12,
       1/2*x^4+(y+1)*x^3+(y-4)*x^2+(-9*y+23)*x+(55*y+55/2),x+1/3]
 ? L[2][3]  \\ dual isogeny g_2
 %5 = [1/9*x^3-1/4*x^2-141/16*x+5613/64,
       -1/18*x^4+(1/27*y-1/3)*x^3+(-1/12*y+87/16)*x^2+(49/16*y-48)*x
       +(-3601/64*y+16947/512),x-3/4]
 ? apply(E->ellidentify(ellinit(E))[1][1], LE)
 %6 = ["14a1","14a4","14a3","14a2","14a6","14a5"]
 ? M
 %7 =
 [1  3  3 2  6  6]
 
 [3  1  9 6  2 18]
 
 [3  9  1 6 18  2]
 
 [2  6  6 1  3  3]
 
 [6  2 18 3  1  9]
 
 [6 18  2 3  9  1]
 @eprog

Function: ellisoncurve
Class: basic
Section: elliptic_curves
C-Name: ellisoncurve
Prototype: GG
Help: ellisoncurve(E,z): true(1) if z is on elliptic curve E, false(0) if not.
Doc: gives 1 (i.e.~true) if the point $z$ is on the elliptic curve $E$, 0
 otherwise. If $E$ or $z$ have imprecise coefficients, an attempt is made to
 take this into account, i.e.~an imprecise equality is checked, not a precise
 one. It is allowed for $z$ to be a vector of points in which case a vector
 (of the same type) is returned.
Variant: Also available is \fun{int}{oncurve}{GEN E, GEN z} which does not
 accept vectors of points.

Function: ellisotree
Class: basic
Section: elliptic_curves
C-Name: ellisotree
Prototype: G
Help: ellisotree(E): E being an elliptic curve over Q or a set of isogenous
 rational curves as given by ellisomat, return minimal models of the isomorphism
 classes of elliptic curves isogenous to E (or in the set) and the oriented
 graph of isogenies of prime degree (adjacency matrix).
Doc: Given an elliptic curve $E$ defined over $\Q$ or a set of
 $\Q$-isogenous curves as given by \kbd{ellisomat}, return a pair $[L,M]$ where
 
 \item $L$ lists the minimal models of the isomorphism classes of elliptic
 curves $\Q$-isogenous to $E$ (or in the set of isogenous curves),
 
 \item $M$ is the adjacency matrix of the prime degree isogenies tree:
 there is an edge from $E_i$ to $E_j$ if there is an isogeny $E_i \to E_j$ of
 prime degree such that the N\'eron differential forms are preserved.
 
 \bprog
 ? E = ellinit("14a1");
 ? [L,M] = ellisotree(E);
 ? M
 %3 =
 [0 0 3 2 0 0]
 
 [3 0 0 0 2 0]
 
 [0 0 0 0 0 2]
 
 [0 0 0 0 0 3]
 
 [0 0 0 3 0 0]
 
 [0 0 0 0 0 0]
 ? [L2,M2] = ellisotree(ellisomat(E,2,1));
 %4 =
 [0 2]
 
 [0 0]
 ? [L3,M3] = ellisotree(ellisomat(E,3,1));
 ? M3
 %6 =
 [0 0 3]
 
 [3 0 0]
 
 [0 0 0]
 @eprog\noindent Compare with the result of \kbd{ellisomat}.
 \bprog
 ? [L,M]=ellisomat(E,,1);
 ? M
 %7 =
 [1  3  3 2  6  6]
 
 [3  1  9 6  2 18]
 
 [3  9  1 6 18  2]
 
 [2  6  6 1  3  3]
 
 [6  2 18 3  1  9]
 
 [6 18  2 3  9  1]
 @eprog

Function: ellissupersingular
Class: basic
Section: elliptic_curves
C-Name: ellissupersingular
Prototype: iGDG
Help: ellissupersingular(E,{p}): return 1 if the elliptic curve E, defined
 over a number field or a finite field, is supersingular at p, and 0 otherwise.
Doc: 
 Return 1 if the elliptic curve $E$ defined over a number field, $\Q_p$
 or a finite field is supersingular at $p$, and $0$ otherwise.
 If the curve is defined over a number field, $p$ must be explicitly given,
 and must be a prime number, resp.~a maximal ideal, if the curve is defined
 over $\Q$, resp.~a general number field: we return $1$ if and only if $E$
 has supersingular good reduction at $p$.
 
 Alternatively, $E$ can be given by its $j$-invariant in a finite field. In
 this case $p$ must be omitted.
 \bprog
 ? setrand(1); \\ make the choice of g deterministic
 ? g = ffprimroot(ffgen(7^5))
 %1 = 4*x^4 + 5*x^3 + 6*x^2 + 5*x + 6
 ? [g^n | n <- [1 .. 7^5 - 1], ellissupersingular(g^n)]
 %2 = [6]
 
 ? K = nfinit(y^3-2); P = idealprimedec(K, 2)[1];
 ? E = ellinit([y,1], K);
 ? ellissupersingular(E, P)
 %5 = 1
 ? Q = idealprimedec(K,5)[1];
 ? ellissupersingular(E, Q)
 %6 = 0
 @eprog
Variant: Also available is
 \fun{int}{elljissupersingular}{GEN j} where $j$ is a $j$-invariant of a curve
 over a finite field.

Function: ellj
Class: basic
Section: elliptic_curves
C-Name: jell
Prototype: Gp
Help: ellj(x): elliptic j invariant of x.
Doc: 
 elliptic $j$-invariant. $x$ must be a complex number
 with positive imaginary part, or convertible into a power series or a
 $p$-adic number with positive valuation.

Function: elllocalred
Class: basic
Section: elliptic_curves
C-Name: elllocalred
Prototype: GDG
Help: elllocalred(E,{p}): E being an elliptic curve, returns
 [f,kod,[u,r,s,t],c], where f is the conductor's exponent, kod is the Kodaira
 type for E at p, [u,r,s,t] is the change of variable needed to make E
 minimal at p, and c is the local Tamagawa number c_p.
Doc: 
 calculates the \idx{Kodaira} type of the local fiber of the elliptic curve
 $E$ at $p$. $E$ must be an \kbd{ell} structure as output by
 \kbd{ellinit}, over $\Q_\ell$ ($p$ better left omitted, else equal to $\ell$)
 over $\Q$ ($p$ a rational prime) or a number field $K$ ($p$
 a maximal ideal given by a \kbd{prid} structure).
 The result is a 4-component vector $[f,kod,v,c]$. Here $f$ is the exponent of
 $p$ in the arithmetic conductor of $E$, and $kod$ is the Kodaira type which
 is coded as follows:
 
 1 means good reduction (type I$_0$), 2, 3 and 4 