% Copyright (c) 2000  The PARI Group
%
% This file is part of the PARI/GP documentation
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU General Public License
\chapter{Functions and Operations Available in PARI and GP}
\label{se:functions}

The functions and operators available in PARI and in the GP/PARI calculator
are numerous and ever-expanding. Here is a description of the ones available
in version \vers. It should be noted that many of these functions accept
quite different types as arguments, but others are more restricted. The list
of acceptable types will be given for each function or class of functions.
Except when stated otherwise, it is understood that a function or operation
which should make natural sense is legal.

On the other hand, many routines list explicit preconditions for some of their
argument, e.g. $p$ is a prime number, or $q$ is a positive definite quadratic
form. For reasons of efficiency, all trust the user input and only perform
minimal sanity checks. When a precondition is not satisfied, any of the
following may occur: a regular exception is raised, the PARI stack overflows, a
\kbd{SIGSEGV} or \kbd{SIGBUS} signal is generated, or we enter an infinite
loop. The function can also quietly return a mathematically meaningless
result: junk in, junk out.

In this chapter, we will describe the functions according to a rough
classification. The general entry looks something like:

\key{foo}$(x,\{\fl=0\})$: short description.

The library syntax is \kbd{GEN foo(GEN x, long fl = 0)}.

\noindent
This means that the GP function \kbd{foo} has one mandatory argument $x$, and
an optional one, $\fl$, whose default value is 0. (The $\{\}$ should not be
typed, it is just a convenient notation we will use throughout to denote
optional arguments.) That is, you can type \kbd{foo(x,2)}, or \kbd{foo(x)},
which is then understood to mean \kbd{foo(x,0)}. As well, a comma or closing
parenthesis, where an optional argument should have been, signals to GP it
should use the default. Thus, the syntax \kbd{foo(x,)} is also accepted as a
synonym for our last expression. When a function has more than one optional
argument, the argument list is filled with user supplied values, in order.
When none are left, the defaults are used instead. Thus, assuming that
\kbd{foo}'s prototype had been
$$\hbox{%
\key{foo}$(\{x=1\},\{y=2\},\{z=3\})$,%
}$$
typing in \kbd{foo(6,4)} would give
you \kbd{foo(6,4,3)}. In the rare case when you want to set some far away
argument, and leave the defaults in between as they stand, you can use the
``empty arg'' trick alluded to above: \kbd{foo(6,,1)} would yield
\kbd{foo(6,2,1)}. By the way, \kbd{foo()} by itself yields
\kbd{foo(1,2,3)} as was to be expected.

In this rather special case of a function having no mandatory argument, you
can even omit the $()$: a standalone \kbd{foo} would be enough (though we
do not recommend it for your scripts, for the sake of clarity). In defining
GP syntax, we strove to put optional arguments at the end of the argument
list (of course, since they would not make sense otherwise), and in order of
decreasing usefulness so that, most of the time, you will be able to ignore
them.

Finally, an optional argument (between braces) followed by a star, like
$\{\var{x}\}*$, means that any number of such arguments (possibly none) can
be given. This is in particular used by the various \kbd{print} routines.

\misctitle{Flags} A \tev{flag} is an argument which, rather than conveying
actual information to the routine, instructs it to change its default
behavior, e.g.~return more or less information. All such
flags are optional, and will be called \fl\ in the function descriptions to
follow. There are two different kind of flags

\item generic: all valid values for the flag are individually
described (``If \fl\ is equal to $1$, then\dots'').

\item binary:\sidx{binary flag} use customary binary notation as a
compact way to represent many toggles with just one integer. Let
$(p_0,\dots,p_n)$ be a list of switches (i.e.~of properties which take either
the value $0$ or~$1$), the number $2^3 + 2^5 = 40$ means that $p_3$ and $p_5$
are set (that is, set to $1$), and none of the others are (that is, they
are set to $0$). This is announced as ``The binary digits of $\fl$ mean 1:
$p_0$, 2: $p_1$, 4: $p_2$'', and so on, using the available consecutive
powers of~$2$.

\misctitle{Mnemonics for binary flags} Numeric flags as mentioned above are
obscure, error-prone, and quite rigid: should the authors want to adopt a new
flag numbering scheme, it would break backward compatibility. The only
advantage of explicit numeric values is that they are fast to type, so their
use is only advised when using the calculator \kbd{gp}.

As an alternative, one can replace a binary flag by a character string
containing symbolic identifiers (mnemonics). In the function description,
mnemonics corresponding to the various toggles are given after each of them.
They can be negated by prepending \kbd{no\_} to the mnemonic, or by removing
such a prefix. These toggles are grouped together using any punctuation
character (such as ',' or ';'). For instance (taken from description of
$\tet{ploth}(X=a,b,\var{expr},\{\fl=0\},\{n=0\})$)

\centerline{Binary digits of flags mean: $1=\kbd{Parametric}$,
$2=\kbd{Recursive}$, \dots}

\noindent so that, instead of $1$, one could use the mnemonic
\kbd{"Parametric; no\_Recursive"}, or simply \kbd{"Parametric"} since
\kbd{Recursive} is unset by default (default value of $\fl$ is $0$,
i.e.~everything unset). People used to the bit-or notation in languages like
C may also use the form \kbd{"Parametric | no\_Recursive"}.

\misctitle{Pointers} \varsidx{pointer} If a parameter in the function
prototype is prefixed with a \& sign, as in

\key{foo}$(x,\&e)$

\noindent it means that, besides the normal return value, the function may
assign a value to $e$ as a side effect. When passing the argument, the \&
sign has to be typed in explicitly. As of version \vers, this \tev{pointer}
argument is optional for all documented functions, hence the \& will always
appear between brackets as in \kbd{Z\_issquare}$(x,\{\&e\})$.

\misctitle{About library programming}
The \var{library} function \kbd{foo}, as defined at the beginning of this
section, is seen to have two mandatory arguments, $x$ and \fl: no function
seen in the present chapter has been implemented so as to accept a variable
number of arguments, so all arguments are mandatory when programming with the
library (usually, variants are provided corresponding to the various flag values).
We include an \kbd{= default value} token in the prototype to signal how a missing
argument should be encoded. Most of the time, it will be a \kbd{NULL} pointer, or
-1 for a variable number. Refer to the \emph{User's Guide to the PARI library}
for general background and details.

\section{Programming in GP: control statements}
\sidx{programming}\label{se:programming}

  A number of control statements are available in GP. They are simpler and
have a syntax slightly different from their C counterparts, but are quite
powerful enough to write any kind of program. Some of them are specific to
GP, since they are made for number theorists. As usual, $X$ will denote any
simple variable name, and \var{seq} will always denote a sequence of
expressions, including the empty sequence.

\misctitle{Caveat} In constructs like
\bprog
    for (X = a,b, seq)
@eprog\noindent
the variable \kbd{X} is lexically scoped to the loop, leading to possibly
unexpected behavior:
\bprog
    n = 5;
    for (n = 1, 10,
      if (something_nice(), break);
    );
    \\ @com at this point \kbd{n} is 5 !
@eprog\noindent
If the sequence \kbd{seq} modifies the loop index, then the loop
is modified accordingly:
\bprog
    ? for (n = 1, 10, n += 2; print(n))
    3
    6
    9
    12
@eprog

\subsec{break$(\{n=1\})$}\kbdsidx{break}\label{se:break}
Interrupts execution of current \var{seq}, and
immediately exits from the $n$ innermost enclosing loops, within the
current function call (or the top level loop); the integer $n$ must be
positive. If $n$ is greater than the number of enclosing loops, all
enclosing loops are exited.

\subsec{breakpoint$()$}\kbdsidx{breakpoint}\label{se:breakpoint}
Interrupt the program and enter the breakloop. The program continues when
the breakloop is exited.
\bprog
? f(N,x)=my(z=x^2+1);breakpoint();gcd(N,z^2+1-z);
? f(221,3)
  ***   at top-level: f(221,3)
  ***                 ^--------
  ***   in function f: my(z=x^2+1);breakpoint();gcd(N,z
  ***                              ^--------------------
  ***   Break loop: type <Return> to continue; 'break' to go back to GP
break> z
10
break>
%2 = 13
@eprog

\subsec{dbg\_down$(\{n=1\})$}\kbdsidx{dbg_down}\label{se:dbg_down}
(In the break loop) go down n frames. This allows to cancel a previous
call to \kbd{dbg\_up}.
\bprog
? x = 0;
? g(x) = x-3;
? f(x) = 1 / g(x+1);
? for (x = 1, 5, f(x+1))
   ***   at top-level: for(x=1,5,f(x+1))
   ***                           ^-------
   ***   in function f: 1/g(x+1)
   ***                   ^-------
   *** _/_: impossible inverse in gdiv: 0.
   ***   Break loop: type 'break' to go back to GP prompt
break> dbg_up(3) \\ go up 3 frames
  ***   at top-level: for(x=1,5,f(x+1))
  ***                 ^-----------------
break> x
0
break> dbg_down()
  ***   at top-level: for(x=1,5,f(x+1))
  ***                           ^-------
break> x
1
break> dbg_down()
  ***   at top-level: for(x=1,5,f(x+1))
  ***                           ^-------
break> x
1
break> dbg_down()
  ***   at top-level: for(x=1,5,f(x+1))
  ***                           ^-------
  ***   in function f: 1/g(x+1)
  ***                   ^-------
break> x
2
@eprog\noindent The above example shows that the notion of GP frame is
finer than the usual stack of function calls (as given for instance by the
GDB \kbd{backtrace} command): GP frames are attached to variable scopes
and there are frames attached to control flow instructions such as a
\kbd{for} loop above.

\subsec{dbg\_err$()$}\kbdsidx{dbg_err}\label{se:dbg_err}
In the break loop, return the error data of the current error, if any.
See \tet{iferr} for details about error data.  Compare:
\bprog
? iferr(1/(Mod(2,12019)^(6!)-1),E,Vec(E))
%1 = ["e_INV", "Fp_inv", Mod(119, 12019)]
? 1/(Mod(2,12019)^(6!)-1)
  ***   at top-level: 1/(Mod(2,12019)^(6!)-
  ***                  ^--------------------
  *** _/_: impossible inverse in Fp_inv: Mod(119, 12019).
  ***   Break loop: type 'break' to go back to GP prompt
break> Vec(dbg_err())
["e_INV", "Fp_inv", Mod(119, 12019)]
@eprog

\subsec{dbg\_up$(\{n=1\})$}\kbdsidx{dbg_up}\label{se:dbg_up}
(In the break loop) go up n frames, which allows to inspect data of the
parent function. To cancel a \tet{dbg_up} call, use \tet{dbg_down}.
\bprog
? x = 0;
? g(x) = x-3;
? f(x) = 1 / g(x+1);
? for (x = 1, 5, f(x+1))
   ***   at top-level: for(x=1,5,f(x+1))
   ***                           ^-------
   ***   in function f: 1/g(x+1)
   ***                   ^-------
   *** _/_: impossible inverse in gdiv: 0.
   ***   Break loop: type 'break' to go back to GP prompt
 break> x
 2
 break> dbg_up()
   ***   at top-level: for(x=1,5,f(x+1))
   ***                           ^-------
 break> x
 1
 break> dbg_up()
   ***   at top-level: for(x=1,5,f(x+1))
   ***                           ^-------
 break> x
 1
 break> dbg_up()
   ***   at top-level: for(x=1,5,f(x+1))
   ***                 ^-----------------
 break> x
 0
 break> dbg_down()    \\ back up once
   ***   at top-level: for(x=1,5,f(x+1))
   ***                           ^-------
 break> x
 1
@eprog\noindent The above example shows that the notion of GP frame is
finer than the usual stack of function calls (as given for instance by the
GDB \kbd{backtrace} command): GP frames are attached to variable scopes
and there are frames attached to control flow instructions such as a
\kbd{for} loop above.

\subsec{dbg\_x$(A,\{n\})$}\kbdsidx{dbg_x}\label{se:dbg_x}
Print the inner structure of \kbd{A}, complete if \kbd{n} is omitted, up
to level \kbd{n} otherwise. This is useful for debugging. This is similar to
\b{x} but does not require \kbd{A} to be an history entry. In particular,
it can be used in the break loop.

\subsec{for$(X=a,b,\var{seq})$}\kbdsidx{for}\label{se:for}
Evaluates \var{seq}, where
the formal variable $X$ goes from $a$ to $b$. Nothing is done if $a>b$.
$a$ and $b$ must be in $\R$. If $b$ is set to \kbd{+oo}, the loop will not
stop; it is expected that the caller will break out of the loop itself at some
point, using \kbd{break} or \kbd{return}.

\subsec{forcomposite$(n=a,\{b\},\var{seq})$}\kbdsidx{forcomposite}\label{se:forcomposite}
Evaluates \var{seq},
where the formal variable $n$ ranges over the composite numbers between the
nonnegative real numbers $a$ to $b$, including $a$ and $b$ if they are
composite. Nothing is done if $a>b$.
\bprog
? forcomposite(n = 0, 10, print(n))
4
6
8
9
10
@eprog\noindent Omitting $b$ means we will run through all composites $\geq a$,
starting an infinite loop; it is expected that the user will break out of
the loop himself at some point, using \kbd{break} or \kbd{return}.

Note that the value of $n$ cannot be modified within \var{seq}:
\bprog
? forcomposite(n = 2, 10, n = [])
 ***   at top-level: forcomposite(n=2,10,n=[])
 ***                                      ^---
 ***   index read-only: was changed to [].
@eprog

\subsec{fordiv$(n,X,\var{seq})$}\kbdsidx{fordiv}\label{se:fordiv}
Evaluates \var{seq}, where
the formal variable $X$ ranges through the divisors of $n$
(see \tet{divisors}, which is used as a subroutine). It is assumed that
\kbd{factor} can handle $n$, without negative exponents. Instead of $n$,
it is possible to input a factorization matrix, i.e. the output of
\kbd{factor(n)}.

This routine uses \kbd{divisors} as a subroutine, then loops over the
divisors. In particular, if $n$ is an integer, divisors are sorted by
increasing size.

To avoid storing all divisors, possibly using a lot of memory, the following
(slower) routine loops over the divisors using essentially constant space:
\bprog
FORDIV(N)=
{ my(F = factor(N), P = F[,1], E = F[,2]);

  forvec(v = vector(#E, i, [0,E[i]]), X = factorback(P, v));
}
? for(i=1, 10^6, FORDIV(i))
time = 11,180 ms.
? for(i=1, 10^6, fordiv(i, d, ))
time = 2,667 ms.
@eprog\noindent Of course, the divisors are no longer sorted by inreasing
size.

\subsec{fordivfactored$(n,X,\var{seq})$}\kbdsidx{fordivfactored}\label{se:fordivfactored}
Evaluates \var{seq}, where
the formal variable $X$ ranges through $[d, \kbd{factor}(d)]$,
where $d$ is a divisors of $n$
(see \tet{divisors}, which is used as a subroutine). Note that such a pair
is accepted as argument to all multiplicative functions.

It is assumed that
\kbd{factor} can handle $n$, without negative exponents. Instead of $n$,
it is possible to input a factorization matrix, i.e. the output of
\kbd{factor(n)}. This routine uses \kbd{divisors}$(,1)$ as a subroutine,
then loops over the divisors. In particular, if $n$ is an integer, divisors
are sorted by increasing size.

This function is particularly useful when $n$ is hard to factor and one
must evaluate multiplicative function on its divisors: we avoid
refactoring each divisor in turn. It also provides a small speedup
when $n$ is easy to factor; compare
\bprog
? A = 10^8; B = A + 10^5;
? for (n = A, B, fordiv(n, d, eulerphi(d)));
time = 2,091 ms.
? for (n = A, B, fordivfactored(n, d, eulerphi(d)));
time = 1,298 ms. \\ avoid refactoring the divisors
? forfactored (n = A, B, fordivfactored(n, d, eulerphi(d)));
time = 1,270 ms. \\ also avoid factoring the consecutive n's !
@eprog

\subsec{foreach$(V,X,\var{seq})$}\kbdsidx{foreach}\label{se:foreach}
Evaluates \var{seq}, where the formal variable $X$ ranges through the
components of $V$ (\typ{VEC}, \typ{COL}, \typ{LIST} or \typ{MAT}). A matrix
argument is interpreted as a vector containing column vectors, as in
\kbd{Vec}$(V)$.

\subsec{forell$(E,a,b,\var{seq},\{\fl=0\})$}\kbdsidx{forell}\label{se:forell}
Evaluates \var{seq}, where the formal variable $E = [\var{name}, M, G]$
ranges through all elliptic curves of conductors from $a$ to $b$. In this
notation \var{name} is the curve name in Cremona's elliptic  curve  database,
$M$ is the minimal model, $G$ is a $\Z$-basis of the free part of the
Mordell-Weil group $E(\Q)$. If flag is nonzero, select
only the first curve in each isogeny class.
\bprog
? forell(E, 1, 500, my([name,M,G] = E); \
    if (#G > 1, print(name)))
389a1
433a1
446d1
? c = 0; forell(E, 1, 500, c++); c   \\ number of curves
%2 = 2214
? c = 0; forell(E, 1, 500, c++, 1); c \\ number of isogeny classes
%3 = 971
@eprog\noindent
The \tet{elldata} database must be installed and contain data for the
specified conductors.

\synt{forell}{void *data, long (*f)(void*,GEN), long a, long b, long flag}.

\subsec{forfactored$(N=a,b,\var{seq})$}\kbdsidx{forfactored}\label{se:forfactored}
Evaluates \var{seq}, where
the formal variable $N$ is $[n, \kbd{factor}(n)]$ and $n$ goes from
$a$ to $b$; $a$ and $b$ must be integers. Nothing is done if $a>b$.

This function is only implemented for $|a|, |b| < 2^{64}$ ($2^{32}$ on a 32-bit
machine). It uses a sieve and runs in time $O(\sqrt{b} + b-a)$. It should
be at least 3 times faster than regular factorization as long as the interval
length $b-a$ is much larger than $\sqrt{b}$ and get relatively faster as
the bounds increase. The function slows down dramatically
if $\kbd{primelimit} < \sqrt{b}$.

\bprog
? B = 10^9;
? for (N = B, B+10^6, factor(N))
time = 4,538 ms.
? forfactored (N = B, B+10^6, [n,fan] = N)
time = 1,031 ms.

? B = 10^11;
? for (N = B, B+10^6, factor(N))
time = 15,575 ms.
? forfactored (N = B, B+10^6, [n,fan] = N)
time = 2,375 ms.

? B = 10^14;
? for (N = B, B+10^6, factor(N))
time = 1min, 4,948 ms.
? forfactored (N = B, B+10^6, [n,fan] = N)
time = 58,601 ms.
@eprog\noindent The last timing is with the default \kbd{primelimit}
(500000) which is much less than $\sqrt{B+10^6}$; it goes down
to \kbd{26,750ms} if \kbd{primelimit} gets bigger than that bound.
In any case $\sqrt{B+10^6}$ is much larger than the interval length $10^6$
so \kbd{forfactored} gets relatively slower for that reason as well.

Note that all PARI multiplicative functions accept the \kbd{[n,fan]}
argument natively:
\bprog
? s = 0; forfactored(N = 1, 10^7, s += moebius(N)*eulerphi(N)); s
time = 6,001 ms.
%1 = 6393738650
? s = 0; for(N = 1, 10^7, s += moebius(N)*eulerphi(N)); s
time = 28,398 ms. \\ slower, we must factor N. Twice.
%2 = 6393738650
@eprog

The following loops over the fundamental dicriminants less than $X$:
\bprog
? X = 10^8;
? forfactored(d=1,X, if (isfundamental(d),));
time = 34,030 ms.
? for(d=1,X, if (isfundamental(d),))
time = 1min, 24,225 ms.
@eprog

\subsec{forpart$(X=k,\var{seq},\{a=k\},\{n=k\})$}\kbdsidx{forpart}\label{se:forpart}
Evaluate \var{seq} over the partitions $X=[x_1,\dots x_n]$ of the
integer $k$, i.e.~increasing sequences $x_1\leq x_2\dots \leq x_n$ of sum
$x_1+\dots + x_n=k$. By convention, $0$ admits only the empty partition and
negative numbers have no partitions. A partition is given by a
\typ{VECSMALL}, where parts are sorted in nondecreasing order. The
partitions are listed by increasing size and in lexicographic order when
sizes are equal:
\bprog
? forpart(X=4, print(X))
Vecsmall([4])
Vecsmall([1, 3])
Vecsmall([2, 2])
Vecsmall([1, 1, 2])
Vecsmall([1, 1, 1, 1])
@eprog\noindent Optional parameters $n$ and $a$ are as follows:

\item $n=\var{nmax}$ (resp. $n=[\var{nmin},\var{nmax}]$) restricts
partitions to length less than $\var{nmax}$ (resp. length between
$\var{nmin}$ and $nmax$), where the \emph{length} is the number of nonzero
entries.

\item $a=\var{amax}$ (resp. $a=[\var{amin},\var{amax}]$) restricts the parts
to integers less than $\var{amax}$ (resp. between $\var{amin}$ and
$\var{amax}$).

By default, parts are positive and we remove zero entries unless $amin\leq0$,
in which case we fix the size $\#X = \var{nmax}$:
\bprog
\\ at most 3 nonzero parts, all <= 4
? forpart(v=5,print(Vec(v)), 4, 3)
[1, 4]
[2, 3]
[1, 1, 3]
[1, 2, 2]

\\ between 2 and 4 parts less than 5, fill with zeros
? forpart(v=5,print(Vec(v)),[0,5],[2,4])
[0, 0, 1, 4]
[0, 0, 2, 3]
[0, 1, 1, 3]
[0, 1, 2, 2]
[1, 1, 1, 2]

\\ no partitions of 1 with 2 to 4 nonzero parts
? forpart(v=1,print(v),[0,5],[2,4])
?
@eprog\noindent
The behavior is unspecified if $X$ is modified inside the loop.

\synt{forpart}{void *data, long (*call)(void*,GEN), long k, GEN a, GEN n}.

\subsec{forperm$(a,p,\var{seq})$}\kbdsidx{forperm}\label{se:forperm}
Evaluates \var{seq}, where the formal variable $p$ goes through some
permutations given by a \typ{VECSMALL}. If $a$ is a positive integer then
$P$ goes through the permutations of $\{1, 2, ..., a\}$ in lexicographic
order and if $a$ is a small vector then $p$ goes through the
(multi)permutations lexicographically larger than or equal to $a$.
\bprog
? forperm(3, p, print(p))
Vecsmall([1, 2, 3])
Vecsmall([1, 3, 2])
Vecsmall([2, 1, 3])
Vecsmall([2, 3, 1])
Vecsmall([3, 1, 2])
Vecsmall([3, 2, 1])
@eprog\noindent

When $a$ is itself a \typ{VECSMALL} or a \typ{VEC} then $p$ iterates through
multipermutations
\bprog
? forperm([2,1,1,3], p, print(p))
Vecsmall([2, 1, 1, 3])
Vecsmall([2, 1, 3, 1])
Vecsmall([2, 3, 1, 1])
Vecsmall([3, 1, 1, 2])
Vecsmall([3, 1, 2, 1])
Vecsmall([3, 2, 1, 1])
@eprog\noindent

\subsec{forprime$(p=a,\{b\},\var{seq})$}\kbdsidx{forprime}\label{se:forprime}
Evaluates \var{seq},
where the formal variable $p$ ranges over the prime numbers between the real
numbers $a$ to $b$, including $a$ and $b$ if they are prime. More precisely,
the value of
$p$ is incremented to \kbd{nextprime($p$ + 1)}, the smallest prime strictly
larger than $p$, at the end of each iteration. Nothing is done if $a>b$.
\bprog
? forprime(p = 4, 10, print(p))
5
7
@eprog\noindent Setting $b$ to \kbd{+oo} means we will run through all primes
$\geq a$, starting an infinite loop; it is expected that the caller will break
out of the loop itself at some point, using \kbd{break} or \kbd{return}.

Note that the value of $p$ cannot be modified within \var{seq}:
\bprog
? forprime(p = 2, 10, p = [])
 ***   at top-level: forprime(p=2,10,p=[])
 ***                                   ^---
 ***   prime index read-only: was changed to [].
@eprog

\subsec{forprimestep$(p=a,b,q,\var{seq})$}\kbdsidx{forprimestep}\label{se:forprimestep}
Evaluates \var{seq}, where the formal variable $p$ ranges over the prime
numbers in an arithmetic progression in $[a,b]$: $q$ is either an integer
($p \equiv a \pmod{q}$) or an intmod \kbd{Mod(c,N)} and we restrict
to that congruence class. Nothing is done if $a>b$.
\bprog
? forprimestep(p = 4, 30, 5, print(p))
19
29
? forprimestep(p = 4, 30, Mod(1,5), print(p))
11
@eprog\noindent Setting $b$ to \kbd{+oo} means we will run through all primes
$\geq a$, starting an infinite loop; it is expected that the caller will break
out of the loop itself at some point, using \kbd{break} or \kbd{return}.

The current implementation restricts the modulus of the arithmetic
progression to an unsigned long (64 or 32 bits).
\bprog
? forprimestep(p=2,oo,2^64,print(p))
 ***   at top-level: forprimestep(p=2,oo,2^64,print(p))
 ***                 ^----------------------------------
 *** forprimestep: overflow in t_INT-->ulong assignment.
@eprog

Note that the value of $p$ cannot be modified within \var{seq}:
\bprog
? forprimestep(p = 2, 10, 3, p = [])
 ***   at top-level: forprimestep(p=2,10,3,p=[])
 ***                                         ^---
 ***   prime index read-only: was changed to [].
@eprog

\subsec{forsquarefree$(N=a,b,\var{seq})$}\kbdsidx{forsquarefree}\label{se:forsquarefree}
Evaluates \var{seq}, where the formal variable $N$ is $[n,
\kbd{factor}(n)]$ and $n$ goes through squarefree integers from $a$ to $b$;
$a$ and $b$ must be integers. Nothing is done if $a>b$.

\bprog
? forsquarefree(N=-3,9,print(N))
[-3, [-1, 1; 3, 1]]
[-2, [-1, 1; 2, 1]]
[-1, Mat([-1, 1])]
[1, matrix(0,2)]
[2, Mat([2, 1])]
[3, Mat([3, 1])]
[5, Mat([5, 1])]
[6, [2, 1; 3, 1]]
[7, Mat([7, 1])]
@eprog

This function is only implemented for $|a|, |b| < 2^{64}$ ($2^{32}$ on a 32-bit
machine). It uses a sieve and runs in time $O(\sqrt{b} + b-a)$. It should
be at least 5 times faster than regular factorization as long as the interval
length $b-a$ is much larger than $\sqrt{b}$ and get relatively faster as
the bounds increase. The function slows down dramatically
if $\kbd{primelimit} < \sqrt{b}$. It is comparable to \kbd{forfactored}, but
about $\zeta(2) = \pi^2/6$ times faster due to the relative density
of squarefree integers.

\bprog
? B = 10^9;
? for (N = B, B+10^6, factor(N))
time = 2,463 ms.
? forfactored (N = B, B+10^6, [n,fan] = N)
time = 567 ms.
? forsquarefree (N = B, B+10^6, [n,fan] = N)
time = 343 ms.

? B = 10^11;
? for (N = B, B+10^6, factor(N))
time = 8,012 ms.
? forfactored (N = B, B+10^6, [n,fan] = N)
time = 1,293 ms.
? forsquarefree (N = B, B+10^6, [n,fan] = N)
time = 713 ms.

? B = 10^14;
? for (N = B, B+10^6, factor(N))
time = 41,283 ms.
? forsquarefree (N = B, B+10^6, [n,fan] = N)
time = 33,399 ms.
@eprog\noindent The last timing is with the default \kbd{primelimit}
(500000) which is much less than $\sqrt{B+10^6}$; it goes down
to \kbd{29,253ms} if \kbd{primelimit} gets bigger than that bound.
In any case $\sqrt{B+10^6}$ is much larger than the interval length $10^6$
so \kbd{forsquarefree} gets relatively slower for that reason as well.

Note that all PARI multiplicative functions accept the \kbd{[n,fan]}
argument natively:
\bprog
? s = 0; forsquarefree(N = 1, 10^7, s += moebius(N)*eulerphi(N)); s
time = 2,003 ms.
%1 = 6393738650
? s = 0; for(N = 1, 10^7, s += moebius(N)*eulerphi(N)); s
time = 18,024 ms. \\ slower, we must factor N. Twice.
%2 = 6393738650
@eprog

The following loops over the fundamental dicriminants less than $X$:
\bprog
? X = 10^8;
? for(d=1,X, if (isfundamental(d),))
time = 53,387 ms.
? forfactored(d=1,X, if (isfundamental(d),));
time = 13,861 ms.
? forsquarefree(d=1,X, D = quaddisc(d); if (D <= X, ));
time = 14,341 ms.
@eprog\noindent Note that in the last loop, the fundamental discriminants
$D$ are not evaluated in order (since \kbd{quaddisc(d)} for squarefree $d$
is either $d$ or $4d$) but the set of numbers we run through is the same.
Not worth the complication since it's slower than testing \kbd{isfundamental}.
A faster, more complicated approach uses two loops. For simplicity, assume
$X$ is divisible by $4$:
\bprog
? forsquarefree(d=1,X/4, D = quaddisc(d));
time = 3,642 ms.
? forsquarefree(d=X/4+1,X, if (d[1] % 4 == 1,));
time = 7,772 ms.
@eprog\noindent This is the price we pay for a faster evaluation,

We can run through negative fundamental discriminants in the same way:
\bprog
? forfactored(d=-X,-1, if (isfundamental(d),));
@eprog

\subsec{forstep$(X=a,b,s,\var{seq})$}\kbdsidx{forstep}\label{se:forstep}
Evaluates \var{seq}, where the formal variable $X$ goes from $a$ to $b$
in increments of $s$. Nothing is done if $s>0$ and $a>b$ or if $s<0$
and $a<b$. The $s$ can be

\item a positive real number, preferably an integer: $X = a, a+s, a+2s\dots$

\item an intmod \kbd{Mod(c,N)} (restrict to the corresponding arithmetic
progression starting at the smallest integer $A \geq a$ and congruent to $c$
modulo $N$): $X = A, A + N, \dots$

\item a vector of steps $[s_1,\dots,s_n]$ (the successive steps in $\R^*$
are used in the order they appear in $s$): $X = a, a+s_1, a+s_1+s_2, \dots$

\bprog
? forstep(x=5, 10, 2, print(x))
5
7
9
? forstep(x=5, 10, Mod(1,3), print(x))
7
10
? forstep(x=5, 10, [1,2], print(x))
5
6
8
9
@eprog\noindent Setting $b$ to \kbd{+oo} will start an infinite loop; it is
expected that the caller will break out of the loop itself at some point,
using \kbd{break} or \kbd{return}.

\subsec{forsubgroup$(H=G,\{\var{bound}\},\var{seq})$}\kbdsidx{forsubgroup}\label{se:forsubgroup}
Evaluates \var{seq} for
each subgroup $H$ of the \emph{abelian} group $G$ (given in
SNF\sidx{Smith normal form} form or as a vector of elementary divisors).

If \var{bound} is present, and is a positive integer, restrict the output to
subgroups of index less than \var{bound}. If \var{bound} is a vector
containing a single positive integer $B$, then only subgroups of index
exactly equal to $B$ are computed

The subgroups are not ordered in any
obvious way, unless $G$ is a $p$-group in which case Birkhoff's algorithm
produces them by decreasing index. A \idx{subgroup} is given as a matrix
whose columns give its generators on the implicit generators of $G$. For
example, the following prints all subgroups of index less than 2 in $G =
\Z/2\Z g_1 \times \Z/2\Z g_2$:

\bprog
? G = [2,2]; forsubgroup(H=G, 2, print(H))
[1; 1]
[1; 2]
[2; 1]
[1, 0; 1, 1]
@eprog\noindent
The last one, for instance is generated by $(g_1, g_1 + g_2)$. This
routine is intended to treat huge groups, when \tet{subgrouplist} is not an
option due to the sheer size of the output.

For maximal speed the subgroups have been left as produced by the algorithm.
To print them in canonical form (as left divisors of $G$ in HNF form), one
can for instance use
\bprog
? G = matdiagonal([2,2]); forsubgroup(H=G, 2, print(mathnf(concat(G,H))))
[2, 1; 0, 1]
[1, 0; 0, 2]
[2, 0; 0, 1]
[1, 0; 0, 1]
@eprog\noindent
Note that in this last representation, the index $[G:H]$ is given by the
determinant. See \tet{galoissubcyclo} and \tet{galoisfixedfield} for
applications to \idx{Galois} theory.

\synt{forsubgroup}{void *data, long (*call)(void*,GEN), GEN G, GEN bound}.

\subsec{forsubset$(\var{nk}, s, \var{seq})$}\kbdsidx{forsubset}\label{se:forsubset}
If \var{nk} is a nonnegative integer $n$, evaluates \kbd{seq}, where
the formal variable $s$ goes through all subsets of $\{1, 2, \ldots, n\}$;
if \var{nk} is a pair $[n,k]$ of integers, $s$ goes through subsets
of size $k$ of $\{1, 2, \ldots, n\}$. In both cases $s$ goes through subsets
in lexicographic order among subsets of the same size and smaller subsets
come first.
\bprog
? forsubset([5,3], s, print(s))
Vecsmall([1, 2, 3])
Vecsmall([1, 2, 4])
Vecsmall([1, 2, 5])
Vecsmall([1, 3, 4])
Vecsmall([1, 3, 5])
Vecsmall([1, 4, 5])
Vecsmall([2, 3, 4])
Vecsmall([2, 3, 5])
Vecsmall([2, 4, 5])
Vecsmall([3, 4, 5])
@eprog

\bprog
? forsubset(3, s, print(s))
Vecsmall([])
Vecsmall([1])
Vecsmall([2])
Vecsmall([3])
Vecsmall([1, 2])
Vecsmall([1, 3])
Vecsmall([2, 3])
Vecsmall([1, 2, 3])
@eprog\noindent The running time is proportional to the number
of subsets enumerated, respectively $2^n$ and \kbd{binomial}$(n,k)$:
\bprog
? c = 0; forsubset([40,35],s,c++); c
time = 128 ms.
%4 = 658008
? binomial(40,35)
%5 = 658008
@eprog

\subsec{forvec$(X=v,\var{seq},\{\fl=0\})$}\kbdsidx{forvec}\label{se:forvec}
Let $v$ be an $n$-component vector (where $n$ is arbitrary) of
two-component vectors $[a_i,b_i]$ for $1\le i\le n$, where all entries $a_i$,
$b_i$ are real numbers. This routine lets $X$ vary over the $n$-dimensional
box given by $v$ with unit steps: $X$ is an $n$-dimensional vector whose $i$-th
entry $X[i]$ runs through $a_i, a_i+1, a_i+2, \dots $ stopping with the
first value greater than $b_i$ (note that neither $a_i$ nor $b_i - a_i$
are required to be integers). The values of $X$ are ordered
lexicographically, like embedded \kbd{for} loops, and the expression
\var{seq} is evaluated with the successive values of $X$. The type of $X$ is
the same as the type of $v$: \typ{VEC} or \typ{COL}.

If $\fl=1$, generate only nondecreasing vectors $X$, and
if $\fl=2$, generate only strictly increasing vectors $X$.
\bprog
? forvec (X=[[0,1],[-1,1]], print(X));
[0, -1]
[0, 0]
[0, 1]
[1, -1]
[1, 0]
[1, 1]
? forvec (X=[[0,1],[-1,1]], print(X), 1);
[0, 0]
[0, 1]
[1, 1]
? forvec (X=[[0,1],[-1,1]], print(X), 2)
[0, 1]
@eprog

\subsec{if$(a,\{\var{seq1}\},\{\var{seq2}\})$}\kbdsidx{if}\label{se:if}
Evaluates the expression sequence \var{seq1} if $a$ is nonzero, otherwise
the expression \var{seq2}. Of course, \var{seq1} or \var{seq2} may be empty:

\kbd{if ($a$,\var{seq})} evaluates \var{seq} if $a$ is not equal to zero
(you don't have to write the second comma), and does nothing otherwise,

\kbd{if ($a$,,\var{seq})} evaluates \var{seq} if $a$ is equal to zero, and
does nothing otherwise. You could get the same result using the \kbd{!}
(\kbd{not}) operator: \kbd{if (!$a$,\var{seq})}.

The value of an \kbd{if} statement is the value of the branch that gets
evaluated: for instance
\bprog
x = if(n % 4 == 1, y, z);
@eprog\noindent sets $x$ to $y$ if $n$ is $1$ modulo $4$, and to $z$
otherwise.

Successive 'else' blocks can be abbreviated in a single compound \kbd{if}
as follows:
\bprog
if (test1, seq1,
    test2, seq2,
    ...
    testn, seqn,
    seqdefault);
@eprog\noindent is equivalent to
\bprog
if (test1, seq1
         , if (test2, seq2
                    , ...
                      if (testn, seqn, seqdefault)...));
@eprog For instance, this allows to write traditional switch / case
constructions:
\bprog
if (x == 0, do0(),
    x == 1, do1(),
    x == 2, do2(),
    dodefault());
@eprog

\misctitle{Remark}
The boolean operators \kbd{\&\&} and \kbd{||} are evaluated
according to operator precedence as explained in \secref{se:operators}, but,
contrary to other operators, the evaluation of the arguments is stopped
as soon as the final truth value has been determined. For instance
\bprog
if (x != 0 && f(1/x), ...)
@eprog
\noindent is a perfectly safe statement.

\misctitle{Remark} Functions such as \kbd{break} and \kbd{next} operate on
\emph{loops}, such as \kbd{for$xxx$}, \kbd{while}, \kbd{until}. The \kbd{if}
statement is \emph{not} a loop. (Obviously!)

\subsec{iferr$(\var{seq1},E,\var{seq2},\{\var{pred}\})$}\kbdsidx{iferr}\label{se:iferr}
Evaluates the expression sequence \var{seq1}. If an error occurs,
set the formal parameter \var{E} set to the error data.
If \var{pred} is not present or evaluates to true, catch the error
and evaluate \var{seq2}. Both \var{pred} and \var{seq2} can reference \var{E}.
The error type is given by \kbd{errname(E)}, and other data can be
accessed using the \tet{component} function. The code \var{seq2} should check
whether the error is the one expected. In the negative the error can be
rethrown using \tet{error(E)} (and possibly caught by an higher \kbd{iferr}
instance). The following uses \kbd{iferr} to implement Lenstra's ECM factoring
 method
\bprog
? ecm(N, B = 1000!, nb = 100)=
  {
    for(a = 1, nb,
      iferr(ellmul(ellinit([a,1]*Mod(1,N)), [0,1]*Mod(1,N), B),
        E, return(gcd(lift(component(E,2)),N)),
        errname(E)=="e_INV" && type(component(E,2)) == "t_INTMOD"))
  }
? ecm(2^101-1)
%2 = 7432339208719
@eprog
The return value of \kbd{iferr} itself is the value of \var{seq2} if an
error occurs, and the value of \var{seq1} otherwise. We now describe the
list of valid error types, and the attached error data \var{E}; in each
case, we list in order the components of \var{E}, accessed via
\kbd{component(E,1)}, \kbd{component(E,2)}, etc.

 \misctitle{Internal errors, ``system'' errors}

 \item \kbd{"e\_ARCH"}. A requested feature $s$ is not available on this
 architecture or operating system.
 \var{E} has one component (\typ{STR}): the missing feature name $s$.

 \item \kbd{"e\_BUG"}. A bug in the PARI library, in function $s$.
 \var{E} has one component (\typ{STR}): the function name $s$.

 \item \kbd{"e\_FILE"}. Error while trying to open a file.
 \var{E} has two components, 1 (\typ{STR}): the file type (input, output,
 etc.), 2 (\typ{STR}): the file name.

 \item \kbd{"e\_IMPL"}. A requested feature $s$ is not implemented.
 \var{E} has one component, 1 (\typ{STR}): the feature name $s$.

 \item \kbd{"e\_PACKAGE"}. Missing optional package $s$.
 \var{E} has one component, 1 (\typ{STR}): the package name $s$.

 \misctitle{Syntax errors, type errors}

 \item \kbd{"e\_DIM"}. The dimensions of arguments $x$ and $y$ submitted
 to function $s$ does not match up.
 E.g., multiplying matrices of inconsistent dimension, adding vectors of
 different lengths,\dots
 \var{E} has three component, 1 (\typ{STR}): the function name $s$, 2: the
 argument $x$, 3: the argument $y$.

 \item \kbd{"e\_FLAG"}. A flag argument is out of bounds in function $s$.
 \var{E} has one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_NOTFUNC"}. Generated by the PARI evaluator; tried to use a
\kbd{GEN} $x$ which is not a \typ{CLOSURE} in a function call syntax (as in
\kbd{f = 1; f(2);}).
 \var{E} has one component, 1: the offending \kbd{GEN} $x$.

 \item \kbd{"e\_OP"}. Impossible operation between two objects than cannot
 be typecast to a sensible common domain for deeper reasons than a type
 mismatch, usually for arithmetic reasons. As in \kbd{O(2) + O(3)}: it is
 valid to add two \typ{PADIC}s, provided the underlying prime is the same; so
 the addition is not forbidden a priori for type reasons, it only becomes so
 when inspecting the objects and trying to perform the operation.
 \var{E} has three components, 1 (\typ{STR}): the operator name \var{op},
 2: first argument, 3: second argument.

 \item \kbd{"e\_TYPE"}. An argument $x$ of function $s$ had an unexpected type.
 (As in \kbd{factor("blah")}.)
 \var{E} has two components, 1 (\typ{STR}): the function name $s$,
 2: the offending argument $x$.

 \item \kbd{"e\_TYPE2"}. Forbidden operation between two objects than cannot be
 typecast to a sensible common domain, because their types do not match up.
 (As in \kbd{Mod(1,2) + Pi}.)
 \var{E} has three components, 1 (\typ{STR}): the operator name \var{op},
 2: first argument, 3: second argument.

 \item \kbd{"e\_PRIORITY"}. Object $o$ in function $s$ contains
 variables whose priority is incompatible with the expected operation.
 E.g.~\kbd{Pol([x,1], 'y)}: this raises an error because it's not possible to
 create a polynomial whose coefficients involve variables with higher priority
 than the main variable. $E$ has four components: 1 (\typ{STR}): the function
 name $s$, 2: the offending argument $o$, 3 (\typ{STR}): an operator
 $\var{op}$ describing the priority error, 4 (\typ{POL}):
 the variable $v$ describing the priority error. The argument
 satisfies $\kbd{variable}(x)~\var{op} \kbd{variable}(v)$.

 \item \kbd{"e\_VAR"}. The variables of arguments $x$ and $y$ submitted
 to function $s$ does not match up. E.g., considering the algebraic number
 \kbd{Mod(t,t\pow2+1)} in \kbd{nfinit(x\pow2+1)}.
 \var{E} has three component, 1 (\typ{STR}): the function name $s$, 2
 (\typ{POL}): the argument $x$, 3 (\typ{POL}): the argument $y$.

 \misctitle{Overflows}

 \item \kbd{"e\_COMPONENT"}. Trying to access an inexistent component in a
 vector/matrix/list in a function: the index is less than $1$ or greater
 than the allowed length.
 \var{E} has four components,
 1 (\typ{STR}): the function name
 2 (\typ{STR}): an operator $\var{op}$ ($<$ or $>$),
 2 (\typ{GEN}): a numerical limit $l$ bounding the allowed range,
 3 (\kbd{GEN}): the index $x$. It satisfies $x$ \var{op} $l$.

 \item \kbd{"e\_DOMAIN"}. An argument is not in the function's domain.
 \var{E} has five components, 1 (\typ{STR}): the function name,
 2 (\typ{STR}): the mathematical name of the out-of-domain argument
 3 (\typ{STR}): an operator $\var{op}$ describing the domain error,
 4 (\typ{GEN}): the numerical limit $l$ describing the domain error,
 5 (\kbd{GEN}): the out-of-domain argument $x$. The argument satisfies $x$
 \var{op} $l$, which prevents it from belonging to the function's domain.

 \item \kbd{"e\_MAXPRIME"}. A function using the precomputed list of prime
 numbers ran out of primes.
 \var{E} has one component, 1 (\typ{INT}): the requested prime bound, which
 overflowed \kbd{primelimit} or $0$ (bound is unknown).

 \item \kbd{"e\_MEM"}. A call to \tet{pari_malloc} or \tet{pari_realloc}
 failed. \var{E} has no component.

 \item \kbd{"e\_OVERFLOW"}. An object in function $s$ becomes too large to be
 represented within PARI's hardcoded limits. (As in \kbd{2\pow2\pow2\pow10} or
 \kbd{exp(1e100)}, which overflow in \kbd{lg} and \kbd{expo}.)
 \var{E} has one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_PREC"}. Function $s$ fails because input accuracy is too low.
 (As in \kbd{floor(1e100)} at default accuracy.)
 \var{E} has one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_STACK"}. The PARI stack overflows.
 \var{E} has no component.

 \misctitle{Errors triggered intentionally}

 \item \kbd{"e\_ALARM"}. A timeout, generated by the \tet{alarm} function.
 \var{E} has one component (\typ{STR}): the error message to print.

 \item \kbd{"e\_USER"}. A user error, as triggered by
 \tet{error}($g_1,\dots,g_n)$.
 \var{E} has one component, 1 (\typ{VEC}): the vector of $n$ arguments given
 to \kbd{error}.

 \misctitle{Mathematical errors}

 \item \kbd{"e\_CONSTPOL"}. An argument of function $s$ is a constant
 polynomial, which does not make sense. (As in \kbd{galoisinit(Pol(1))}.)
 \var{E} has one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_COPRIME"}. Function $s$ expected coprime arguments,
 and did receive $x,y$, which were not.
 \var{E} has three component, 1 (\typ{STR}): the function name $s$,
 2: the argument $x$, 3: the argument $y$.

 \item \kbd{"e\_INV"}. Tried to invert a noninvertible object $x$ in
 function $s$.
 \var{E} has two components, 1 (\typ{STR}): the function name $s$,
 2: the noninvertible $x$. If $x = \kbd{Mod}(a,b)$
 is a \typ{INTMOD} and $a$ is not $0$ mod $b$, this allows to factor
 the modulus, as \kbd{gcd}$(a,b)$ is a nontrivial divisor of $b$.

 \item \kbd{"e\_IRREDPOL"}. Function $s$ expected an irreducible polynomial,
 and did receive $T$, which was not. (As in \kbd{nfinit(x\pow2-1)}.)
 \var{E} has two component, 1 (\typ{STR}): the function name $s$,
 2 (\typ{POL}): the polynomial $x$.

 \item \kbd{"e\_MISC"}. Generic uncategorized error.
 \var{E} has one component (\typ{STR}): the error message to print.

 \item \kbd{"e\_MODULUS"}. moduli $x$ and $y$ submitted to function $s$ are
 inconsistent. As in
 \bprog
   nfalgtobasis(nfinit(t^3-2), Mod(t,t^2+1)
 @eprog\noindent
 \var{E} has three component, 1 (\typ{STR}): the function $s$,
 2: the argument $x$, 3: the argument $x$.

 \item \kbd{"e\_PRIME"}. Function $s$ expected a prime number,
 and did receive $p$, which was not. (As in \kbd{idealprimedec(nf, 4)}.)
 \var{E} has two component, 1 (\typ{STR}): the function name $s$,
 2: the argument $p$.

 \item \kbd{"e\_ROOTS0"}. An argument of function $s$ is a zero polynomial,
 and we need to consider its roots. (As in \kbd{polroots(0)}.) \var{E} has
 one component, 1 (\typ{STR}): the function name $s$.

 \item \kbd{"e\_SQRTN"}. Trying to compute an $n$-th root of $x$, which does
 not exist, in function $s$. (As in \kbd{sqrt(Mod(-1,3))}.)
 \var{E} has two components, 1 (\typ{STR}): the function name $s$,
 2: the argument $x$.

\subsec{next$(\{n=1\})$}\kbdsidx{next}\label{se:next}
Interrupts execution of current $seq$,
resume the next iteration of the innermost enclosing loop, within the
current function call (or top level loop). If $n$ is specified, resume at
the $n$-th enclosing loop. If $n$ is bigger than the number of enclosing
loops, all enclosing loops are exited.

\subsec{return$(\{x=0\})$}\kbdsidx{return}\label{se:return}
Returns from current subroutine, with
result $x$. If $x$ is omitted, return the \kbd{(void)} value (return no
result, like \kbd{print}).

\subsec{setdebug$(\{D\},\{n\})$}\kbdsidx{setdebug}\label{se:setdebug}
Set debug level for domain $D$ to $n$ ($0 \leq n \leq 20$).
The domain $D$ is a character string describing a Pari feature or code
module, such as \kbd{"bnf"}, \kbd{"qflll"} or \kbd{"polgalois"}. This allows
to selectively increase or decrease the diagnostics attached to a particular
feature.
If $n$ is omitted, return the current level for domain $D$.
If $D$ is omitted, return a two-column matrix which lists the available
domains with their levels. The \kbd{debug} default allows to reset all debug
levels to a given value.
\bprog
? setdebug()[,1] \\ list of all domains
["alg", "arith", "bern", "bnf", "bnr", "bnrclassfield", ..., "zetamult"]

? \g 1   \\ set all debug levels to 1
  debug = 1
? setdebug("bnf", 0); \\ kill messages related to bnfinit and bnfisrincipal
@eprog

\subsec{until$(a,\var{seq})$}\kbdsidx{until}\label{se:until}
Evaluates \var{seq} until $a$ is not
equal to 0 (i.e.~until $a$ is true). If $a$ is initially not equal to 0,
\var{seq} is evaluated once (more generally, the condition on $a$ is tested
\emph{after} execution of the \var{seq}, not before as in \kbd{while}).

\subsec{while$(a,\var{seq})$}\kbdsidx{while}\label{se:while}
While $a$ is nonzero, evaluates the expression sequence \var{seq}. The
test is made \emph{before} evaluating the $seq$, hence in particular if $a$
is initially equal to zero the \var{seq} will not be evaluated at all.

\section{Programming in GP: other specific functions}
\label{se:gp_program}

  In addition to the general PARI functions, it is necessary to have some
functions which will be of use specifically for \kbd{gp}, though a few of these
can be accessed under library mode. Before we start describing these, we recall
the difference between \emph{strings} and \emph{keywords} (see
\secref{se:strings}): the latter don't get expanded at all, and you can type
them without any enclosing quotes. The former are dynamic objects, where
everything outside quotes gets immediately expanded.

\subsec{Strchr$(x)$}\kbdsidx{Strchr}\label{se:Strchr}
Deprecated alias for strchr.

The library syntax is \fun{GEN}{pari_strchr}{GEN x}.

\subsec{Strexpand$(\{x\}*)$}\kbdsidx{Strexpand}\label{se:Strexpand}
Deprecated alias for strexpand

The library syntax is \fun{GEN}{strexpand}{const char *x*}.

\subsec{Strprintf$(\var{fmt},\{x\}*)$}\kbdsidx{Strprintf}\label{se:Strprintf}
Deprecated alias for strprintf.

The library syntax is \fun{GEN}{strprintf}{const char *fmt, const char *x*}.

\subsec{Strtex$(\{x\}*)$}\kbdsidx{Strtex}\label{se:Strtex}
Deprecated alias for strtex.

The library syntax is \fun{GEN}{strtex}{const char *x*}.

\subsec{addhelp$(\var{sym},\var{str})$}\kbdsidx{addhelp}\label{se:addhelp}
Changes the help message for the symbol \kbd{sym}. The string \var{str}
is expanded on the spot and stored as the online help for \kbd{sym}. It is
recommended to document global variables and user functions in this way,
although \kbd{gp} will not protest if you don't.

You can attach a help text to an alias, but it will never be
shown: aliases are expanded by the \kbd{?} help operator and we get the help
of the symbol the alias points to. Nothing prevents you from modifying the
help of built-in PARI functions. But if you do, we would like to hear why you
needed it!

Without \tet{addhelp}, the standard help for user functions consists of its
name and definition.
\bprog
gp> f(x) = x^2;
gp> ?f
f =
  (x)->x^2

@eprog\noindent Once addhelp is applied to $f$, the function code is no
longer included. It can still be consulted by typing the function name:
\bprog
gp> addhelp(f, "Square")
gp> ?f
Square

gp> f
%2 = (x)->x^2
@eprog

The library syntax is \fun{void}{addhelp}{const char *sym, const char *str}.

\subsec{alarm$(\{s = 0\},\{\var{code}\})$}\kbdsidx{alarm}\label{se:alarm}
If \var{code} is omitted, trigger an \var{e\_ALARM} exception after $s$
seconds (wall-clock time), cancelling any previously set alarm; stop a pending
alarm if $s = 0$ or is omitted.

Otherwise, if $s$ is positive, the function evaluates \var{code},
aborting after $s$ seconds. The return value is the value of \var{code} if
it ran to completion before the alarm timeout, and a \typ{ERROR} object
otherwise.
\bprog
? p = nextprime(10^25); q = nextprime(10^26); N = p*q;
? E = alarm(1, factor(N));
? type(E)
%3 = "t_ERROR"
? print(E)
%4 = error("alarm interrupt after 964 ms.")
? alarm(10, factor(N));   \\ enough time
%5 =
[ 10000000000000000000000013 1]

[100000000000000000000000067 1]
@eprog\noindent Here is a more involved example: the function
\kbd{timefact(N,sec)} below tries to factor $N$ and gives up after \var{sec}
seconds, returning a partial factorization.
\bprog
\\ Time-bounded partial factorization
default(factor_add_primes,1);
timefact(N,sec)=
{
  F = alarm(sec, factor(N));
  if (type(F) == "t_ERROR", factor(N, 2^24), F);
}
@eprog\noindent We either return the factorization directly, or replace the
\typ{ERROR} result by a simple bounded factorization \kbd{factor(N, 2\pow 24)}.
Note the \tet{factor_add_primes} trick: any prime larger than $2^{24}$
discovered while attempting the initial factorization is stored and
remembered. When the alarm rings, the subsequent bounded factorization finds
it right away.

\misctitle{Caveat} It is not possible to set a new alarm \emph{within}
another \kbd{alarm} code: the new timer erases the parent one.

\misctitle{Caveat2} In a parallel-enabled \kbd{gp}, if the \var{code}
involves parallel subtasks, then \kbd{alarm} may not return right away: il
will prevent new tasks from being launched but will not interrupt previously
launched secondary threads. This avoids leaving the system in an
inconsistent state.

The library syntax is \fun{GEN}{gp_alarm}{long s, GEN code = NULL}.

\subsec{alias$(\var{newsym},\var{sym})$}\kbdsidx{alias}\label{se:alias}
Defines the symbol \var{newsym} as an alias for the symbol \var{sym}:
\bprog
? alias("det", "matdet");
? det([1,2;3,4])
%1 = -2
@eprog\noindent
You are not restricted to ordinary functions, as in the above example:
to alias (from/to) member functions, prefix them with `\kbd{\_.}';
to alias operators, use their internal name, obtained by writing
\kbd{\_} in lieu of the operators argument: for instance, \kbd{\_!} and
\kbd{!\_} are the internal names of the factorial and the
logical negation, respectively.
\bprog
? alias("mod", "_.mod");
? alias("add", "_+_");
? alias("_.sin", "sin");
? mod(Mod(x,x^4+1))
%2 = x^4 + 1
? add(4,6)
%3 = 10
? Pi.sin
%4 = 0.E-37
@eprog
Alias expansion is performed directly by the internal GP compiler.
Note that since alias is performed at compilation-time, it does not
require any run-time processing, however it only affects GP code
compiled \emph{after} the alias command is evaluated. A slower but more
flexible alternative is to use variables. Compare
\bprog
? fun = sin;
? g(a,b) = intnum(t=a,b,fun(t));
? g(0, Pi)
%3 = 2.0000000000000000000000000000000000000
? fun = cos;
? g(0, Pi)
%5 = 1.8830410776607851098 E-39
@eprog\noindent
with
\bprog
? alias(fun, sin);
? g(a,b) = intnum(t=a,b,fun(t));
? g(0,Pi)
%2 = 2.0000000000000000000000000000000000000
? alias(fun, cos);  \\ Oops. Does not affect *previous* definition!
? g(0,Pi)
%3 = 2.0000000000000000000000000000000000000
? g(a,b) = intnum(t=a,b,fun(t)); \\ Redefine, taking new alias into account
? g(0,Pi)
%5 = 1.8830410776607851098 E-39
@eprog

A sample alias file \kbd{misc/gpalias} is provided with
the standard distribution.

The library syntax is \fun{void}{alias0}{const char *newsym, const char *sym}.

\subsec{allocatemem$(\{s=0\})$}\kbdsidx{allocatemem}\label{se:allocatemem}
This special operation changes the stack size \emph{after}
initialization. The argument $s$ must be a nonnegative integer.
If $s > 0$, a new stack of at least $s$ bytes is allocated. We may allocate
more than $s$ bytes if $s$ is way too small, or for alignment reasons: the
current formula is $\max(16*\ceil{s/16}, 500032)$ bytes.

If $s=0$, the size of the new stack is twice the size of the old one.

This command is much more useful if \tet{parisizemax} is nonzero, and we
describe this case first. With \kbd{parisizemax} enabled, there are three
sizes of interest:

\item a virtual stack size, \tet{parisizemax}, which is an absolute upper
limit for the stack size; this is set by \kbd{default(parisizemax, ...)}.

\item the desired typical stack size, \tet{parisize}, that will grow as
needed, up to \tet{parisizemax}; this is set by \kbd{default(parisize, ...)}.

\item the current stack size, which is less that \kbd{parisizemax},
typically equal to \kbd{parisize} but possibly larger and increasing
dynamically as needed; \kbd{allocatemem} allows to change that one
explicitly.

The \kbd{allocatemem} command forces stack
usage to increase temporarily (up to \kbd{parisizemax} of course); for
instance if you notice using \kbd{\bs gm2} that we seem to collect garbage a
lot, e.g.
\bprog
? \gm2
  debugmem = 2
? default(parisize,"32M")
 ***   Warning: new stack size = 32000000 (30.518 Mbytes).
? bnfinit('x^2+10^30-1)
 *** bnfinit: collecting garbage in hnffinal, i = 1.
 *** bnfinit: collecting garbage in hnffinal, i = 2.
 *** bnfinit: collecting garbage in hnffinal, i = 3.
@eprog\noindent and so on for hundred of lines. Then, provided the
\tet{breakloop} default is set, you can interrupt the computation, type
\kbd{allocatemem(100*10\pow6)} at the break loop prompt, then let the
computation go on by typing \kbd{<Enter>}. Back at the \kbd{gp} prompt,
the desired stack size of \kbd{parisize} is restored. Note that changing either
\kbd{parisize} or \kbd{parisizemax} at the break loop prompt would interrupt
the computation, contrary to the above.

In most cases, \kbd{parisize} will increase automatically (up to
\kbd{parisizemax}) and there is no need to perform the above maneuvers.
But that the garbage collector is sufficiently efficient that
a given computation can still run without increasing the stack size,
albeit very slowly due to the frequent garbage collections.

\misctitle{Deprecated: when \kbd{parisizemax} is unset}
This is currently still the default behavior in order not to break backward
compatibility. The rest of this section documents the
behavior of \kbd{allocatemem} in that (deprecated) situation: it becomes a
synonym for \kbd{default(parisize,...)}. In that case, there is no
notion of a virtual stack, and the stack size is always equal to
\kbd{parisize}. If more memory is needed, the PARI stack overflows, aborting
the computation.

Thus, increasing \kbd{parisize} via \kbd{allocatemem} or
\kbd{default(parisize,...)} before a big computation is important.
Unfortunately, either must be typed at the \kbd{gp} prompt in
interactive usage, or left by itself at the start of batch files.
They cannot be used meaningfully in loop-like constructs, or as part of a
larger expression sequence, e.g
\bprog
   allocatemem(); x = 1;   \\@com This will not set \kbd{x}!
@eprog\noindent
In fact, all loops are immediately exited, user functions terminated, and
the rest of the sequence following \kbd{allocatemem()} is silently
discarded, as well as all pending sequences of instructions. We just go on
reading the next instruction sequence from the file we are in (or from the
user). In particular, we have the following possibly unexpected behavior: in
\bprog
   read("file.gp"); x = 1
@eprog\noindent were \kbd{file.gp} contains an \kbd{allocatemem} statement,
the \kbd{x = 1} is never executed, since all pending instructions in the
current sequence are discarded.

The reason for these unfortunate side-effects is that, with
\kbd{parisizemax} disabled, increasing the stack size physically
moves the stack, so temporary objects created during the current expression
evaluation are not correct anymore. (In particular byte-compiled expressions,
which are allocated on the stack.) To avoid accessing obsolete pointers to
the old stack, this routine ends by a \kbd{longjmp}.

The library syntax is \fun{void}{gp_allocatemem}{GEN s = NULL}.

\subsec{apply$(f, A)$}\kbdsidx{apply}\label{se:apply}
Apply the \typ{CLOSURE} \kbd{f} to the entries of \kbd{A}.

\item If \kbd{A} is a scalar, return \kbd{f(A)}.

\item If \kbd{A} is a polynomial or power series $\sum a_i x^i$ ($+
O(x^N)$), apply \kbd{f} on all coefficients and return $\sum f(a_i) x^i$ ($+
O(x^N)$).

\item If \kbd{A} is a vector or list $[a_1,\dots,a_n]$, return the vector
or list $[f(a_1),\dots, f(a_n)]$. If \kbd{A} is a matrix, return the matrix
whose entries are the $f(\kbd{A[i,j]})$.

\bprog
? apply(x->x^2, [1,2,3,4])
%1 = [1, 4, 9, 16]
? apply(x->x^2, [1,2;3,4])
%2 =
[1 4]

[9 16]
? apply(x->x^2, 4*x^2 + 3*x+ 2)
%3 = 16*x^2 + 9*x + 4
? apply(sign, 2 - 3* x + 4*x^2 + O(x^3))
%4 = 1 - x + x^2 + O(x^3)
@eprog\noindent Note that many functions already act componentwise on
vectors or matrices, but they almost never act on lists; in this case,
\kbd{apply} is a good solution:
\bprog
? L = List([Mod(1,3), Mod(2,4)]);
? lift(L)
  ***   at top-level: lift(L)
  ***                 ^-------
  *** lift: incorrect type in lift.
? apply(lift, L);
%2 = List([1, 2])
@eprog
\misctitle{Remark} For $v$ a \typ{VEC}, \typ{COL}, \typ{VECSMALL},
\typ{LIST} or \typ{MAT}, the alternative set-notations
\bprog
[g(x) | x <- v, f(x)]
[x | x <- v, f(x)]
[g(x) | x <- v]
@eprog\noindent
are available as shortcuts for
\bprog
apply(g, select(f, Vec(v)))
select(f, Vec(v))
apply(g, Vec(v))
@eprog\noindent respectively:
\bprog
? L = List([Mod(1,3), Mod(2,4)]);
? [ lift(x) | x<-L ]
%2 = [1, 2]
@eprog

\synt{genapply}{void *E, GEN (*fun)(void*,GEN), GEN a}.

\subsec{arity$(C)$}\kbdsidx{arity}\label{se:arity}
Return the arity of the closure $C$, i.e., the number of its arguments.
\bprog
? f1(x,y=0)=x+y;
? arity(f1)
%1 = 2
? f2(t,s[..])=print(t,":",s);
? arity(f2)
%2 = 2
@eprog\noindent Note that a variadic argument, such as $s$ in \kbd{f2} above,
is counted as a single argument.

The library syntax is \fun{GEN}{arity0}{GEN C}.

\subsec{call$(f, A)$}\kbdsidx{call}\label{se:call}
$A=[a_1,\dots, a_n]$ being a vector and $f$ being a function, returns the
evaluation of $f(a_1,\dots,a_n)$.
$f$ can also be the name of a built-in GP function.
If $\# A =1$, \tet{call}($f,A$) = \tet{apply}($f,A$)[1].
If $f$ is variadic, the variadic arguments must grouped in a vector in
the last component of $A$.

This function is useful

\item when writing a variadic function, to call another one:
\bprog
fprintf(file,format,args[..]) = write(file,call(strprintf,[format,args]))
@eprog

\item when dealing with function arguments with unspecified arity

The function below implements a global memoization interface:
\bprog
memo=Map();
memoize(f,A[..])=
{
  my(res);
  if(!mapisdefined(memo, [f,A], &res),
    res = call(f,A);
    mapput(memo,[f,A],res));
 res;
}
@eprog
for example:
\bprog
? memoize(factor,2^128+1)
%3 = [59649589127497217,1;5704689200685129054721,1]
? ##
  ***   last result computed in 76 ms.
? memoize(factor,2^128+1)
%4 = [59649589127497217,1;5704689200685129054721,1]
? ##
  ***   last result computed in 0 ms.
? memoize(ffinit,3,3)
%5 = Mod(1,3)*x^3+Mod(1,3)*x^2+Mod(1,3)*x+Mod(2,3)
? fibo(n)=if(n==0,0,n==1,1,memoize(fibo,n-2)+memoize(fibo,n-1));
? fibo(100)
%7 = 354224848179261915075
@eprog

\item to call operators through their internal names without using
\kbd{alias}
\bprog
matnbelts(M) = call("_*_",matsize(M))
@eprog

The library syntax is \fun{GEN}{call0}{GEN f, GEN A}.

\subsec{default$(\{\var{key}\},\{\var{val}\})$}\kbdsidx{default}\label{se:default}
Returns the default corresponding to keyword \var{key}. If \var{val} is
present, sets the default to \var{val} first (which is subject to string
expansion first). Typing \kbd{default()} (or \b{d}) yields the complete
default list as well as their current values. See \secref{se:defaults} for an
introduction to GP defaults, \secref{se:gp_defaults} for a
list of available defaults, and \secref{se:meta} for some shortcut
alternatives. Note that the shortcuts are meant for interactive use and
usually display more information than \kbd{default}.

The library syntax is \fun{GEN}{default0}{const char *key = NULL, const char *val = NULL}.

\subsec{errname$(E)$}\kbdsidx{errname}\label{se:errname}
Returns the type of the error message \kbd{E} as a string.
\bprog
? iferr(1 / 0, E, print(errname(E)))
e_INV
? ?? e_INV
[...]
* "e_INV".  Tried to invert a noninvertible object x in function s.
[...]
@eprog

The library syntax is \fun{GEN}{errname}{GEN E}.

\subsec{error$(\{\var{str}\}*)$}\kbdsidx{error}\label{se:error}
Outputs its argument list (each of
them interpreted as a string), then interrupts the running \kbd{gp} program,
returning to the input prompt. For instance
\bprog
error("n = ", n, " is not squarefree!")
@eprog\noindent
 % \syn{NO}

\subsec{export$(x\{=...\},...,z\{=...\})$}\kbdsidx{export}\label{se:export}
Export the variables $x,\ldots, z$ to the parallel world.
Such variables are visible inside parallel sections in place of global
variables, but cannot be modified inside a parallel section.
\kbd{export(a)} set the variable $a$ in the parallel world to current value of $a$.
\kbd{export(a=z)} set the variable $a$ in the parallel world to $z$, without
affecting the current value of $a$.
\bprog
? fun(x)=x^2+1;
? parvector(10,i,fun(i))
  ***   mt: please use export(fun).
? export(fun)
? parvector(10,i,fun(i))
%4 = [2,5,10,17,26,37,50,65,82,101]
@eprog

\subsec{exportall$()$}\kbdsidx{exportall}\label{se:exportall}
Declare all current dynamic variables as exported variables.
Such variables are visible inside parallel sections in place of global variables.
\bprog
? fun(x)=x^2+1;
? parvector(10,i,fun(i))
  ***   mt: please use export(fun).
? exportall()
? parvector(10,i,fun(i))
%4 = [2,5,10,17,26,37,50,65,82,101]
@eprog

The library syntax is \fun{void}{exportall}{}.

\subsec{extern$(\var{str})$}\kbdsidx{extern}\label{se:extern}
The string \var{str} is the name of an external command (i.e.~one you
would type from your UNIX shell prompt). This command is immediately run and
its output fed into \kbd{gp}, just as if read from a file.

The library syntax is \fun{GEN}{gpextern}{const char *str}.

\subsec{externstr$(\var{str})$}\kbdsidx{externstr}\label{se:externstr}
The string \var{str} is the name of an external command (i.e.~one you
would type from your UNIX shell prompt). This command is immediately run and
its output is returned as a vector of GP strings, one component per output
line.

The library syntax is \fun{GEN}{externstr}{const char *str}.

\subsec{fileclose$(n)$}\kbdsidx{fileclose}\label{se:fileclose}
Close the file descriptor $n$, created via \kbd{fileopen} or
\kbd{fileextern}. Finitely many files can be opened at a given time,
closing them recycles file descriptors and avoids running out of them:
\bprog
? n = 0; while(n++, fileopen("/tmp/test", "w"))
 ***   at top-level: n=0;while(n++,fileopen("/tmp/test","w"))
 ***                               ^--------------------------
 *** fileopen: error opening requested file: `/tmp/test'.
 ***   Break loop: type 'break' to go back to GP prompt
break> n
65533
@eprog\noindent This is a limitation of the operating system and does not
depend on PARI: if you open too many files in \kbd{gp} without closing them,
the operating system will also prevent unrelated applications from opening
files. Independently, your operating system (e.g. Windows) may prevent other
applications from accessing or deleting your file while it is opened by
\kbd{gp}. Quitting \kbd{gp} implicitly calls this function on all opened
file descriptors.

On files opened for writing, this function also forces a write of all
buffered data to the file system and completes all pending write operations.
This function is implicitly called for all open file descriptors when
exiting \kbd{gp} but it is cleaner and safer to call it explicitly, for
instance in case of a \kbd{gp} crash or general system failure, which could
cause data loss.
\bprog
? n = fileopen("./here");
? while(l = fileread(n), print(l));
? fileclose(n);

? n = fileopen("./there", "w");
? for (i = 1, 100, filewrite(n, i^2+1))
? fileclose(n)
@eprog Until a \kbd{fileclose}, there is no guarantee that the file on disk
contains all the expected data from previous \kbd{filewrite}s. (And even
then the operating system may delay the actual write to hardware.)

Closing a file twice raises an exception:
\bprog
? n = fileopen("/tmp/test");
? fileclose(n)
? fileclose(n)
 ***   at top-level: fileclose(n)
 ***                 ^------------
 *** fileclose: invalid file descriptor 0
@eprog

The library syntax is \fun{void}{gp_fileclose}{long n}.

\subsec{fileextern$(\var{str})$}\kbdsidx{fileextern}\label{se:fileextern}
The string \var{str} is the name of an external command, i.e.~one you
would type from your UNIX shell prompt. This command is immediately run and
the function returns a file descriptor attached to the command output as if
it were read from a file.
\bprog
? n = fileextern("ls -l");
? while(l = filereadstr(n), print(l))
? fileclose(n)
@eprog\noindent If the \kbd{secure} default is set, this function will raise
en exception.

The library syntax is \fun{long}{gp_fileextern}{const char *str}.

\subsec{fileflush$(\{n\})$}\kbdsidx{fileflush}\label{se:fileflush}
Flushes the file descriptor $n$, created via \kbd{fileopen} or
\kbd{fileextern}. On files opened for writing, this function forces a write
of all buffered data to the file system and completes all pending write
operations. This function is implicitly called by \kbd{fileclose} but you may
want to call it explicitly at synchronization points, for instance after
writing a large result to file and before printing diagnostics on screen.
(In order to be sure that the file contains the expected content on
inspection.)

If $n$ is omitted, flush all descriptors to output streams.

\bprog
? n = fileopen("./here", "w");
? for (i = 1, 10^5,      \
    filewrite(n, i^2+1); \
    if (i % 10000 == 0, fileflush(n)))
@eprog Until a \kbd{fileflush} or \kbd{fileclose}, there is no guarantee
that the file contains all the expected data from previous \kbd{filewrite}s.

The library syntax is \fun{void}{gp_fileflush0}{GEN n = NULL}.
But the direct and more specific variant
\fun{void}{gp_fileflush}{long n} is also available.

\subsec{fileopen$(\var{path}, \var{mode})$}\kbdsidx{fileopen}\label{se:fileopen}
Open the file pointed to by 'path' and return a file descriptor which
can be used with other file functions.

The mode can be

\item \kbd{"r"} (default): open for reading; allow \kbd{fileread} and
\kbd{filereadstr}.

\item \kbd{"w"}: open for writing, discarding existing content; allow
\kbd{filewrite}, \kbd{filewrite1}.

\item \kbd{"a"}: open for writing, appending to existing content; same
operations allowed as \kbd{"w"}.

Eventually, the file should be closed and the descriptor recycled using
\kbd{fileclose}.

\bprog
? n = fileopen("./here");  \\ "r" by default
? while (l = filereadstr(n), print(l))  \\ print successive lines
? fileclose(n) \\ done
@eprog\noindent In \emph{read} mode, raise an exception if the file does not
exist or the user does not have read permission. In \emph{write} mode, raise
an exception if the file cannot be written to. Trying to read or write to a
file that was not opend with the right mode raises an exception.
\bprog
? n = fileopen("./read", "r");
? filewrite(n, "test")      \\ not open for writing
 ***   at top-level: filewrite(n,"test")
 ***                 ^-------------------
 *** filewrite: invalid file descriptor 0
@eprog

The library syntax is \fun{long}{gp_fileopen}{const char *path, const char *mode}.

\subsec{fileread$(n)$}\kbdsidx{fileread}\label{se:fileread}
Read a logical line from the file attached to the descriptor $n$, opened
for reading with \kbd{fileopen}. Return 0 at end of file.

A logical line is a full command as it is prepared by gp's
preprocessor (skipping blanks and comments or assembling multiline commands
between braces) before being fed to the interpreter. The function
\kbd{filereadstr} would read a \emph{raw} line exactly as input, up to the
next carriage return \kbd{\bs n}.

Compare raw lines
\bprog
? n = fileopen("examples/bench.gp");
? while(l = filereadstr(n), print(l));
{
  u=v=p=q=1;
  for (k=1, 2000,
    [u,v] = [v,u+v];
    p *= v; q = lcm(q,v);
    if (k%50 == 0,
      print(k, " ", log(p)/log(q))
    )
  )
}
@eprog\noindent and logical lines
\bprog
? n = fileopen("examples/bench.gp");
? while(l = fileread(n), print(l));
u=v=p=q=1;for(k=1,2000,[u,v]=[v,u+v];p*=v;q=lcm(q,v);[...]
@eprog

The library syntax is \fun{GEN}{gp_fileread}{long n}.

\subsec{filereadstr$(n)$}\kbdsidx{filereadstr}\label{se:filereadstr}
Read a raw line from the file attached to the descriptor $n$, opened
for reading with \kbd{fileopen}, discarding the terminating newline.
In other words the line is read exactly as input, up to the
next carriage return \kbd{\bs n}. By comparison, \kbd{fileread} would
read a logical line, as assembled by gp's preprocessor (skipping blanks
and comments for instance).

The library syntax is \fun{GEN}{gp_filereadstr}{long n}.

\subsec{filewrite$(n, s)$}\kbdsidx{filewrite}\label{se:filewrite}
Write the string $s$ to the file attached to descriptor $n$, ending with
a newline. The file must have been opened with \kbd{fileopen} in
\kbd{"w"} or \kbd{"a"} mode. There is no guarantee that $s$ is completely
written to disk until \kbd{fileclose$(n)$} is executed, which is automatic
when quitting \kbd{gp}.

If the newline is not desired, use \kbd{filewrite1}.

\misctitle{Variant} The high-level function \kbd{write} is expensive when many
consecutive writes are expected because it cannot use buffering. The low-level
interface \kbd{fileopen} / \kbd{filewrite} / \kbd{fileclose} is more efficient:
\bprog
? f = "/tmp/bigfile";
? for (i = 1, 10^5, write(f, i^2+1))
time = 240 ms.

? v = vector(10^5, i, i^2+1);
time = 10 ms. \\ computing the values is fast
? write("/tmp/bigfile2",v)
time = 12 ms. \\ writing them in one operation is fast

? n = fileopen("/tmp/bigfile", "w");
? for (i = 1, 10^5, filewrite(n, i^2+1))
time = 24 ms.  \\ low-level write is ten times faster
? fileclose(n);
@eprog\noindent In the final example, the file needs not be in a consistent
state until the ending \kbd{fileclose} is evaluated, e.g. some lines might be
half-written or not present at all even though the corresponding
\kbd{filewrite} was executed already. Both a single high-level \kbd{write}
and a succession of low-level \kbd{filewrite}s achieve the same efficiency,
but the latter is often more natural. In fact, concatenating naively
the entries to be written is quadratic in the number of entries, hence
much more expensive than the original write operations:
\bprog
? v = []; for (i = 1, 10^5, v = concat(v,i))
time = 1min, 41,456 ms.
@eprog

The library syntax is \fun{void}{gp_filewrite}{long n, const char *s}.

\subsec{filewrite1$(n, s)$}\kbdsidx{filewrite1}\label{se:filewrite1}
Write the string $s$ to the file attached to descriptor $n$.
The file must have been opened with \kbd{fileopen} in \kbd{"w"} or \kbd{"a"}
mode.

If you want to append a newline at the end of $s$, you can use
\kbd{Str(s,"\bs n")} or \kbd{filewrite}.

The library syntax is \fun{void}{gp_filewrite1}{long n, const char *s}.

\subsec{fold$(f, A)$}\kbdsidx{fold}\label{se:fold}
Apply the \typ{CLOSURE} \kbd{f} of arity $2$ to the entries of \kbd{A},
in order to return \kbd{f(\dots f(f(A[1],A[2]),A[3])\dots ,A[\#A])}.
\bprog
? fold((x,y)->x*y, [1,2,3,4])
%1 = 24
? fold((x,y)->[x,y], [1,2,3,4])
%2 = [[[1, 2], 3], 4]
? fold((x,f)->f(x), [2,sqr,sqr,sqr])
%3 = 256
? fold((x,y)->(x+y)/(1-x*y),[1..5])
%4 = -9/19
? bestappr(tan(sum(i=1,5,atan(i))))
%5 = -9/19
@eprog

The library syntax is \fun{GEN}{fold0}{GEN f, GEN A}.
Also available is
\fun{GEN}{genfold}{void *E, GEN (*fun)(void*,GEN, GEN), GEN A}.

\subsec{getabstime$()$}\kbdsidx{getabstime}\label{se:getabstime}
Returns the CPU time (in milliseconds) elapsed since \kbd{gp} startup.
This provides a reentrant version of \kbd{gettime}:
\bprog
my (t = getabstime());
...
print("Time: ", strtime(getabstime() - t));
@eprog
For a version giving wall-clock time, see \tet{getwalltime}.

The library syntax is \fun{long}{getabstime}{}.

\subsec{getenv$(s)$}\kbdsidx{getenv}\label{se:getenv}
Return the value of the environment variable \kbd{s} if it is defined, otherwise return 0.

The library syntax is \fun{GEN}{gp_getenv}{const char *s}.

\subsec{getheap$()$}\kbdsidx{getheap}\label{se:getheap}
Returns a two-component row vector giving the
number of objects on the heap and the amount of memory they occupy in long
words. Useful mainly for debugging purposes.

The library syntax is \fun{GEN}{getheap}{}.

\subsec{getlocalbitprec$()$}\kbdsidx{getlocalbitprec}\label{se:getlocalbitprec}
Returns the current dynamic bit precision.
%\syn{NO}

\subsec{getlocalprec$()$}\kbdsidx{getlocalprec}\label{se:getlocalprec}
Returns the current dynamic precision, in decimal digits.
%\syn{NO}

\subsec{getrand$()$}\kbdsidx{getrand}\label{se:getrand}
Returns the current value of the seed used by the
pseudo-random number generator \tet{random}. Useful mainly for debugging
purposes, to reproduce a specific chain of computations. The returned value
is technical (reproduces an internal state array), and can only be used as an
argument to \tet{setrand}.

The library syntax is \fun{GEN}{getrand}{}.

\subsec{getstack$()$}\kbdsidx{getstack}\label{se:getstack}
Returns the current value of $\kbd{top}-\kbd{avma}$, i.e.~the number of
bytes used up to now on the stack. Useful mainly for debugging purposes.

The library syntax is \fun{long}{getstack}{}.

\subsec{gettime$()$}\kbdsidx{gettime}\label{se:gettime}
Returns the CPU time (in milliseconds) used since either the last call to
\kbd{gettime}, or to the beginning of the containing GP instruction (if
inside \kbd{gp}), whichever came last.

For a reentrant version, see \tet{getabstime}.

For a version giving wall-clock time, see \tet{getwalltime}.

The library syntax is \fun{long}{gettime}{}.

\subsec{getwalltime$()$}\kbdsidx{getwalltime}\label{se:getwalltime}
Returns the time (in milliseconds) elapsed since
00:00:00 UTC Thursday 1, January 1970 (the Unix epoch).
\bprog
my (t = getwalltime());
...
print("Time: ", strtime(getwalltime() - t));
@eprog

The library syntax is \fun{GEN}{getwalltime}{}.

\subsec{global$(\var{list} \var{of} \var{variables})$}\kbdsidx{global}\label{se:global}
Obsolete. Scheduled for deletion.
% \syn{NO}

\subsec{inline$(x,...,z)$}\kbdsidx{inline}\label{se:inline}
Declare $x,\ldots, z$ as inline variables. Such variables
behave like lexically scoped variable (see my()) but with unlimited scope.
It is however possible to exit the scope by using \kbd{uninline()}.
When used in a GP script, it is recommended to call \kbd{uninline()} before
the script's end to avoid inline variables leaking outside the script.
DEPRECATED, use \kbd{export}.

\subsec{input$()$}\kbdsidx{input}\label{se:input}
Reads a string, interpreted as a GP expression,
from the input file, usually standard input (i.e.~the keyboard). If a
sequence of expressions is given, the result is the result of the last
expression of the sequence. When using this instruction, it is useful to
prompt for the string by using the \kbd{print1} function. Note that in the
present version 2.19 of \kbd{pari.el}, when using \kbd{gp} under GNU Emacs (see
\secref{se:emacs}) one \emph{must} prompt for the string, with a string
which ends with the same prompt as any of the previous ones (a \kbd{"? "}
will do for instance).

The library syntax is \fun{GEN}{gp_input}{}.

\subsec{install$(\var{name},\var{code},\{\var{gpname}\},\{\var{lib}\})$}\kbdsidx{install}\label{se:install}
Loads from dynamic library \var{lib} the function \var{name}. Assigns to it
the name \var{gpname} in this \kbd{gp} session, with \emph{prototype}
\var{code} (see below). If \var{gpname} is omitted, uses \var{name}.
If \var{lib} is omitted, all symbols known to \kbd{gp} are available: this
includes the whole of \kbd{libpari.so} and possibly others (such as
\kbd{libc.so}).

Most importantly, \kbd{install} gives you access to all nonstatic functions
defined in the PARI library. For instance, the function
\bprog
  GEN addii(GEN x, GEN y)
@eprog\noindent adds two PARI integers, and is not directly accessible under
\kbd{gp} (it is eventually called by the \kbd{+} operator of course):
\bprog
? install("addii", "GG")
? addii(1, 2)
%1 = 3
@eprog\noindent
It also allows to add external functions to the \kbd{gp} interpreter.
For instance, it makes the function \tet{system} obsolete:
\bprog
? install(system, vs, sys,/*omitted*/)
? sys("ls gp*")
gp.c            gp.h            gp_rl.c
@eprog\noindent This works because \kbd{system} is part of \kbd{libc.so},
which is linked to \kbd{gp}. It is also possible to compile a shared library
yourself and provide it to gp in this way: use \kbd{gp2c}, or do it manually
(see the \kbd{modules\_build} variable in \kbd{pari.cfg} for hints).

Re-installing a function will print a warning and update the prototype code
if needed. However, it will not reload a symbol from the library, even if the
latter has been recompiled.

\misctitle{Prototype} We only give a simplified description here, covering
most functions, but there are many more possibilities. The full documentation
is available in \kbd{libpari.dvi}, see
\bprog
  ??prototype
@eprog

\item First character \kbd{i}, \kbd{l}, \kbd{u}, \kbd{v} : return type
\kbd{int} / \kbd{long} / \kbd{ulong} / \kbd{void}. (Default: \kbd{GEN})

\item One letter for each mandatory argument, in the same order as they appear
in the argument list: \kbd{G} (\kbd{GEN}), \kbd{\&}
(\kbd{GEN*}), \kbd{L} (\kbd{long}), \kbd{U} (\kbd{ulong}),
\kbd{s} (\kbd{char *}), \kbd{n} (variable).

 \item \kbd{p} to supply \kbd{realprecision} (usually \kbd{long prec} in the
 argument list), \kbd{b} to supply \kbd{realbitprecision}
 (usually \kbd{long bitprec}), \kbd{P} to supply \kbd{seriesprecision}
 (usually \kbd{long precdl}).

 \noindent We also have special constructs for optional arguments and default
 values:

 \item \kbd{DG} (optional \kbd{GEN}, \kbd{NULL} if omitted),

 \item \kbd{D\&} (optional \kbd{GEN*}, \kbd{NULL} if omitted),

 \item \kbd{Dn} (optional variable, $-1$ if omitted),

For instance the prototype corresponding to
\bprog
  long issquareall(GEN x, GEN *n = NULL)
@eprog\noindent is \kbd{lGD\&}.

\misctitle{Caution} This function may not work on all systems, especially
when \kbd{gp} has been compiled statically. In that case, the first use of an
installed function will provoke a Segmentation Fault (this should never
happen with a dynamically linked executable). If you intend to use this
function, please check first on some harmless example such as the one above
that it works properly on your machine.

The library syntax is \fun{void}{gpinstall}{const char *name, const char *code, const char *gpname, const char *lib}.

\subsec{kill$(\var{sym})$}\kbdsidx{kill}\label{se:kill}
Restores the symbol \kbd{sym} to its ``undefined'' status, and deletes any
help messages attached to \kbd{sym} using \kbd{addhelp}. Variable names
remain known to the interpreter and keep their former priority: you cannot
make a variable ``less important" by killing it!
\bprog
? z = y = 1; y
%1 = 1
? kill(y)
? y            \\ restored to ``undefined'' status
%2 = y
? variable()
%3 = [x, y, z] \\ but the variable name y is still known, with y > z !
@eprog\noindent
For the same reason, killing a user function (which is an ordinary
variable holding a \typ{CLOSURE}) does not remove its name from the list of
variable names.

If the symbol is attached to a variable --- user functions being an
important special case ---, one may use the \idx{quote} operator
\kbd{a = 'a} to reset variables to their starting values. However, this
will not delete a help message attached to \kbd{a}, and is also slightly
slower than \kbd{kill(a)}.
\bprog
? x = 1; addhelp(x, "foo"); x
%1 = 1
? x = 'x; x   \\ same as 'kill', except we don't delete help.
%2 = x
? ?x
foo
@eprog\noindent
On the other hand, \kbd{kill} is the only way to remove aliases and installed
functions.
\bprog
? alias(fun, sin);
? kill(fun);

? install(addii, GG);
? kill(addii);
@eprog

The library syntax is \fun{void}{kill0}{const char *sym}.

\subsec{listcreate$(\{n\})$}\kbdsidx{listcreate}\label{se:listcreate}
This function is obsolete, use \kbd{List}.

Creates an empty list. This routine used to have a mandatory argument,
which is now ignored (for backward compatibility).
% \syn{NO}

\subsec{listinsert$(~L,x,n)$}\kbdsidx{listinsert}\label{se:listinsert}
Inserts the object $x$ at
position $n$ in $L$ (which must be of type \typ{LIST}).
This has complexity $O(\#L - n + 1)$: all the
remaining elements of \var{list} (from position $n+1$ onwards) are shifted
to the right. If $n$ is greater than the list length, appends $x$.
\bprog
? L = List([1,2,3]);
? listput(~L, 4); L \\ listput inserts at end
%4 = List([1, 2, 3, 4])
? listinsert(~L, 5, 1); L \\insert at position 1
%5 = List([5, 1, 2, 3, 4])
? listinsert(~L, 6, 1000); L  \\ trying to insert beyond position #L
%6 = List([5, 1, 2, 3, 4, 6]) \\ ... inserts at the end
@eprog\noindent Note the \kbd{\til L}: this means that the function is
called with a \emph{reference} to \kbd{L} and changes \kbd{L} in place.

The library syntax is \fun{GEN}{listinsert}{GEN ~L, GEN x, long n}.

\subsec{listkill$(~L)$}\kbdsidx{listkill}\label{se:listkill}
Obsolete, retained for backward compatibility. Just use \kbd{L = List()}
instead of \kbd{listkill(L)}. In most cases, you won't even need that, e.g.
local variables are automatically cleared when a user function returns.

The library syntax is \fun{void}{listkill}{GEN ~L}.

\subsec{listpop$(~\var{list},\{n\})$}\kbdsidx{listpop}\label{se:listpop}
Removes the $n$-th element of the list
\var{list} (which must be of type \typ{LIST}). If $n$ is omitted,
or greater than the list current length, removes the last element.
If the list is already empty, do nothing. This runs in time $O(\#L - n + 1)$.
\bprog
? L = List([1,2,3,4]);
? listpop(~L); L  \\ remove last entry
%2 = List([1, 2, 3])
? listpop(~L, 1); L \\ remove first entry
%3 = List([2, 3])
@eprog\noindent Note the \kbd{\til L}: this means that the function is
called with a \emph{reference} to \kbd{L} and changes \kbd{L} in place.

The library syntax is \fun{void}{listpop0}{GEN ~list, long n}.

\subsec{listput$(~\var{list},x,\{n\})$}\kbdsidx{listput}\label{se:listput}
Sets the $n$-th element of the list
\var{list} (which must be of type \typ{LIST}) equal to $x$. If $n$ is omitted,
or greater than the list length, appends $x$. The function returns the
inserted element.
\bprog
? L = List();
? listput(~L, 1)
%2 = 1
? listput(~L, 2)
%3 = 2
? L
%4 = List([1, 2])
@eprog\noindent Note the \kbd{\til L}: this means that the function is
called with a \emph{reference} to \kbd{L} and changes \kbd{L} in place.

You may put an element into an occupied cell (not changing the
list length), but it is easier to use the standard \kbd{list[n] = x}
construct.
\bprog
? listput(~L, 3, 1) \\ insert at position 1
%5 = 3
? L
%6 = List([3, 2])
? L[2] = 4 \\ simpler
%7 = List([3, 4])
? L[10] = 1  \\ can't insert beyond the end of the list
 ***   at top-level: L[10]=1
 ***                  ^------
 ***   nonexistent component: index > 2
? listput(L, 1, 10) \\ but listput can
%8 = 1
? L
%9 = List([3, 2, 1])
@eprog

This function runs in time $O(\#L)$ in the worst case (when the list must
be reallocated), but in time $O(1)$ on average: any number of successive
\kbd{listput}s run in time $O(\#L)$, where $\#L$ denotes the list
\emph{final} length.

The library syntax is \fun{GEN}{listput0}{GEN ~list, GEN x, long n}.

\subsec{listsort$(~L,\{\fl=0\})$}\kbdsidx{listsort}\label{se:listsort}
Sorts the \typ{LIST} \var{list} in place, with respect to the (somewhat
arbitrary) universal comparison function \tet{cmp}. In particular, the
ordering is the same as for sets and \tet{setsearch} can be used on a sorted
list. No value is returned. If $\fl$ is nonzero, suppresses all repeated
coefficients.
\bprog
? L = List([1,2,4,1,3,-1]); listsort(~L); L
%1 = List([-1, 1, 1, 2, 3, 4])
? setsearch(L, 4)
%2 = 6
? setsearch(L, -2)
%3 = 0
? listsort(~L, 1); L \\ remove duplicates
%4 = List([-1, 1, 2, 3, 4])
@eprog\noindent Note the \kbd{\til L}: this means that the function is
called with a \emph{reference} to \kbd{L} and changes \kbd{L} in place:
this is faster than the \kbd{vecsort} command since the list
is sorted in place and we avoid unnecessary copies.
\bprog
? v = vector(100,i,random); L = List(v);
? for(i=1,10^4, vecsort(v))
time = 162 ms.
? for(i=1,10^4, vecsort(L))
time = 162 ms.
? for(i=1,10^4, listsort(~L))
time = 63 ms.
@eprog

The library syntax is \fun{void}{listsort}{GEN ~L, long flag}.

\subsec{localbitprec$(p)$}\kbdsidx{localbitprec}\label{se:localbitprec}
Set the real precision to $p$ bits in the dynamic scope.
All computations are performed as if \tet{realbitprecision} was $p$:
transcendental constants (e.g.~\kbd{Pi}) and
conversions from exact to floating point inexact data use $p$ bits, as well as
iterative routines implicitly using a floating point
accuracy as a termination criterion (e.g.~\tet{solve} or \tet{intnum}).
But \kbd{realbitprecision} itself is unaffected
and is ``unmasked'' when we exit the dynamic (\emph{not} lexical) scope.
In effect, this is similar to
\bprog
my(bit = default(realbitprecision));
default(realbitprecision,p);
...
default(realbitprecision, bit);
@eprog\noindent but is both less cumbersome, cleaner (no need to manipulate
a global variable, which in fact never changes and is only temporarily masked)
and more robust: if the above computation is interrupted or an exception
occurs, \kbd{realbitprecision} will not be restored as intended.

Such \kbd{localbitprec} statements can be nested, the innermost one taking
precedence as expected. Beware that \kbd{localbitprec} follows the semantic of
\tet{local}, not \tet{my}: a subroutine called from \kbd{localbitprec} scope
uses the local accuracy:
\bprog
? f()=bitprecision(1.0);
? f()
%2 = 128
? localbitprec(1000); f()
%3 = 1024
@eprog\noindent Note that the bit precision of \emph{data} (\kbd{1.0} in the
above example) increases by steps of 64 (32 on a 32-bit machine) so we get
$1024$ instead of the expected $1000$; \kbd{localbitprec} bounds the
relative error exactly as specified in functions that support that
granularity (e.g.~\kbd{lfun}), and rounded to the next multiple of 64
(resp.~32) everywhere else.

\misctitle{Warning} Changing \kbd{realbitprecision} or \kbd{realprecision}
in programs is deprecated in favor of \kbd{localbitprec} and
\kbd{localprec}. Think about the \kbd{realprecision} and
\kbd{realbitprecision} defaults as interactive commands for the \kbd{gp}
interpreter, best left out of GP programs. Indeed, the above rules imply that
mixing both constructs yields surprising results:

\bprog
? \p38
? localprec(19); default(realprecision,1000); Pi
%1 = 3.141592653589793239
? \p
  realprecision = 1001 significant digits (1000 digits displayed)
@eprog\noindent Indeed, \kbd{realprecision} itself is ignored within
\kbd{localprec} scope, so \kbd{Pi} is computed to a low accuracy. And when
we leave the \kbd{localprec} scope, \kbd{realprecision} only regains precedence,
it is not ``restored'' to the original value.
%\syn{NO}

\subsec{localprec$(p)$}\kbdsidx{localprec}\label{se:localprec}
Set the real precision to $p$ in the dynamic scope and return $p$.
All computations are performed as if \tet{realprecision} was $p$:
transcendental constants (e.g.~\kbd{Pi}) and
conversions from exact to floating point inexact data use $p$ decimal
digits, as well as iterative routines implicitly using a floating point
accuracy as a termination criterion (e.g.~\tet{solve} or \tet{intnum}).
But \kbd{realprecision} itself is unaffected
and is ``unmasked'' when we exit the dynamic (\emph{not} lexical) scope.
In effect, this is similar to
\bprog
my(prec = default(realprecision));
default(realprecision,p);
...
default(realprecision, prec);
@eprog\noindent but is both less cumbersome, cleaner (no need to manipulate
a global variable, which in fact never changes and is only temporarily masked)
and more robust: if the above computation is interrupted or an exception
occurs, \kbd{realprecision} will not be restored as intended.

Such \kbd{localprec} statements can be nested, the innermost one taking
precedence as expected. Beware that \kbd{localprec} follows the semantic of
\tet{local}, not \tet{my}: a subroutine called from \kbd{localprec} scope
uses the local accuracy:
\bprog
? f()=precision(1.);
? f()
%2 = 38
? localprec(19); f()
%3 = 19
@eprog\noindent
\misctitle{Warning} Changing \kbd{realprecision} itself in programs is
now deprecated in favor of \kbd{localprec}. Think about the
\kbd{realprecision} default as an interactive command for the \kbd{gp}
interpreter, best left out of GP programs. Indeed, the above rules
imply that mixing both constructs yields surprising results:
\bprog
? \p38
? localprec(19); default(realprecision,100); Pi
%1 = 3.141592653589793239
? \p
    realprecision = 115 significant digits (100 digits displayed)
@eprog\noindent Indeed, \kbd{realprecision} itself is ignored within
\kbd{localprec} scope, so \kbd{Pi} is computed to a low accuracy. And when
we leave \kbd{localprec} scope, \kbd{realprecision} only regains precedence,
it is not ``restored'' to the original value.
%\syn{NO}

\subsec{mapdelete$(~M,x)$}\kbdsidx{mapdelete}\label{se:mapdelete}
Removes $x$ from the domain of the map $M$.
\bprog
? M = Map(["a",1; "b",3; "c",7]);
? mapdelete(M,"b");
? Mat(M)
["a" 1]

["c" 7]
@eprog

The library syntax is \fun{void}{mapdelete}{GEN ~M, GEN x}.

\subsec{mapget$(M,x)$}\kbdsidx{mapget}\label{se:mapget}
Returns the image of $x$ by the map $M$.
\bprog
? M=Map(["a",23;"b",43]);
? mapget(M,"a")
%2 = 23
? mapget(M,"b")
%3 = 43
@eprog\noindent Raises an exception when the key $x$ is not present in $M$.
\bprog
? mapget(M,"c")
  ***   at top-level: mapget(M,"c")
  ***                 ^-------------
  *** mapget: nonexistent component in mapget: index not in map
@eprog

The library syntax is \fun{GEN}{mapget}{GEN M, GEN x}.

\subsec{mapisdefined$(M,x,\{\&z\})$}\kbdsidx{mapisdefined}\label{se:mapisdefined}
Returns true ($1$) if \kbd{x} has an image by the map $M$, false ($0$)
otherwise. If \kbd{z} is present, set \kbd{z} to the image of $x$, if it exists.
\bprog
? M1 = Map([1, 10; 2, 20]);
? mapisdefined(M1,3)
%1 = 0
? mapisdefined(M1, 1, &z)
%2 = 1
? z
%3 = 10
@eprog

\bprog
? M2 = Map(); N = 19;
? for (a=0, N-1, mapput(M2, a^3%N, a));
? {for (a=0, N-1,
     if (mapisdefined(M2, a, &b),
       printf("%d is the cube of %d mod %d\n",a,b,N)));}
0 is the cube of 0 mod 19
1 is the cube of 11 mod 19
7 is the cube of 9 mod 19
8 is the cube of 14 mod 19
11 is the cube of 17 mod 19
12 is the cube of 15 mod 19
18 is the cube of 18 mod 19
@eprog

The library syntax is \fun{GEN}{mapisdefined}{GEN M, GEN x, GEN *z = NULL}.

\subsec{mapput$(~M,x,y)$}\kbdsidx{mapput}\label{se:mapput}
Associates $x$ to $y$ in the map $M$. The value $y$ can be retrieved
with \tet{mapget}.
\bprog
? M = Map();
? mapput(~M, "foo", 23);
? mapput(~M, 7718, "bill");
? mapget(M, "foo")
%4 = 23
? mapget(M, 7718)
%5 = "bill"
? Vec(M)  \\ keys
%6 = [7718, "foo"]
? Mat(M)
%7 =
[ 7718 "bill"]

["foo"     23]
@eprog

The library syntax is \fun{void}{mapput}{GEN ~M, GEN x, GEN y}.

\subsec{print$(\{\var{str}\}*)$}\kbdsidx{print}\label{se:print}
Outputs its arguments in raw format ending with a newline.
The arguments are converted to strings following the rules in
\secref{se:strings}.
\bprog
? m = matid(2);
? print(m)  \\ raw format
[1, 0; 0, 1]
? printp(m) \\ prettymatrix format

[1 0]

[0 1]
@eprog
%\syn{NO}

\subsec{print1$(\{\var{str}\}*)$}\kbdsidx{print1}\label{se:print1}
Outputs its arguments in raw
format, without ending with a newline. Note that you can still embed newlines
within your strings, using the \b{n} notation~!
The arguments are converted to strings following the rules in
\secref{se:strings}.
%\syn{NO}

\subsec{printf$(\var{fmt},\{x\}*)$}\kbdsidx{printf}\label{se:printf}
This function is based on the C library command of the same name.
It prints its arguments according to the format \var{fmt}, which specifies how
subsequent arguments are converted for output. The format is a
character string composed of zero or more directives:

\item ordinary characters (not \kbd{\%}), printed unchanged,

\item conversions specifications (\kbd{\%} followed by some characters)
which fetch one argument from the list and prints it according to the
specification.

More precisely, a conversion specification consists in a \kbd{\%}, one or more
optional flags (among \kbd{\#}, \kbd{0}, \kbd{-}, \kbd{+}, ` '), an optional
decimal digit string specifying a minimal field width, an optional precision
in the form of a period (`\kbd{.}') followed by a decimal digit string, and
the conversion specifier (among \kbd{d},\kbd{i}, \kbd{o}, \kbd{u},
\kbd{x},\kbd{X}, \kbd{p}, \kbd{e},\kbd{E}, \kbd{f}, \kbd{g},\kbd{G}, \kbd{s}).

\misctitle{The flag characters} The character \kbd{\%} is followed by zero or
more of the following flags:

\item \kbd{\#}: the value is converted to an ``alternate form''. For
\kbd{o} conversion (octal), a \kbd{0} is prefixed to the string. For \kbd{x}
and \kbd{X} conversions (hexa), respectively \kbd{0x} and \kbd{0X} are
prepended. For other conversions, the flag is ignored.

\item \kbd{0}: the value should be zero padded. For
\kbd{d},
\kbd{i},
\kbd{o},
\kbd{u},
\kbd{x},
\kbd{X}
\kbd{e},
\kbd{E},
\kbd{f},
\kbd{F},
\kbd{g}, and
\kbd{G} conversions, the value is padded on the left with zeros rather than
blanks. (If the \kbd{0} and \kbd{-} flags both appear, the \kbd{0} flag is
ignored.)

\item \kbd{-}: the value is left adjusted on the field boundary. (The
default is right justification.) The value is padded on the right with
blanks, rather than on the left with blanks or zeros. A \kbd{-} overrides a
\kbd{0} if both are given.

\item \kbd{` '} (a space): a blank is left before a positive number
produced by a signed conversion.

\item \kbd{+}: a sign (+ or -) is placed before a number produced by a
signed conversion. A \kbd{+} overrides a space if both are used.

\misctitle{The field width} An optional decimal digit string (whose first
digit is nonzero) specifying a \emph{minimum} field width. If the value has
fewer characters than the field width, it is padded with spaces on the left
(or right, if the left-adjustment flag has been given). In no case does a
small field width cause truncation of a field; if the value is wider than
the field width, the field is expanded to contain the conversion result.
Instead of a decimal digit string, one may write \kbd{*} to specify that the
field width is given in the next argument.

\misctitle{The precision} An optional precision in the form of a period
(`\kbd{.}') followed by a decimal digit string. This gives
the number of digits to appear after the radix character for \kbd{e},
\kbd{E}, \kbd{f}, and \kbd{F} conversions, the maximum number of significant
digits for \kbd{g} and \kbd{G} conversions, and the maximum number of
characters to be printed from an \kbd{s} conversion.
Instead of a decimal digit string, one may write \kbd{*} to specify that the
field width is given in the next argument.

\misctitle{The length modifier} This is ignored under \kbd{gp}, but
necessary for \kbd{libpari} programming. Description given here for
completeness:

\item \kbd{l}: argument is a \kbd{long} integer.

\item \kbd{P}: argument is a \kbd{GEN}.

\misctitle{The conversion specifier} A character that specifies the type of
conversion to be applied.

\item \kbd{d}, \kbd{i}: a signed integer.

\item \kbd{o}, \kbd{u}, \kbd{x}, \kbd{X}: an unsigned integer, converted
to unsigned octal (\kbd{o}), decimal (\kbd{u}) or hexadecimal (\kbd{x} or
\kbd{X}) notation. The letters \kbd{abcdef} are used for \kbd{x}
conversions;  the letters \kbd{ABCDEF} are used for \kbd{X} conversions.

\item \kbd{e}, \kbd{E}: the (real) argument is converted in the style
\kbd{[ -]d.ddd e[ -]dd}, where there is one digit before the decimal point,
and the number of digits after it is equal to the precision; if the
precision is missing, use the current \kbd{realprecision} for the total
number of printed digits. If the precision is explicitly 0, no decimal-point
character appears. An \kbd{E} conversion uses the letter \kbd{E} rather
than \kbd{e} to introduce the exponent.

\item \kbd{f}, \kbd{F}: the (real) argument is converted in the style
\kbd{[ -]ddd.ddd}, where the number of digits after the decimal point
is equal to the precision; if the precision is missing, use the current
\kbd{realprecision} for the total number of printed digits. If the precision
is explicitly 0, no decimal-point character appears. If a decimal point
appears, at least one digit appears before it.

\item \kbd{g}, \kbd{G}: the (real) argument is converted in style
\kbd{e} or \kbd{f} (or \kbd{E} or \kbd{F} for \kbd{G} conversions)
\kbd{[ -]ddd.ddd}, where the total number of digits printed
is equal to the precision; if the precision is missing, use the current
\kbd{realprecision}. If the precision is explicitly 0, it is treated as 1.
Style \kbd{e} is used when
the decimal exponent is $< -4$, to print \kbd{0.}, or when the integer
part cannot be decided given the known significant digits, and the \kbd{f}
format otherwise.

\item \kbd{c}: the integer argument is converted to an unsigned char, and the
resulting character is written.

\item \kbd{s}: convert to a character string. If a precision is given, no
more than the specified number of characters are written.

\item \kbd{p}: print the address of the argument in hexadecimal (as if by
\kbd{\%\#x}).

\item \kbd{\%}: a \kbd{\%} is written. No argument is converted. The complete
conversion specification is \kbd{\%\%}.

\noindent Examples:

\bprog
? printf("floor: %d, field width 3: %3d, with sign: %+3d\n", Pi, 1, 2);
floor: 3, field width 3:   1, with sign:  +2

? printf("%.5g %.5g %.5g\n",123,123/456,123456789);
123.00 0.26974 1.2346 e8

? printf("%-2.5s:%2.5s:%2.5s\n", "P", "PARI", "PARIGP");
P :PARI:PARIG

\\ min field width and precision given by arguments
? x = 23; y=-1/x; printf("x=%+06.2f y=%+0*.*f\n", x, 6, 2, y);
x=+23.00 y=-00.04

\\ minimum fields width 5, pad left with zeroes
? for (i = 2, 5, printf("%05d\n", 10^i))
00100
01000
10000
100000  \\@com don't truncate fields whose length is larger than the minimum width
? printf("%.2f  |%06.2f|", Pi,Pi)
3.14  |  3.14|
@eprog\noindent All numerical conversions apply recursively to the entries
of vectors and matrices:
\bprog
? printf("%4d", [1,2,3]);
[   1,   2,   3]
? printf("%5.2f", mathilbert(3));
[ 1.00  0.50  0.33]

[ 0.50  0.33  0.25]

[ 0.33  0.25  0.20]
@eprog
\misctitle{Technical note} Our implementation of \tet{printf}
deviates from the C89 and C99 standards in a few places:

\item whenever a precision is missing, the current \kbd{realprecision} is
used to determine the number of printed digits (C89: use 6 decimals after
the radix character).

\item in conversion style \kbd{e}, we do not impose that the
exponent has at least two digits; we never write a \kbd{+} sign in the
exponent; 0 is printed in a special way, always as \kbd{0.E\var{exp}}.

\item in conversion style \kbd{f}, we switch to style \kbd{e} if the
exponent is greater or equal to the precision.

\item in conversion \kbd{g} and \kbd{G}, we do not remove trailing zeros
 from the fractional part of the result; nor a trailing decimal point;
 0 is printed in a special way, always as \kbd{0.E\var{exp}}.
%\syn{NO}

\subsec{printp$(\{\var{str}\}*)$}\kbdsidx{printp}\label{se:printp}
Outputs its arguments in prettymatrix format, ending with a
newline. The arguments are converted to strings following the rules in
\secref{se:strings}.
\bprog
? m = matid(2);
? print(m)  \\ raw format
[1, 0; 0, 1]
? printp(m) \\ prettymatrix format

[1 0]

[0 1]
@eprog
%\syn{NO}

\subsec{printsep$(\var{sep},\{\var{str}\}*)$}\kbdsidx{printsep}\label{se:printsep}
Outputs its arguments in raw format, ending with a newline.
The arguments are converted to strings following the rules in
\secref{se:strings}. Successive entries are separated by \var{sep}:
\bprog
? printsep(":", 1,2,3,4)
1:2:3:4
@eprog
%\syn{NO}

\subsec{printsep1$(\var{sep},\{\var{str}\}*)$}\kbdsidx{printsep1}\label{se:printsep1}
Outputs its arguments in raw format, without ending with a
newline. The arguments are converted to strings following the rules in
\secref{se:strings}. Successive entries are separated by \var{sep}:
\bprog
? printsep1(":", 1,2,3,4);print("|")
1:2:3:4|
@eprog
%\syn{NO}

\subsec{printtex$(\{\var{str}\}*)$}\kbdsidx{printtex}\label{se:printtex}
Outputs its arguments in \TeX\ format. This output can then be
used in a \TeX\ manuscript, see \kbd{strtex} for details. The arguments are
converted to strings following the rules in \secref{se:strings}. The printing
is done on the standard output. If you want to print it to a file you should
use \kbd{writetex} (see there).

Another possibility is to enable the \tet{log} default
(see~\secref{se:defaults}).
You could for instance do:\sidx{logfile}
%
\bprog
default(logfile, "new.tex");
default(log, 1);
printtex(result);
@eprog
%\syn{NO}

\subsec{quit$(\{\var{status} = 0\})$}\kbdsidx{quit}\label{se:quit}
Exits \kbd{gp} and return to the system with exit status
\kbd{status}, a small integer. A nonzero exit status normally indicates
abnormal termination. (Note: the system actually sees only
\kbd{status} mod $256$, see your man pages for \kbd{exit(3)} or \kbd{wait(2)}).

\subsec{read$(\{\var{filename}\})$}\kbdsidx{read}\label{se:read}
Reads in the file
\var{filename} (subject to string expansion). If \var{filename} is
omitted, re-reads the last file that was fed into \kbd{gp}. The return
value is the result of the last expression evaluated.

If a GP \tet{binary file} is read using this command (see
\secref{se:writebin}), the file is loaded and the last object in the file
is returned.

In case the file you read in contains an \tet{allocatemem} statement (to be
generally avoided), you should leave \kbd{read} instructions by themselves,
and not part of larger instruction sequences.

\misctitle{Variants} \kbd{readvec} allows to read a whole file at once;
\kbd{fileopen} followed by either \kbd{fileread} (evaluated lines) or
\kbd{filereadstr} (lines as nonevaluated strings) allows to read a file
one line at a time.

The library syntax is \fun{GEN}{gp_read_file}{const char *filename}.

\subsec{readstr$(\{\var{filename}\})$}\kbdsidx{readstr}\label{se:readstr}
Reads in the file \var{filename} and return a vector of GP strings,
each component containing one line from the file. If \var{filename} is
omitted, re-reads the last file that was fed into \kbd{gp}.

The library syntax is \fun{GEN}{readstr}{const char *filename}.

\subsec{readvec$(\{\var{filename}\})$}\kbdsidx{readvec}\label{se:readvec}
Reads in the file
\var{filename} (subject to string expansion). If \var{filename} is
omitted, re-reads the last file that was fed into \kbd{gp}. The return
value is a vector whose components are the evaluation of all sequences
of instructions contained in the file. For instance, if \var{file} contains
\bprog
1
2
3
@eprog\noindent
then we will get:
\bprog
? \r a
%1 = 1
%2 = 2
%3 = 3
? read(a)
%4 = 3
? readvec(a)
%5 = [1, 2, 3]
@eprog
In general a sequence is just a single line, but as usual braces and
\kbd{\bs} may be used to enter multiline sequences.

The library syntax is \fun{GEN}{gp_readvec_file}{const char *filename}.
The underlying library function
\fun{GEN}{gp_readvec_stream}{FILE *f} is usually more flexible.

\subsec{select$(f, A, \{\fl = 0\})$}\kbdsidx{select}\label{se:select}
We first describe the default behavior, when $\fl$ is 0 or omitted.
Given a vector or list \kbd{A} and a \typ{CLOSURE} \kbd{f}, \kbd{select}
returns the elements $x$ of \kbd{A} such that $f(x)$ is nonzero. In other
words, \kbd{f} is seen as a selection function returning a boolean value.
\bprog
? select(x->isprime(x), vector(50,i,i^2+1))
%1 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
? select(x->(x<100), %)
%2 = [2, 5, 17, 37]
@eprog\noindent returns the primes of the form $i^2+1$ for some $i\leq 50$,
then the elements less than 100 in the preceding result. The \kbd{select}
function also applies to a matrix \kbd{A}, seen as a vector of columns, i.e. it
selects columns instead of entries, and returns the matrix whose columns are
the selected ones.

\misctitle{Remark} For $v$ a \typ{VEC}, \typ{COL}, \typ{VECSMALL},
\typ{LIST} or \typ{MAT}, the alternative set-notations
\bprog
[g(x) | x <- v, f(x)]
[x | x <- v, f(x)]
[g(x) | x <- v]
@eprog\noindent
are available as shortcuts for
\bprog
apply(g, select(f, Vec(v)))
select(f, Vec(v))
apply(g, Vec(v))
@eprog\noindent respectively:
\bprog
? [ x | x <- vector(50,i,i^2+1), isprime(x) ]
%1 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
@eprog

\noindent If $\fl = 1$, this function returns instead the \emph{indices} of
the selected elements, and not the elements themselves (indirect selection):
\bprog
? V = vector(50,i,i^2+1);
? select(x->isprime(x), V, 1)
%2 = Vecsmall([1, 2, 4, 6, 10, 14, 16, 20, 24, 26, 36, 40])
? vecextract(V, %)
%3 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
@eprog\noindent
The following function lists the elements in $(\Z/N\Z)^*$:
\bprog
? invertibles(N) = select(x->gcd(x,N) == 1, [1..N])
@eprog

\noindent Finally
\bprog
? select(x->x, M)
@eprog\noindent selects the nonzero entries in \kbd{M}. If the latter is a
\typ{MAT}, we extract the matrix of nonzero columns. Note that \emph{removing}
entries instead of selecting them just involves replacing the selection
function \kbd{f} with its negation:
\bprog
? select(x->!isprime(x), vector(50,i,i^2+1))
@eprog

\synt{genselect}{void *E, long (*fun)(void*,GEN), GEN a}. Also available
is \fun{GEN}{genindexselect}{void *E, long (*fun)(void*, GEN), GEN a},
corresponding to $\fl = 1$.

\subsec{self$()$}\kbdsidx{self}\label{se:self}
Return the calling function or closure as a \typ{CLOSURE} object.
This is useful for defining anonymous recursive functions.
\bprog
? (n -> if(n==0,1,n*self()(n-1)))(5)
%1 = 120  \\ 5!

? (n -> if(n<=1, n, self()(n-1)+self()(n-2)))(20)
%2 = 6765 \\ Fibonacci(20)
@eprog

The library syntax is \fun{GEN}{pari_self}{}.

\subsec{setrand$(n)$}\kbdsidx{setrand}\label{se:setrand}
Reseeds the random number generator using the seed $n$. No value is
returned. The seed is a small positive integer $0 < n < 2^{64}$ used to
generate deterministically a suitable state array. All gp session start
by an implicit \kbd{setrand(1)}, so resetting the seed to this value allows
to replay all computations since the session start. Alternatively,
running a randomized computation starting by \kbd{setrand}($n$)
twice with the same $n$ will generate the exact same output.

In the other direction, including a call to \kbd{setrand(getwalltime())}
from your gprc will cause GP to produce different streams of random numbers
in each session. (Unix users may want to use \kbd{/dev/urandom} instead
of \kbd{getwalltime}.)

For debugging purposes, one can also record a particular random state
using \kbd{getrand} (the value is encoded as a huge integer) and feed it to
\kbd{setrand}:
\bprog
? state = getrand(); \\ record seed
...
? setrand(state); \\ we can now replay the exact same computations
@eprog

The library syntax is \fun{void}{setrand}{GEN n}.

\subsec{strchr$(x)$}\kbdsidx{strchr}\label{se:strchr}
Converts integer or vector of integers $x$ to a string, translating each
integer (in the range $[1,255]$) into a character using ASCII encoding.
\bprog
? strchr(97)
%1 = "a"
? Vecsmall("hello world")
%2 = Vecsmall([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])
? strchr(%)
%3 = "hello world"
@eprog

The library syntax is \fun{GEN}{pari_strchr}{GEN x}.

\subsec{strexpand$(\{x\}*)$}\kbdsidx{strexpand}\label{se:strexpand}
Converts its argument list into a
single character string (type \typ{STR}, the empty string if $x$ is omitted).
Then perform \idx{environment expansion}, see \secref{se:envir}.
This feature can be used to read \idx{environment variable} values.
\bprog
? strexpand("$HOME/doc")
%1 = "/home/pari/doc"

? module = "aprcl"; n = 10;
? strexpand("$HOME/doc/", module, n, ".tex")
%3 = "/home/pari/doc/aprcl10.tex"
@eprog

The individual arguments are read in string context, see \secref{se:strings}.
%\syn{NO}

\subsec{strjoin$(v,\{p = ""\})$}\kbdsidx{strjoin}\label{se:strjoin}
Joins the strings in vector $v$, separating them with delimiter $p$.
The reverse operation is \kbd{strsplit}.
\bprog
? v = ["abc", "def", "ghi"]
? strjoin(v, "/")
%2 = "abc/def/ghi"
? strjoin(v)
%3 = "abcdefghi"
@eprog

The library syntax is \fun{GEN}{strjoin}{GEN v, GEN p = NULL}.

\subsec{strprintf$(\var{fmt},\{x\}*)$}\kbdsidx{strprintf}\label{se:strprintf}
Returns a string built from the remaining arguments according to the
format fmt. The format consists of ordinary characters (not \%), printed
unchanged, and conversions specifications. See \kbd{printf}.
\bprog
? dir = "/home/pari"; file = "aprcl"; n = 10;
? strprintf("%s/%s%ld.tex", dir, file, n)
%2 = "/home/pari/aprcl10.tex"
@eprog
%\syn{NO}

\subsec{strsplit$(s,\{p = ""\})$}\kbdsidx{strsplit}\label{se:strsplit}
Splits the string $s$ into a vector of strings, with $p$ acting as a
delimiter. If $p$ is empty or omitted, split the string into characters.
\bprog
? strsplit("abc::def::ghi", "::")
%1 = ["abc", "def", "ghi"]
? strsplit("abc", "")
%2 = ["a", "b", "c"]
? strsplit("aba", "a")
@eprog\noindent If $s$ starts (resp.~ends) with the pattern $p$, then the
first (resp.~last) entry in the vector is the empty string:
\bprog
? strsplit("aba", "a")
%3 = ["", "b", ""]
@eprog

The library syntax is \fun{GEN}{strsplit}{GEN s, GEN p = NULL}.

\subsec{strtex$(\{x\}*)$}\kbdsidx{strtex}\label{se:strtex}
Translates its arguments to TeX format, and concatenates the results into a
single character string (type \typ{STR}, the empty string if $x$ is omitted).

The individual arguments are read in string context, see \secref{se:strings}.
\bprog
? v = [1, 2, 3]
%1 [1, 2, 3]
? strtex(v)
%2 = "\\pmatrix{ 1&2&3\\cr}\n"
@eprog

\misctitle{\TeX-nical notes} The TeX output engine was originally written
for plain TeX and designed for maximal portability. Unfortunately later
\kbd{LaTeX} packages have obsoleted valid \TeX\ primitives, leading us
to replace TeX's \kbd{\bs{}over} by LaTeX's \kbd{\bs{}frac} in PARI's TeX
output. We have decided not to update further our TeX markup and let the
users of various LaTeX engines customize their preambles. The following
documents the precise changes you may need to include in your style files to
incorporate PARI TeX output verbatim:

\item if you enabled bit 4 in \tet{TeXstyle} default, you must define
\kbd{\bs{}PARIbreak}; see \kbd{??TeXstyle};

\item if you use plain TeX only: you must define \kbd{\bs{}frac} as follows
\bprog
  \def\frac#1#2{{#1\over#2}}
@eprog

\item if you use LaTeX and \kbd{amsmath}, \kbd{\bs{}pmatrix} is
obsoleted in favor of the \kbd{pmatrix} environment; see
\kbd{examples/parigp.sty} for how to re-enable the deprecated construct.

%\syn{NO}

\subsec{strtime$(t)$}\kbdsidx{strtime}\label{se:strtime}
Return a string describing the time t in milliseconds in the format used by
 the GP timer.
\bprog
? print(strtime(12345678))
3h, 25min, 45,678 ms
? {
    my(t=getabstime());
    F=factor(2^256+1);t=getabstime()-t;
    print("factor(2^256+1) took ",strtime(t));
  }
factor(2^256+1) took 1,320 ms
@eprog

The library syntax is \fun{GEN}{strtime}{long t}.

\subsec{system$(\var{str})$}\kbdsidx{system}\label{se:system}
\var{str} is a string representing a system command. This command is
executed, its output written to the standard output (this won't get into your
logfile), and control returns to the PARI system. This simply calls the C
\kbd{system} command. Return the shell return value (which is system-dependent).
Beware that UNIX shell convention for boolean is opposite to GP, true is $0$
and false is non-$0$.
\bprog
? system("test -d /") \\ test if '/' is a directory (true)
%1 = 0
? system("test -f /") \\ test if '/' is a file (false)
%2 = 1
@eprog

The library syntax is \fun{long}{gpsystem}{const char *str}.

\subsec{trap$(\{e\}, \{\var{rec}\}, \var{seq})$}\kbdsidx{trap}\label{se:trap}
This function is obsolete, use \tet{iferr}, which has a nicer and much
more powerful interface. For compatibility's sake we now describe the
\emph{obsolete} function \tet{trap}.

This function tries to
evaluate \var{seq}, trapping runtime error $e$, that is effectively preventing
it from aborting computations in the usual way; the recovery sequence
\var{rec} is executed if the error occurs and the evaluation of \var{rec}
becomes the result of the command. If $e$ is omitted, all exceptions are
trapped. See \secref{se:errorrec} for an introduction to error recovery
under \kbd{gp}.

\bprog
? \\@com trap division by 0
? inv(x) = trap (e_INV, INFINITY, 1/x)
? inv(2)
%1 = 1/2
? inv(0)
%2 = INFINITY
@eprog\noindent
Note that \var{seq} is effectively evaluated up to the point that produced
the error, and the recovery sequence is evaluated starting from that same
context, it does not "undo" whatever happened in the other branch (restore
the evaluation context):
\bprog
? x = 1; trap (, /* recover: */ x, /* try: */ x = 0; 1/x)
%1 = 0
@eprog

\misctitle{Note} The interface is currently not adequate for trapping
individual exceptions. In the current version \vers, the following keywords
are recognized, but the name list will be expanded and changed in the
future (all library mode errors can be trapped: it's a matter of defining
the keywords to \kbd{gp}):

\kbd{e\_ALARM}: alarm time-out

\kbd{e\_ARCH}: not available on this architecture or operating system

\kbd{e\_STACK}: the PARI stack overflows

\kbd{e\_INV}: impossible inverse

\kbd{e\_IMPL}: not yet implemented

\kbd{e\_OVERFLOW}: all forms of arithmetic overflow, including length
or exponent overflow (when a larger value is supplied than the
implementation can handle).

\kbd{e\_SYNTAX}: syntax error

\kbd{e\_MISC}: miscellaneous error

\kbd{e\_TYPE}: wrong type

\kbd{e\_USER}: user error (from the \kbd{error} function)

The library syntax is \fun{GEN}{trap0}{const char *e = NULL, GEN rec = NULL, GEN seq = NULL}.

\subsec{type$(x)$}\kbdsidx{type}\label{se:type}
This is useful only under \kbd{gp}. Returns the internal type name of
the PARI object $x$ as a  string. Check out existing type names with the
metacommand \b{t}. For example \kbd{type(1)} will return "\typ{INT}".

The library syntax is \fun{GEN}{type0}{GEN x}.
The macro \kbd{typ} is usually simpler to use since it returns a
\kbd{long} that can easily be matched with the symbols \typ{*}. The name
\kbd{type} was avoided since it is a reserved identifier for some compilers.

\subsec{unexport$(x,...,z)$}\kbdsidx{unexport}\label{se:unexport}
Remove $x,\ldots, z$ from the list of variables exported
to the parallel world.  See \key{export}.

\subsec{unexportall$()$}\kbdsidx{unexportall}\label{se:unexportall}
Empty the list of variables exported to the parallel world.

The library syntax is \fun{void}{unexportall}{}.

\subsec{uninline$()$}\kbdsidx{uninline}\label{se:uninline}
Exit the scope of all current \kbd{inline} variables. DEPRECATED, use
\kbd{export} / \kbd{unexport}.

\subsec{version$()$}\kbdsidx{version}\label{se:version}
Returns the current version number as a \typ{VEC} with three integer
components (major version number, minor version number and patchlevel);
if your sources were obtained through our version control system, this will
be followed by further more precise arguments, including
e.g.~a~\kbd{git} \emph{commit hash}.

This function is present in all versions of PARI following releases 2.3.4
(stable) and 2.4.3 (testing).

Unless you are working with multiple development versions, you probably only
care about the 3 first numeric components. In any case, the \kbd{lex} function
offers a clever way to check against a particular version number, since it will
compare each successive vector entry, numerically or as strings, and will not
mind if the vectors it compares have different lengths:
\bprog
   if (lex(version(), [2,3,5]) >= 0,
     \\ code to be executed if we are running 2.3.5 or more recent.
   ,
     \\ compatibility code
   );
@eprog\noindent On a number of different machines, \kbd{version()} could return either of
\bprog
 %1 = [2, 3, 4]    \\ released version, stable branch
 %1 = [2, 4, 3]    \\ released version, testing branch
 %1 = [2, 6, 1, 15174, ""505ab9b"] \\ development
@eprog

In particular, if you are only working with released versions, the first
line of the gp introductory message can be emulated by
\bprog
   [M,m,p] = version();
   printf("GP/PARI CALCULATOR Version %s.%s.%s", M,m,p);
 @eprog\noindent If you \emph{are} working with many development versions of
 PARI/GP, the 4th and/or 5th components can be profitably included in the
 name of your logfiles, for instance.

 \misctitle{Technical note} For development versions obtained via \kbd{git},
 the 4th and 5th components are liable to change eventually, but we document
 their current meaning for completeness. The 4th component counts the number
 of reachable commits in the branch (analogous to \kbd{svn}'s revision
 number), and the 5th is the \kbd{git} commit hash. In particular, \kbd{lex}
 comparison still orders correctly development versions with respect to each
 others or to released versions (provided we stay within a given branch,
 e.g. \kbd{master})!

The library syntax is \fun{GEN}{pari_version}{}.

\subsec{warning$(\{\var{str}\}*)$}\kbdsidx{warning}\label{se:warning}
Outputs the message ``user warning''
and the argument list (each of them interpreted as a string).
If colors are enabled, this warning will be in a different color,
making it easy to distinguish.
\bprog
warning(n, " is very large, this might take a while.")
@eprog
% \syn{NO}

\subsec{whatnow$(\var{key})$}\kbdsidx{whatnow}\label{se:whatnow}
If keyword \var{key} is the name of a function that was present in GP
version 1.39.15, outputs the new function name and syntax, if it
changed at all. Functions that where introduced since then, then modified
are also recognized.
\bprog
? whatnow("mu")
New syntax: mu(n) ===> moebius(n)

moebius(x): Moebius function of x.

? whatnow("sin")
This function did not change
@eprog When a function was removed and the underlying functionality
is not available under a compatible interface, no equivalent is mentioned:
\bprog
? whatnow("buchfu")
This function no longer exists
@eprog\noindent (The closest equivalent would be to set \kbd{K = bnfinit(T)}
then access \kbd{K.fu}.)

\subsec{write$(\var{filename},\{\var{str}\}*)$}\kbdsidx{write}\label{se:write}
Writes (appends) to \var{filename} the remaining arguments, and appends a
newline (same output as \kbd{print}).

\misctitle{Variant} The high-level function \kbd{write} is expensive when many
consecutive writes are expected because it cannot use buffering. The low-level
interface \kbd{fileopen} / \kbd{filewrite} / \kbd{fileclose} is more efficient.
It also allows to truncate existing files and replace their contents.
%\syn{NO}

\subsec{write1$(\var{filename},\{\var{str}\}*)$}\kbdsidx{write1}\label{se:write1}
Writes (appends) to \var{filename} the remaining arguments without a
trailing newline (same output as \kbd{print1}).
%\syn{NO}

\subsec{writebin$(\var{filename},\{x\})$}\kbdsidx{writebin}\label{se:writebin}
Writes (appends) to
\var{filename} the object $x$ in binary format. This format is not human
readable, but contains the exact internal structure of $x$, and is much
faster to save/load than a string expression, as would be produced by
\tet{write}. The binary file format includes a magic number, so that such a
file can be recognized and correctly input by the regular \tet{read} or \b{r}
function. If saved objects refer to polynomial variables that are not
defined in the new session, they will be displayed as \kbd{t$n$} for some
integer $n$ (the attached variable number).
Installed functions and history objects can not be saved via this function.

If $x$ is omitted, saves all user variables from the session, together with
their names. Reading such a ``named object'' back in a \kbd{gp} session will set
the corresponding user variable to the saved value. E.g after
\bprog
x = 1; writebin("log")
@eprog\noindent
reading \kbd{log} into a clean session will set \kbd{x} to $1$.
The relative variables priorities (see \secref{se:priority}) of new variables
set in this way remain the same (preset variables retain their former
priority, but are set to the new value). In particular, reading such a
session log into a clean session will restore all variables exactly as they
were in the original one.

Just as a regular input file, a binary file can be compressed
using \tet{gzip}, provided the file name has the standard \kbd{.gz}
extension.\sidx{binary file}

In the present implementation, the binary files are architecture dependent
and compatibility with future versions of \kbd{gp} is not guaranteed. Hence
binary files should not be used for long term storage (also, they are
larger and harder to compress than text files).

The library syntax is \fun{void}{gpwritebin}{const char *filename, GEN x = NULL}.

\subsec{writetex$(\var{filename},\{\var{str}\}*)$}\kbdsidx{writetex}\label{se:writetex}
As \kbd{write}, in \TeX\ format. See \tet{strtex} for details:
this function is essentially equivalent to calling \kbd{strtex} on remaining
arguments and writing them to file.
%\syn{NO}

\section{Parallel programming}

These function are only available if PARI was configured using
\kbd{Configure --mt=\dots}. Two multithread interfaces are supported:

\item POSIX threads

\item Message passing interface (MPI)

As a rule, POSIX threads are well-suited for single systems, while MPI is used
by most clusters. However the parallel GP interface does not depend on the
chosen multithread interface: a properly written GP program will work
identically with both.

\subsec{parapply$(f, x)$}\kbdsidx{parapply}\label{se:parapply}
Parallel evaluation of \kbd{f} on the elements of \kbd{x}.
The function \kbd{f} must not access global variables or variables
declared with local(), and must be free of side effects.
\bprog
parapply(factor,[2^256 + 1, 2^193 - 1])
@eprog
factors $2^{256} + 1$ and $2^{193} - 1$ in parallel.
\bprog
{
  my(E = ellinit([1,3]), V = vector(12,i,randomprime(2^200)));
  parapply(p->ellcard(E,p), V)
}
@eprog
computes the order of $E(\F_p)$ for $12$ random primes of $200$ bits.

The library syntax is \fun{GEN}{parapply}{GEN f, GEN x}.

\subsec{pareval$(x)$}\kbdsidx{pareval}\label{se:pareval}
Parallel evaluation of the elements of \kbd{x}, where \kbd{x} is a
vector of closures. The closures must be of arity $0$, must not access
global variables or variables declared with \kbd{local} and must be
free of side effects.

Here is an artificial example explaining the MOV attack on the elliptic
discrete log problem (by reducing it to a standard discrete log over a
finite field):
\bprog
{
  my(q = 2^30 + 3, m = 40 * q; p = 1 + m^2); \\ p, q are primes
  my(E = ellinit([0,0,0,1,0] * Mod(1,p)));
  my([P, Q] = ellgenerators(E));
  \\ E(F_p) ~ Z/m P + Z/m Q and the order of the
  \\ Weil pairing <P,Q> in (Z/p)^* is m
  my(F = [m,factor(m)], e = random(m), R, wR, wQ);
  R = ellpow(E, Q, e);
  wR = ellweilpairing(E,P,R,m);
  wQ = ellweilpairing(E,P,Q,m); \\ wR = wQ^e
  pareval([()->znlog(wR,wQ,F), ()->elllog(E,R,Q), ()->e])
}
@eprog\noindent Note the use of \kbd{my} to pass "arguments" to the
functions we need to evaluate while satisfying the listed requirements:
closures of arity $0$ and no global variables (another possibility would be
to use \kbd{export}). As a result, the final three statements satisfy all
the listed requirements and are run in parallel. (Which is silly for
this computation but illustrates the use of pareval.) The function
\kbd{parfor} is more powerful but harder to use.

The library syntax is \fun{GEN}{pareval}{GEN x}.

\subsec{parfor$(i=a,\{b\},\var{expr1},\{r\},\{\var{expr2}\})$}\kbdsidx{parfor}\label{se:parfor}
Evaluates in parallel the expression \kbd{expr1} in the formal
argument $i$ running from $a$ to $b$.
If $b$ is set to \kbd{+oo}, the loop runs indefinitely.
If $r$ and \kbd{expr2} are present, the expression \kbd{expr2} in the
formal variables $r$ and $i$ is evaluated with $r$ running through all
the different results obtained for \kbd{expr1} and $i$ takes the
corresponding argument.

The computations of \kbd{expr1} are \emph{started} in increasing order
of $i$; otherwise said, the computation for $i=c$ is started after those
for $i=1, \ldots, c-1$ have been started, but before the computation for
$i=c+1$ is started. Notice that the order of \emph{completion}, that is,
the order in which the different $r$ become available, may be different;
\kbd{expr2} is evaluated sequentially on each $r$ as it appears.

The following example computes the sum of the squares of the integers
from $1$ to $10$ by computing the squares in parallel and is equivalent
to \kbd{parsum (i=1, 10, i\^{}2)}:
\bprog
? s=0;
? parfor (i=1, 10, i^2, r, s=s+r)
? s
%3 = 385
@eprog
More precisely, apart from a potentially different order of evaluation
due to the parallelism, the line containing \kbd{parfor} is equivalent to
\bprog
? my (r); for (i=1, 10, r=i^2; s=s+r)
@eprog
The sequentiality of the evaluation of \kbd{expr2} ensures that the
variable \kbd{s} is not modified concurrently by two different additions,
although the order in which the terms are added is nondeterministic.

It is allowed for \kbd{expr2} to exit the loop using
\kbd{break}/\kbd{next}/\kbd{return}. If that happens for $i=c$,
then the evaluation of \kbd{expr1} and \kbd{expr2} is continued
for all values $i<c$, and the return value is the one obtained for
the smallest $i$ causing an interruption in \kbd{expr2} (it may be
undefined if this is a \kbd{break}/\kbd{next}).
In that case, using side-effects
in \kbd{expr2} may lead to undefined behavior, as the exact
number of values of $i$ for which it is executed is nondeterministic.
The following example computes \kbd{nextprime(1000)} in parallel:
\bprog
? parfor (i=1000, , isprime (i), r, if (r, return (i)))
%1 = 1009
@eprog

%\syn{NO}

\subsec{parforeach$(V,x,\var{expr1},\{r\},\{\var{expr2}\})$}\kbdsidx{parforeach}\label{se:parforeach}
Evaluates in parallel the expression \kbd{expr1} in the formal
argument $x$, where $x$ runs through all components of $V$.
If $r$ and \kbd{expr2} are present, evaluate sequentially the expression
\kbd{expr2}, in which the formal variables $x$ and $r$ are replaced
by the successive arguments and corresponding values. The sequential
evaluation ordering is not specified:
\bprog
? parforeach([50..100], x,isprime(x), r, if(r,print(x)))
53
67
71
79
83
89
97
73
59
61
@eprog
%\syn{NO}

\subsec{parforprime$(p=a,\{b\},\var{expr1},\{r\},\{\var{expr2}\})$}\kbdsidx{parforprime}\label{se:parforprime}
Behaves exactly as \kbd{parfor}, but loops only over prime values $p$.
Precisely, the functions evaluates in parallel the expression \kbd{expr1}
in the formal
argument $p$ running through the primes from $a$ to $b$.
If $b$ is set to \kbd{+oo}, the loop runs indefinitely.
If $r$ and \kbd{expr2} are present, the expression \kbd{expr2} in the
formal variables $r$ and $p$ is evaluated with $r$ running through all
the different results obtained for \kbd{expr1} and $p$ takes the
corresponding argument.

It is allowed fo \kbd{expr2} to exit the loop using
\kbd{break}/\kbd{next}/\kbd{return}; see the remarks in the documentation
of \kbd{parfor} for details.

%\syn{NO}

\subsec{parforprimestep$(p=a,\{b\},q,\var{expr1},\{r\},\{\var{expr2}\})$}\kbdsidx{parforprimestep}\label{se:parforprimestep}
Behaves exactly as \kbd{parfor}, but loops only over prime values $p$
in an arithmetic progression
Precisely, the functions evaluates in parallel the expression \kbd{expr1}
in the formal argument $p$ running through the primes from $a$ to $b$
in an arithmetic progression of the form $a + k\*q$.
($p \equiv a \pmod{q}$) or an intmod \kbd{Mod(c,N)}.
If $b$ is set to \kbd{+oo}, the loop runs indefinitely.
If $r$ and \kbd{expr2} are present, the expression \kbd{expr2} in the
formal variables $r$ and $p$ is evaluated with $r$ running through all
the different results obtained for \kbd{expr1} and $p$ takes the
corresponding argument.

It is allowed fo \kbd{expr2} to exit the loop using
\kbd{break}/\kbd{next}/\kbd{return}; see the remarks in the documentation
of \kbd{parfor} for details.

%\syn{NO}

\subsec{parforvec$(X=v,\var{expr1},\{j\},\{\var{expr2}\},\{\fl\})$}\kbdsidx{parforvec}\label{se:parforvec}
Evaluates the sequence \kbd{expr2} (dependent on $X$ and $j$) for $X$
as generated by \kbd{forvec}, in random order, computed in parallel. Substitute
for $j$ the value of \kbd{expr1} (dependent on $X$).

It is allowed fo \kbd{expr2} to exit the loop using
\kbd{break}/\kbd{next}/\kbd{return}, however in that case, \kbd{expr2} will
still be evaluated for all remaining value of $p$ less than the current one,
unless a subsequent \kbd{break}/\kbd{next}/\kbd{return} happens.
%\syn{NO}

\subsec{parselect$(f, A, \{\fl = 0\})$}\kbdsidx{parselect}\label{se:parselect}
Selects elements of $A$ according to the selection function $f$, done in
parallel.  If \fl is $1$, return the indices of those elements (indirect
selection) The function \kbd{f} must not access global variables or
variables declared with local(), and must be free of side effects.

The library syntax is \fun{GEN}{parselect}{GEN f, GEN A, long flag}.

\subsec{parsum$(i=a,b,\var{expr})$}\kbdsidx{parsum}\label{se:parsum}
Sum of expression \var{expr}, the formal parameter
going from $a$ to $b$, evaluated in parallel in random order.
The expression \kbd{expr} must not access global variables or
variables declared with \kbd{local()}, and must be free of side effects.
\bprog
? parsum(i=1,1000,ispseudoprime(2^prime(i)-1))
cpu time = 1min, 26,776 ms, real time = 5,854 ms.
%1 = 20
@eprog
returns the number of prime numbers among the first $1000$ Mersenne numbers.
%\syn{NO}

\subsec{parvector$(N,i,\var{expr})$}\kbdsidx{parvector}\label{se:parvector}
As \kbd{vector(N,i,expr)} but the evaluations of \kbd{expr} are done in
parallel. The expression \kbd{expr} must not access global variables or
variables declared with \kbd{local()}, and must be free of side effects.
\bprog
parvector(10,i,quadclassunit(2^(100+i)+1).no)
@eprog\noindent
computes the class numbers in parallel.
%\syn{NO}

\section{GP defaults}
\label{se:gp_defaults} This section documents the GP defaults,
that can be set either by the GP function \tet{default} or in your GPRC.
Be sure to check out \tet{parisize} and \tet{parisizemax} !

\subsec{TeXstyle}\kbdsidx{TeXstyle}\label{se:def,TeXstyle}
The bits of this default allow
\kbd{gp} to use less rigid TeX formatting commands in the logfile. This
default is only taken into account when $\kbd{log} = 3$. The bits of
\kbd{TeXstyle} have the following meaning

2: insert \kbd{{\bs}right} / \kbd{{\bs}left} pairs where appropriate.

4: insert discretionary breaks in polynomials, to enhance the probability of
a good line break. You \emph{must} then define \kbd{{\bs}PARIbreak} as
follows:
\bprog
   \def\PARIbreak{\hskip 0pt plus \hsize\relax\discretionary{}{}{}}
@eprog

The default value is \kbd{0}.

\subsec{breakloop}\kbdsidx{breakloop}\label{se:def,breakloop}
If true, enables the ``break loop'' debugging mode, see
\secref{se:break_loop}.

The default value is \kbd{1} if we are running an interactive \kbd{gp}
session, and \kbd{0} otherwise.

\subsec{colors}\kbdsidx{colors}\label{se:def,colors}
This default is only usable if \kbd{gp}
is running within certain color-capable terminals. For instance \kbd{rxvt},
\kbd{color\_xterm} and modern versions of \kbd{xterm} under X Windows, or
standard Linux/DOS text consoles. It causes \kbd{gp} to use a small palette of
colors for its output. With xterms, the colormap used corresponds to the
resources \kbd{Xterm*color$n$} where $n$ ranges from $0$ to $15$ (see the
file \kbd{misc/color.dft} for an example). Accepted values for this
default are strings \kbd{"$a_1$,\dots,$a_k$"} where $k\le7$ and each
$a_i$ is either

\noindent\item the keyword \kbd{no} (use the default color, usually
black on transparent background)

\noindent\item an integer between 0 and 15 corresponding to the
aforementioned colormap

\noindent\item a triple $[c_0,c_1,c_2]$ where $c_0$ stands for foreground
color, $c_1$ for background color, and $c_2$ for attributes (0 is default, 1
is bold, 4 is underline).

The output objects thus affected are respectively error messages,
history numbers, prompt, input line, output, help messages, timer (that's
seven of them). If $k < 7$, the remaining $a_i$ are assumed to be $no$. For
instance
%
\bprog
default(colors, "9, 5, no, no, 4")
@eprog
\noindent
typesets error messages in color $9$, history numbers in color $5$, output in
color $4$, and does not affect the rest.

A set of default colors for dark (reverse video or PC console) and light
backgrounds respectively is activated when \kbd{colors} is set to
\kbd{darkbg}, resp.~\kbd{lightbg} (or any proper prefix: \kbd{d} is
recognized as an abbreviation for \kbd{darkbg}). A bold variant of
\kbd{darkbg}, called \kbd{boldfg}, is provided if you find the former too
pale.

\emacs In the present version, this default is incompatible with PariEmacs.
Changing it will just fail silently (the alternative would be to display
escape sequences as is, since Emacs will refuse to interpret them).
You must customize color highlighting from the PariEmacs side, see its
documentation.

The default value is \kbd{""} (no colors).

\subsec{compatible}\kbdsidx{compatible}\label{se:def,compatible}
Obsolete. This default is now a no-op.

\subsec{datadir}\kbdsidx{datadir}\label{se:def,datadir}
The name of directory containing the optional data files. For now,
this includes the \kbd{elldata}, \kbd{galdata}, \kbd{galpol}, \kbd{seadata}
packages.

The default value is \kbd{/usr/local/share/pari}, or the override specified
via \kbd{Configure --datadir=}.

\misctitle{Windows-specific note} On Windows operating systems, the
special value \kbd{@} stands for ``the directory where the \kbd{gp}
binary is installed''. This is the default value.

\subsec{debug}\kbdsidx{debug}\label{se:def,debug}
Debugging level. If it is nonzero, some extra messages may be printed,
according to what is going on (see~\b{g}). To turn on and off diagnostics
attached to a specific feature (such as the LLL algorithm), use
\tet{setdebug}.

The default value is \kbd{0} (no debugging messages).

\subsec{debugfiles}\kbdsidx{debugfiles}\label{se:def,debugfiles}
This is a deprecated alias for \kbd{setdebug("io",)}. If nonzero,
\kbd{gp} will print information on file descriptors in use and I/O
operations (see~\b{gf}).

The default value is \kbd{0} (no debugging messages).

\subsec{debugmem}\kbdsidx{debugmem}\label{se:def,debugmem}
Memory debugging level (see \b{gm}). If this is nonzero, \kbd{gp} will
print increasingly precise notifications about memory use:

\item $\kbd{debugmem} > 0$, notify when \kbd{parisize} changes (within the
boundaries set by \kbd{parisizemax});

\item $\kbd{debugmem} > 1$, indicate any important garbage collection and the
function it is taking place in;

\item $\kbd{debugmem} > 2$, indicate the creation/destruction of
``blocks'' (or clones); expect lots of messages.

\noindent {\bf Important Note:}
if you are running a version compiled for debugging (see Appendix~A) and
$\kbd{debugmem} > 1$, \kbd{gp} will further regularly print information on
memory usage, notifying whenever stack usage goes up or down by 1 MByte.
This functionality is disabled on non-debugging builds as it noticeably
slows down the performance.

The default value is \kbd{1}.

\subsec{echo}\kbdsidx{echo}\label{se:def,echo}
This default can be 0 (off), 1 (on) or 2 (on, raw). When \kbd{echo}
mode is on, each command is reprinted before being executed. This can be
useful when reading a file with the \b{r} or \kbd{read} commands. For
example, it is turned on at the beginning of the test files used to check
whether \kbd{gp} has been built correctly (see \b{e}). When \kbd{echo} is set
to 1 the input is cleaned up, removing white space and comments and uniting
multi-line input. When set to 2 (raw), the input is written as-is, without any
pre-processing.

The default value is \kbd{0} (no echo).

\subsec{factor\_add\_primes}\kbdsidx{def,factor_add_primes}\label{se:def,factor_add_primes}
This toggle is either 1 (on) or 0 (off). If on,
the integer factorization machinery calls \tet{addprimes} on prime
factors that were difficult to find (larger than $2^{24}$), so they are
automatically tried first in other factorizations. If a routine is performing
(or has performed) a factorization and is interrupted by an error or via
Control-C, this lets you recover the prime factors already found. The
downside is that a huge \kbd{addprimes} table unrelated to the current
computations will slow down arithmetic functions relying on integer
factorization; one should then empty the table using \tet{removeprimes}.

The default value is \kbd{0}.

\subsec{factor\_proven}\kbdsidx{def,factor_proven}\label{se:def,factor_proven}
This toggle is either 1 (on) or 0 (off). By
default, the factors output by the integer factorization machinery are
only pseudo-primes, not proven primes. If this toggle is
set, a primality proof is done for each factor and all results depending on
integer factorization are fully proven. This flag does not affect partial
factorization when it is explicitly requested. It also does not affect the
private table managed by \tet{addprimes}: its entries are included as is in
factorizations, without being tested for primality.

The default value is \kbd{0}.

\subsec{format}\kbdsidx{format}\label{se:def,format}
Of the form x$.n$, where x (conversion style)
is a letter in $\{\kbd{e},\kbd{f},\kbd{g}\}$, and $n$ (precision) is an
integer; this affects the way real numbers are printed:

\item If the conversion style is \kbd{e}, real numbers are printed in
\idx{scientific format}, always with an explicit exponent,
e.g.~\kbd{3.3 E-5}.

\item In style \kbd{f}, real numbers are generally printed in
\idx{fixed floating point format} without exponent, e.g.~\kbd{0.000033}. A
large real number, whose integer part is not well defined (not enough
significant digits), is printed in style~\kbd{e}. For instance
\kbd{10.\pow 100} known to ten significant digits is always printed in style
\kbd{e}.

\item In style \kbd{g}, nonzero real numbers are printed in \kbd{f} format,
except when their decimal exponent is $< -4$, in which case they are printed
in \kbd{e} format. Real zeroes (of arbitrary exponent) are printed in \kbd{e}
format.

The precision $n$ is the number of significant digits printed for real
numbers, except if $n<0$ where all the significant digits will be printed
(initial default 28, or 38 for 64-bit machines). For more powerful formatting
possibilities, see \tet{printf} and \tet{strprintf}.

The default value is \kbd{"g.28"} and \kbd{"g.38"} on 32-bit and
64-bit machines, respectively.

\subsec{graphcolormap}\kbdsidx{graphcolormap}\label{se:def,graphcolormap}
A vector of colors, to be used by hi-res graphing routines. Its length is
arbitrary, but it must contain at least 3 entries: the first 3 colors are
used for background, frame/ticks and axes respectively. All colors in the
colormap may be freely used in \tet{plotcolor} calls.

A color is either given as in the default by character strings or by an RGB
code. For valid color names, see the standard \kbd{rgb.txt} file in X11
distributions, where we restrict to lowercase letters and remove all
whitespace from color names. An RGB code is a vector with 3 integer entries
between 0 and 255 or a \kbd{\#} followed by 6 hexadecimal digits.
For instance \kbd{[250, 235, 215]}, \kbd{"\#faebd7"}  and
\kbd{"antiquewhite"} all represent the same color.

The default value is [\kbd{"white"}, \kbd{"black"}, \kbd{"blue"},
\kbd{"violetred"}, \kbd{"red"}, \kbd{"green"}, \kbd{"grey"},
\kbd{"gainsboro"}].

\subsec{graphcolors}\kbdsidx{graphcolors}\label{se:def,graphcolors}
Entries in the
\tet{graphcolormap} that will be used to plot multi-curves. The successive
curves are drawn in colors

\kbd{graphcolormap[graphcolors[1]]}, \kbd{graphcolormap[graphcolors[2]]},
  \dots

cycling when the \kbd{graphcolors} list is exhausted.

The default value is \kbd{[4,5]}.

\subsec{help}\kbdsidx{help}\label{se:def,help}
Name of the external help program to use from within \kbd{gp} when
extended help is invoked, usually through a \kbd{??} or \kbd{???} request
(see \secref{se:exthelp}), or \kbd{M-H} under readline (see
\secref{se:readline}).

\misctitle{Windows-specific note} On Windows operating systems, if the
first character of \kbd{help} is \kbd{@}, it is replaced by ``the directory
where the \kbd{gp} binary is installed''.

The default value is the path to the \kbd{gphelp} script we install.

\subsec{histfile}\kbdsidx{histfile}\label{se:def,histfile}
Name of a file where
\kbd{gp} will keep a history of all \emph{input} commands (results are
omitted). If this file exists when the value of \kbd{histfile} changes,
it is read in and becomes part of the session history. Thus, setting this
default in your gprc saves your readline history between sessions. Setting
this default to the empty string \kbd{""} changes it to
\kbd{$<$undefined$>$}. Note that, by default, the number of history entries
saved is not limited: set \kbd{history-size} in readline's \kbd{.inputrc}
to limit the file size.

The default value is \kbd{$<$undefined$>$} (no history file).

\subsec{histsize}\kbdsidx{histsize}\label{se:def,histsize}
\kbd{gp} keeps a history of the last
\kbd{histsize} results computed so far, which you can recover using the
\kbd{\%} notation (see \secref{se:history}). When this number is exceeded,
the oldest values are erased. Tampering with this default is the only way to
get rid of the ones you do not need anymore.

The default value is \kbd{5000}.

\subsec{lines}\kbdsidx{lines}\label{se:def,lines}
If set to a positive value, \kbd{gp} prints at
most that many lines from each result, terminating the last line shown with
\kbd{[+++]} if further material has been suppressed. The various \kbd{print}
commands (see \secref{se:gp_program}) are unaffected, so you can always type
\kbd{print(\%)} or \b{a} to view the full result. If the actual screen width
cannot be determined, a ``line'' is assumed to be 80 characters long.

The default value is \kbd{0}.

\subsec{linewrap}\kbdsidx{linewrap}\label{se:def,linewrap}
If set to a positive value, \kbd{gp} wraps every single line after
printing that many characters.

The default value is \kbd{0} (unset).

\subsec{log}\kbdsidx{log}\label{se:def,log}
This can be either 0 (off) or 1, 2, 3
(on, see below for the various modes). When logging mode is turned on, \kbd{gp}
opens a log file, whose exact name is determined by the \kbd{logfile}
default. Subsequently, all the commands and results will be written to that
file (see \b{l}). In case a file with this precise name already existed, it
will not be erased: your data will be \emph{appended} at the end.

The specific positive values of \kbd{log} have the following meaning

1: plain logfile

2: emit color codes to the logfile (if \kbd{colors} is set).

3: write LaTeX output to the logfile (can be further customized using
\tet{TeXstyle}).

The default value is \kbd{0}.

\misctitle{Note} Logging starts as soon as \kbd{log} is set to a nonzero
value. In particular, when \kbd{log} is set in \kbd{gprc}, warnings and
errors triggered from the rest of the file will be written in the logfile.
For instance, on clean startup, the logfile will start by \kbd{Done.}
(from the \kbd{Reading GPRC:\dots Done.} diagnostic printed when starting
\kbd{gp}), then the \kbd{gp} header and prompt.

\subsec{logfile}\kbdsidx{logfile}\label{se:def,logfile}
Name of the log file to be used when the \kbd{log} toggle is on.
Environment and time expansion are performed.

The default value is \kbd{"pari.log"}.

\subsec{nbthreads}\kbdsidx{nbthreads}\label{se:def,nbthreads}
This default is specific to the \emph{parallel} version of PARI and gp
(built via \kbd{Configure --mt=prthread} or \kbd{mpi}) and is ignored
otherwise. In parallel mode, it governs the number of threads to use for
parallel computing. The exact meaning and default value depend on the
\kbd{mt} engine used:

\item \kbd{single}: not used (always a single thread).

\item \kbd{pthread}: number of threads (unlimited, default: number of cores)

\item \kbd{mpi}: number of MPI processes to use (limited to the number
allocated by \kbd{mpirun}, default: use all allocated processes).

See also \kbd{threadsize} and \kbd{threadsizemax}.

\subsec{new\_galois\_format}\kbdsidx{def,new_galois_format}\label{se:def,new_galois_format}
This toggle is either 1 (on) or 0 (off). If on,
the \tet{polgalois} command will use a different, more
consistent, naming scheme for Galois groups. This default is provided to
ensure that scripts can control this behavior and do not break unexpectedly.

The default value is \kbd{0}. This value will change to $1$ (set) in the next
major version.

\subsec{output}\kbdsidx{output}\label{se:def,output}
There are three possible values: 0
(=~\var{raw}), 1 (=~\var{prettymatrix}), or 3
(=~\var{external} \var{prettyprint}). This
means that, independently of the default \kbd{format} for reals which we
explained above, you can print results in three ways:

\item \tev{raw format}, i.e.~a format which is equivalent to what you
input, including explicit multiplication signs, and everything typed on a
line instead of two dimensional boxes. This can have several advantages, for
instance it allows you to pick the result with a mouse or an editor, and to
paste it somewhere else.

\item \tev{prettymatrix format}: this is identical to raw format, except
that matrices are printed as boxes instead of horizontally. This is
prettier, but takes more space and cannot be used for input. Column vectors
are still printed horizontally.

\item \tev{external prettyprint}: pipes all \kbd{gp}
output in TeX format to an external prettyprinter, according to the value of
\tet{prettyprinter}. The default script (\tet{tex2mail}) converts its input
to readable two-dimensional text.

Independently of the setting of this default, an object can be printed
in any of the three formats at any time using the commands \b{a} and \b{m}
and \b{B} respectively.

The default value is \kbd{1} (\var{prettymatrix}).

\subsec{parisize}\kbdsidx{parisize}\label{se:def,parisize}
\kbd{gp}, and in fact any program using the PARI
library, needs a \tev{stack} in which to do its computations; \kbd{parisize}
is the stack size, in bytes. It is recommended to increase this
default using a \tet{gprc}, to the value you believe PARI should be happy
with, given your typical computation. We strongly recommend to also
set \tet{parisizemax} to a much larger value in your \kbd{gprc}, about what
you believe your machine can stand: PARI will then try to fit its
computations within about \kbd{parisize} bytes, but will increase the stack
size if needed (up to \kbd{parisizemax}). Once the memory intensive
computation is over, PARI will restore the stack size to the originally
requested \kbd{parisize}.

If \tet{parisizemax} is unset, this command has a very unintuitive behaviour
since it must abort pending operations, see \kbd{??allocatemem}.

The default value is 4M, resp.~8M on a 32-bit, resp.~64-bit machine.

\subsec{parisizemax}\kbdsidx{parisizemax}\label{se:def,parisizemax}
\kbd{gp}, and in fact any program using the PARI library, needs a
\tev{stack} in which to do its computations.  If nonzero,  \tet{parisizemax}
is the maximum size the stack can grow to, in bytes.  If zero, the stack will
not automatically grow, and will be limited to the value of \kbd{parisize}.

When \kbd{parisizemax} is set, PARI tries to fit its
computations within about \kbd{parisize} bytes, but will increase the stack
size if needed, roughly doubling it each time (up to \kbd{parisizemax}
of course!) and printing a message such as \kbd{Warning: increasing stack size to}
\var{some value}. Once the memory intensive computation is over, PARI
will restore the stack size to the originally requested \kbd{parisize}
without printing further messages.

We \emph{strongly} recommend to set \tet{parisizemax} permanently to a large
nonzero value in your \tet{gprc}, about what you believe your machine can
stand. It is possible to increase or decrease \kbd{parisizemax} inside a
running \kbd{gp} session, just use \kbd{default} as usual.

The default value is $0$, for backward compatibility reasons.

\subsec{path}\kbdsidx{path}\label{se:def,path}
This is a list of directories, separated by colons ':'
(semicolons ';' in the DOS world, since colons are preempted for drive names).
When asked to read a file whose name is not given by an absolute path
(does not start with \kbd{/}, \kbd{./} or \kbd{../}), \kbd{gp} will look for
it in these directories, in the order they were written in \kbd{path}. Here,
as usual, \kbd{.} means the current directory, and \kbd{..} its immediate
parent. Environment expansion is performed.

The default value is \kbd{".:\til:\til/gp"} on UNIX systems,
\kbd{".;C:\bs;C:\bs GP"} on DOS, OS/2 and Windows, and \kbd{"."} otherwise.

\subsec{plothsizes}\kbdsidx{plothsizes}\label{se:def,plothsizes}
If the graphic driver allows it, the array contains the size of the
terminal, the size of the font, the size of the ticks.

\subsec{prettyprinter}\kbdsidx{prettyprinter}\label{se:def,prettyprinter}
The name of an external prettyprinter to use when
\kbd{output} is~3 (alternate prettyprinter). Note that the default
\tet{tex2mail} looks much nicer than the built-in ``beautified
format'' ($\kbd{output} = 2$).

The default value is \kbd{"tex2mail -TeX -noindent -ragged -by\_par"}.

\subsec{primelimit}\kbdsidx{primelimit}\label{se:def,primelimit}
\kbd{gp} precomputes a list of
all primes less than \kbd{primelimit} at initialization time, and can build
fast sieves on demand to quickly iterate over primes up to the \emph{square}
of \kbd{primelimit}. These are used by many arithmetic functions, usually for
trial division purposes. The maximal value is $2^{32} - 2049$ (resp $2^{64} -
2049$) on a 32-bit (resp.~64-bit) machine, but values beyond $10^8$,
allowing to iterate over primes up to $10^{16}$, do not seem useful.

Since almost all arithmetic functions eventually require some table of prime
numbers, PARI guarantees that the first 6547 primes, up to and
including 65557, are precomputed, even if \kbd{primelimit} is $1$.

This default is only used on startup: changing it will not recompute a new
table.

\misctitle{Deprecated feature} \kbd{primelimit} was used in some
situations by algebraic number theory functions using the
\tet{nf_PARTIALFACT} flag (\tet{nfbasis}, \tet{nfdisc}, \tet{nfinit}, \dots):
this assumes that all primes $p > \kbd{primelimit}$ have a certain
property (the equation order is $p$-maximal). This is never done by default,
and must be explicitly set by the user of such functions. Nevertheless,
these functions now provide a more flexible interface, and their use
of the global default \kbd{primelimit} is deprecated.

\misctitle{Deprecated feature} \kbd{factor(N, 0)} was used to partially
factor integers by removing all prime factors $\leq$ \kbd{primelimit}.
Don't use this, supply an explicit bound: \kbd{factor(N, bound)},
which avoids relying on an unpredictable global variable.

The default value is \kbd{500k}.

\subsec{prompt}\kbdsidx{prompt}\label{se:def,prompt}
A string that will be printed as
prompt. Note that most usual escape sequences are available there: \b{e} for
Esc, \b{n} for Newline, \dots, \kbd{\bs\bs} for \kbd{\bs}. Time expansion is
performed.

This string is sent through the library function \tet{strftime} (on a
Unix system, you can try \kbd{man strftime} at your shell prompt). This means
that \kbd{\%} constructs have a special meaning, usually related to the time
and date. For instance, \kbd{\%H} = hour (24-hour clock) and \kbd{\%M} =
minute [00,59] (use \kbd{\%\%} to get a real \kbd{\%}).

If you use \kbd{readline}, escape sequences in your prompt will result in
display bugs. If you have a relatively recent \kbd{readline} (see the comment
at the end of \secref{se:def,colors}), you can brace them with special sequences
(\kbd{\bs[} and \kbd{\bs]}), and you will be safe. If these just result in
extra spaces in your prompt, then you'll have to get a more recent
\kbd{readline}. See the file \kbd{misc/gprc.dft} for an example.

\emacs {\bf Caution}: PariEmacs needs to know about the prompt pattern to
separate your input from previous \kbd{gp} results, without ambiguity. It is
not a trivial problem to adapt automatically this regular expression to an
arbitrary prompt (which can be self-modifying!). See PariEmacs's
documentation.

The default value is \kbd{"? "}.

\subsec{prompt\_cont}\kbdsidx{def,prompt_cont}\label{se:def,prompt_cont}
A string that will be printed
to prompt for continuation lines (e.g. in between braces, or after a
line-terminating backslash). Everything that applies to \kbd{prompt}
applies to \kbd{prompt\_cont} as well.

The default value is \kbd{""}.

\subsec{psfile}\kbdsidx{psfile}\label{se:def,psfile}
This default is obsolete, use one of plotexport, plothexport or
plothrawexport functions and write the result to file.

\subsec{readline}\kbdsidx{readline}\label{se:def,readline}
Switches readline line-editing
facilities on and off. This may be useful if you are running \kbd{gp} in a Sun
\tet{cmdtool}, which interacts badly with readline. Of course, until readline
is switched on again, advanced editing features like automatic completion
and editing history are not available.

The default value is \kbd{1}.

\subsec{realbitprecision}\kbdsidx{realbitprecision}\label{se:def,realbitprecision}
The number of significant bits used to convert exact inputs given to
transcendental functions (see \secref{se:trans}), or to create
absolute floating point constants (input as \kbd{1.0} or \kbd{Pi} for
instance). Unless you tamper with the \tet{format} default, this is also
the number of significant bits used to print a \typ{REAL} number;
\kbd{format} will override this latter behavior, and allow you to have a
large internal precision while outputting few digits for instance.

Note that most PARI's functions currently handle precision on a word basis (by
increments of 32 or 64 bits), hence bit precision may be a little larger
than the number of bits you expected. For instance to get 10 bits of
precision, you need one word of precision which, on a 64-bit machine,
correspond to 64 bits. To make things even more confusing, this internal bit
accuracy is converted to decimal digits when printing floating point numbers:
now 64 bits correspond to 19 printed decimal digits
($19 <  \log_{10}(2^{64}) < 20$).

The value returned when typing \kbd{default(realbitprecision)} is the internal
number of significant bits, not the number of printed decimal digits:
\bprog
? default(realbitprecision, 10)
? \pb
      realbitprecision = 64 significant bits
? default(realbitprecision)
%1 = 64
? \p
      realprecision = 3 significant digits
? default(realprecision)
%2 = 19
@eprog\noindent Note that \tet{realprecision} and \kbd{\bs p} allow
to view and manipulate the internal precision in decimal digits.

The default value is \kbd{128}, resp.~\kbd{96}, on a 64-bit, resp~.32-bit,
machine.

\subsec{realprecision}\kbdsidx{realprecision}\label{se:def,realprecision}
The number of significant digits used to convert exact inputs given to
transcendental functions (see \secref{se:trans}), or to create
absolute floating point constants (input as \kbd{1.0} or \kbd{Pi} for
instance). Unless you tamper with the \tet{format} default, this is also
the number of significant digits used to print a \typ{REAL} number;
\kbd{format} will override this latter behavior, and allow you to have a
large internal precision while outputting few digits for instance.

Note that PARI's internal precision works on a word basis (by increments of
32 or 64 bits), hence may be a little larger than the number of decimal
digits you expected. For instance to get 2 decimal digits you need one word
of precision which, on a 64-bit machine, actually gives you 19 digits ($19 <
\log_{10}(2^{64}) < 20$). The value returned when typing
\kbd{default(realprecision)} is the internal number of significant digits,
not the number of printed digits:
\bprog
? default(realprecision, 2)
      realprecision = 19 significant digits (2 digits displayed)
? default(realprecision)
%1 = 19
@eprog
The default value is \kbd{38}, resp.~\kbd{28}, on a 64-bit, resp.~32-bit,
machine.

\subsec{recover}\kbdsidx{recover}\label{se:def,recover}
This toggle is either 1 (on) or 0 (off). If you change this to $0$, any
error becomes fatal and causes the gp interpreter to exit immediately. Can be
useful in batch job scripts.

The default value is \kbd{1}.

\subsec{secure}\kbdsidx{secure}\label{se:def,secure}
This toggle is either 1 (on) or 0 (off). If on, the \tet{system} and
\tet{extern} command are disabled. These two commands are potentially
dangerous when you execute foreign scripts since they let \kbd{gp} execute
arbitrary UNIX commands. \kbd{gp} will ask for confirmation before letting
you (or a script) unset this toggle.

The default value is \kbd{0}.

\subsec{seriesprecision}\kbdsidx{seriesprecision}\label{se:def,seriesprecision}
Number of significant terms
when converting a polynomial or rational function to a power series
(see~\b{ps}).

The default value is \kbd{16}.

\subsec{simplify}\kbdsidx{simplify}\label{se:def,simplify}
This toggle is either 1 (on) or 0 (off). When the PARI library computes
something, the type of the
result is not always the simplest possible. The only type conversions which
the PARI library does automatically are rational numbers to integers (when
they are of type \typ{FRAC} and equal to integers), and similarly rational
functions to polynomials (when they are of type \typ{RFRAC} and equal to
polynomials). This feature is useful in many cases, and saves time, but can
be annoying at times. Hence you can disable this and, whenever you feel like
it, use the function \kbd{simplify} (see Chapter 3) which allows you to
simplify objects to the simplest possible types recursively (see~\b{y}).
\sidx{automatic simplification}

The default value is \kbd{1}.

\subsec{sopath}\kbdsidx{sopath}\label{se:def,sopath}
This is a list of directories, separated by colons ':'
(semicolons ';' in the DOS world, since colons are preempted for drive names).
When asked to \tet{install} an external symbol from a shared library whose
name is not given by an absolute path (does not start with \kbd{/}, \kbd{./}
or \kbd{../}), \kbd{gp} will look for it in these directories, in the order
they were written in \kbd{sopath}. Here, as usual, \kbd{.} means the current
directory, and \kbd{..} its immediate parent. Environment expansion is
performed.

The default value is \kbd{""}, corresponding to an empty list of
directories: \tet{install} will use the library name as input (and look in
the current directory if the name is not an absolute path).

\subsec{strictargs}\kbdsidx{strictargs}\label{se:def,strictargs}
This toggle is either 1 (on) or 0 (off). If on, all arguments to \emph{new}
user functions are mandatory unless the function supplies an explicit default
value.
Otherwise arguments have the default value $0$.

In this example,
\bprog
  fun(a,b=2)=a+b
@eprog
\kbd{a} is mandatory, while \kbd{b} is optional. If \kbd{strictargs} is on:
\bprog
? fun()
 ***   at top-level: fun()
 ***                 ^-----
 ***   in function fun: a,b=2
 ***                    ^-----
 ***   missing mandatory argument 'a' in user function.
@eprog
This applies to functions defined while \kbd{strictargs} is on. Changing \kbd{strictargs}
does not affect the behavior of previously defined functions.

The default value is \kbd{0}.

\subsec{strictmatch}\kbdsidx{strictmatch}\label{se:def,strictmatch}
Obsolete. This toggle is now a no-op.

\subsec{threadsize}\kbdsidx{threadsize}\label{se:def,threadsize}
This default is specific to the \emph{parallel} version of PARI and gp
(built via \kbd{Configure --mt=prthread} or \kbd{mpi}) and is ignored
otherwise. In parallel mode,
each thread allocates its own private \tev{stack} for its
computations, see \kbd{parisize}. This value determines the size in bytes of
the stacks of each thread, so the total memory allocated will be
$\kbd{parisize}+\kbd{nbthreads}\times\kbd{threadsize}$.

If set to $0$, the value used is the same as \kbd{parisize}. It is not
easy to estimate reliably a sufficient value for this parameter because PARI
itself will parallelize computations and we recommend to not set this value
explicitly unless it solves a specific problem for you. For instance if you
see frequent messages of the form
\bprog
 *** Warning: not enough memory, new thread stack 10000002048
@eprog (Meaning that \kbd{threadsize} had to be temporarily increased.)
On the other hand we strongly recommend to set \kbd{parisizemax} and
\kbd{threadsizemax} to a nonzero value.

The default value is $0$.

\subsec{threadsizemax}\kbdsidx{threadsizemax}\label{se:def,threadsizemax}
This default is specific to the \emph{parallel} version of PARI and gp
(built via \kbd{Configure --mt=pthread} or \kbd{mpi}) and is ignored
otherwise. In parallel mode,
each threads allocates its own private \tev{stack} for
its computations, see \kbd{parisize} and \kbd{parisizemax}. The
values of \kbd{threadsize} and \kbd{threadsizemax} determine the usual
and maximal size in bytes of the stacks of each thread, so the total memory
allocated will
be between $\kbd{parisize}+\kbd{nbthreads}\times\kbd{threadsize}$. and
$\kbd{parisizemax}+\kbd{nbthreads}\times\kbd{threadsizemax}$.

If set to $0$, the value used is the same as \kbd{threadsize}. We strongy
recommend to set both \kbd{parisizemax} and \kbd{threadsizemax} to a
nonzero value.

The default value is $0$.

\subsec{timer}\kbdsidx{timer}\label{se:def,timer}
This toggle is either 1 (on) or 0 (off). Every instruction sequence
in the gp calculator (anything ended by a newline in your input) is timed,
to some accuracy depending on the hardware and operating system. When
\tet{timer} is on, each such timing is printed immediately before the
output as follows:
\bprog
? factor(2^2^7+1)
time = 108 ms.     \\ this line omitted if 'timer' is 0
%1 =
[     59649589127497217 1]

[5704689200685129054721 1]
@eprog\noindent (See also \kbd{\#} and \kbd{\#\#}.)

The time measured is the user \idx{CPU time}, \emph{not} including the time
for printing the results. If the time is negligible ($< 1$ ms.), nothing is
printed: in particular, no timing should be printed when defining a user
function or an alias, or installing a symbol from the library.

The default value is \kbd{0} (off).

\section{Standard monadic or dyadic operators}

\subsec{Boolean operators}\sidx{Boolean operators}

Any nonzero value is interpreted as \var{true} and any zero as \var{false}
(this includes empty vectors or matrices). The standard boolean operators
\kbd{||} (\idx{inclusive or}), \kbd{\&\&} (\idx{and})\sidx{or} and \kbd{!}
in prefix notation (\idx{not}) are available.
Their value is $1$ (true) or $0$ (false):
\bprog
? a && b  \\ 1 iff a and b are nonzero
? a || b  \\ 1 iff a or b is nonzero
? !a      \\ 1 iff a is zero
@eprog

\subsec{Comparison}
The standard real \idx{comparison operators} \kbd{<=}, \kbd{<}, \kbd{>=},
\kbd{>}, are available in GP. The result is 1 if the comparison is true, 0
if it is false. These operators allow to compare integers (\typ{INT}),
rational (\typ{FRAC}) or real (\typ{REAL}) numbers,
real quadratic numbers (\typ{QUAD} of positive discriminant) and infinity
(\kbd{oo}, \typ{INFINITY}).

By extension, two character strings (\typ{STR}) are compared using
the standard lexicographic order. Comparing a string to an object of a
different type raises an exception. See also the \tet{cmp} universal
comparison function.

\subsec{Equality}
Two operators allow to test for equality: \kbd{==} (equality up to type
coercion) and \kbd{===} (identity). The result is $1$ if equality is decided,
else $0$.

The operator \kbd{===} is strict: objects of different type or length are
never identical, polynomials in different variables are never identical,
even if constant. On the contrary, \kbd{==} is very liberal: $a~\kbd{==}~b$
decides whether there is a natural map sending $a$ to the domain of $b$
or sending $b$ to the domain of $a$, such that the comparison makes sense
and equality holds. For instance
\bprog
? 4 == Mod(1,3) \\ equal
%1 = 1
? 4 === Mod(1,3) \\ but not identical
%2 = 0

? 'x == 'y   \\ not equal (nonconstant and different variables)
%3 = 0
? Pol(0,'x) == Pol(0,'y)  \\ equal (constant: ignore variable)
%4 = 1
? Pol(0,'x) === Pol(0,'y)  \\ not identical
%5 = 0

? 0 == Pol(0) \\ equal (not identical)
%6 = 1
? [0] == 0     \\ equal (not identical)
%7 = 1
? [0, 0] == 0  \\ equal (not identical)
%8 = 1
? [0] == [0,0] \\ not equal
%9 = 0
@eprog\noindent In particular \kbd{==} is not transitive in general; it is
transitive when used to compare objects known to have the same type. The
operator \kbd{===} is transitive. The \kbd{==} operator allows two
equivalent negated forms: \kbd{!=} or \kbd{<>}; there is no negated form for
\kbd{===}.

Do not mistake \kbd{=} for \kbd{==}: it is the assignment statement.

\subseckbd{+$/$-} The expressions \kbd{+}$x$ and \kbd{-}$x$ refer
to monadic operators: the first does nothing, the second negates $x$.

The library syntax is \fun{GEN}{gneg}{GEN x} for \kbd{-}$x$.

\subseckbd{+} The expression $x$ \kbd{+} $y$ is the \idx{sum} of $x$ and $y$.
Addition between a scalar type $x$ and a \typ{COL} or \typ{MAT} $y$ returns
respectively $[y[1] + x, y[2],\dots]$ and $y + x \text{Id}$. Other additions
between a scalar type and a vector or a matrix, or between vector/matrices of
incompatible sizes are forbidden.

The library syntax is \fun{GEN}{gadd}{GEN x, GEN y}.

\subseckbd{-} The expression $x$ \kbd{-} $y$ is the \idx{difference} of $x$
and $y$. Subtraction between a scalar type $x$ and a \typ{COL} or \typ{MAT}
$y$ returns respectively $[y[1] - x, y[2],\dots]$ and $y - x \text{Id}$.
Other subtractions between a scalar type and a vector or a matrix, or
between vector/matrices of incompatible sizes are forbidden.

The library syntax is \fun{GEN}{gsub}{GEN x, GEN y} for $x$ \kbd{-} $y$.

\subseckbd{*} The expression $x$ \kbd{*} $y$ is the \idx{product} of $x$
and $y$. Among the prominent impossibilities are multiplication between
vector/matrices of incompatible sizes, between a \typ{INTMOD} or \typ{PADIC}
Restricted to scalars, \kbd{*} is commutative; because of vector and matrix
operations, it is not commutative in general.

Multiplication between two \typ{VEC}s or two \typ{COL}s is not
allowed; to take the \idx{scalar product} of two vectors of the same length,
transpose one of the vectors (using the operator \kbd{\til} or the function
\kbd{mattranspose}, see \secref{se:linear_algebra}) and multiply a line vector
by a column vector:
\bprog
? a = [1,2,3];
? a * a
  ***   at top-level: a*a
  ***                  ^--
  *** _*_: forbidden multiplication t_VEC * t_VEC.
? a * a~
%2 = 14
@eprog

If $x,y$ are binary quadratic forms, compose them; see also
\kbd{qfbnucomp} and \kbd{qfbnupow}. If $x,y$ are \typ{VECSMALL} of the same
length, understand them as permutations and compose them.

The library syntax is \fun{GEN}{gmul}{GEN x, GEN y} for $x$ \kbd{*} $y$.
Also available is \fun{GEN}{gsqr}{GEN x} for $x$ \kbd{*} $x$.

\subseckbd{/} The expression $x$ \kbd{/} $y$ is the \idx{quotient} of $x$
and $y$. In addition to the impossibilities for multiplication, note that if
the divisor is a matrix, it must be an invertible square matrix, and in that
case the result is $x*y^{-1}$. Furthermore note that the result is as exact
as possible: in particular, division of two integers always gives a rational
number (which may be an integer if the quotient is exact) and \emph{not} the
Euclidean quotient (see $x$ \kbd{\bs} $y$ for that), and similarly the
quotient of two polynomials is a rational function in general. To obtain the
approximate real value of the quotient of two integers, add \kbd{0.} to the
result; to obtain the approximate $p$-adic value of the quotient of two
integers, add \kbd{O(p\pow k)} to the result; finally, to obtain the
\idx{Taylor series} expansion of the quotient of two polynomials, add
\kbd{O(X\pow k)} to the result or use the \kbd{taylor} function
(see \secref{se:taylor}). \label{se:gdiv}

The library syntax is \fun{GEN}{gdiv}{GEN x, GEN y} for $x$ \kbd{/} $y$.

\subseckbd{\bs} The expression \kbd{$x$ \bs\ $y$} is the
\idx{Euclidean quotient} of $x$ and $y$. If $y$ is a real scalar, this is
defined as \kbd{floor($x$/$y$)} if $y > 0$, and \kbd{ceil($x$/$y$)} if
$y < 0$ and the division is not exact. Hence the remainder
\kbd{$x$ - ($x$\bs$y$)*$y$} is in $[0, |y|[$.

Note that when $y$ is an integer and $x$ a polynomial, $y$ is first promoted
to a polynomial of degree $0$. When $x$ is a vector or matrix, the operator
is applied componentwise.

The library syntax is \fun{GEN}{gdivent}{GEN x, GEN y}
for $x$ \kbd{\bs} $y$.

\subseckbd{\bs/} The expression $x$ \b{/} $y$ evaluates to the rounded
\idx{Euclidean quotient} of $x$ and $y$. This is the same as \kbd{$x$ \bs\ $y$}
except for scalar division: the quotient is such that the corresponding
remainder is smallest in absolute value and in case of a tie the quotient
closest to $+\infty$ is chosen (hence the remainder would belong to
$[{-}|y|/2, |y|/2[$).

When $x$ is a vector or matrix, the operator is applied componentwise.

The library syntax is \fun{GEN}{gdivround}{GEN x, GEN y}
for $x$ \b{/} $y$.

\subseckbd{\%} The expression \kbd{$x$ \% $y$} evaluates to the modular
\idx{Euclidean remainder} of $x$ and $y$, which we now define. When $x$ or $y$
is a nonintegral real number, \kbd{$x$\%$y$} is defined as
\kbd{$x$ - ($x$\bs$y$)*$y$}. Otherwise, if $y$ is an integer, this is
the smallest
nonnegative integer congruent to $x$ modulo $y$. (This actually coincides
with the previous definition if and only if $x$ is an integer.) If $y$ is a
polynomial, this is the polynomial of smallest degree congruent to
$x$ modulo $y$. For instance:
\bprog
? (1/2) % 3
%1 = 2
? 0.5 % 3
%2 = 0.5000000000000000000000000000
? (1/2) % 3.0
%3 = 1/2
@eprog
Note that when $y$ is an integer and $x$ a polynomial, $y$ is first promoted
to a polynomial of degree $0$. When $x$ is a vector or matrix, the operator
is applied componentwise.

The library syntax is \fun{GEN}{gmod}{GEN x, GEN y}
for $x$ \kbd{\%} $y$.

\subseckbd{op=} When \kbd{op} is a binary arithmetic operator among
\kbd{+}, \kbd{-}, \kbd{\%}, \kbd{/}, \kbd{\bs} or \kbd{\bs/}, the construct
$x \var{op}= y$ is a shortcut for $x = x \var{op} y$.
\bprog
? v[1] += 10  \\ increment v[1] by 10
? a /= 2 \\ divide a by 2
@eprog

\subseckbd{++} \kbd{$x$++} is a shortcut for \kbd{$x$ = $x$ + 1}.

\subseckbd{--} \kbd{$x$--} is a shortcut for \kbd{$x$ = $x$ - 1}.

\subseckbd{\pow} The expression $x\hbox{\kbd{\pow}}n$ is \idx{powering}.

\item If the exponent $n$ is an integer, then exact operations are performed
using binary (left-shift) powering techniques. By definition, $x^0$ is
(an empty product interpreted as) an exact $1$ in the underlying prime
ring:
\bprog
? 0.0 ^ 0
%1 = 1
? (1 + O(2^3)) ^ 0
%2 = 1
? (1 + O(x)) ^ 0
%3 = 1
? Mod(2,4)^0
%4 = Mod(1,4)
? Mod(x,x^2)^0
%5 = Mod(1, x^2)
@eprog\noindent
If $x$ is a $p$-adic number, its precision will increase if $v_p(n) > 0$ and
$n \neq 0$. Powering a binary quadratic form (type \typ{QFB}) returns a
representative of the class, which is reduced if the input was.
(In particular, \kbd{x \pow 1} returns $x$ itself, whether it is reduced or
not.)

PARI rewrites the multiplication $x * x$ of two \emph{identical}
objects as $x^2$. Here, identical means the operands are reference the same
chunk of memory; no equality test is performed. This is no longer true when
more than two arguments are involved.
\bprog
? a = 1 + O(2); b = a;
? a * a  \\ = a^2, precision increases
%2 = 1 + O(2^3)
? a * b \\ not rewritten as a^2
%3 = 1 + O(2)
? a*a*a \\ not rewritten as a^3
%4 = 1 + O(2)
@eprog

\item If the exponent is a rational number $p/q$ the behaviour depends
on~$x$. If $x$ is a complex number, return $\exp(n \log x)$ (principal
branch), in an exact form if possible:
\bprog
? 4^(1/2)  \\ 4 being a square, this is exact
%1 = 2
? 2^(1/2)  \\ now inexact
%2 = 1.4142135623730950488016887242096980786
? (-1/4)^(1/2) \\ exact again
%3 = 1/2*I
? (-1)^(1/3)
%4 = 0.500...+ 0.866...*I
@eprog\noindent Note that even though $-1$ is an exact cube root of $-1$,
it is not $\exp(\log(-1)/3)$; the latter is returned.

Otherwise return a solution $y$ of $y^q = x^p$ if it exists; beware that
this is defined up to $q$-th roots of 1 in the base field. Intmods modulo
composite numbers are not supported.
\bprog
? Mod(7,19)^(1/2)
%1 = Mod(11, 19) \\ is any square root
? sqrt(Mod(7,19))
%2 = Mod(8, 19)  \\ is the smallest square root
? Mod(1,4)^(1/2)
 ***   at top-level: Mod(1,4)^(1/2)
 ***                         ^------
 *** _^_: not a prime number in gpow: 4.
@eprog

\item If the exponent is a negative integer or rational number,
an \idx{inverse} must be computed. For noninvertible \typ{INTMOD} $x$, this
will fail and (for $n$ an integer) implicitly exhibit a factor of the modulus:
\bprog
? Mod(4,6)^(-1)
  ***   at top-level: Mod(4,6)^(-1)
  ***                         ^-----
  *** _^_: impossible inverse modulo: Mod(2, 6).
@eprog\noindent
Here, a factor 2 is obtained directly. In general, take the gcd of the
representative and the modulus. This is most useful when performing
complicated operations modulo an integer $N$ whose factorization is
unknown. Either the computation succeeds and all is well, or a factor $d$
is discovered and the computation may be restarted modulo $d$ or $N/d$.

For noninvertible \typ{POLMOD} $x$, the behavior is the same:
\bprog
? Mod(x^2, x^3-x)^(-1)
  ***   at top-level: Mod(x^2,x^3-x)^(-1)
  ***                               ^-----
  *** _^_: impossible inverse in RgXQ_inv: Mod(x^2, x^3 - x).
@eprog\noindent Note that the underlying algorihm (subresultant) assumes
that the base ring is a domain:
\bprog
? a = Mod(3*y^3+1, 4); b = y^6+y^5+y^4+y^3+y^2+y+1; c = Mod(a,b);
? c^(-1)
  ***   at top-level: Mod(a,b)^(-1)
  ***                         ^-----
  *** _^_: impossible inverse modulo: Mod(2, 4).
@eprog\noindent
In fact $c$ is invertible, but $\Z/4\Z$ is not a domain and the algorithm
fails. It is possible for the algorithm to succeed in such situations
and any returned result will be correct, but chances are that an error
will occur first. In this specific case, one should work with $2$-adics.
In general, one can also try the following approach
\bprog
? inversemod(a, b) =
{ my(m, v = variable(b));
  m = polsylvestermatrix(polrecip(a), polrecip(b));
  m = matinverseimage(m, matid(#m)[,1]);
  Polrev(m[1..poldegree(b)], v);
}
? inversemod(a,b)
%2 = Mod(2,4)*y^5 + Mod(3,4)*y^3 + Mod(1,4)*y^2 + Mod(3,4)*y + Mod(2,4)
@eprog\noindent
This is not guaranteed to work either since \kbd{matinverseimage} must also
invert pivots. See \secref{se:linear_algebra}.

For a \typ{MAT} $x$, the matrix is expected to be square and invertible, except
in the special case \kbd{x\pow(-1)} which returns a left inverse if one exists
(rectangular $x$ with full column rank).
\bprog
? x = Mat([1;2])
%1 =
[1]

[2]

? x^(-1)
%2 =
[1 0]
@eprog

\item Finally, if the exponent $n$ is not an rational number, powering is
treated as the transcendental function $\exp(n\log x)$, although it will be
more precise than the latter when $n$ and $x$ are exact:
\bprog
? s = 1/2 + 10^14 * I
? localprec(200); z = 2^s  \\ for reference
? exponent(2^s - z)
%3 = -127  \\ perfect
? exponent(exp(s * log(2)) - z)
%4 = -84 \\ not so good
@eprog\noindent The second computation is less precise because $\log(2)$ is
first computed to $38$ decimal digits, then multiplied by $s$, which has a
huge imaginary part amplifying the error.

In this case, $x \mapsto x^n$ is treated as a transcendental function and
and in particular acts
componentwise on vector or matrices, even square matrices ! (See
\secref{se:trans}.) If $x$ is $0$ and $n$ is an inexact $0$, this will raise
an exception:
\bprog
? 4 ^ 1.0
%1 = 4.0000000000000000000000000000000000000
? 0^ 0.0
 ***   at top-level: 0^0.0
 ***                  ^----
 *** _^_: domain error in gpow(0,n): n <= 0
@eprog

The library syntax is \fun{GEN}{gpow}{GEN x, GEN n, long prec}
for $x\hbox{\kbd{\pow}}n$.

\subsec{cmp$(x,y)$}\kbdsidx{cmp}\label{se:cmp}
Gives the result of a comparison between arbitrary objects $x$ and $y$
(as $-1$, $0$ or $1$). The underlying order relation is transitive,
the function returns $0$ if and only if $x~\kbd{===}~y$. It has no
mathematical meaning but satisfies the following properties when comparing
entries of the same type:

\item two \typ{INT}s compare as usual (i.e. \kbd{cmp}$(x,y) < 0$ if and only
if $x < y$);

\item two \typ{VECSMALL}s of the same length compare lexicographically;

\item two \typ{STR}s compare lexicographically.

In case all components are equal up to the smallest length of the operands,
the more complex is considered to be larger. More precisely, the longest is
the largest; when lengths are equal, we have matrix $>$ vector $>$ scalar.
For example:
\bprog
? cmp(1, 2)
%1 = -1
? cmp(2, 1)
%2 = 1
? cmp(1, 1.0)   \\ note that 1 == 1.0, but (1===1.0) is false.
%3 = -1
? cmp(x + Pi, [])
%4 = -1
@eprog\noindent This function is mostly useful to handle sorted lists or
vectors of arbitrary objects. For instance, if $v$ is a vector, the
construction \kbd{vecsort(v, cmp)} is equivalent to \kbd{Set(v)}.

The library syntax is \fun{GEN}{cmp_universal}{GEN x, GEN y}.

\subsec{divrem$(x,y,\{v\})$}\kbdsidx{divrem}\label{se:divrem}
Creates a column vector with two components, the first being the Euclidean
quotient (\kbd{$x$ \bs\ $y$}), the second the Euclidean remainder
(\kbd{$x$ - ($x$\bs$y$)*$y$}), of the division of $x$ by $y$. This avoids the
need to do two divisions if one needs both the quotient and the remainder.
If $v$ is present, and $x$, $y$ are multivariate
polynomials, divide with respect to the variable $v$.

Beware that \kbd{divrem($x$,$y$)[2]} is in general not the same as
\kbd{$x$ \% $y$}; no GP operator corresponds to it:
\bprog
? divrem(1/2, 3)[2]
%1 = 1/2
? (1/2) % 3
%2 = 2
? divrem(Mod(2,9), 3)[2]
 ***   at top-level: divrem(Mod(2,9),3)[2
 ***                 ^--------------------
 ***   forbidden division t_INTMOD \ t_INT.
? Mod(2,9) % 6
%3 = Mod(2,3)
@eprog

The library syntax is \fun{GEN}{divrem}{GEN x, GEN y, long v = -1} where \kbd{v} is a variable number.
Also available is \fun{GEN}{gdiventres}{GEN x, GEN y} when $v$ is
not needed.

\subsec{lex$(x,y)$}\kbdsidx{lex}\label{se:lex}
Gives the result of a lexicographic comparison
between $x$ and $y$ (as $-1$, $0$ or $1$). This is to be interpreted in quite
a wide sense: it is admissible to compare objects of different types
(scalars, vectors, matrices), provided the scalars can be compared, as well
as vectors/matrices of different lengths; finally, when comparing two scalars,
a complex number $a + I*b$ is interpreted as a vector $[a,b]$ and a real
number $a$ as $[a,0]$. The comparison is recursive.

In case all components are equal up to the smallest length of the operands,
the more complex is considered to be larger. More precisely, the longest is
the largest; when lengths are equal, we have matrix $>$ vector $>$ scalar.
For example:
\bprog
? lex([1,3], [1,2,5])
%1 = 1
? lex([1,3], [1,3,-1])
%2 = -1
? lex([1], [[1]])
%3 = -1
? lex([1], [1]~)
%4 = 0
? lex(2 - I, 1)
%5 = 1
? lex(2 - I, 2)
%6 = 2
@eprog

The library syntax is \fun{GEN}{lexcmp}{GEN x, GEN y}.

\subsec{max$(x,y)$}\kbdsidx{max}\label{se:max}
Creates the maximum of $x$ and $y$ when they can be compared.

The library syntax is \fun{GEN}{gmax}{GEN x, GEN y}.

\subsec{min$(x,y)$}\kbdsidx{min}\label{se:min}
Creates the minimum of $x$ and $y$ when they can be compared.

The library syntax is \fun{GEN}{gmin}{GEN x, GEN y}.

\subsec{shift$(x,n)$}\kbdsidx{shift}\label{se:shift}
Shifts $x$ componentwise left by $n$ bits if $n\ge0$ and right by $|n|$
bits if $n<0$. May be abbreviated as $x$ \kbd{<<} $n$ or $x$ \kbd{>>} $(-n)$.
A left shift by $n$ corresponds to multiplication by $2^n$. A right shift of an
integer $x$ by $|n|$ corresponds to a Euclidean division of $x$ by $2^{|n|}$
with a remainder of the same sign as $x$, hence is not the same (in general) as
$x \kbd{\bs} 2^n$.

The library syntax is \fun{GEN}{gshift}{GEN x, long n}.

\subsec{shiftmul$(x,n)$}\kbdsidx{shiftmul}\label{se:shiftmul}
Multiplies $x$ by $2^n$. The difference with
\kbd{shift} is that when $n<0$, ordinary division takes place, hence for
example if $x$ is an integer the result may be a fraction, while for shifts
Euclidean division takes place when $n<0$ hence if $x$ is an integer the result
is still an integer.

The library syntax is \fun{GEN}{gmul2n}{GEN x, long n}.

\subsec{sign$(x)$}\kbdsidx{sign}\label{se:sign}
\idx{sign} ($0$, $1$ or $-1$) of $x$, which must be of
type integer, real or fraction; \typ{QUAD} with positive discriminants and
\typ{INFINITY} are also supported.

The library syntax is \fun{GEN}{gsigne}{GEN x}.

\subsec{vecmax$(x,\{\&v\})$}\kbdsidx{vecmax}\label{se:vecmax}
If $x$ is a vector or a matrix, returns the largest entry of $x$,
otherwise returns a copy of $x$. Error if $x$ is empty.

If $v$ is given, set it to the index of a largest entry (indirect maximum),
when $x$ is a vector. If $x$ is a matrix, set $v$ to coordinates $[i,j]$
such that $x[i,j]$ is a largest entry. This flag is ignored if $x$ is not a
vector or matrix.

\bprog
? vecmax([10, 20, -30, 40])
%1 = 40
? vecmax([10, 20, -30, 40], &v); v
%2 = 4
? vecmax([10, 20; -30, 40], &v); v
%3 = [2, 2]
@eprog

The library syntax is \fun{GEN}{vecmax0}{GEN x, GEN *v = NULL}.
When $v$ is not needed, the function \fun{GEN}{vecmax}{GEN x} is
also available.

\subsec{vecmin$(x,\{\&v\})$}\kbdsidx{vecmin}\label{se:vecmin}
If $x$ is a vector or a matrix, returns the smallest entry of $x$,
otherwise returns a copy of $x$. Error if $x$ is empty.

If $v$ is given, set it to the index of a smallest entry (indirect minimum),
when $x$ is a vector. If $x$ is a matrix, set $v$ to coordinates $[i,j]$ such
that $x[i,j]$ is a smallest entry. This is ignored if $x$ is not a vector or
matrix.

\bprog
? vecmin([10, 20, -30, 40])
%1 = -30
? vecmin([10, 20, -30, 40], &v); v
%2 = 3
? vecmin([10, 20; -30, 40], &v); v
%3 = [2, 1]
@eprog

The library syntax is \fun{GEN}{vecmin0}{GEN x, GEN *v = NULL}.
When $v$ is not needed, the function \fun{GEN}{vecmin}{GEN x} is also
available.

\section{Conversions and similar elementary functions or commands}
\label{se:conversion}

\noindent
Many of the conversion functions are rounding or truncating operations. In
this case, if the argument is a rational function, the result is the
Euclidean quotient of the numerator by the denominator, and if the argument
is a vector or a matrix, the operation is done componentwise. This will not
be restated for every function.

\subsec{Col$(x, \{n\})$}\kbdsidx{Col}\label{se:Col}
Transforms the object $x$ into a column vector. The dimension of the
resulting vector can be optionally specified via the extra parameter $n$.

If $n$ is omitted or $0$, the dimension depends on the type of $x$; the
vector has a single component, except when $x$ is

\item a vector or a quadratic form (in which case the resulting vector
is simply the initial object considered as a row vector),

\item a polynomial or a power series. In the case of a polynomial, the
coefficients of the vector start with the leading coefficient of the
polynomial, while for power series only the significant coefficients are
taken into account, but this time by increasing order of degree.
In this last case, \kbd{Vec} is the reciprocal function of \kbd{Pol} and
\kbd{Ser} respectively,

\item a matrix (the column of row vector comprising the matrix is returned),

\item a character string (a vector of individual characters is returned).

In the last two cases (matrix and character string), $n$ is meaningless and
must be omitted or an error is raised. Otherwise, if $n$ is given, $0$
entries are appended at the end of the vector if $n > 0$, and prepended at
the beginning if $n < 0$. The dimension of the resulting vector is $|n|$.

See ??Vec for examples.

The library syntax is \fun{GEN}{gtocol0}{GEN x, long n}.
\fun{GEN}{gtocol}{GEN x} is also available.

\subsec{Colrev$(x, \{n\})$}\kbdsidx{Colrev}\label{se:Colrev}
As $\kbd{Col}(x, -n)$, then reverse the result. In particular,
\kbd{Colrev} is the reciprocal function of \kbd{Polrev}: the
coefficients of the vector start with the constant coefficient of the
polynomial and the others follow by increasing degree.

The library syntax is \fun{GEN}{gtocolrev0}{GEN x, long n}.
\fun{GEN}{gtocolrev}{GEN x} is also available.

\subsec{List$(\{x=[\,]\})$}\kbdsidx{List}\label{se:List}
Transforms a (row or column) vector $x$ into a list, whose components are
the entries of $x$. Similarly for a list, but rather useless in this case.
For other types, creates a list with the single element $x$.

The library syntax is \fun{GEN}{gtolist}{GEN x = NULL}.
The variant \fun{GEN}{mklist}{void} creates an empty list.

\subsec{Map$(\{x\})$}\kbdsidx{Map}\label{se:Map}
A ``Map'' is an associative array, or dictionary: a data
type composed of a collection of (\emph{key}, \emph{value}) pairs, such that
each key appears just once in the collection. This function
converts the matrix $[a_1,b_1;a_2,b_2;\dots;a_n,b_n]$ to the map $a_i\mapsto
b_i$.
\bprog
? M = Map(factor(13!));
? mapget(M, 3)
%2 = 5
? P = Map(matreduce(primes([1,20])))
%3 = Map([2,1;3,1;5,1;7,1;11,1;13,1;17,1;19,1])
? select(i->mapisdefined(P,i), [1..20])
%4 = [2, 3, 5, 7, 11, 13, 17, 19]
@eprog\noindent If the argument $x$ is omitted, creates an empty map, which
may be filled later via \tet{mapput}.

The library syntax is \fun{GEN}{gtomap}{GEN x = NULL}.

\subsec{Mat$(\{x=[\,]\})$}\kbdsidx{Mat}\label{se:Mat}
Transforms the object $x$ into a matrix.
If $x$ is already a matrix, a copy of $x$ is created.
If $x$ is a row (resp. column) vector, this creates a 1-row (resp.
1-column) matrix, \emph{unless} all elements are column (resp.~row) vectors
of the same length, in which case the vectors are concatenated sideways
and the attached big matrix is returned.
If $x$ is a binary quadratic form, creates the attached $2\times 2$
matrix. Otherwise, this creates a $1\times 1$ matrix containing $x$.

\bprog
? Mat(x + 1)
%1 =
[x + 1]
? Vec( matid(3) )
%2 = [[1, 0, 0]~, [0, 1, 0]~, [0, 0, 1]~]
? Mat(%)
%3 =
[1 0 0]

[0 1 0]

[0 0 1]
? Col( [1,2; 3,4] )
%4 = [[1, 2], [3, 4]]~
? Mat(%)
%5 =
[1 2]

[3 4]
? Mat(Qfb(1,2,3))
%6 =
[1 1]

[1 3]
@eprog

The library syntax is \fun{GEN}{gtomat}{GEN x = NULL}.

\subsec{Mod$(a,b)$}\kbdsidx{Mod}\label{se:Mod}
In its basic form, create an intmod or a polmod $(a \mod b)$; $b$ must
be an integer or a polynomial. We then obtain a \typ{INTMOD} and a
\typ{POLMOD} respectively:
\bprog
? t = Mod(2,17); t^8
%1 = Mod(1, 17)
? t = Mod(x,x^2+1); t^2
%2 = Mod(-1, x^2+1)
@eprog\noindent If $a \% b$ makes sense and yields a result of the
appropriate type (\typ{INT} or scalar/\typ{POL}), the operation succeeds as
well:
\bprog
? Mod(1/2, 5)
%3 = Mod(3, 5)
? Mod(7 + O(3^6), 3)
%4 = Mod(1, 3)
? Mod(Mod(1,12), 9)
%5 = Mod(1, 3)
? Mod(1/x, x^2+1)
%6 = Mod(-x, x^2+1)
? Mod(exp(x), x^4)
%7 = Mod(1/6*x^3 + 1/2*x^2 + x + 1, x^4)
@eprog
If $a$ is a complex object, ``base change'' it to $\Z/b\Z$ or $K[x]/(b)$,
which is equivalent to, but faster than, multiplying it by \kbd{Mod(1,b)}:
\bprog
? Mod([1,2;3,4], 2)
%8 =
[Mod(1, 2) Mod(0, 2)]

[Mod(1, 2) Mod(0, 2)]
? Mod(3*x+5, 2)
%9 = Mod(1, 2)*x + Mod(1, 2)
? Mod(x^2 + y*x + y^3, y^2+1)
%10 = Mod(1, y^2 + 1)*x^2 + Mod(y, y^2 + 1)*x + Mod(-y, y^2 + 1)
@eprog

This function is not the same as $x$ \kbd{\%} $y$, the result of which
has no knowledge of the intended modulus $y$. Compare
\bprog
? x = 4 % 5; x + 1
%11 = 5
? x = Mod(4,5); x + 1
%12 = Mod(0,5)
@eprog Note that such ``modular'' objects can be lifted via \tet{lift} or
\tet{centerlift}. The modulus of a \typ{INTMOD} or \typ{POLMOD} $z$ can
be recovered via \kbd{$z$.mod}.

The library syntax is \fun{GEN}{gmodulo}{GEN a, GEN b}.

\subsec{Pol$(t,\{v='x\})$}\kbdsidx{Pol}\label{se:Pol}
Transforms the object $t$ into a polynomial with main variable $v$. If $t$
is a scalar, this gives a constant polynomial. If $t$ is a power series with
nonnegative valuation or a rational function, the effect is similar to
\kbd{truncate}, i.e.~we chop off the $O(X^k)$ or compute the Euclidean
quotient of the numerator by the denominator, then change the main variable
of the result to $v$.

The main use of this function is when $t$ is a vector: it creates the
polynomial whose coefficients are given by $t$, with $t[1]$ being the leading
coefficient (which can be zero). It is much faster to evaluate
\kbd{Pol} on a vector of coefficients in this way, than the corresponding
formal expression $a_n X^n + \dots + a_0$, which is evaluated naively exactly
as written (linear versus quadratic time in $n$). \tet{Polrev} can be used if
one wants $x[1]$ to be the constant coefficient:
\bprog
? Pol([1,2,3])
%1 = x^2 + 2*x + 3
? Polrev([1,2,3])
%2 = 3*x^2 + 2*x + 1
@eprog\noindent
The reciprocal function of \kbd{Pol} (resp.~\kbd{Polrev}) is \kbd{Vec} (resp.~
\kbd{Vecrev}).
\bprog
? Vec(Pol([1,2,3]))
%1 = [1, 2, 3]
? Vecrev( Polrev([1,2,3]) )
%2 = [1, 2, 3]
@eprog\noindent

\misctitle{Warning} This is \emph{not} a substitution function. It will not
transform an object containing variables of higher priority than~$v$.
\bprog
? Pol(x + y, y)
  ***   at top-level: Pol(x+y,y)
  ***                 ^----------
  *** Pol: variable must have higher priority in gtopoly.
@eprog

The library syntax is \fun{GEN}{gtopoly}{GEN t, long v = -1} where \kbd{v} is a variable number.

\subsec{Polrev$(t,\{v='x\})$}\kbdsidx{Polrev}\label{se:Polrev}
Transform the object $t$ into a polynomial
with main variable $v$. If $t$ is a scalar, this gives a constant polynomial.
If $t$ is a power series, the effect is identical to \kbd{truncate}, i.e.~it
chops off the $O(X^k)$.

The main use of this function is when $t$ is a vector: it creates the
polynomial whose coefficients are given by $t$, with $t[1]$ being the
constant term. \tet{Pol} can be used if one wants $t[1]$ to be the leading
coefficient:
\bprog
? Polrev([1,2,3])
%1 = 3*x^2 + 2*x + 1
? Pol([1,2,3])
%2 = x^2 + 2*x + 3
@eprog
The reciprocal function of \kbd{Pol} (resp.~\kbd{Polrev}) is \kbd{Vec} (resp.~
\kbd{Vecrev}).

The library syntax is \fun{GEN}{gtopolyrev}{GEN t, long v = -1} where \kbd{v} is a variable number.

\subsec{Qfb$(a,\{b\},\{c\})$}\kbdsidx{Qfb}\label{se:Qfb}
Creates the binary quadratic form\sidx{binary quadratic form}
$ax^2+bxy+cy^2$. Negative definite forms are not implemented,
use their positive definite counterpart instead.
The syntax Qfb([a,b,c]) is also accepted.

The library syntax is \fun{GEN}{Qfb0}{GEN a, GEN b = NULL, GEN c = NULL}.

\subsec{Ser$(s,\{v='x\},\{d=\var{seriesprecision}\})$}\kbdsidx{Ser}\label{se:Ser}
Transforms the object $s$ into a power series with main variable $v$
($x$ by default) and precision (number of significant terms) equal to
$d \geq 0$ ($d = \kbd{seriesprecision}$ by default). If $s$ is a
scalar, this gives a constant power series in $v$ with precision \kbd{d}.
If $s$ is a polynomial, the polynomial is truncated to $d$ terms if needed
\bprog
? \ps
  seriesprecision = 16 significant terms
? Ser(1)  \\ 16 terms by default
%1 = 1 + O(x^16)
? Ser(1, 'y, 5)
%2 = 1 + O(y^5)
? Ser(x^2,, 5)
%3 = x^2 + O(x^7)
? T = polcyclo(100)
%4 = x^40 - x^30 + x^20 - x^10 + 1
? Ser(T, 'x, 11)
%5 = 1 - x^10 + O(x^11)
@eprog\noindent The function is more or less equivalent with multiplication by
$1 + O(v^d)$ in theses cases, only faster.

For the remaining types, vectors and power series, we first explain what
occurs if $d$ is omitted. In this case, the function uses exactly the amount
of information given in the input:

\item If $s$ is already a power series in $v$, we return it verbatim;

\item If $s$ is a vector, the coefficients of the vector are
understood to be the coefficients of the power series starting from the
constant term (as in \tet{Polrev}$(x)$); in other words we convert
\typ{VEC} / \typ{COL} to the power series whose significant terms are exactly
given by the vector entries.

On the other hand, if $d$ is explicitly given, we abide by its value
and return a series, truncated or extended with zeros as needed, with
$d$ significant terms.

\bprog
? v = [1,2,3];
? Ser(v, t) \\ 3 terms: seriesprecision is ignored!
%7 = 1 + 2*t + 3*t^2 + O(t^3)
? Ser(v, t, 7)  \\ 7 terms as explicitly requested
%8 = 1 + 2*t + 3*t^2 + O(t^7)
? s = 1+x+O(x^2);
? Ser(s)
%10 = 1 + x + O(x^2)  \\ 2 terms: seriesprecision is ignored
? Ser(s, x, 7)  \\ extend to 7 terms
%11 = 1 + x + O(x^7)
? Ser(s, x, 1)  \\ truncate to 1 term
%12 = 1 + O(x)
@eprog\noindent
The warning given for \kbd{Pol} also applies here: this is not a substitution
function.

The library syntax is \fun{GEN}{Ser0}{GEN s, long v = -1, GEN d = NULL, long precdl} where \kbd{v} is a variable number.

\subsec{Set$(\{x=[\,]\})$}\kbdsidx{Set}\label{se:Set}
Converts $x$ into a set, i.e.~into a row vector, with strictly increasing
entries with respect to the (somewhat arbitrary) universal comparison function
\tet{cmp}. Standard container types \typ{VEC}, \typ{COL}, \typ{LIST} and
\typ{VECSMALL} are converted to the set with corresponding elements. All
others are converted to a set with one element.
\bprog
? Set([1,2,4,2,1,3])
%1 = [1, 2, 3, 4]
? Set(x)
%2 = [x]
? Set(Vecsmall([1,3,2,1,3]))
%3 = [1, 2, 3]
@eprog

The library syntax is \fun{GEN}{gtoset}{GEN x = NULL}.

\subsec{Str$(\{x\}*)$}\kbdsidx{Str}\label{se:Str}
Converts its argument list into a
single character string (type \typ{STR}, the empty string if $x$ is omitted).
To recover an ordinary \kbd{GEN} from a string, apply \kbd{eval} to it. The
arguments of \kbd{Str} are evaluated in string context, see \secref{se:strings}.

\bprog
? x2 = 0; i = 2; Str(x, i)
%1 = "x2"
? eval(%)
%2 = 0
@eprog\noindent
This function is mostly useless in library mode. Use the pair
\tet{strtoGEN}/\tet{GENtostr} to convert between \kbd{GEN} and \kbd{char*}.
The latter returns a malloced string, which should be freed after usage.
%\syn{NO}

\subsec{Vec$(x, \{n\})$}\kbdsidx{Vec}\label{se:Vec}
Transforms the object $x$ into a row vector. The dimension of the
resulting vector can be optionally specified via the extra parameter $n$.
If $n$ is omitted or $0$, the dimension depends on the type of $x$; the
vector has a single component, except when $x$ is

\item a vector or a quadratic form: returns the initial object considered as a
row vector,

\item a polynomial or a power series: returns a vector consisting of the
coefficients. In the case of a polynomial, the coefficients of the vector
start with the leading coefficient of the polynomial, while for power series
only the significant coefficients are taken into account, but this time by
increasing order of degree. In particular the valuation is ignored
(which makes the function useful for series of negative valuation):
\bprog
? Vec(3*x^2 + x)
%1 = [3, 1, 0]
? Vec(x^2 + 3*x^3 + O(x^5))
%2 = [1, 3, 0]
? Vec(x^-2 + 3*x^-1 + O(x))
%3 = [1, 3, 0]
@eprog\noindent \kbd{Vec} is the reciprocal function of \kbd{Pol} for a
polynomial and of \kbd{Ser} for power series of valuation $0$.

\item a matrix: returns the vector of columns comprising the matrix,
\bprog
? m = [1,2,3;4,5,6]
%4 =
[1 2 3]

[4 5 6]
? Vec(m)
%5 = [[1, 4]~, [2, 5]~, [3, 6]~]
@eprog

\item a character string: returns the vector of individual characters,
\bprog
? Vec("PARI")
%6 = ["P", "A", "R", "I"]
@eprog

\item a map: returns the vector of the domain of the map,

\item an error context (\typ{ERROR}): returns the error components, see
\tet{iferr}.

In the last four cases (matrix, character string, map, error), $n$ is
meaningless and must be omitted or an error is raised. Otherwise, if $n$ is
given, $0$ entries are appended at the end of the vector if $n > 0$, and
prepended at the beginning if $n < 0$. The dimension of the resulting vector
is $|n|$. This allows to write a conversion function for series that
takes positive valuations into account:
\bprog
? serVec(s) = Vec(s, -serprec(s,variable(s)));
? Vec(x^2 + 3*x^3 + O(x^5))
%2 = [0, 0, 1, 3, 0]
@eprog (That function is not intended for series of negative valuation.)

The library syntax is \fun{GEN}{gtovec0}{GEN x, long n}.
\fun{GEN}{gtovec}{GEN x} is also available.

\subsec{Vecrev$(x, \{n\})$}\kbdsidx{Vecrev}\label{se:Vecrev}
As $\kbd{Vec}(x, -n)$, then reverse the result. In particular,
\kbd{Vecrev} is the reciprocal function of \kbd{Polrev}: the
coefficients of the vector start with the constant coefficient of the
polynomial and the others follow by increasing degree.

The library syntax is \fun{GEN}{gtovecrev0}{GEN x, long n}.
\fun{GEN}{gtovecrev}{GEN x} is also available.

\subsec{Vecsmall$(x, \{n\})$}\kbdsidx{Vecsmall}\label{se:Vecsmall}
Transforms the object $x$ into a row vector of type \typ{VECSMALL}. The
dimension of the resulting vector can be optionally specified via the extra
parameter $n$.

This acts as \kbd{Vec}$(x,n)$, but only on a limited set of objects:
the result must be representable as a vector of small integers.
If $x$ is a character string, a vector of individual characters in ASCII
encoding is returned (\tet{strchr} yields back the character string).

The library syntax is \fun{GEN}{gtovecsmall0}{GEN x, long n}.
\fun{GEN}{gtovecsmall}{GEN x} is also available.

\subsec{binary$(x)$}\kbdsidx{binary}\label{se:binary}
Outputs the vector of the binary digits of $|x|$. Here $x$ can be an
integer, a real number (in which case the result has two components, one for
the integer part, one for the fractional part) or a vector/matrix.
\bprog
? binary(10)
%1 = [1, 0, 1, 0]

? binary(3.14)
%2 = [[1, 1], [0, 0, 1, 0, 0, 0, [...]]

? binary([1,2])
%3 = [[1], [1, 0]]
@eprog\noindent For integer $x\ge1$, the number of bits is
$\kbd{logint}(x,2) + 1$. By convention, $0$ has no digits:
\bprog
? binary(0)
%4 = []
@eprog

The library syntax is \fun{GEN}{binaire}{GEN x}.

\subsec{bitand$(x,y)$}\kbdsidx{bitand}\label{se:bitand}
Bitwise \tet{and}
\sidx{bitwise and}of two integers $x$ and $y$, that is the integer
$$\sum_i (x_i~\kbd{and}~y_i) 2^i$$

Negative numbers behave $2$-adically, i.e.~the result is the $2$-adic limit
of \kbd{bitand}$(x_n,y_n)$, where $x_n$ and $y_n$ are nonnegative integers
tending to $x$ and $y$ respectively. (The result is an ordinary integer,
possibly negative.)

\bprog
? bitand(5, 3)
%1 = 1
? bitand(-5, 3)
%2 = 3
? bitand(-5, -3)
%3 = -7
@eprog

The library syntax is \fun{GEN}{gbitand}{GEN x, GEN y}.
Also available is
\fun{GEN}{ibitand}{GEN x, GEN y}, which returns the bitwise \emph{and}
of $|x|$ and $|y|$, two integers.

\subsec{bitneg$(x,\{n=-1\})$}\kbdsidx{bitneg}\label{se:bitneg}
\idx{bitwise negation} of an integer $x$,
truncated to $n$ bits, $n\geq 0$, that is the integer
$$\sum_{i=0}^{n-1} \kbd{not}(x_i) 2^i.$$
The special case $n=-1$ means no truncation: an infinite sequence of
leading $1$ is then represented as a negative number.

See \secref{se:bitand} for the behavior for negative arguments.

The library syntax is \fun{GEN}{gbitneg}{GEN x, long n}.

\subsec{bitnegimply$(x,y)$}\kbdsidx{bitnegimply}\label{se:bitnegimply}
Bitwise negated imply of two integers $x$ and
$y$ (or \kbd{not} $(x \Rightarrow y)$), that is the integer $$\sum
(x_i~\kbd{and not}(y_i)) 2^i$$

See \secref{se:bitand} for the behavior for negative arguments.

The library syntax is \fun{GEN}{gbitnegimply}{GEN x, GEN y}.
Also available is
\fun{GEN}{ibitnegimply}{GEN x, GEN y}, which returns the bitwise negated
imply of $|x|$ and $|y|$, two integers.

\subsec{bitor$(x,y)$}\kbdsidx{bitor}\label{se:bitor}
\sidx{bitwise inclusive or}bitwise (inclusive)
\tet{or} of two integers $x$ and $y$, that is the integer $$\sum
(x_i~\kbd{or}~y_i) 2^i$$

See \secref{se:bitand} for the behavior for negative arguments.

The library syntax is \fun{GEN}{gbitor}{GEN x, GEN y}.
Also available is
\fun{GEN}{ibitor}{GEN x, GEN y}, which returns the bitwise \emph{or}
of $|x|$ and $|y|$, two integers.

\subsec{bitprecision$(x,\{n\})$}\kbdsidx{bitprecision}\label{se:bitprecision}
The function behaves differently according to whether $n$ is
present or not. If $n$ is missing, the function returns
the (floating point) precision in bits of the PARI object $x$.

If $x$ is an exact object, the function returns \kbd{+oo}.
\bprog
? bitprecision(exp(1e-100))
%1 = 512                 \\ 512 bits
? bitprecision( [ exp(1e-100), 0.5 ] )
%2 = 128                 \\ minimal accuracy among components
? bitprecision(2 + x)
%3 = +oo                  \\ exact object
@eprog\noindent Use \kbd{getlocalbitprec()} to retrieve the
working bit precision (as modified by possible \kbd{localbitprec}
statements).

If $n$ is present and positive, the function creates a new object equal to $x$
with the new bit-precision roughly $n$. In fact, the smallest multiple of 64
(resp.~32 on a 32-bit machine) larger than or equal to $n$.

For $x$ a vector or a matrix, the operation is
done componentwise; for series and polynomials, the operation is done
coefficientwise. For real $x$, $n$ is the number of desired significant
\emph{bits}. If $n$ is smaller than the precision of $x$, $x$ is truncated,
otherwise $x$ is extended with zeros. For exact or non-floating-point types,
no change.
\bprog
? bitprecision(Pi, 10)    \\ actually 64 bits ~ 19 decimal digits
%1 = 3.141592653589793239
? bitprecision(1, 10)
%2 = 1
? bitprecision(1 + O(x), 10)
%3 = 1 + O(x)
? bitprecision(2 + O(3^5), 10)
%4 = 2 + O(3^5)
@eprog\noindent

The library syntax is \fun{GEN}{bitprecision00}{GEN x, GEN n = NULL}.

\subsec{bittest$(x,n)$}\kbdsidx{bittest}\label{se:bittest}
Outputs the $n^{\text{th}}$ bit of $x$ starting
from the right (i.e.~the coefficient of $2^n$ in the binary expansion of $x$).
The result is 0 or 1. For $x\ge1$, the highest 1-bit is at $n =
\kbd{logint}(x)$ (and bigger $n$ gives $0$).
\bprog
? bittest(7, 0)
%1 = 1 \\ the bit 0 is 1
? bittest(7, 2)
%2 = 1 \\ the bit 2 is 1
? bittest(7, 3)
%3 = 0 \\ the bit 3 is 0
@eprog\noindent
See \secref{se:bitand} for the behavior at negative arguments.

The library syntax is \fun{GEN}{gbittest}{GEN x, long n}.
For a \typ{INT} $x$, the variant \fun{long}{bittest}{GEN x, long n} is
generally easier to use, and if furthermore $n\ge 0$ the low-level function
\fun{ulong}{int_bit}{GEN x, long n} returns \kbd{bittest(abs(x),n)}.

\subsec{bitxor$(x,y)$}\kbdsidx{bitxor}\label{se:bitxor}
Bitwise (exclusive) \tet{or}
\sidx{bitwise exclusive or}of two integers $x$ and $y$, that is the integer
$$\sum (x_i~\kbd{xor}~y_i) 2^i$$

See \secref{se:bitand} for the behavior for negative arguments.

The library syntax is \fun{GEN}{gbitxor}{GEN x, GEN y}.
Also available is
\fun{GEN}{ibitxor}{GEN x, GEN y}, which returns the bitwise \emph{xor}
of $|x|$ and $|y|$, two integers.

\subsec{ceil$(x)$}\kbdsidx{ceil}\label{se:ceil}
Ceiling of $x$. When $x$ is in $\R$, the result is the
smallest integer greater than or equal to $x$. Applied to a rational
function, $\kbd{ceil}(x)$ returns the Euclidean quotient of the numerator by
the denominator.

The library syntax is \fun{GEN}{gceil}{GEN x}.

\subsec{centerlift$(x,\{v\})$}\kbdsidx{centerlift}\label{se:centerlift}
Same as \tet{lift}, except that \typ{INTMOD} and \typ{PADIC} components
are lifted using centered residues:

\item for a \typ{INTMOD} $x\in \Z/n\Z$, the lift $y$ is such that
$-n/2<y\le n/2$.

\item  a \typ{PADIC} $x$ is lifted in the same way as above (modulo
$p^\kbd{padicprec(x)}$) if its valuation $v$ is nonnegative; if not, returns
the fraction $p^v$ \kbd{centerlift}$(x p^{-v})$; in particular, rational
reconstruction is not attempted. Use \tet{bestappr} for this.

For backward compatibility, \kbd{centerlift(x,'v)} is allowed as an alias
for \kbd{lift(x,'v)}.

\synt{centerlift}{GEN x}.

\subsec{characteristic$(x)$}\kbdsidx{characteristic}\label{se:characteristic}
Returns the characteristic of the base ring over which $x$ is defined (as
defined by \typ{INTMOD} and \typ{FFELT} components). The function raises an
exception if incompatible primes arise from \typ{FFELT} and \typ{PADIC}
components.
\bprog
? characteristic(Mod(1,24)*x + Mod(1,18)*y)
%1 = 6
@eprog

The library syntax is \fun{GEN}{characteristic}{GEN x}.

\subsec{component$(x,n)$}\kbdsidx{component}\label{se:component}
Extracts the $n^{\text{th}}$-component of $x$. This is to be understood
as follows: every PARI type has one or two initial \idx{code words}. The
components are counted, starting at 1, after these code words. In particular
if $x$ is a vector, this is indeed the $n^{\text{th}}$-component of $x$, if
$x$ is a matrix, the $n^{\text{th}}$ column, if $x$ is a polynomial, the
$n^{\text{th}}$ coefficient (i.e.~of degree $n-1$), and for power series,
the $n^{\text{th}}$ significant coefficient.

For polynomials and power series, one should rather use \tet{polcoef}, and
for vectors and matrices, the \kbd{[$\,$]} operator. Namely, if $x$ is a
vector, then \tet{x[n]} represents the $n^{\text{th}}$ component of $x$. If
$x$ is a matrix, \tet{x[m,n]} represents the coefficient of row \kbd{m} and
column \kbd{n} of the matrix, \tet{x[m,]} represents the $m^{\text{th}}$
\emph{row} of $x$, and \tet{x[,n]} represents the $n^{\text{th}}$
\emph{column} of $x$.

Using of this function requires detailed knowledge of the structure of the
different PARI types, and thus it should almost never be used directly.
Some useful exceptions:
\bprog
    ? x = 3 + O(3^5);
    ? component(x, 2)
    %2 = 81   \\ p^(p-adic accuracy)
    ? component(x, 1)
    %3 = 3    \\ p
    ? q = Qfb(1,2,3);
    ? component(q, 1)
    %5 = 1
@eprog

The library syntax is \fun{GEN}{compo}{GEN x, long n}.

\subsec{conj$(x)$}\kbdsidx{conj}\label{se:conj}
Conjugate of $x$. The meaning of this
is clear, except that for real quadratic numbers, it means conjugation in the
real quadratic field. This function has no effect on integers, reals,
intmods, fractions or $p$-adics. The only forbidden type is polmod
(see \kbd{conjvec} for this).

The library syntax is \fun{GEN}{gconj}{GEN x}.

\subsec{conjvec$(z)$}\kbdsidx{conjvec}\label{se:conjvec}
Conjugate vector representation of $z$. If $z$ is a
polmod, equal to \kbd{Mod}$(a,T)$, this gives a vector of length
$\text{degree}(T)$ containing:

\item the complex embeddings of $z$ if $T$ has rational coefficients,
i.e.~the $a(r[i])$ where $r = \kbd{polroots}(T)$;

\item the conjugates of $z$ if $T$ has some intmod coefficients;

\noindent if $z$ is a finite field element, the result is the vector of
conjugates $[z,z^p,z^{p^2},\ldots,z^{p^{n-1}}]$ where $n=\text{degree}(T)$.

\noindent If $z$ is an integer or a rational number, the result is~$z$. If
$z$ is a (row or column) vector, the result is a matrix whose columns are
the conjugate vectors of the individual elements of $z$.

The library syntax is \fun{GEN}{conjvec}{GEN z, long prec}.

\subsec{denominator$(f,\{D\})$}\kbdsidx{denominator}\label{se:denominator}
Denominator of $f$. The meaning of this is clear when $f$ is a rational number
or function. If $f$ is an integer or a polynomial, it is treated as a rational
number or function, respectively, and the result is equal to $1$. For
polynomials, you probably want to use
\bprog
denominator( content(f) )
@eprog\noindent instead. As for modular objects, \typ{INTMOD} and \typ{PADIC}
have denominator $1$, and the denominator of a \typ{POLMOD} is the
denominator of its lift.

If $f$ is a recursive structure, for instance a vector or matrix, the lcm
of the denominators of its components (a common denominator) is computed.
This also applies for \typ{COMPLEX}s and \typ{QUAD}s.

\misctitle{Warning} Multivariate objects are created according to variable
priorities, with possibly surprising side effects ($x/y$ is a polynomial, but
$y/x$ is a rational function). See \secref{se:priority}.

The optional argument $D$ allows to control over which ring we compute the
denominator and get a more predictable behaviour:

\item $1$: we only consider the underlying $\Q$-structure and the
denominator is a (positive) rational integer

\item a simple variable, say \kbd{'x}: all entries as rational functions
in $K(x)$ and the denominator is a polynomial in $x$.

\bprog
? f = x + 1/y + 1/2;
? denominator(f) \\ a t_POL in x
%2 = 1
? denominator(f, 1) \\ Q-denominator
%3 = 2
? denominator(f, x) \\ as a t_POL in x, seen above
%4 = 1
? denominator(f, y) \\ as a rational function in y
%5 = 2*y
@eprog

The library syntax is \fun{GEN}{denominator}{GEN f, GEN D = NULL}.
Also available are
\fun{GEN}{denom}{GEN x}  which implements the not very useful default
behaviour ($D$ is \kbd{NULL}) and \fun{GEN}{Q_denom}{GEN x} ($D = 1$).

\subsec{digits$(x,\{b\})$}\kbdsidx{digits}\label{se:digits}
Outputs the vector of the digits of $|x|$ in base $b$, where $x$ and $b$ are
integers ($b = 10$ by default), from most significant down to least
significant. For $x\ge1$, the number of digits is
$\kbd{logint}(x,b) + 1$. See \kbd{fromdigits} for the reverse operation.

We also allow $x$ an integral $p$-adic in which case $b$ should be omitted
or equal to $p$. Digits are still ordered from most significant to least
significant in the $p$-adic sense (meaning we start from $x$ mod $p$);
trailing zeros are truncated.
\bprog
? digits(1230)
%1 = [1, 2, 3, 0]

? digits(10, 2) \\ base 2
%2 = [1, 0, 1, 0]
@eprog\noindent By convention, $0$ has no digits:
\bprog
? digits(0)
%3 = []
? 1105 + O(5^5)
%4 = 5 + 4*5^2 + 3*5^3 + O(5^5)
? digits(%)
%5 = [0, 1, 4, 3]
@eprog

The library syntax is \fun{GEN}{digits}{GEN x, GEN b = NULL}.

\subsec{exponent$(x)$}\kbdsidx{exponent}\label{se:exponent}
When $x$ is a \typ{REAL}, the result is the binary exponent $e$ of $x$.
For a nonzero $x$, this is the unique integer $e$ such that
$2^e \leq |x| < 2^{e+1}$. For a real $0$, this returns the PARI exponent $e$
attached to $x$ (which may represent any floating-point number less than
$2^e$ in absolute value).
\bprog
? exponent(Pi)
%1 = 1
? exponent(4.0)
%2 = 2
? exponent(0.0)
%3 = -128
? default(realbitprecision)
%4 = 128
@eprog\noindent This definition extends naturally to nonzero integers,
and the exponent of an exact $0$ is $-\kbd{oo}$ by convention.

For convenience, we \emph{define} the exponent of a \typ{FRAC} $a/b$ as
the difference of \kbd{exponent}$(a)$ and \kbd{exponent}$(b)$; note that,
if $e'$ denotes the exponent of \kbd{$a/b$ * 1.0}, then the exponent $e$
we return is either $e'$ or $e'+1$, thus $2^{e+1}$ is an upper bound for
$|a/b|$.
\bprog
? [ exponent(9), exponent(10), exponent(9/10), exponent(9/10*1.) ]
%5 = [3, 3, 0, -1]
@eprog

For a PARI object of type \typ{COMPLEX}, \typ{POL}, \typ{SER}, \typ{VEC},
\typ{COL}, \typ{MAT} this returns the largest exponent found among the
components of $x$. Hence $2^{e+1}$ is a quick upper bound for the sup norm
of real matrices or polynomials; and $2^{e+(3/2)}$ for complex ones.

\bprog
? exponent(3*x^2 + 15*x - 100)
%5 = 6
? exponent(0)
%6 = -oo
@eprog

The library syntax is \fun{GEN}{gpexponent}{GEN x}.

\subsec{floor$(x)$}\kbdsidx{floor}\label{se:floor}
Floor of $x$. When $x$ is in $\R$, the result is the
largest integer smaller than or equal to $x$. Applied to a rational function,
$\kbd{floor}(x)$ returns the Euclidean quotient of the numerator by the
denominator.

The library syntax is \fun{GEN}{gfloor}{GEN x}.

\subsec{frac$(x)$}\kbdsidx{frac}\label{se:frac}
Fractional part of $x$. Identical to
$x-\text{floor}(x)$. If $x$ is real, the result is in $[0,1[$.

The library syntax is \fun{GEN}{gfrac}{GEN x}.

\subsec{fromdigits$(x,\{b=10\})$}\kbdsidx{fromdigits}\label{se:fromdigits}
Gives the integer formed by the elements of $x$ seen as the digits of a
number in base $b$ ($b = 10$ by default).  This is the reverse of \kbd{digits}:
\bprog
? digits(1234,5)
%1 = [1,4,4,1,4]
? fromdigits([1,4,4,1,4],5)
%2 = 1234
@eprog\noindent By convention, $0$ has no digits:
\bprog
? fromdigits([])
%3 = 0
@eprog

The library syntax is \fun{GEN}{fromdigits}{GEN x, GEN b = NULL}.

\subsec{imag$(x)$}\kbdsidx{imag}\label{se:imag}
Imaginary part of $x$. When $x$ is a quadratic number, this is the
coefficient of $\omega$ in the ``canonical'' integral basis $(1,\omega)$.
\bprog
? imag(3 + I)
%1 = 1
? x = 3 + quadgen(-23);
? imag(x) \\ as a quadratic number
%3 = 1
? imag(x * 1.) \\ as a complex number
%4 = 2.3979157616563597707987190320813469600
@eprog

The library syntax is \fun{GEN}{gimag}{GEN x}.

\subsec{length$(x)$}\kbdsidx{length}\label{se:length}
Length of $x$; \kbd{\#}$x$ is a shortcut for \kbd{length}$(x)$.
This is mostly useful for

\item vectors: dimension (0 for empty vectors),

\item lists: number of entries (0 for empty lists),

\item maps: number of entries (0 for empty maps),

\item matrices: number of columns,

\item character strings: number of actual characters (without
trailing \kbd{\bs 0}, should you expect it from $C$ \kbd{char*}).
\bprog
 ? #"a string"
 %1 = 8
 ? #[3,2,1]
 %2 = 3
 ? #[]
 %3 = 0
 ? #matrix(2,5)
 %4 = 5
 ? L = List([1,2,3,4]); #L
 %5 = 4
 ? M = Map([a,b; c,d; e,f]); #M
 %6 = 3
@eprog

The routine is in fact defined for arbitrary GP types, but is awkward and
useless in other cases: it returns the number of non-code words in $x$, e.g.
the effective length minus 2 for integers since the \typ{INT} type has two code
words.

The library syntax is \fun{long}{glength}{GEN x}.

\subsec{lift$(x,\{v\})$}\kbdsidx{lift}\label{se:lift}
If $v$ is omitted, lifts intmods from $\Z/n\Z$ in $\Z$,
$p$-adics from $\Q_p$ to $\Q$ (as \tet{truncate}), and polmods to
polynomials. Otherwise, lifts only polmods whose modulus has main
variable~$v$. \typ{FFELT} are not lifted, nor are List elements: you may
convert the latter to vectors first, or use \kbd{apply(lift,L)}. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.
\bprog
? lift(Mod(5,3))
%1 = 2
? lift(3 + O(3^9))
%2 = 3
? lift(Mod(x,x^2+1))
%3 = x
? lift(Mod(x,x^2+1))
%4 = x
@eprog
Lifts are performed recursively on an object components, but only
by \emph{one level}: once a \typ{POLMOD} is lifted, the components of
the result are \emph{not} lifted further.
\bprog
? lift(x * Mod(1,3) + Mod(2,3))
%4 = x + 2
? lift(x * Mod(y,y^2+1) + Mod(2,3))
%5 = y*x + Mod(2, 3)   \\@com do you understand this one?
? lift(x * Mod(y,y^2+1) + Mod(2,3), 'x)
%6 = Mod(y, y^2 + 1)*x + Mod(Mod(2, 3), y^2 + 1)
? lift(%, y)
%7 = y*x + Mod(2, 3)
@eprog\noindent To recursively lift all components not only by one level,
but as long as possible, use \kbd{liftall}. To lift only \typ{INTMOD}s and
\typ{PADIC}s components, use \tet{liftint}. To lift only \typ{POLMOD}s
components, use \tet{liftpol}. Finally, \tet{centerlift} allows to lift
\typ{INTMOD}s and \typ{PADIC}s using centered residues (lift of smallest
absolute value).

The library syntax is \fun{GEN}{lift0}{GEN x, long v = -1} where \kbd{v} is a variable number.
Also available is \fun{GEN}{lift}{GEN x} corresponding to
\kbd{lift0(x,-1)}.

\subsec{liftall$(x)$}\kbdsidx{liftall}\label{se:liftall}
Recursively lift all components of $x$ from $\Z/n\Z$ to $\Z$,
from $\Q_p$ to $\Q$ (as \tet{truncate}), and polmods to
polynomials. \typ{FFELT} are not lifted, nor are List elements: you may
convert the latter to vectors first, or use \kbd{apply(liftall,L)}. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.
\bprog
? liftall(x * (1 + O(3)) + Mod(2,3))
%1 = x + 2
? liftall(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = y*x + 2*z
@eprog

The library syntax is \fun{GEN}{liftall}{GEN x}.

\subsec{liftint$(x)$}\kbdsidx{liftint}\label{se:liftint}
Recursively lift all components of $x$ from $\Z/n\Z$ to $\Z$ and
from $\Q_p$ to $\Q$ (as \tet{truncate}).
\typ{FFELT} are not lifted, nor are List elements: you may
convert the latter to vectors first, or use \kbd{apply(liftint,L)}. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.
\bprog
? liftint(x * (1 + O(3)) + Mod(2,3))
%1 = x + 2
? liftint(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = Mod(y, y^2 + 1)*x + Mod(Mod(2*z, z^2), y^2 + 1)
@eprog

The library syntax is \fun{GEN}{liftint}{GEN x}.

\subsec{liftpol$(x)$}\kbdsidx{liftpol}\label{se:liftpol}
Recursively lift all components of $x$ which are polmods to
polynomials. \typ{FFELT} are not lifted, nor are List elements: you may
convert the latter to vectors first, or use \kbd{apply(liftpol,L)}. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.
\bprog
? liftpol(x * (1 + O(3)) + Mod(2,3))
%1 = (1 + O(3))*x + Mod(2, 3)
? liftpol(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = y*x + Mod(2, 3)*z
@eprog

The library syntax is \fun{GEN}{liftpol}{GEN x}.

\subsec{norm$(x)$}\kbdsidx{norm}\label{se:norm}
Algebraic norm of $x$, i.e.~the product of $x$ with
its conjugate (no square roots are taken), or conjugates for polmods. For
vectors and matrices, the norm is taken componentwise and hence is not the
$L^2$-norm (see \kbd{norml2}). Note that the norm of an element of
$\R$ is its square, so as to be compatible with the complex norm.

The library syntax is \fun{GEN}{gnorm}{GEN x}.

\subsec{numerator$(f,\{D\})$}\kbdsidx{numerator}\label{se:numerator}
Numerator of $f$. This is defined as \kbd{f * denominator(f,D)}, see
\kbd{denominator} for details. The optional argument $D$ allows to control
over which ring we compute the denominator:

\item $1$: we only consider the underlying $\Q$-structure and the
denominator is a (positive) rational integer

\item a simple variable, say \kbd{'x}: all entries as rational functions
in $K(x)$ and the denominator is a polynomial in $x$.

\bprog
? f = x + 1/y + 1/2;
? numerator(f) \\ a t_POL in x
%2 = x + ((y + 2)/(2*y))
? numerator(f, 1) \\ Q-denominator is 2
%3 = x + ((y + 2)/y)
? numerator(f, y) \\ as a rational function in y
%5 = 2*y*x + (y + 2)
@eprog

The library syntax is \fun{GEN}{numerator}{GEN f, GEN D = NULL}.
Also available are
\fun{GEN}{numer}{GEN x}  which implements the not very useful default
behaviour ($D$ is \kbd{NULL}) and
\fun{GEN}{Q_remove_denom}{GEN x, GEN *ptd} ($D = 1$) and also returns the
denominator (coding $1$ as \kbd{NULL}).

\subsec{oo}\kbdsidx{oo}\label{se:oo}
Returns an object meaning $+\infty$, for use in functions such as
\kbd{intnum}. It can be negated (\kbd{-oo} represents $-\infty$), and
compared to real numbers (\typ{INT}, \typ{FRAC}, \typ{REAL}), with the
expected meaning: $+\infty$ is greater than any real number and $-\infty$ is
smaller.

The library syntax is \fun{GEN}{mkoo}{}.

\subsec{padicprec$(x,p)$}\kbdsidx{padicprec}\label{se:padicprec}
Returns the absolute $p$-adic precision of the object $x$; this is the
minimum precision of the components of $x$. The result is \tet{+oo} if $x$
is an exact object (as a $p$-adic):
\bprog
? padicprec((1 + O(2^5)) * x + (2 + O(2^4)), 2)
%1 = 4
? padicprec(x + 2, 2)
%2 = +oo
? padicprec(2 + x + O(x^2), 2)
%3 = +oo
@eprog\noindent The function raises an exception if it encounters
an object incompatible with $p$-adic computations:
\bprog
? padicprec(O(3), 2)
 ***   at top-level: padicprec(O(3),2)
 ***                 ^-----------------
 *** padicprec: inconsistent moduli in padicprec: 3 != 2

? padicprec(1.0, 2)
 ***   at top-level: padicprec(1.0,2)
 ***                 ^----------------
 *** padicprec: incorrect type in padicprec (t_REAL).
@eprog

The library syntax is \fun{GEN}{gppadicprec}{GEN x, GEN p}.
Also available is the function \fun{long}{padicprec}{GEN x, GEN p},
which returns \tet{LONG_MAX} if $x = 0$ and the $p$-adic precision as a
\kbd{long} integer.

\subsec{precision$(x,\{n\})$}\kbdsidx{precision}\label{se:precision}
The function behaves differently according to whether $n$ is
present or not. If $n$ is missing, the function returns
the floating point precision in decimal digits of the PARI object $x$. If $x$
has no floating point component, the function returns \kbd{+oo}.
\bprog
? precision(exp(1e-100))
%1 = 154                \\ 154 significant decimal digits
? precision(2 + x)
%2 = +oo                \\ exact object
? precision(0.5 + O(x))
%3 = 38                 \\ floating point accuracy, NOT series precision
? precision( [ exp(1e-100), 0.5 ] )
%4 = 38                 \\ minimal accuracy among components
@eprog\noindent Using \kbd{getlocalprec()} allows to retrieve
the working precision (as modified by possible \kbd{localprec}
statements).

If $n$ is present, the function creates a new object equal to $x$ with a new
floating point precision $n$: $n$ is the number of desired significant
\emph{decimal} digits. If $n$ is smaller than the precision of a \typ{REAL}
component of $x$, it is truncated, otherwise it is extended with zeros.
For non-floating-point types, no change.

The library syntax is \fun{GEN}{precision00}{GEN x, GEN n = NULL}.
Also available are \fun{GEN}{gprec}{GEN x, long n} and
\fun{long}{precision}{GEN x}. In both, the accuracy is expressed in
\emph{words} (32-bit or 64-bit depending on the architecture).

\subsec{random$(\{N=2^{31}\})$}\kbdsidx{random}\label{se:random}
Returns a random element in various natural sets depending on the
argument $N$.

\item \typ{INT}: let $n = |N|-1$; if $N > 0$ returns an integer uniformly
distributed in $[0, n]$; if $N < 0$ returns an integer uniformly
distributed in $[-n, n]$. Omitting the argument is
equivalent to \kbd{random(2\pow31)}.

\item \typ{REAL}: returns a real number in $[0,1[$ with the same accuracy as
$N$ (whose mantissa has the same number of significant words).

\item \typ{INTMOD}: returns a random intmod for the same modulus.

\item \typ{FFELT}: returns a random element in the same finite field.

\item \typ{VEC} of length $2$, $N = [a,b]$: returns an integer uniformly
distributed between $a$ and $b$.

\item \typ{VEC} generated by \kbd{ellinit} over a finite field $k$
(coefficients are \typ{INTMOD}s modulo a prime or \typ{FFELT}s): returns a
``random'' $k$-rational \emph{affine} point on the curve. More precisely
if the curve has a single point (at infinity!) we return it; otherwise
we return an affine point by drawing an abscissa uniformly at
random until \tet{ellordinate} succeeds. Note that this is definitely not a
uniform distribution over $E(k)$, but it should be good enough for
applications.

\item \typ{POL} return a random polynomial of degree at most the degree of $N$.
The coefficients are drawn by applying \kbd{random} to the leading
coefficient of $N$.

\bprog
? random(10)
%1 = 9
? random(Mod(0,7))
%2 = Mod(1, 7)
? a = ffgen(ffinit(3,7), 'a); random(a)
%3 = a^6 + 2*a^5 + a^4 + a^3 + a^2 + 2*a
? E = ellinit([3,7]*Mod(1,109)); random(E)
%4 = [Mod(103, 109), Mod(10, 109)]
? E = ellinit([1,7]*a^0); random(E)
%5 = [a^6 + a^5 + 2*a^4 + 2*a^2, 2*a^6 + 2*a^4 + 2*a^3 + a^2 + 2*a]
? random(Mod(1,7)*x^4)
%6 = Mod(5, 7)*x^4 + Mod(6, 7)*x^3 + Mod(2, 7)*x^2 + Mod(2, 7)*x + Mod(5, 7)

@eprog
These variants all depend on a single internal generator, and are
independent from your operating system's random number generators.
A random seed may be obtained via \tet{getrand}, and reset
using \tet{setrand}: from a given seed, and given sequence of \kbd{random}s,
the exact same values will be generated. The same seed is used at each
startup, reseed the generator yourself if this is a problem. Note that
internal functions also call the random number generator; adding such a
function call in the middle of your code will change the numbers produced.

\misctitle{Technical note}
Up to
version 2.4 included, the internal generator produced pseudo-random numbers
by means of linear congruences, which were not well distributed in arithmetic
progressions. We now
use Brent's XORGEN algorithm, based on Feedback Shift Registers, see
\url{http://wwwmaths.anu.edu.au/~brent/random.html}. The generator has period
$2^{4096}-1$, passes the Crush battery of statistical tests of L'Ecuyer and
Simard, but is not suitable for cryptographic purposes: one can reconstruct
the state vector from a small sample of consecutive values, thus predicting
the entire sequence.

The library syntax is \fun{GEN}{genrand}{GEN N = NULL}.

 Also available: \fun{GEN}{ellrandom}{GEN E} and \fun{GEN}{ffrandom}{GEN a}.

\subsec{real$(x)$}\kbdsidx{real}\label{se:real}
Real part of $x$. When $x$ is a quadratic number, this is the
coefficient of $1$ in the ``canonical'' integral basis $(1,\omega)$.
\bprog
? real(3 + I)
%1 = 3
? x = 3 + quadgen(-23);
? real(x) \\ as a quadratic number
%3 = 3
? real(x * 1.) \\ as a complex number
%4 = 3.5000000000000000000000000000000000000
@eprog

The library syntax is \fun{GEN}{greal}{GEN x}.

\subsec{round$(x,\{\&e\})$}\kbdsidx{round}\label{se:round}
If $x$ is in $\R$, rounds $x$ to the nearest integer (rounding to
$+\infty$ in case of ties), then and sets $e$ to the number of error bits,
that is the binary exponent of the difference between the original and the
rounded value (the ``fractional part''). If the exponent of $x$ is too large
compared to its precision (i.e.~$e>0$), the result is undefined and an error
occurs if $e$ was not given.

\misctitle{Important remark} Contrary to the other truncation functions,
this function operates on every coefficient at every level of a PARI object.
For example
$$\text{truncate}\left(\dfrac{2.4*X^2-1.7}{X}\right)=2.4*X,$$
whereas
$$\text{round}\left(\dfrac{2.4*X^2-1.7}{X}\right)=\dfrac{2*X^2-2}{X}.$$
An important use of \kbd{round} is to get exact results after an approximate
computation, when theory tells you that the coefficients must be integers.

The library syntax is \fun{GEN}{round0}{GEN x, GEN *e = NULL}.
Also available are \fun{GEN}{grndtoi}{GEN x, long *e} and
\fun{GEN}{ground}{GEN x}.

\subsec{serchop$(s,\{n=0\})$}\kbdsidx{serchop}\label{se:serchop}
Remove all terms of degree strictly less than $n$ in series $s$. When
the series contains no terms of degree $< n$, return $O(x^n)$.
\bprog
? s = 1/x + x + 2*x^2 + O(x^3);
? serchop(s)
%2 = x + 2*x^3 + O(x^3)
? serchop(s, 2)
%3 = 2*x^2 + O(x^3)
? serchop(s, 100)
%4 = O(x^100)
@eprog

The library syntax is \fun{GEN}{serchop}{GEN s, long n}.

\subsec{serprec$(x,v)$}\kbdsidx{serprec}\label{se:serprec}
Returns the absolute precision of $x$ with respect to power series
in the variable $v$; this is the
minimum precision of the components of $x$. The result is \tet{+oo} if $x$
is an exact object (as a series in $v$):
\bprog
? serprec(x + O(y^2), y)
%1 = 2
? serprec(x + 2, x)
%2 = +oo
? serprec(2 + x + O(x^2), y)
%3 = +oo
@eprog

The library syntax is \fun{GEN}{gpserprec}{GEN x, long v} where \kbd{v} is a variable number.
Also available is \fun{long}{serprec}{GEN x, GEN p}, which returns
\tet{LONG_MAX} if $x = 0$, otherwise the series precision as a \kbd{long} integer.

\subsec{simplify$(x)$}\kbdsidx{simplify}\label{se:simplify}
This function simplifies $x$ as much as it can. Specifically, a complex or
quadratic number whose imaginary part is the integer 0 (i.e.~not \kbd{Mod(0,2)}
or \kbd{0.E-28}) is converted to its real part, and a polynomial of degree $0$
is converted to its constant term. Simplifications occur recursively.

This function is especially useful before using arithmetic functions,
which expect integer arguments:
\bprog
? x = 2 + y - y
%1 = 2
? isprime(x)
  ***   at top-level: isprime(x)
  ***                 ^----------
  *** isprime: not an integer argument in an arithmetic function
? type(x)
%2 = "t_POL"
? type(simplify(x))
%3 = "t_INT"
@eprog
Note that GP results are simplified as above before they are stored in the
history. (Unless you disable automatic simplification with \b{y}, that is.)
In particular
\bprog
? type(%1)
%4 = "t_INT"
@eprog

The library syntax is \fun{GEN}{simplify}{GEN x}.

\subsec{sizebyte$(x)$}\kbdsidx{sizebyte}\label{se:sizebyte}
Outputs the total number of bytes occupied by the tree representing the
PARI object $x$.

The library syntax is \fun{long}{gsizebyte}{GEN x}.
Also available is \fun{long}{gsizeword}{GEN x} returning a
number of \emph{words}.

\subsec{sizedigit$(x)$}\kbdsidx{sizedigit}\label{se:sizedigit}
This function is DEPRECATED, essentially meaningless, and provided for
backwards compatibility only. Don't use it!

outputs a quick upper bound for the number of decimal digits of (the
components of) $x$, off by at most $1$. More precisely, for a positive
integer $x$, it computes (approximately) the ceiling of
$$\kbd{floor}(1 + \log_2 x) \log_{10}2,$$

To count the number of decimal digits of a positive integer $x$, use
\kbd{\#digits(x)}. To estimate (recursively) the size of $x$, use
\kbd{normlp(x)}.

The library syntax is \fun{long}{sizedigit}{GEN x}.

\subsec{truncate$(x,\{\&e\})$}\kbdsidx{truncate}\label{se:truncate}
Truncates $x$ and sets $e$ to the number of
error bits. When $x$ is in $\R$, this means that the part after the decimal
point is chopped away, $e$ is the binary exponent of the difference between
the original and the truncated value (the ``fractional part''). If the
exponent of $x$ is too large compared to its precision (i.e.~$e>0$), the
result is undefined and an error occurs if $e$ was not given. The function
applies componentwise on vector / matrices; $e$ is then the maximal number of
error bits. If $x$ is a rational function, the result is the ``integer part''
(Euclidean quotient of numerator by denominator) and $e$ is not set.

Note a very special use of \kbd{truncate}: when applied to a power series, it
transforms it into a polynomial or a rational function with denominator
a power of $X$, by chopping away the $O(X^k)$. Similarly, when applied to
a $p$-adic number, it transforms it into an integer or a rational number
by chopping away the $O(p^k)$.

The library syntax is \fun{GEN}{trunc0}{GEN x, GEN *e = NULL}.
The following functions are also available: \fun{GEN}{gtrunc}{GEN x}
and \fun{GEN}{gcvtoi}{GEN x, long *e}.

\subsec{valuation$(x,\{p\})$}\kbdsidx{valuation}\label{se:valuation}
Computes the highest
exponent of $p$ dividing $x$. If $p$ is of type integer, $x$ must be an
integer, an intmod whose modulus is divisible by $p$, a fraction, a
$q$-adic number with $q=p$, or a polynomial or power series in which case the
valuation is the minimum of the valuation of the coefficients.

If $p$ is of type polynomial, $x$ must be of type polynomial or rational
function, and also a power series if $x$ is a monomial. Finally, the
valuation of a vector, complex or quadratic number is the minimum of the
component valuations.

If $x=0$, the result is \kbd{+oo} if $x$ is an exact object. If $x$ is a
$p$-adic numbers or power series, the result is the exponent of the zero.
Any other type combinations gives an error.

Finally, $p$ can be omitted if $x$ is a \typ{PADIC} (taken to be the
underlying prime), a \typ{SER} or a \typ{POL} (taken to be the main variable).

The library syntax is \fun{GEN}{gpvaluation}{GEN x, GEN p = NULL}.
Also available is
\fun{long}{gvaluation}{GEN x, GEN p}, which returns \tet{LONG_MAX} if $x = 0$
and the valuation as a \kbd{long} integer.

\subsec{varhigher$(\var{name},\{v\})$}\kbdsidx{varhigher}\label{se:varhigher}
Return a variable \emph{name} whose priority is higher
than the priority of $v$ (of all existing variables if $v$ is omitted).
This is a counterpart to \tet{varlower}.
\bprog
? Pol([x,x], t)
 ***   at top-level: Pol([x,x],t)
 ***                 ^------------
 *** Pol: incorrect priority in gtopoly: variable x <= t
? t = varhigher("t", x);
? Pol([x,x], t)
%3 = x*t + x
@eprog\noindent This routine is useful since new GP variables directly
created by the interpreter always have lower priority than existing
GP variables. When some basic objects already exist in a variable
that is incompatible with some function requirement, you can now
create a new variable with a suitable priority instead of changing variables
in existing objects:
\bprog
? K = nfinit(x^2+1);
? rnfequation(K,y^2-2)
 ***   at top-level: rnfequation(K,y^2-2)
 ***                 ^--------------------
 *** rnfequation: incorrect priority in rnfequation: variable y >= x
? y = varhigher("y", x);
? rnfequation(K, y^2-2)
%3 = y^4 - 2*y^2 + 9
@eprog\noindent
\misctitle{Caution 1}
The \emph{name} is an arbitrary character string, only used for display
purposes and need not be related to the GP variable holding the result, nor
to be a valid variable name. In particular the \emph{name} can
not be used to retrieve the variable, it is not even present in the parser's
hash tables.
\bprog
? x = varhigher("#");
? x^2
%2 = #^2
@eprog
\misctitle{Caution 2} There are a limited number of variables and if no
existing variable with the given display name has the requested
priority, the call to \kbd{varhigher} uses up one such slot. Do not create
new variables in this way unless it's absolutely necessary,
reuse existing names instead and choose sensible priority requirements:
if you only need a variable with higher priority than $x$, state so
rather than creating a new variable with highest priority.
\bprog
\\ quickly use up all variables
? n = 0; while(1,varhigher("tmp"); n++)
 ***   at top-level: n=0;while(1,varhigher("tmp");n++)
 ***                             ^-------------------
 *** varhigher: no more variables available.
 ***   Break loop: type 'break' to go back to GP prompt
break> n
65510
\\ infinite loop: here we reuse the same 'tmp'
? n = 0; while(1,varhigher("tmp", x); n++)
@eprog

The library syntax is \fun{GEN}{varhigher}{const char *name, long v = -1} where \kbd{v} is a variable number.

\subsec{variable$(\{x\})$}\kbdsidx{variable}\label{se:variable}
Gives the main variable of the object $x$ (the variable with the highest
priority used in $x$), and $p$ if $x$ is a $p$-adic number. Return $0$ if
$x$ has no variable attached to it.
\bprog
? variable(x^2 + y)
%1 = x
? variable(1 + O(5^2))
%2 = 5
? variable([x,y,z,t])
%3 = x
? variable(1)
%4 = 0
@eprog\noindent The construction
\bprog
   if (!variable(x),...)
@eprog\noindent can be used to test whether a variable is attached to $x$.

If $x$ is omitted, returns the list of user variables known to the
interpreter, by order of decreasing priority. (Highest priority is initially
$x$, which come first until \tet{varhigher} is used.) If \kbd{varhigher}
or \kbd{varlower} are used, it is quite possible to end up with different
variables (with different priorities) printed in the same way: they
will then appear multiple times in the output:
\bprog
? varhigher("y");
? varlower("y");
? variable()
%4 = [y, x, y]
@eprog\noindent Using \kbd{v = variable()} then \kbd{v[1]}, \kbd{v[2]},
etc.~allows to recover and use existing variables.

The library syntax is \fun{GEN}{gpolvar}{GEN x = NULL}.
However, in library mode, this function should not be used for $x$
non-\kbd{NULL}, since \tet{gvar} is more appropriate. Instead, for
$x$ a $p$-adic (type \typ{PADIC}), $p$ is $gel(x,2)$; otherwise, use
\fun{long}{gvar}{GEN x} which returns the variable number of $x$ if
it exists, \kbd{NO\_VARIABLE} otherwise, which satisfies the property
$\kbd{varncmp}(\kbd{NO\_VARIABLE}, v) > 0$ for all valid variable number
$v$, i.e. it has lower priority than any variable.

\subsec{variables$(\{x\})$}\kbdsidx{variables}\label{se:variables}
Returns the list of all variables occurring in object $x$ (all user
variables known to the interpreter if $x$ is omitted), sorted by
decreasing priority.
\bprog
? variables([x^2 + y*z + O(t), a+x])
%1 = [x, y, z, t, a]
@eprog\noindent The construction
\bprog
   if (!variables(x),...)
@eprog\noindent can be used to test whether a variable is attached to $x$.

If \kbd{varhigher} or \kbd{varlower} are used, it is quite possible to end up
with different variables (with different priorities) printed in the same
way: they will then appear multiple times in the output:
\bprog
? y1 = varhigher("y");
? y2 = varlower("y");
? variables(y*y1*y2)
%4 = [y, y, y]
@eprog

The library syntax is \fun{GEN}{variables_vec}{GEN x = NULL}.

Also available is \fun{GEN}{variables_vecsmall}{GEN x} which returns
the (sorted) variable numbers instead of the attached monomials of degree 1.

\subsec{varlower$(\var{name},\{v\})$}\kbdsidx{varlower}\label{se:varlower}
Return a variable \emph{name} whose priority is lower
than the priority of $v$ (of all existing variables if $v$ is omitted).
This is a counterpart to \tet{varhigher}.

New GP variables directly created by the interpreter always
have lower priority than existing GP variables, but it is not easy
to check whether an identifier is currently unused, so that the
corresponding variable has the expected priority when it's created!
Thus, depending on the session history, the same command may fail or succeed:
\bprog
? t; z;  \\ now t > z
? rnfequation(t^2+1,z^2-t)
 ***   at top-level: rnfequation(t^2+1,z^
 ***                 ^--------------------
 *** rnfequation: incorrect priority in rnfequation: variable t >= t
@eprog\noindent Restart and retry:
\bprog
? z; t;  \\ now z > t
? rnfequation(t^2+1,z^2-t)
%2 = z^4 + 1
@eprog\noindent It is quite annoying for package authors, when trying to
define a base ring, to notice that the package may fail for some users
depending on their session history. The safe way to do this is as follows:
\bprog
? z; t;  \\ In new session: now z > t
...
? t = varlower("t", 'z);
? rnfequation(t^2+1,z^2-2)
%2 = z^4 - 2*z^2 + 9
? variable()
%3 = [x, y, z, t]
@eprog
\bprog
? t; z;  \\ In new session: now t > z
...
? t = varlower("t", 'z); \\ create a new variable, still printed "t"
? rnfequation(t^2+1,z^2-2)
%2 = z^4 - 2*z^2 + 9
? variable()
%3 = [x, y, t, z, t]
@eprog\noindent Now both constructions succeed. Note that in the
first case, \kbd{varlower} is essentially a no-op, the existing variable $t$
has correct priority. While in the second case, two different variables are
displayed as \kbd{t}, one with higher priority than $z$ (created in the first
 line) and another one with lower priority (created by \kbd{varlower}).

\misctitle{Caution 1}
The \emph{name} is an arbitrary character string, only used for display
purposes and need not be related to the GP variable holding the result, nor
to be a valid variable name. In particular the \emph{name} can
not be used to retrieve the variable, it is not even present in the parser's
hash tables.
\bprog
? x = varlower("#");
? x^2
%2 = #^2
@eprog
\misctitle{Caution 2} There are a limited number of variables and if no
existing variable with the given display name has the requested
priority, the call to \kbd{varlower} uses up one such slot. Do not create
new variables in this way unless it's absolutely necessary,
reuse existing names instead and choose sensible priority requirements:
if you only need a variable with higher priority than $x$, state so
rather than creating a new variable with highest priority.
\bprog
\\ quickly use up all variables
? n = 0; while(1,varlower("x"); n++)
 ***   at top-level: n=0;while(1,varlower("x");n++)
 ***                             ^-------------------
 *** varlower: no more variables available.
 ***   Break loop: type 'break' to go back to GP prompt
break> n
65510
\\ infinite loop: here we reuse the same 'tmp'
? n = 0; while(1,varlower("tmp", x); n++)
@eprog

The library syntax is \fun{GEN}{varlower}{const char *name, long v = -1} where \kbd{v} is a variable number.

\section{Combinatorics}\label{se:combinat}

Permutations are represented in gp as \typ{VECSMALL}s and can be input
directly as \kbd{Vecsmall([1,3,2,4])} or obtained from the iterator
\kbd{forperm}:
\bprog
? forperm(3, p, print(p))  \\ iterate through S_3
Vecsmall([1, 2, 3])
Vecsmall([1, 3, 2])
Vecsmall([2, 1, 3])
Vecsmall([2, 3, 1])
Vecsmall([3, 1, 2])
Vecsmall([3, 2, 1])
@eprog

Permutations can be multiplied via \kbd{*}, raised to some power using
\kbd{\pow}, inverted using \kbd{\pow(-1)}, conjugated as
\kbd{p * q * p\pow(-1)}. Their order and signature is available via
\kbd{permorder} and \kbd{permsign}.

\subsec{bernfrac$(n)$}\kbdsidx{bernfrac}\label{se:bernfrac}
Bernoulli number\sidx{Bernoulli numbers} $B_n$,
where $B_0=1$, $B_1=-1/2$, $B_2=1/6$,\dots, expressed as a rational number.
The argument $n$ should be a nonnegative integer. The function \tet{bervec}
creates a cache of successive Bernoulli numbers which greatly speeds up
later calls to \kbd{bernfrac}:
\bprog
? bernfrac(20000);
time = 107 ms.
? bernvec(10000); \\ cache B_0, B_2, ..., B_20000
time = 35,957 ms.
? bernfrac(20000); \\ now instantaneous
?
@eprog

The library syntax is \fun{GEN}{bernfrac}{long n}.

\subsec{bernpol$(n, \{v = 'x\})$}\kbdsidx{bernpol}\label{se:bernpol}
\idx{Bernoulli polynomial} $B_n$ in variable $v$.
\bprog
? bernpol(1)
%1 = x - 1/2
? bernpol(3)
%2 = x^3 - 3/2*x^2 + 1/2*x
@eprog

The library syntax is \fun{GEN}{bernpol}{long n, long v = -1} where \kbd{v} is a variable number.

\subsec{bernreal$(n)$}\kbdsidx{bernreal}\label{se:bernreal}
Bernoulli number\sidx{Bernoulli numbers}
$B_n$, as \kbd{bernfrac}, but $B_n$ is returned as a real number
(with the current precision). The argument $n$ should be a nonnegative
integer. The function slows down as the precision increases:
\bprog
? \p1000
? bernreal(200000);
time = 5 ms.
? \p10000
? bernreal(200000);
time = 18 ms.
? \p100000
? bernreal(200000);
time = 84 ms.
@eprog

The library syntax is \fun{GEN}{bernreal}{long n, long prec}.

\subsec{bernvec$(n)$}\kbdsidx{bernvec}\label{se:bernvec}
Returns a vector containing, as rational numbers,
the \idx{Bernoulli numbers} $B_0$, $B_2$,\dots, $B_{2n}$:
\bprog
? bernvec(5) \\ B_0, B_2..., B_10
%1 = [1, 1/6, -1/30, 1/42, -1/30, 5/66]
? bernfrac(10)
%2 = 5/66
@eprog\noindent This routine uses a lot of memory but is much faster than
repeated calls to \kbd{bernfrac}:
\bprog
? forstep(n = 2, 10000, 2, bernfrac(n))
time = 18,245 ms.
? bernvec(5000);
time = 1,338 ms.
@eprog\noindent The computed Bernoulli numbers are stored in an incremental
cache which makes later calls to \kbd{bernfrac} and \kbd{bernreal}
instantaneous in the cache range: re-running the same previous \kbd{bernfrac}s
after the \kbd{bernvec} call gives:
\bprog
? forstep(n = 2, 10000, 2, bernfrac(n))
time = 1 ms.
@eprog\noindent The time and space complexity of this function are
$\tilde{O}(n^2)$; in the feasible range $n \leq 10^5$ (requires about two
hours), the practical time complexity is closer to $\tilde{O}(n^{\log_2 6})$.

The library syntax is \fun{GEN}{bernvec}{long n}.

\subsec{binomial$(x,\{k\})$}\kbdsidx{binomial}\label{se:binomial}
\idx{binomial coefficient} $\binom{x}{k}$.
Here $k$ must be an integer, but $x$ can be any PARI object.
\bprog
? binomial(4,2)
%1 = 6
? n = 4; vector(n+1, k, binomial(n,k-1))
%2 = [1, 4, 6, 4, 1]
@eprog\noindent The argument $k$ may be omitted if $x = n$ is a
nonnegative integer; in this case, return the vector with $n+1$
components whose $k+1$-th entry is \kbd{binomial}$(n,k)$
\bprog
? binomial(4)
%3 = [1, 4, 6, 4, 1]
@eprog

The library syntax is \fun{GEN}{binomial0}{GEN x, GEN k = NULL}.

\subsec{eulerfrac$(n)$}\kbdsidx{eulerfrac}\label{se:eulerfrac}
Euler number\sidx{Euler numbers} $E_n$,
where $E_0=1$, $E_1=0$, $E_2=-1$, \dots, are integers such that
$$ \dfrac{1}{\cosh t} = \sum_{n\geq 0} \dfrac{E_n}{n!} t^n. $$
The argument $n$ should be a nonnegative integer.
\bprog
? vector(10,i,eulerfrac(i))
%1 = [0, -1, 0, 5, 0, -61, 0, 1385, 0, -50521]
? eulerfrac(20000);
? sizedigit(%))
%3 = 73416
@eprog

The library syntax is \fun{GEN}{eulerfrac}{long n}.

\subsec{eulerianpol$(n, \{v = 'x\})$}\kbdsidx{eulerianpol}\label{se:eulerianpol}
\idx{Eulerian polynomial} $A_n$ in variable $v$.
\bprog
? eulerianpol(2)
%1 = x + 1
? eulerianpol(5, 't)
%2 = t^4 + 26*t^3 + 66*t^2 + 26*t + 1

@eprog

The library syntax is \fun{GEN}{eulerianpol}{long n, long v = -1} where \kbd{v} is a variable number.

\subsec{eulerpol$(n, \{v = 'x\})$}\kbdsidx{eulerpol}\label{se:eulerpol}
\idx{Euler polynomial} $E_n$ in variable $v$.
\bprog
? eulerpol(1)
%1 = x - 1/2
? eulerpol(3)
%2 = x^3 - 3/2*x^2 + 1/4
@eprog

The library syntax is \fun{GEN}{eulerpol}{long n, long v = -1} where \kbd{v} is a variable number.

\subsec{eulerreal$(n)$}\kbdsidx{eulerreal}\label{se:eulerreal}
Euler number\sidx{Euler numbers} $E_n$,
where $E_0=1$, $E_1=0$, $E_2=-1$, \dots, are integers such that
$$ \dfrac{1}{\cosh t} = \sum_{n\geq 0} \dfrac{E_n}{n!} t^n. $$
The argument $n$ should be a nonnegative integer. Return $E_n$
as a real number (with the current precision).
\bprog
? sizedigit(eulerfrac(20000))
%1 = 73416
? eulerreal(20000);
%2 = 9.2736664576330851823546169139003297830 E73414
@eprog

The library syntax is \fun{GEN}{eulerreal}{long n, long prec}.

\subsec{eulervec$(n)$}\kbdsidx{eulervec}\label{se:eulervec}
Returns a vector containing the nonzero \idx{Euler numbers} $E_0$,
$E_2$,\dots, $E_{2n}$:
\bprog
? eulervec(5) \\ E_0, E_2..., E_10
%1 = [1, -1, 5, -61, 1385, -50521]
? eulerfrac(10)
%2 = -50521
@eprog\noindent This routine uses more memory but is faster than
repeated calls to \kbd{eulerfrac}:
\bprog
? forstep(n = 2, 8000, 2, eulerfrac(n))
time = 27,3801ms.
? eulervec(4000);
time = 8,430 ms.
@eprog
The computed Euler numbers are stored in an incremental
cache which makes later calls to \kbd{eulerfrac} and \kbd{eulerreal}
instantaneous in the cache range: re-running the same previous \kbd{eulerfrac}s
after the \kbd{eulervec} call gives:
\bprog
? forstep(n = 2, 10000, 2, eulerfrac(n))
time = 0 ms.
@eprog

The library syntax is \fun{GEN}{eulervec}{long n}.

\subsec{fibonacci$(x)$}\kbdsidx{fibonacci}\label{se:fibonacci}
$x^{\text{th}}$ Fibonacci number.

The library syntax is \fun{GEN}{fibo}{long x}.

\subsec{hammingweight$(x)$}\kbdsidx{hammingweight}\label{se:hammingweight}
If $x$ is a \typ{INT}, return the binary Hamming weight of $|x|$. Otherwise
$x$ must be of type \typ{POL}, \typ{VEC}, \typ{COL}, \typ{VECSMALL}, or
\typ{MAT} and the function returns the number of nonzero coefficients of
$x$.
\bprog
? hammingweight(15)
%1 = 4
? hammingweight(x^100 + 2*x + 1)
%2 = 3
? hammingweight([Mod(1,2), 2, Mod(0,3)])
%3 = 2
? hammingweight(matid(100))
%4 = 100
@eprog

The library syntax is \fun{long}{hammingweight}{GEN x}.

\subsec{harmonic$(n,\{r = 1\})$}\kbdsidx{harmonic}\label{se:harmonic}
Generalized harmonic number of index $n \geq 0$ in power $r$, as a rational
number. If $r = 1$ (or omitted), this is the harmonic number
$$ H_n = \sum_{i = 1}^n \dfrac{1}{i}.$$
In general, this is
$$ H_{n,r} = \sum_{i = 1}^n \dfrac{1}{i^r}.$$
The function runs in time $\tilde{O}(r n)$, essentially linear in the
size of the output.
\bprog
? harmonic(0)
%1 = 0
? harmonic(1)
%2 = 1
? harmonic(10)
%3 = 7381/2520
? harmonic(10, 2)
%4 = 1968329/1270080
? harmonic(10, -2)
%5 = 385
@eprog\noindent Note that the numerator and denominator are of order
$\exp((r+o(1))n)$ and this will overflow for large $n$. To obtain $H_n$ as a
floating point number, use $H_n = \kbd{psi}(n+1) + \kbd{Euler}$.

The library syntax is \fun{GEN}{harmonic0}{ulong n, GEN r = NULL}.
Also available is \fun{GEN}{harmonic}{ulong n} for $r = 1$.

\subsec{numbpart$(n)$}\kbdsidx{numbpart}\label{se:numbpart}
Gives the number of unrestricted partitions of
$n$, usually called $p(n)$ in the literature; in other words the number of
nonnegative integer solutions to $a+2b+3c+\cdots=n$. $n$ must be of type
integer and $n<10^{15}$ (with trivial values $p(n) = 0$ for $n < 0$ and
$p(0) = 1$). The algorithm uses the Hardy-Ramanujan-Rademacher formula.
To explicitly enumerate them, see \tet{partitions}.

The library syntax is \fun{GEN}{numbpart}{GEN n}.

\subsec{numtoperm$(n,k)$}\kbdsidx{numtoperm}\label{se:numtoperm}
Generates the $k$-th permutation (as a row vector of length $n$) of the
numbers $1$ to $n$. The number $k$ is taken modulo $n!\,$, i.e.~inverse
function of \tet{permtonum}. The numbering used is the standard lexicographic
ordering, starting at $0$.

The library syntax is \fun{GEN}{numtoperm}{long n, GEN k}.

\subsec{partitions$(k,\{a=k\},\{n=k\})$}\kbdsidx{partitions}\label{se:partitions}
Returns the vector of partitions of the integer $k$ as a sum of positive
integers (parts); for $k < 0$, it returns the empty set \kbd{[]}, and for $k
= 0$ the trivial partition (no parts). A partition is given by a
\typ{VECSMALL}, where parts are sorted in nondecreasing order:
\bprog
? partitions(3)
%1 = [Vecsmall([3]), Vecsmall([1, 2]), Vecsmall([1, 1, 1])]
@eprog\noindent correspond to $3$, $1+2$ and $1+1+1$. The number
of (unrestricted) partitions of $k$ is given
by \tet{numbpart}:
\bprog
? #partitions(50)
%1 = 204226
? numbpart(50)
%2 = 204226
@eprog

\noindent Optional parameters $n$ and $a$ are as follows:

\item $n=\var{nmax}$ (resp. $n=[\var{nmin},\var{nmax}]$) restricts
partitions to length less than $\var{nmax}$ (resp. length between
$\var{nmin}$ and $nmax$), where the \emph{length} is the number of nonzero
entries.

\item $a=\var{amax}$ (resp. $a=[\var{amin},\var{amax}]$) restricts the parts
to integers less than $\var{amax}$ (resp. between $\var{amin}$ and
$\var{amax}$).
\bprog
? partitions(4, 2)  \\ parts bounded by 2
%1 = [Vecsmall([2, 2]), Vecsmall([1, 1, 2]), Vecsmall([1, 1, 1, 1])]
? partitions(4,, 2) \\ at most 2 parts
%2 = [Vecsmall([4]), Vecsmall([1, 3]), Vecsmall([2, 2])]
? partitions(4,[0,3], 2) \\ at most 2 parts
%3 = [Vecsmall([4]), Vecsmall([1, 3]), Vecsmall([2, 2])]
@eprog\noindent
By default, parts are positive and we remove zero entries unless
$amin\leq0$, in which case $nmin$ is ignored and we fix $\#X = \var{nmax}$:
\bprog
? partitions(4, [0,3])  \\ parts between 0 and 3
%1 = [Vecsmall([0, 0, 1, 3]), Vecsmall([0, 0, 2, 2]),\
      Vecsmall([0, 1, 1, 2]), Vecsmall([1, 1, 1, 1])]
? partitions(1, [0,3], [2,4]) \\ no partition with 2 to 4 nonzero parts
%2 = []
@eprog

The library syntax is \fun{GEN}{partitions}{long k, GEN a = NULL, GEN n = NULL}.

\subsec{permcycles$(x)$}\kbdsidx{permcycles}\label{se:permcycles}
Given a permutation $x$ on $n$ elements, return the orbits of
$\{1,\ldots,n\}$ under the action of $x$ as cycles.
\bprog
? permcycles(Vecsmall([1,2,3]))
%1 = [Vecsmall([1]),Vecsmall([2]),Vecsmall([3])]
? permcycles(Vecsmall([2,3,1]))
%2 = [Vecsmall([1,2,3])]
? permcycles(Vecsmall([2,1,3]))
%3 = [Vecsmall([1,2]),Vecsmall([3])]
@eprog

The library syntax is \fun{GEN}{permcycles}{GEN x}.

\subsec{permorder$(x)$}\kbdsidx{permorder}\label{se:permorder}
Given a permutation $x$ on $n$ elements, return its order.
\bprog
? p = Vecsmall([3,1,4,2,5]);
? p^2
%2 = Vecsmall([4,3,2,1,5])
? p^4
%3 = Vecsmall([1,2,3,4,5])
? permorder(p)
%4 = 4
@eprog

The library syntax is \fun{GEN}{permorder}{GEN x}.

\subsec{permsign$(x)$}\kbdsidx{permsign}\label{se:permsign}
Given a permutation $x$ on $n$ elements, return its signature.
\bprog
? p = Vecsmall([3,1,4,2,5]);
? permsign(p)
%2 = -1
? permsign(p^2)
%3 = 1
@eprog

The library syntax is \fun{long}{permsign}{GEN x}.

\subsec{permtonum$(x)$}\kbdsidx{permtonum}\label{se:permtonum}
Given a permutation $x$ on $n$ elements, gives the number $k$ such that
$x=\kbd{numtoperm(n,k)}$, i.e.~inverse function of \tet{numtoperm}.
The numbering used is the standard lexicographic ordering, starting at $0$.

The library syntax is \fun{GEN}{permtonum}{GEN x}.

\subsec{stirling$(n,k,\{\fl=1\})$}\kbdsidx{stirling}\label{se:stirling}
\idx{Stirling number} of the first kind $s(n,k)$ ($\fl=1$, default) or
of the second kind $S(n,k)$ (\fl=2), where $n$, $k$ are nonnegative
integers. The former is $(-1)^{n-k}$ times the
number of permutations of $n$ symbols with exactly $k$ cycles; the latter is
the number of ways of partitioning a set of $n$ elements into $k$ nonempty
subsets. Note that if all $s(n,k)$ are needed, it is much faster to compute
$$\sum_k s(n,k) x^k = x(x-1)\dots(x-n+1).$$
Similarly, if a large number of $S(n,k)$ are needed for the same $k$,
one should use
$$\sum_n S(n,k) x^n = \dfrac{x^k}{(1-x)\dots(1-kx)}.$$
(Should be implemented using a divide and conquer product.) Here are
simple variants for $n$ fixed:
\bprog
/* list of s(n,k), k = 1..n */
vecstirling(n) = Vec( factorback(vector(n-1,i,1-i*'x)) )

/* list of S(n,k), k = 1..n */
vecstirling2(n) =
{ my(Q = x^(n-1), t);
  vector(n, i, t = divrem(Q, x-i); Q=t[1]; simplify(t[2]));
}

/* Bell numbers, B_n = B[n+1] = sum(k = 0, n, S(n,k)), n = 0..N */
vecbell(N)=
{ my (B = vector(N+1));
  B[1] = B[2] = 1;
  for (n = 2, N,
    my (C = binomial(n-1));
    B[n+1] = sum(k = 1, n, C[k]*B[k]);
  ); B;
}
@eprog

The library syntax is \fun{GEN}{stirling}{long n, long k, long flag}.
Also available are \fun{GEN}{stirling1}{ulong n, ulong k}
($\fl=1$) and \fun{GEN}{stirling2}{ulong n, ulong k} ($\fl=2$).

\section{Arithmetic functions}\label{se:arithmetic}

These functions are by definition functions whose natural domain of
definition is either $\Z$ (or $\Z_{>0}$). The way these functions are used is
completely different from transcendental functions in that there are no
automatic type conversions: in general only integers are accepted as
arguments. An integer argument $N$ can be given in the following alternate
formats:

\item \typ{MAT}: its factorization \kbd{fa = factor($N$)},

\item \typ{VEC}: a pair \kbd{[$N$, fa]} giving both the integer and
  its factorization.

This allows to compute different arithmetic functions at a given $N$
while factoring the latter only once.

\bprog
  ? N = 10!; faN = factor(N);
  ? eulerphi(N)
  %2 = 829440
  ? eulerphi(faN)
  %3 = 829440
  ? eulerphi(S = [N, faN])
  %4 = 829440
  ? sigma(S)
  %5 = 15334088
@eprog

\subsec{Arithmetic functions and the factoring engine}
All arithmetic functions in the narrow sense of the word~--- Euler's
totient\sidx{Euler totient function} function, the \idx{Moebius} function,
the sums over divisors or powers of divisors etc.--- call, after trial
division by small primes, the same versatile factoring machinery described
under \kbd{factorint}. It includes \idx{Shanks SQUFOF}, \idx{Pollard Rho},
\idx{ECM} and \idx{MPQS} stages, and has an early exit option for the
functions \teb{moebius} and (the integer function underlying)
\teb{issquarefree}. This machinery relies on a fairly strong
probabilistic primality test, see \kbd{ispseudoprime}, but you may also set
\bprog
  default(factor_proven, 1)
@eprog\noindent to ensure that all tentative factorizations are fully proven.
This should not slow down PARI too much, unless prime numbers with
hundreds of decimal digits occur frequently in your application.

\subsec{Orders in finite groups and Discrete Logarithm functions}
\label{se:DLfun}

The following functions compute the order of an element in a finite group:
\kbd{ellorder} (the rational points on an elliptic curve defined over a
finite field), \kbd{fforder} (the multiplicative group of a finite field),
\kbd{znorder} (the invertible elements in $\Z/n\Z$). The following functions
compute discrete logarithms in the same groups (whenever this is meaningful)
\kbd{elllog}, \kbd{fflog}, \kbd{znlog}.

All such functions allow an optional argument specifying an integer
$N$, representing the order of the group. (The \emph{order} functions also
allows any nonzero multiple of the order, with a minor loss of efficiency.)
That optional argument follows the same format as given above:

\item \typ{INT}: the integer $N$,

\item \typ{MAT}: the factorization \kbd{fa = factor($N$)},

\item \typ{VEC}: this is the preferred format and provides both the
integer $N$ and its factorization in a two-component vector
\kbd{[$N$, fa]}.

When the group is fixed and many orders or discrete logarithms will be
computed, it is much more efficient to initialize this data once and for all
and pass it to the relevant functions, as in
\bprog
? p = nextprime(10^30);
? v = [p-1, factor(p-1)]; \\ data for discrete log & order computations
? znorder(Mod(2,p), v)
%3 = 500000000000000000000000000028
? g = znprimroot(p);
? znlog(2, g, v)
%5 = 543038070904014908801878611374
@eprog

\subsec{Dirichlet characters}\label{se:dirichletchar}

The finite abelian group $G = (\Z/N\Z)^*$ can be written $G = \oplus_{i\leq
n} (\Z/d_i\Z) g_i$, with $d_n \mid \dots \mid d_2 \mid d_1$ (SNF condition),
all $d_i > 0$, and $\prod_i d_i = \phi(N)$.

The SNF condition makes the $d_i$ unique, but the generators $g_i$, of
respective order $d_i$, are definitely not unique. The $\oplus$ notation
means that all elements of $G$ can be written uniquely as $\prod_i g_i^{n_i}$
where $n_i \in \Z/d_i\Z$. The $g_i$ are the so-called \tev{SNF generators}
of $G$.

\item a \tev{character} on the abelian group
$\oplus (\Z/d_j\Z) g_j$
is given by a row vector $\chi = [a_1,\ldots,a_n]$ of integers $0\leq a_i  <
d_i$ such that $\chi(g_j) = e(a_j / d_j)$ for all $j$, with the standard
notation $e(x) := \exp(2i\pi x)$.
In other words,
$\chi(\prod g_j^{n_j}) = e(\sum a_j n_j / d_j)$.

This will be generalized to more general abelian groups in later sections
(Hecke characters), but in the present case of $(\Z/N\Z)^*$, there is a useful
alternate convention : namely, it is not necessary to impose the SNF
condition and we can use Chinese remainders instead. If $N = \prod p^{e_p}$ is
the factorization of $N$ into primes, the so-called \tev{Conrey generators}
of $G$ are the generators of the $(\Z/p^{e_p}\Z)^*$ lifted to $(\Z/N\Z)^*$ by
requesting that they be congruent to $1$ modulo $N/p^{e_p}$ (for $p$ odd we
take the smallest positive primitive root mod $p^2$, and for $p = 2$
we take $-1$ if
$e_2 > 1$ and additionally $5$ if $e_2 > 2$). We can again write $G =
\oplus_{i\leq n} (\Z/D_i\Z) G_i$, where again $\prod_i D_i = \phi(N)$. These
generators don't satisfy the SNF condition in general since their orders are
now $(p-1)p^{e_p-1}$ for $p$ odd; for $p = 2$, the generator $-1$ has order
$2$ and $5$ has order $2^{e_2-2}$ $(e_2 > 2)$. Nevertheless, any $m\in
(\Z/N\Z)^*$ can be uniquely decomposed as $\prod G_i^{m_i}$ for some $m_i$
modulo $D_i$ and we can define a character by $\chi(G_j) = e(m_j / D_j)$ for
all $j$.

\item The \emph{column vector} of the $m_j$, $0 \leq m_j < D_j$ is called the
\tev{Conrey logarithm} of $m$ (discrete logarithm in terms of the Conrey
generators). Note that discrete logarithms in PARI/GP are always expressed as
\typ{COL}s.

\item The attached character is called the \tev{Conrey character}
attached to $m$.

To sum up a Dirichlet character can be defined by a \typ{INT} (the Conrey
label $m$), a \typ{COL} (the Conrey logarithm of $m$, in terms of the Conrey
generators) or a \typ{VEC} (in  terms of the SNF generators). The \typ{COL}
format, i.e. Conrey logarithms, is the preferred (fastest) representation.

Concretely, this works as follows:

\kbd{G = znstar(N, 1)} initializes $(\Z/N\Z)^*$, which must be given as
first arguments to all functions handling Dirichlet characters.

\kbd{znconreychar} transforms \typ{INT} and \typ{COL} to a SNF character.

\kbd{znconreylog} transforms \typ{INT} and \typ{VEC} to a Conrey logarithm.

\kbd{znconreyexp} transforms \typ{VEC} and \typ{COL} to a Conrey label.

Also available are \kbd{charconj},  \kbd{chardiv}, \kbd{charmul},
\kbd{charker}, \kbd{chareval}, \kbd{charorder}, \kbd{zncharinduce},
\kbd{znconreyconductor} (also computes the primitive character attached to
the input character). The prefix \kbd{char} indicates that the function
applies to all characters, the prefix \kbd{znchar} that it is specific to
Dirichlet characters (on $(\Z/N\Z)^*$) and the prefix \kbd{znconrey} that it
is specific to Conrey representation.

\subsec{addprimes$(\{x=[\,]\})$}\kbdsidx{addprimes}\label{se:addprimes}
Adds the integers contained in the
vector $x$ (or the single integer $x$) to a special table of
``user-defined primes'', and returns that table. Whenever \kbd{factor} is
subsequently called, it will trial divide by the elements in this table.
If $x$ is empty or omitted, just returns the current list of extra
primes.
\bprog
? addprimes(37975227936943673922808872755445627854565536638199)
? factor(15226050279225333605356183781326374297180681149613806\
         88657908494580122963258952897654000350692006139)
%2 =
[37975227936943673922808872755445627854565536638199 1]

[40094690950920881030683735292761468389214899724061 1]
? ##
  ***   last result computed in 0 ms.
@eprog

The entries in $x$ must be primes: there is no internal check, even if
the \tet{factor_proven} default is set. To remove primes from the list use
\kbd{removeprimes}.

The library syntax is \fun{GEN}{addprimes}{GEN x = NULL}.

\subsec{bestappr$(x, \{B\})$}\kbdsidx{bestappr}\label{se:bestappr}
Using variants of the extended Euclidean algorithm, returns a rational
approximation $a/b$ to $x$, whose denominator is limited
by $B$, if present. If $B$ is omitted, returns the best approximation
affordable given the input accuracy; if you are looking for true rational
numbers, presumably approximated to sufficient accuracy, you should first
try that option. Otherwise, $B$ must be a positive real scalar (impose
$0 < b \leq B$).

\item If $x$ is a \typ{REAL} or a \typ{FRAC}, this function uses continued
fractions.
\bprog
? bestappr(Pi, 100)
%1 = 22/7
? bestappr(0.1428571428571428571428571429)
%2 = 1/7
? bestappr([Pi, sqrt(2) + 'x], 10^3)
%3 = [355/113, x + 1393/985]
@eprog
By definition, $a/b$ is the best rational approximation to $x$ if
$|b x - a| < |v x - u|$ for all integers $(u,v)$ with $0 < v \leq B$.
(Which implies that $n/d$ is a convergent of the continued fraction of $x$.)

\item If $x$ is a \typ{INTMOD} modulo $N$ or a \typ{PADIC} of precision $N =
p^k$, this function performs rational modular reconstruction modulo $N$. The
routine then returns the unique rational number $a/b$ in coprime integers
$|a| < N/2B$ and $b\leq B$ which is congruent to $x$ modulo $N$. Omitting
$B$ amounts to choosing it of the order of $\sqrt{N/2}$. If rational
reconstruction is not possible (no suitable $a/b$ exists), returns $[]$.
\bprog
? bestappr(Mod(18526731858, 11^10))
%1 = 1/7
? bestappr(Mod(18526731858, 11^20))
%2 = []
? bestappr(3 + 5 + 3*5^2 + 5^3 + 3*5^4 + 5^5 + 3*5^6 + O(5^7))
%2 = -1/3
@eprog\noindent In most concrete uses, $B$ is a prime power and we performed
Hensel lifting to obtain $x$.

The function applies recursively to components of complex objects
(polynomials, vectors, \dots). If rational reconstruction fails for even a
single entry, returns $[]$.

The library syntax is \fun{GEN}{bestappr}{GEN x, GEN B = NULL}.

\subsec{bestapprPade$(x, \{B\})$}\kbdsidx{bestapprPade}\label{se:bestapprPade}
Using variants of the extended Euclidean algorithm (Pad\'{e}
approximants), returns a rational
function approximation $a/b$ to $x$, whose denominator is limited
by $B$, if present. If $B$ is omitted, return the best approximation
affordable given the input accuracy; if you are looking for true rational
functions, presumably approximated to sufficient accuracy, you should first
try that option. Otherwise, $B$ must be a nonnegative real
(impose $0 \leq \text{degree}(b) \leq B$).

\item If $x$ is a \typ{POLMOD} modulo $N$ this function performs rational
modular reconstruction modulo $N$. The routine then returns the unique
rational function $a/b$ in coprime polynomials, with $\text{degree}(b)\leq B$
and $\text{degree}(a)$ minimal, which is congruent to $x$ modulo $N$.
Omitting $B$ amounts to choosing it equal to the floor of
$\text{degree}(N) / 2$. If rational reconstruction is not possible (no
suitable $a/b$ exists), returns $[]$.
\bprog
? T = Mod(x^3 + x^2 + x + 3, x^4 - 2);
? bestapprPade(T)
%2 = (2*x - 1)/(x - 1)
? U = Mod(1 + x + x^2 + x^3 + x^5, x^9);
? bestapprPade(U)  \\ internally chooses B = 4
%3 = []
? bestapprPade(U, 5) \\ with B = 5, a solution exists
%4 = (2*x^4 + x^3 - x - 1)/(-x^5 + x^3 + x^2 - 1)
@eprog

\item If $x$ is a \typ{SER}, we implicitly
convert the input to a \typ{POLMOD} modulo $N = t^k$ where $k$ is the
series absolute precision.
\bprog
? T = 1 + t + t^2 + t^3 + t^4 + t^5 + t^6 + O(t^7); \\ mod t^7
? bestapprPade(T)
%1 = 1/(-t + 1)
@eprog
\item If $x$ is a \typ{RFRAC}, we implicitly convert the input to a
\typ{POLMOD} modulo $N = t^k$ where $k = 2B + 1$. If $B$ was omitted,
we return $x$:
\bprog
? T = (4*t^2 + 2*t + 3)/(t+1)^10;
? bestapprPade(T,1)
%2 = [] \\ impossible
? bestapprPade(T,2)
%3 = 27/(337*t^2 + 84*t + 9)
? bestapprPade(T,3)
%4 = (4253*t - 3345)/(-39007*t^3 - 28519*t^2 - 8989*t - 1115)
@eprog\noindent
The function applies recursively to components of complex objects
(polynomials, vectors, \dots). If rational reconstruction fails for even a
single entry, return $[]$.

The library syntax is \fun{GEN}{bestapprPade}{GEN x, long B}.

\subsec{bezout$(x,y)$}\kbdsidx{bezout}\label{se:bezout}
Deprecated alias for \kbd{gcdext}

The library syntax is \fun{GEN}{gcdext0}{GEN x, GEN y}.

\subsec{bigomega$(x)$}\kbdsidx{bigomega}\label{se:bigomega}
Number of prime divisors of the integer $|x|$ counted with
multiplicity:
\bprog
? factor(392)
%1 =
[2 3]

[7 2]

? bigomega(392)
%2 = 5;  \\ = 3+2
? omega(392)
%3 = 2;  \\ without multiplicity
@eprog

The library syntax is \fun{long}{bigomega}{GEN x}.

\subsec{charconj$(\var{cyc},\var{chi})$}\kbdsidx{charconj}\label{se:charconj}
Let \var{cyc} represent a finite abelian group by its elementary
divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
\mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
on this group is given by a row vector $\chi = [a_1,\ldots,a_n]$ such that
$\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
the generator (of order $d_j$) of the $j$-th cyclic component.

This function returns the conjugate character.
\bprog
? cyc = [15,5]; chi = [1,1];
? charconj(cyc, chi)
%2 = [14, 4]
? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? charconj(bnf, [1])
%5 = [2]
@eprog\noindent For Dirichlet characters (when \kbd{cyc} is
\kbd{znstar(q,1)}), characters in Conrey representation are available,
see \secref{se:dirichletchar} or \kbd{??character}:
\bprog
? G = znstar(16, 1);  \\ (Z/16Z)^*
? charconj(G, 3)  \\ Conrey label
%2 = [1, 1]~
? znconreyexp(G, %)
%3 = 11 \\ attached Conrey label; indeed 11 = 3^(-1) mod 16
? chi = znconreylog(G, 3);
? charconj(G, chi)  \\ Conrey logarithm
%5 = [1, 1]~
@eprog

The library syntax is \fun{GEN}{charconj0}{GEN cyc, GEN chi}.
Also available is
\fun{GEN}{charconj}{GEN cyc, GEN chi}, when \kbd{cyc} is known to
be a vector of elementary divisors and \kbd{chi} a compatible character
(no checks).

\subsec{chardiv$(\var{cyc}, a,b)$}\kbdsidx{chardiv}\label{se:chardiv}
Let \var{cyc} represent a finite abelian group by its elementary
divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
\mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
on this group is given by a row vector $a = [a_1,\ldots,a_n]$ such that
$\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
the generator (of order $d_j$) of the $j$-th cyclic component.

Given two characters $a$ and $b$, return the character
$a / b = a \overline{b}$.
\bprog
? cyc = [15,5]; a = [1,1]; b =  [2,4];
? chardiv(cyc, a,b)
%2 = [14, 2]
? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? chardiv(bnf, [1], [2])
%5 = [2]
@eprog\noindent For Dirichlet characters on  $(\Z/N\Z)^*$, additional
representations are available (Conrey labels, Conrey logarithm),
see \secref{se:dirichletchar} or \kbd{??character}.
If the two characters are in the same format, the
result is given in the same format, otherwise a Conrey logarithm is used.
\bprog
? G = znstar(100, 1);
? G.cyc
%2 = [20, 2]
? a = [10, 1]; \\ usual representation for characters
? b = 7; \\ Conrey label;
? c = znconreylog(G, 11); \\ Conrey log
? chardiv(G, b,b)
%6 = 1   \\ Conrey label
? chardiv(G, a,b)
%7 = [0, 5]~  \\ Conrey log
? chardiv(G, a,c)
%7 = [0, 14]~   \\ Conrey log
@eprog

The library syntax is \fun{GEN}{chardiv0}{GEN cyc, GEN a, GEN b}.
Also available is
\fun{GEN}{chardiv}{GEN cyc, GEN a, GEN b}, when \kbd{cyc} is known to
be a vector of elementary divisors and $a, b$ are compatible characters
(no checks).

\subsec{chareval$(G, \var{chi}, x, \{z\})$}\kbdsidx{chareval}\label{se:chareval}
Let $G$ be an abelian group structure affording a discrete logarithm
method, e.g $G = \kbd{znstar}(N, 1)$ for $(\Z/N\Z)^*$ or a \kbd{bnr}
structure, let $x$ be an element of $G$ and let \var{chi} be a character of
$G$ (see the note below for details). This function returns the value of
\var{chi} at~$x$.

\misctitle{Note on characters}
Let $K$ be some field. If $G$ is an abelian group,
let $\chi: G \to K^*$ be a character of finite order and let $o$ be a
multiple of the character order such that $\chi(n) = \zeta^{c(n)}$ for some
fixed $\zeta\in K^*$ of multiplicative order $o$ and a unique morphism $c: G
\to (\Z/o\Z,+)$. Our usual convention is to write
$$G = (\Z/o_1\Z) g_1 \oplus \cdots \oplus (\Z/o_d\Z) g_d$$
for some generators $(g_i)$ of respective order $d_i$, where the group has
exponent $o := \text{lcm}_i o_i$. Since $\zeta^o = 1$, the vector $(c_i)$ in
$\prod (\Z/o_i\Z)$ defines a character $\chi$ on $G$ via $\chi(g_i) =
\zeta^{c_i (o/o_i)}$ for all $i$. Classical Dirichlet characters have values
in $K = \C$ and we can take $\zeta = \exp(2i\pi/o)$.

\misctitle{Note on Dirichlet characters}
In the special case where \var{bid} is attached to $G = (\Z/q\Z)^*$
(as per \kbd{G = znstar(q,1)}), the Dirichlet
character \var{chi} can be written in one of the usual 3 formats: a \typ{VEC}
in terms of \kbd{bid.gen} as above, a \typ{COL} in terms of the Conrey
generators, or a \typ{INT} (Conrey label);
see \secref{se:dirichletchar} or \kbd{??character}.

The character value is encoded as follows, depending on the optional
argument $z$:

\item If $z$ is omitted: return the rational number $c(x)/o$ for $x$ coprime
to $q$, where we normalize $0\leq c(x) < o$. If $x$ can not be mapped to the
group (e.g. $x$ is not coprime to the conductor of a Dirichlet or Hecke
character) we return the sentinel value $-1$.

\item If $z$ is an integer $o$, then we assume that $o$ is a multiple of the
character order and we return the integer $c(x)$ when $x$ belongs
to the group, and the sentinel value $-1$ otherwise.

\item $z$ can be of the form $[\var{zeta}, o]$, where \var{zeta}
is an $o$-th root of $1$ and $o$ is a multiple of the character order.
We return $\zeta^{c(x)}$ if $x$ belongs to the group, and the sentinel
value $0$ otherwise. (Note that this coincides  with the usual extension
of Dirichlet characters to $\Z$, or of Hecke characters to general ideals.)

\item Finally, $z$ can be of the form $[\var{vzeta}, o]$, where
\var{vzeta} is a vector of powers $\zeta^0, \dots, \zeta^{o-1}$
of some $o$-th root of $1$ and $o$ is a multiple of the character order.
As above, we return $\zeta^{c(x)}$ after a table lookup. Or the sentinel
value $0$.

The library syntax is \fun{GEN}{chareval}{GEN G, GEN chi, GEN x, GEN z = NULL}.

\subsec{chargalois$(\var{cyc},\{\var{ORD}\})$}\kbdsidx{chargalois}\label{se:chargalois}
Let \var{cyc} represent a finite abelian group by its elementary divisors
(any object which has a \kbd{.cyc} method is also allowed, i.e. the output of
\kbd{znstar} or \kbd{bnrinit}). Return a list of representatives for the
Galois orbits of complex characters of $G$.
If \kbd{ORD} is present, select characters depending on their orders:

\item if \kbd{ORD} is a \typ{INT}, restrict to orders less than this
bound;

\item if \kbd{ORD} is a \typ{VEC} or \typ{VECSMALL}, restrict to orders in
the list.

\bprog
? G = znstar(96);
? #chargalois(G) \\ 16 orbits of characters mod 96
%2 = 16
? #chargalois(G,4) \\ order less than 4
%3 = 12
? chargalois(G,[1,4]) \\ order 1 or 4; 5 orbits
%4 = [[0, 0, 0], [2, 0, 0], [2, 1, 0], [2, 0, 1], [2, 1, 1]]
@eprog\noindent
Given a character $\chi$, of order $n$ (\kbd{charorder(G,chi)}), the
elements in its orbit are the $\phi(n)$ characters $\chi^i$, $(i,n)=1$.

The library syntax is \fun{GEN}{chargalois}{GEN cyc, GEN ORD = NULL}.

\subsec{charker$(\var{cyc},\var{chi})$}\kbdsidx{charker}\label{se:charker}
Let \var{cyc} represent a finite abelian group by its elementary
divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
\mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
on this group is given by a row vector $\chi = [a_1,\ldots,a_n]$ such that
$\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
the generator (of order $d_j$) of the $j$-th cyclic component.

This function returns the kernel of $\chi$, as a matrix $K$ in HNF which is a
left-divisor of \kbd{matdiagonal(d)}. Its columns express in terms of
the $g_j$ the generators of the subgroup. The determinant of $K$ is the
kernel index.
\bprog
? cyc = [15,5]; chi = [1,1];
? charker(cyc, chi)
%2 =
[15 12]

[ 0  1]

? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? charker(bnf, [1])
%5 =
[3]
@eprog\noindent Note that for Dirichlet characters (when \kbd{cyc} is
\kbd{znstar(q, 1)}), characters in Conrey representation are available,
see \secref{se:dirichletchar} or \kbd{??character}.
\bprog
? G = znstar(8, 1);  \\ (Z/8Z)^*
? charker(G, 1) \\ Conrey label for trivial character
%2 =
[1 0]

[0 1]
@eprog

The library syntax is \fun{GEN}{charker0}{GEN cyc, GEN chi}.
Also available is
\fun{GEN}{charker}{GEN cyc, GEN chi}, when \kbd{cyc} is known to
be a vector of elementary divisors and \kbd{chi} a compatible character
(no checks).

\subsec{charmul$(\var{cyc}, a,b)$}\kbdsidx{charmul}\label{se:charmul}
Let \var{cyc} represent a finite abelian group by its elementary
divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
\mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
on this group is given by a row vector $a = [a_1,\ldots,a_n]$ such that
$\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
the generator (of order $d_j$) of the $j$-th cyclic component.

Given two characters $a$ and $b$, return the product character $ab$.
\bprog
? cyc = [15,5]; a = [1,1]; b =  [2,4];
? charmul(cyc, a,b)
%2 = [3, 0]
? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? charmul(bnf, [1], [2])
%5 = [0]
@eprog\noindent For Dirichlet characters on  $(\Z/N\Z)^*$, additional
representations are available (Conrey labels, Conrey logarithm), see
\secref{se:dirichletchar} or \kbd{??character}. If the two characters are in
the same format, their
product is given in the same format, otherwise a Conrey logarithm is used.
\bprog
? G = znstar(100, 1);
? G.cyc
%2 = [20, 2]
? a = [10, 1]; \\ usual representation for characters
? b = 7; \\ Conrey label;
? c = znconreylog(G, 11); \\ Conrey log
? charmul(G, b,b)
%6 = 49   \\ Conrey label
? charmul(G, a,b)
%7 = [0, 15]~  \\ Conrey log
? charmul(G, a,c)
%7 = [0, 6]~   \\ Conrey log
@eprog

The library syntax is \fun{GEN}{charmul0}{GEN cyc, GEN a, GEN b}.
Also available is
\fun{GEN}{charmul}{GEN cyc, GEN a, GEN b}, when \kbd{cyc} is known to
be a vector of elementary divisors and $a, b$ are compatible characters
(no checks).

\subsec{charorder$(\var{cyc},\var{chi})$}\kbdsidx{charorder}\label{se:charorder}
Let \var{cyc} represent a finite abelian group by its elementary
divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
\mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
on this group is given by a row vector $\chi = [a_1,\ldots,a_n]$ such that
$\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
the generator (of order $d_j$) of the $j$-th cyclic component.

This function returns the order of the character \kbd{chi}.
\bprog
? cyc = [15,5]; chi = [1,1];
? charorder(cyc, chi)
%2 = 15
? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? charorder(bnf, [1])
%5 = 3
@eprog\noindent For Dirichlet characters (when \kbd{cyc} is
\kbd{znstar(q, 1)}), characters in Conrey representation are available,
see \secref{se:dirichletchar} or \kbd{??character}:
\bprog
? G = znstar(100, 1); \\ (Z/100Z)^*
? charorder(G, 7)   \\ Conrey label
%2 = 4
@eprog

The library syntax is \fun{GEN}{charorder0}{GEN cyc, GEN chi}.
Also available is
\fun{GEN}{charorder}{GEN cyc, GEN chi}, when \kbd{cyc} is known to
be a vector of elementary divisors and \kbd{chi} a compatible character
(no checks).

\subsec{charpow$(\var{cyc}, a,n)$}\kbdsidx{charpow}\label{se:charpow}
Let \var{cyc} represent a finite abelian group by its elementary
divisors, i.e. $(d_j)$ represents $\sum_{j \leq k} \Z/d_j\Z$ with $d_k
\mid \dots \mid d_1$; any object which has a \kbd{.cyc} method is also
allowed, e.g.~the output of \kbd{znstar} or \kbd{bnrinit}. A character
on this group is given by a row vector $a = [a_1,\ldots,a_n]$ such that
$\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$, where $g_j$ denotes
the generator (of order $d_j$) of the $j$-th cyclic component.

Given $n\in \Z$ and a character $a$, return the character $a^n$.
\bprog
? cyc = [15,5]; a = [1,1];
? charpow(cyc, a, 3)
%2 = [3, 3]
? charpow(cyc, a, 5)
%2 = [5, 0]
? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? charpow(bnf, [1], 3)
%5 = [0]
@eprog\noindent For Dirichlet characters on  $(\Z/N\Z)^*$, additional
representations are available (Conrey labels, Conrey logarithm), see
\secref{se:dirichletchar} or \kbd{??character} and the output uses the
same format as the input.
\bprog
? G = znstar(100, 1);
? G.cyc
%2 = [20, 2]
? a = [10, 1]; \\ standard representation for characters
? b = 7; \\ Conrey label;
? c = znconreylog(G, 11); \\ Conrey log
? charpow(G, a,3)
%6 = [10, 1]   \\ standard representation
? charpow(G, b,3)
%7 = 43   \\ Conrey label
? charpow(G, c,3)
%8 = [1, 8]~  \\ Conrey log
@eprog

The library syntax is \fun{GEN}{charpow0}{GEN cyc, GEN a, GEN n}.
Also available is
\fun{GEN}{charpow}{GEN cyc, GEN a, GEN n}, when \kbd{cyc} is known to
be a vector of elementary divisors (no check).

\subsec{chinese$(x,\{y\})$}\kbdsidx{chinese}\label{se:chinese}
If $x$ and $y$ are both intmods or both polmods, creates (with the same
type) a $z$ in the same residue class as $x$ and in the same residue class as
$y$, if it is possible.
\bprog
? chinese(Mod(1,2), Mod(2,3))
%1 = Mod(5, 6)
? chinese(Mod(x,x^2-1), Mod(x+1,x^2+1))
%2 = Mod(-1/2*x^2 + x + 1/2, x^4 - 1)
@eprog\noindent
This function also allows vector and matrix arguments, in which case the
operation is recursively applied to each component of the vector or matrix.
\bprog
? chinese([Mod(1,2),Mod(1,3)], [Mod(1,5),Mod(2,7)])
%3 = [Mod(1, 10), Mod(16, 21)]
@eprog\noindent
For polynomial arguments in the same variable, the function is applied to each
coefficient; if the polynomials have different degrees, the high degree terms
are copied verbatim in the result, as if the missing high degree terms in the
polynomial of lowest degree had been \kbd{Mod(0,1)}. Since the latter
behavior is usually \emph{not} the desired one, we propose to convert the
polynomials to vectors of the same length first:
\bprog
 ? P = x+1; Q = x^2+2*x+1;
 ? chinese(P*Mod(1,2), Q*Mod(1,3))
 %4 = Mod(1, 3)*x^2 + Mod(5, 6)*x + Mod(3, 6)
 ? chinese(Vec(P,3)*Mod(1,2), Vec(Q,3)*Mod(1,3))
 %5 = [Mod(1, 6), Mod(5, 6), Mod(4, 6)]
 ? Pol(%)
 %6 = Mod(1, 6)*x^2 + Mod(5, 6)*x + Mod(4, 6)
@eprog

If $y$ is omitted, and $x$ is a vector, \kbd{chinese} is applied recursively
to the components of $x$, yielding a residue belonging to the same class as all
components of $x$.

Finally $\kbd{chinese}(x,x) = x$ regardless of the type of $x$; this allows
vector arguments to contain other data, so long as they are identical in both
vectors.

The library syntax is \fun{GEN}{chinese}{GEN x, GEN y = NULL}.
\fun{GEN}{chinese1}{GEN x} is also available.

\subsec{content$(x,\{D\})$}\kbdsidx{content}\label{se:content}
Computes the gcd of all the coefficients of $x$,
when this gcd makes sense. This is the natural definition
if $x$ is a polynomial (and by extension a power series) or a
vector/matrix. This is in general a weaker notion than the \emph{ideal}
generated by the coefficients:
\bprog
? content(2*x+y)
%1 = 1            \\ = gcd(2,y) over Q[y]
@eprog

If $x$ is a scalar, this simply returns the absolute value of $x$ if $x$ is
rational (\typ{INT} or \typ{FRAC}), and either $1$ (inexact input) or $x$
(exact input) otherwise; the result should be identical to \kbd{gcd(x, 0)}.

The content of a rational function is the ratio of the contents of the
numerator and the denominator. In recursive structures, if a
matrix or vector \emph{coefficient} $x$ appears, the gcd is taken
not with $x$, but with its content:
\bprog
? content([ [2], 4*matid(3) ])
%1 = 2
@eprog\noindent The content of a \typ{VECSMALL} is computed assuming the
entries are signed integers.

The optional argument $D$ allows to control over which ring we compute
and get a more predictable behaviour:

\item $1$: we only consider the underlying $\Q$-structure and the
denominator is a (positive) rational number

\item a simple variable, say \kbd{'x}: all entries are considered as
rational functions in $K(x)$ for some field $K$ and the content is an
element of $K$.

\bprog
? f = x + 1/y + 1/2;
? content(f) \\ as a t_POL in x
%2 = 1/(2*y)
? content(f, 1) \\ Q-content
%3 = 1/2
? content(f, y) \\ as a rational function in y
%4 = 1/2
? g = x^2*y + y^2*x;
? content(g, x)
%6 = y
? content(g, y)
%7 = x
@eprog

The library syntax is \fun{GEN}{content0}{GEN x, GEN D = NULL}.

\subsec{contfrac$(x,\{b\},\{\var{nmax}\})$}\kbdsidx{contfrac}\label{se:contfrac}
Returns the row vector whose components are the partial quotients of the
\idx{continued fraction} expansion of $x$. In other words, a result
$[a_0,\dots,a_n]$ means that $x \approx a_0+1/(a_1+\dots+1/a_n)$. The
output is normalized so that $a_n \neq 1$ (unless we also have $n = 0$).

The number of partial quotients $n+1$ is limited by \kbd{nmax}. If
\kbd{nmax} is omitted, the expansion stops at the last significant partial
quotient.
\bprog
? \p19
  realprecision = 19 significant digits
? contfrac(Pi)
%1 = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2]
? contfrac(Pi,, 3)  \\ n = 2
%2 = [3, 7, 15]
@eprog\noindent
$x$ can also be a rational function or a power series.

If a vector $b$ is supplied, the numerators are equal to the coefficients
of $b$, instead of all equal to $1$ as above; more precisely, $x \approx
(1/b_0)(a_0+b_1/(a_1+\dots+b_n/a_n))$; for a numerical continued fraction
($x$ real), the $a_i$ are integers, as large as possible; if $x$ is a
rational function, they are polynomials with $\deg a_i = \deg b_i + 1$.
The length of the result is then equal to the length of $b$, unless the next
partial quotient cannot be reliably computed, in which case the expansion
stops. This happens when a partial remainder is equal to zero (or too small
compared to the available significant digits for $x$ a \typ{REAL}).

A direct implementation of the numerical continued fraction
\kbd{contfrac(x,b)} described above would be
\bprog
\\ "greedy" generalized continued fraction
cf(x, b) =
{ my( a= vector(#b), t );

  x *= b[1];
  for (i = 1, #b,
    a[i] = floor(x);
    t = x - a[i]; if (!t || i == #b, break);
    x = b[i+1] / t;
  ); a;
}
@eprog\noindent There is some degree of freedom when choosing the $a_i$; the
program above can easily be modified to derive variants of the standard
algorithm. In the same vein, although no builtin
function implements the related \idx{Engel expansion} (a special kind of
\idx{Egyptian fraction} decomposition: $x = 1/a_1 + 1/(a_1a_2) + \dots$ ),
it can be obtained as follows:
\bprog
\\ n terms of the Engel expansion of x
engel(x, n = 10) =
{ my( u = x, a = vector(n) );
  for (k = 1, n,
    a[k] = ceil(1/u);
    u = u*a[k] - 1;
    if (!u, break);
  ); a
}
@eprog

\misctitle{Obsolete hack} (don't use this): if $b$ is an integer, \var{nmax}
is ignored and the command is understood as \kbd{contfrac($x,, b$)}.

The library syntax is \fun{GEN}{contfrac0}{GEN x, GEN b = NULL, long nmax}.
Also available are \fun{GEN}{gboundcf}{GEN x, long nmax},
\fun{GEN}{gcf}{GEN x} and \fun{GEN}{gcf2}{GEN b, GEN x}.

\subsec{contfracpnqn$(x, \{n=-1\})$}\kbdsidx{contfracpnqn}\label{se:contfracpnqn}
When $x$ is a vector or a one-row matrix, $x$
is considered as the list of partial quotients $[a_0,a_1,\dots,a_n]$ of a
rational number, and the result is the 2 by 2 matrix
$[p_n,p_{n-1};q_n,q_{n-1}]$ in the standard notation of continued fractions,
so $p_n/q_n=a_0+1/(a_1+\dots+1/a_n)$. If $x$ is a matrix with two rows
$[b_0,b_1,\dots,b_n]$ and $[a_0,a_1,\dots,a_n]$, this is then considered as a
generalized continued fraction and we have similarly
$p_n/q_n=(1/b_0)(a_0+b_1/(a_1+\dots+b_n/a_n))$. Note that in this case one
usually has $b_0=1$.

If $n \geq 0$ is present, returns all convergents from $p_0/q_0$ up to
$p_n/q_n$. (All convergents if $x$ is too small to compute the $n+1$
requested convergents.)
\bprog
? a = contfrac(Pi,10)
%1 = [3, 7, 15, 1, 292, 1, 1, 1, 3]
? allpnqn(x) = contfracpnqn(x,#x) \\ all convergents
? allpnqn(a)
%3 =
[3 22 333 355 103993 104348 208341 312689 1146408]

[1  7 106 113  33102  33215  66317  99532  364913]
? contfracpnqn(a) \\ last two convergents
%4 =
[1146408 312689]

[ 364913  99532]

? contfracpnqn(a,3) \\ first three convergents
%5 =
[3 22 333 355]

[1  7 106 113]
@eprog

The library syntax is \fun{GEN}{contfracpnqn}{GEN x, long n}.
also available is \fun{GEN}{pnqn}{GEN x} for $n = -1$.

\subsec{core$(n,\{\fl=0\})$}\kbdsidx{core}\label{se:core}
If $n$ is an integer written as
$n=df^2$ with $d$ squarefree, returns $d$. If $\fl$ is nonzero,
returns the two-element row vector $[d,f]$. By convention, we write $0 = 0
\times 1^2$, so \kbd{core(0, 1)} returns $[0,1]$.

The library syntax is \fun{GEN}{core0}{GEN n, long flag}.
Also available are \fun{GEN}{core}{GEN n} ($\fl = 0$) and
\fun{GEN}{core2}{GEN n} ($\fl = 1$)

\subsec{coredisc$(n,\{\fl=0\})$}\kbdsidx{coredisc}\label{se:coredisc}
A \emph{fundamental discriminant} is an integer of the form $t\equiv 1
\mod 4$ or $4t \equiv 8,12 \mod 16$, with $t$ squarefree (i.e.~$1$ or the
discriminant of a quadratic number field). Given a nonzero integer
$n$, this routine returns the (unique) fundamental discriminant $d$
such that $n=df^2$, $f$ a positive rational number. If $\fl$ is nonzero,
returns the two-element row vector $[d,f]$. If $n$ is congruent to
0 or 1 modulo 4, $f$ is an integer, and a half-integer otherwise.

By convention, \kbd{coredisc(0, 1))} returns $[0,1]$.

Note that \tet{quaddisc}$(n)$ returns the same value as \kbd{coredisc}$(n)$,
and also works with rational inputs $n\in\Q^*$.

The library syntax is \fun{GEN}{coredisc0}{GEN n, long flag}.
Also available are \fun{GEN}{coredisc}{GEN n} ($\fl = 0$) and
\fun{GEN}{coredisc2}{GEN n} ($\fl = 1$)

\subsec{dirdiv$(x,y)$}\kbdsidx{dirdiv}\label{se:dirdiv}
$x$ and $y$ being vectors of perhaps different
lengths but with $y[1]\neq 0$ considered as \idx{Dirichlet series}, computes
the quotient of $x$ by $y$, again as a vector.

The library syntax is \fun{GEN}{dirdiv}{GEN x, GEN y}.

\subsec{direuler$(p=a,b,\var{expr},\{c\})$}\kbdsidx{direuler}\label{se:direuler}
Computes the \idx{Dirichlet series} attached to the
\idx{Euler product} of expression \var{expr} as $p$ ranges through the primes
from $a$
to $b$. \var{expr} must be a polynomial or rational function in another
variable than $p$ (say $X$) and $\var{expr}(X)$ is understood as the local
factor $\var{expr}(p^{-s})$.

The series is output as a vector of coefficients. If $c$ is omitted, output
the first $b$ coefficients of the series; otherwise, output the first $c$
coefficients. The following command computes the \teb{sigma} function,
attached to $\zeta(s)\zeta(s-1)$:
\bprog
? direuler(p=2, 10, 1/((1-X)*(1-p*X)))
%1 = [1, 3, 4, 7, 6, 12, 8, 15, 13, 18]

? direuler(p=2, 10, 1/((1-X)*(1-p*X)), 5) \\ fewer terms
%2 = [1, 3, 4, 7, 6]
@eprog\noindent Setting $c < b$ is useless (the same effect would be
achieved by setting $b = c)$. If $c > b$, the computed coefficients are
``missing'' Euler factors:
\bprog
? direuler(p=2, 10, 1/((1-X)*(1-p*X)), 15) \\ more terms, no longer = sigma !
%3 = [1, 3, 4, 7, 6, 12, 8, 15, 13, 18, 0, 28, 0, 24, 24]
@eprog

\synt{direuler}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN b}

\subsec{dirmul$(x,y)$}\kbdsidx{dirmul}\label{se:dirmul}
$x$ and $y$ being vectors of perhaps different lengths representing
the \idx{Dirichlet series} $\sum_n x_n n^{-s}$ and $\sum_n y_n n^{-s}$,
computes the product of $x$ by $y$, again as a vector.
\bprog
? dirmul(vector(10,n,1), vector(10,n,moebius(n)))
%1 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
@eprog\noindent
The product
length is the minimum of $\kbd{\#}x\kbd{*}v(y)$ and $\kbd{\#}y\kbd{*}v(x)$,
where $v(x)$ is the index of the first nonzero coefficient.
\bprog
? dirmul([0,1], [0,1]);
%2 = [0, 0, 0, 1]
@eprog

The library syntax is \fun{GEN}{dirmul}{GEN x, GEN y}.

\subsec{dirpowerssum$(N,x,\{f\})$}\kbdsidx{dirpowerssum}\label{se:dirpowerssum}
For positive integer $N$ and complex number $x$, return the sum
$f(1)1^x + f(2)2^x + \dots + f(N)N^x$, where $f$ is a completely
multiplicative function. If $f$ is omitted, return
$1^x + \dots + N^x$. When $N \le 0$, the function returns $0$.

Unlike variants using \kbd{dirpowers(N,x)}, this function uses $O(\sqrt{N})$
memory instead of $O(N)$. And it is faster for large $N$. The return value
is usually a floating point number, but it will be exact if the result
is an integer. On the other hand, rational numbers, are converted to
floating point approximations, since they are likely to blow up for large $N$.
\bprog
? dirpowers(5, 2)
%1 = [1, 4, 9, 16, 25]
? vecsum(%)
%2 = 55
? dirpowerssum(5, 2)
%3 = 55
? dirpowerssum(5, -2)
%4 = 1.4636111111111111111111111111111111111
? \p200
? s = 1/2 + I * sqrt(3); N = 10^7;
? dirpowerssum(N, s);
time = 11,425 ms.
? vecsum(dirpowers(N, s))
time = 19,365 ms.
? dirpowerssum(N, s, n->kronecker(-23,n))
time = 10,981 ms.

@eprog\noindent The \kbd{dirpowerssum} commands work with default stack size,
the \kbd{dirpowers} one requires a stacksize of at least 5GB.

\synt{dirpowerssumfun}{ulong N, GEN x, void *E, GEN (*f)(void*, ulong, long), long prec}. When $f = \kbd{NULL}$, one may use
\fun{GEN}{dirpowerssum}{ulong N, GEN x, long prec}.

\subsec{divisors$(x,\{\fl=0\})$}\kbdsidx{divisors}\label{se:divisors}
Creates a row vector whose components are the
divisors of $x$. The factorization of $x$ (as output by \tet{factor}) can
be used instead. If $\fl = 1$, return pairs $[d, \kbd{factor}(d)]$.

By definition, these divisors are the products of the irreducible
factors of $n$, as produced by \kbd{factor(n)}, raised to appropriate
powers (no negative exponent may occur in the factorization). If $n$ is
an integer, they are the positive divisors, in increasing order.

\bprog
? divisors(12)
%1 = [1, 2, 3, 4, 6, 12]
? divisors(12, 1) \\ include their factorization
%2 = [[1, matrix(0,2)], [2, Mat([2, 1])], [3, Mat([3, 1])],
      [4, Mat([2, 2])], [6, [2, 1; 3, 1]], [12, [2, 2; 3, 1]]]

? divisors(x^4 + 2*x^3 + x^2) \\ also works for polynomials
%3 = [1, x, x^2, x + 1, x^2 + x, x^3 + x^2, x^2 + 2*x + 1,
      x^3 + 2*x^2 + x, x^4 + 2*x^3 + x^2]
@eprog

This function requires a lot of memory if $x$ has many divisors. The
following idiom runs through all divisors using very little memory, in no
particular order this time:
\bprog
F = factor(x); P = F[,1]; E = F[,2];
forvec(e = vectorv(#E,i,[0,E[i]]), d = factorback(P,e); ...)
@eprog If the factorization of $d$ is also desired, then $[P,e]$ almost
provides it but not quite: $e$ may contain $0$ exponents, which are not
allowed in factorizations. These must be sieved out as in:
\bprog
? tofact(P,E) = matreduce(Mat([P,E]));
? tofact([2,3,5,7]~, [4,0,2,0]~)
%4 =
[2 4]

[5 2]
@eprog We can then run the above loop with \kbd{tofact(P,e)} instead of,
or together with, \kbd{factorback}.

The library syntax is \fun{GEN}{divisors0}{GEN x, long flag}.
The functions \fun{GEN}{divisors}{GEN N} ($\fl = 0$) and
\fun{GEN}{divisors_factored}{GEN N} ($\fl = 1$) are also available.

\subsec{divisorslenstra$(N, r, s)$}\kbdsidx{divisorslenstra}\label{se:divisorslenstra}
Given three integers $N > s > r \geq 0$ such that $(r,s) = 1$
and $s^3 > N$, find all divisors $d$ of $N$ such that $d \equiv r \pmod{s}$.
There are at most $11$ such divisors (Lenstra).
\bprog
? N = 245784; r = 19; s = 65 ;
? divisorslenstra(N, r, s)
%2 = [19, 84, 539, 1254, 3724, 245784]
? [ d | d <- divisors(N), d % s == r]
%3 = [19, 84, 539, 1254, 3724, 245784]
@eprog\noindent When the preconditions are not met, the result is undefined:
\bprog
? N = 4484075232; r = 7; s = 1303; s^3 > N
%4 = 0
? divisorslenstra(N, r, s)
? [ d | d <- divisors(N), d % s == r ]
%6 = [7, 2613, 9128, 19552, 264516, 3407352, 344928864]
@eprog\noindent (Divisors were missing but $s^3 < N$.)

The library syntax is \fun{GEN}{divisorslenstra}{GEN N, GEN r, GEN s}.

\subsec{eulerphi$(x)$}\kbdsidx{eulerphi}\label{se:eulerphi}
Euler's $\phi$ (totient)\sidx{Euler totient function} function of the
integer $|x|$, in other words $|(\Z/x\Z)^*|$.
\bprog
? eulerphi(40)
%1 = 16
@eprog\noindent
According to this definition we let $\phi(0) := 2$, since $\Z^* = \{-1,1\}$;
this is consistent with \kbd{znstar(0)}: we have
\kbd{znstar$(n)$.no = eulerphi(n)} for all $n\in\Z$.

The library syntax is \fun{GEN}{eulerphi}{GEN x}.

\subsec{factor$(x,\{D\})$}\kbdsidx{factor}\label{se:factor}
Factor $x$ over domain $D$; if $D$ is omitted, it is determined from $x$.
For instance, if $x$ is an integer, it is factored in $\Z$, if it is a
polynomial with rational coefficients, it is factored in $\Q[x]$, etc., see
below for details. The result is a two-column matrix: the first contains the
irreducibles dividing $x$ (rational or Gaussian primes, irreducible
polynomials), and the second the exponents. By convention, $0$ is factored
as $0^1$.

\misctitle{$x \in \Q$}
See \tet{factorint} for the algorithms used. The factorization includes the
unit $-1$ when $x < 0$ and all other factors are positive; a denominator is
factored with negative exponents. The factors are sorted in increasing order.
\bprog
? factor(-7/106)
%1 =
[-1  1]

[ 2 -1]

[ 7  1]

[53 -1]
@eprog\noindent By convention, $1$ is factored as \kbd{matrix(0,2)}
(the empty factorization, printed as \kbd{[;]}).

Large rational ``primes'' $ > 2^{64}$ in the factorization are in fact
\var{pseudoprimes} (see \kbd{ispseudoprime}), a priori not rigorously proven
primes. Use \kbd{isprime} to prove primality of these factors, as in
\bprog
? fa = factor(2^2^7 + 1)
%2 =
[59649589127497217 1]

[5704689200685129054721 1]

? isprime( fa[,1] )
%3 = [1, 1]~   \\ both entries are proven primes
@eprog\noindent
Another possibility is to globally set the default \tet{factor_proven}, which
will perform a rigorous primality proof for each pseudoprime factor but will
slow down PARI.

A \typ{INT} argument $D$ can be added, meaning that we only trial divide
by all primes $p < D$ and the \kbd{addprimes} entries, then skip all
expensive factorization methods. The limit $D$ must be nonnegative.
In this case, one entry in the factorization may be a composite number: all
factors less than $D^2$ and primes from the \kbd{addprimes} table
are actual primes. But (at most) one entry may not verify this criterion,
and it may be prime or composite: it is only known to be coprime to all
other entries and not a pure power..

\bprog
? factor(2^2^7 +1, 10^5)
%4 =
[340282366920938463463374607431768211457 1]
@eprog\noindent
\misctitle{Deprecated feature} Setting $D=0$ is the same
as setting it to $\kbd{primelimit} + 1$.
\smallskip

This routine uses trial division and perfect power tests, and should not be
used for huge values of $D$ (at most $10^9$, say):
\kbd{factorint(, 1 + 8)} will in general be faster. The latter does not
guarantee that all small prime factors are found, but it also finds larger
factors and in a more efficient way.
\bprog
? F = (2^2^7 + 1) * 1009 * (10^5+3); factor(F, 10^5)  \\ fast, incomplete
time = 0 ms.
%5 =
[1009 1]

[34029257539194609161727850866999116450334371 1]

? factor(F, 10^9)    \\ slow
time = 3,260 ms.
%6 =
[1009 1]

[100003 1]

[340282366920938463463374607431768211457 1]

? factorint(F, 1+8)  \\ much faster and all small primes were found
time = 8 ms.
%7 =
[1009 1]

[100003 1]

[340282366920938463463374607431768211457 1]

? factor(F)   \\ complete factorization
time = 60 ms.
%8 =
[1009 1]

[100003 1]

[59649589127497217 1]

[5704689200685129054721 1]
@eprog

\misctitle{$x \in \Q(i)$} The factorization is performed with Gaussian
primes in $\Z[i]$ and includes Gaussian units in $\{\pm1, \pm i\}$;
factors are sorted by increasing norm. Except for a possible leading unit,
the Gaussian factors are normalized: rational factors are positive and
irrational factors have positive imaginary part.

Unless \tet{factor_proven} is set, large factors are actually pseudoprimes,
not proven primes; a rational factor is prime if less than $2^{64}$ and an
irrational one if its norm is less than $2^{64}$.
\bprog
? factor(5*I)
%9 =
[  2 + I 1]

[1 + 2*I 1]
@eprog\noindent One can force the factorization of a rational number
by setting the domain $D = I$:
\bprog
? factor(-5, I)
%10 =
[      I 1]

[  2 + I 1]

[1 + 2*I 1]
? factorback(%)
%11 = -5
@eprog

\misctitle{Univariate polynomials and rational functions}
PARI can factor univariate polynomials in $K[t]$. The following base fields
$K$ are currently supported: $\Q$, $\R$, $\C$, $\Q_p$, finite fields and
number fields. See \tet{factormod} and \tet{factorff} for the algorithms used
over finite fields and \tet{nffactor} for the algorithms over number fields.
The irreducible factors are sorted by increasing degree and normalized: they
are monic except when $K = \Q$ where they are primitive in $\Z[t]$.

The content is \emph{not} included in the factorization, in particular
\kbd{factorback} will in general recover the original $x$ only up to
multiplication by an element of $K^*$: when $K\neq\Q$, this scalar is
\kbd{pollead}$(x)$ (since irreducible factors are monic); and when $K = \Q$
you can either ask for the $\Q$-content explicitly of use factorback:
\bprog
? P = t^2 + 5*t/2 + 1; F = factor(P)
%12 =
[t + 2 1]

[2*t + 1 1]

? content(P, 1) \\ Q-content
%13 = 1/2

? pollead(factorback(F)) / pollead(P)
%14 = 2
@eprog

You can specify $K$ using the optional ``domain'' argument $D$ as follows

\item $K = \Q$ : $D$ a rational number (\typ{INT} or \typ{FRAC}),

\item $K = \Z/p\Z$ with $p$ prime : $D$ a \typ{INTMOD} modulo $p$;
factoring modulo a composite number is not supported.

\item $K = \F_q$ : $D$ a \typ{FFELT} encoding the finite field; you can also
use a \typ{POLMOD} of \typ{INTMOD} modulo a prime $p$ but this is usualy
less convenient;

\item $K = \Q[X]/(T)$ a number field : $D$ a \typ{POLMOD} modulo $T$,

\item $K = \Q(i)$ (alternate syntax for special case): $D = I$,

\item $K = \Q(w)$ a quadratic number field (alternate syntax for special
case): $D$ a \typ{QUAD},

\item $K = \R$ : $D$ a real number (\typ{REAL}); truncate the factorization
at accuracy \kbd{precision}$(D)$. If $x$ is inexact and \kbd{precision}$(x)$
is less than \kbd{precision}$(D)$, then the precision of $x$ is used instead.

\item $K = \C$ : $D$ a complex number with a \typ{REAL} component, e.g.
\kbd{I * 1.}; truncate the factorization as for $K = \R$,

\item $K = \Q_p$ : $D$ a \typ{PADIC}; truncate the factorization at
$p$-adic accuracy \kbd{padicprec}$(D)$, possibly less if $x$ is inexact
with insufficient $p$-adic accuracy;

\bprog
? T = x^2+1;
? factor(T, 1);                      \\ over Q
? factor(T, Mod(1,3))                \\ over F_3
? factor(T, ffgen(ffinit(3,2,'t))^0) \\ over F_{3^2}
? factor(T, Mod(Mod(1,3), t^2+t+2))  \\ over F_{3^2}, again
? factor(T, O(3^6))                  \\ over Q_3, precision 6
? factor(T, 1.)                      \\ over R, current precision
? factor(T, I*1.)                    \\ over C
? factor(T, Mod(1, y^3-2))           \\ over Q(2^{1/3})
@eprog\noindent In most cases, it is possible and simpler to call a
specialized variant rather than use the above scheme:
\bprog
? factormod(T, 3)              \\ over F_3
? factormod(T, [t^2+t+2, 3])   \\ over F_{3^2}
? factormod(T, ffgen(3^2, 't)) \\ over F_{3^2}
? factorpadic(T, 3,6)          \\ over Q_3, precision 6
? nffactor(y^3-2, T)           \\ over Q(2^{1/3})
? polroots(T)                  \\ over C
? polrootsreal(T)              \\ over R (real polynomial)
@eprog

It is also possible to let the routine use the smallest field containing all
coefficients, taking into account quotient structures induced by
\typ{INTMOD}s and \typ{POLMOD}s (e.g.~if a coefficient in $\Z/n\Z$ is known,
all rational numbers encountered are first mapped to $\Z/n\Z$; different
moduli will produce an error):
\bprog
? T = x^2+1;
? factor(T);                         \\ over Q
? factor(T*Mod(1,3))                 \\ over F_3
? factor(T*ffgen(ffinit(3,2,'t))^0)  \\ over F_{3^2}
? factor(T*Mod(Mod(1,3), t^2+t+2))   \\ over F_{3^2}, again
? factor(T*(1 + O(3^6))              \\ over Q_3, precision 6
? factor(T*1.)                       \\ over R, current precision
? factor(T*(1.+0.*I))                \\ over C
? factor(T*Mod(1, y^3-2))            \\ over Q(2^{1/3})
@eprog\noindent Multiplying by a suitable field element equal to $1 \in K$
in this way is error-prone and is not recommanded. Factoring existing
polynomials with obvious fields of coefficients is fine, the domain
argument $D$ should be used instead ad hoc conversions.

\misctitle{Note on inexact polynomials}
Polynomials with inexact coefficients
(e.g. floating point or $p$-adic numbers)
are first rounded to an exact representation, then factored to (potentially)
infinite accuracy and we return a truncated approximation of that
virtual factorization. To avoid pitfalls, we advise to only factor
\emph{exact} polynomials:
\bprog
? factor(x^2-1+O(2^2)) \\ rounded to x^2 + 3, irreducible in Q_2
%1 =
[(1 + O(2^2))*x^2 + O(2^2)*x + (1 + 2 + O(2^2)) 1]

? factor(x^2-1+O(2^3)) \\ rounded to x^2 + 7, reducible !
%2 =
[  (1 + O(2^3))*x + (1 + 2 + O(2^3)) 1]

[(1 + O(2^3))*x + (1 + 2^2 + O(2^3)) 1]

? factor(x^2-1, O(2^2)) \\ no ambiguity now
%3 =
[    (1 + O(2^2))*x + (1 + O(2^2)) 1]

[(1 + O(2^2))*x + (1 + 2 + O(2^2)) 1]
@eprog

\misctitle{Note about inseparable polynomials} Polynomials with inexact
coefficients are considered to be squarefree: indeed, there exist a
squarefree polynomial arbitrarily close to the input, and they cannot be
distinguished at the input accuracy. This means that irreducible factors are
repeated according to their apparent multiplicity. On the contrary, using a
specialized function such as \kbd{factorpadic} with an \emph{exact} rational
input yields the correct multiplicity when the (now exact) input is not
separable. Compare:
\bprog
? factor(z^2 + O(5^2)))
%1 =
[(1 + O(5^2))*z + O(5^2) 1]

[(1 + O(5^2))*z + O(5^2) 1]
? factor(z^2, O(5^2))
%2 =
[1 + O(5^2))*z + O(5^2) 2]
@eprog

\misctitle{Multivariate polynomials and rational functions}
PARI recursively factors \emph{multivariate} polynomials in
$K[t_1,\dots, t_d]$ for the same fields $K$ as above and the argument $D$
is used in the same way to specify $K$. The irreducible factors are sorted
by their main variable (least priority first) then by increasing degree.

\bprog
? factor(x^2 + y^2, Mod(1,5))
%1 =
[          x + Mod(2, 5)*y 1]

[Mod(1, 5)*x + Mod(3, 5)*y 1]

? factor(x^2 + y^2, O(5^2))
%2 =
[  (1 + O(5^2))*x + (O(5^2)*y^2 + (2 + 5 + O(5^2))*y + O(5^2)) 1]

[(1 + O(5^2))*x + (O(5^2)*y^2 + (3 + 3*5 + O(5^2))*y + O(5^2)) 1]

? lift(%)
%3 =
[ x + 7*y 1]

[x + 18*y 1]
@eprog\noindent Note that the implementation does not really support inexact
real fields ($\R$ or $\C$) and usually misses factors even if the input
is exact:
\bprog
? factor(x^2 + y^2, I)  \\ over Q(i)
%4 =
[x - I*y 1]

[x + I*y 1]

? factor(x^2 + y^2, I*1.) \\ over C
%5 =
[x^2 + y^2 1]
@eprog

The library syntax is \fun{GEN}{factor0}{GEN x, GEN D = NULL}.

\fun{GEN}{factor}{GEN x}
\fun{GEN}{boundfact}{GEN x, ulong lim}.

\subsec{factorback$(f,\{e\})$}\kbdsidx{factorback}\label{se:factorback}
Gives back the factored object corresponding to a factorization. The
integer $1$ corresponds to the empty factorization.

If $e$ is present, $e$ and $f$ must be vectors of the same length ($e$ being
integral), and the corresponding factorization is the product of the
$f[i]^{e[i]}$.

If not, and $f$ is vector, it is understood as in the preceding case with $e$
a vector of 1s: we return the product of the $f[i]$. Finally, $f$ can be a
regular factorization, as produced with any \kbd{factor} command. A few
examples:
\bprog
? factor(12)
%1 =
[2 2]

[3 1]

? factorback(%)
%2 = 12
? factorback([2,3], [2,1])   \\ 2^2 * 3^1
%3 = 12
? factorback([5,2,3])
%4 = 30
@eprog

The library syntax is \fun{GEN}{factorback2}{GEN f, GEN e = NULL}.
Also available is \fun{GEN}{factorback}{GEN f} (case $e = \kbd{NULL}$).

\subsec{factorcantor$(x,p)$}\kbdsidx{factorcantor}\label{se:factorcantor}
This function is obsolete, use factormod.

The library syntax is \fun{GEN}{factmod}{GEN x, GEN p}.

\subsec{factorff$(x,\{p\},\{a\})$}\kbdsidx{factorff}\label{se:factorff}
Obsolete, kept for backward compatibility: use factormod.

The library syntax is \fun{GEN}{factorff}{GEN x, GEN p = NULL, GEN a = NULL}.

\subsec{factorial$(x)$}\kbdsidx{factorial}\label{se:factorial}
Factorial of $x$. The expression $x!$ gives a result which is an integer,
while $\kbd{factorial}(x)$ gives a real number.

The library syntax is \fun{GEN}{mpfactr}{long x, long prec}.
\fun{GEN}{mpfact}{long x} returns $x!$ as a \typ{INT}.

\subsec{factorint$(x,\{\fl=0\})$}\kbdsidx{factorint}\label{se:factorint}
Factors the integer $n$ into a product of
pseudoprimes (see \kbd{ispseudoprime}), using a combination of the
\idx{Shanks SQUFOF} and \idx{Pollard Rho} method (with modifications due to
Brent), \idx{Lenstra}'s \idx{ECM} (with modifications by Montgomery), and
\idx{MPQS} (the latter adapted from the \idx{LiDIA} code with the kind
permission of the LiDIA maintainers), as well as a search for pure powers.
The output is a two-column matrix as for \kbd{factor}: the first column
contains the ``prime'' divisors of $n$, the second one contains the
(positive) exponents.

By convention $0$ is factored as $0^1$, and $1$ as the empty factorization;
also the divisors are by default not proven primes if they are larger than
$2^{64}$, they only failed the BPSW compositeness test (see
\tet{ispseudoprime}). Use \kbd{isprime} on the result if you want to
guarantee primality or set the \tet{factor_proven} default to $1$.
Entries of the private prime tables (see \tet{addprimes}) are also included
as is.

This gives direct access to the integer factoring engine called by most
arithmetical functions. \fl\ is optional; its binary digits mean 1: avoid
MPQS, 2: skip first stage ECM (we may still fall back to it later), 4: avoid
Rho and SQUFOF, 8: don't run final ECM (as a result, a huge composite may be
declared to be prime). Note that a (strong) probabilistic primality test is
used; thus composites might not be detected, although no example is known.

You are invited to play with the flag settings and watch the internals at
work by using \kbd{gp}'s \tet{debug} default parameter (level 3 shows
just the outline, 4 turns on time keeping, 5 and above show an increasing
amount of internal details).

The library syntax is \fun{GEN}{factorint}{GEN x, long flag}.

\subsec{factormod$(f,\{D\},\{\fl=0\})$}\kbdsidx{factormod}\label{se:factormod}
Factors the polynomial $f$ over the finite field defined by the domain
$D$ as follows:

\item $D = p$ a prime: factor over $\F_p$;

\item $D = [T,p]$ for a prime $p$ and $T(y)$ an irreducible polynomial over
$\F_p$: factor over $\F_p[y]/(T)$ (as usual the main variable of $T$ must have
lower priority than the main variable of $f$);

\item $D$ a \typ{FFELT}: factor over the attached field;

\item $D$ omitted: factor over the field of definition of $f$, which
must be a finite field.

The coefficients of $f$ must be operation-compatible with the corresponding
finite field. The result is a two-column matrix, the first column being the
irreducible polynomials dividing $f$, and the second the exponents.
By convention, the $0$ polynomial factors as $0^1$; a nonzero constant
polynomial has empty factorization, a $0\times 2$ matrix. The irreducible
factors are ordered by increasing degree and the result is canonical: it will
not change across multiple calls or sessions.

\bprog
? factormod(x^2 + 1, 3)  \\ over F_3
%1 =
[Mod(1, 3)*x^2 + Mod(1, 3) 1]
? liftall( factormod(x^2 + 1, [t^2+1, 3]) ) \\ over F_9
%2 =
[  x + t 1]

[x + 2*t 1]

\\ same, now letting GP choose a model
? T = ffinit(3,2,'t)
%3 = Mod(1, 3)*t^2 + Mod(1, 3)*t + Mod(2, 3)
? liftall( factormod(x^2 + 1, [T, 3]) )
%4 =  \\ t is a root of T !
[  x + (t + 2) 1]

[x + (2*t + 1) 1]
? t = ffgen(t^2+Mod(1,3)); factormod(x^2 + t^0) \\ same using t_FFELT
%5 =
[  x + t 1]

[x + 2*t 1]
? factormod(x^2+Mod(1,3))
%6 =
[Mod(1, 3)*x^2 + Mod(1, 3) 1]
? liftall( factormod(x^2 + Mod(Mod(1,3), y^2+1)) )
%7 =
[  x + y 1]

[x + 2*y 1]
@eprog

If $\fl$ is nonzero, outputs only the \emph{degrees} of the irreducible
polynomials (for example to compute an $L$-function). By convention, a
constant polynomial (including the $0$ polynomial) has empty factorization.
The degrees appear in increasing order but need not correspond to the
ordering with $\fl =0$ when multiplicities are present.
\bprog
? f = x^3 + 2*x^2 + x + 2;
? factormod(f, 5)  \\ (x+2)^2 * (x+3)
%1 =
[Mod(1, 5)*x + Mod(2, 5) 2]

[Mod(1, 5)*x + Mod(3, 5) 1]
? factormod(f, 5, 1) \\ (deg 1) * (deg 1)^2
%2 =
[1 1]

[1 2]
@eprog

The library syntax is \fun{GEN}{factormod0}{GEN f, GEN D = NULL, long flag}.

\subsec{factormodDDF$(f,\{D\})$}\kbdsidx{factormodDDF}\label{se:factormodDDF}
Distinct-degree factorization of the squarefree polynomial $f$ over the
finite field defined by the domain $D$ as follows:

\item $D = p$ a prime: factor over $\F_p$;

\item $D = [T,p]$ for a prime $p$ and $T$ an irreducible polynomial over
$\F_p$: factor over $\F_p[x]/(T)$;

\item $D$ a \typ{FFELT}: factor over the attached field;

\item $D$ omitted: factor over the field of definition of $f$, which
must be a finite field.

If $f$ is not squarefree, the result is undefined.
The coefficients of $f$ must be operation-compatible with the corresponding
finite field. The result is a two-column matrix:

\item the first column contains monic (squarefree, pairwise coprime)
polynomials dividing $f$, all of whose irreducible factors have
the same degree $d$;

\item the second column contains the degrees of the irreducible factors.

The factorization is ordered by increasing degree $d$ of irreducible factors,
and the result is obviously canonical.
This function is somewhat faster than full factorization.

\bprog
? f = (x^2 + 1) * (x^2-1);
? factormodSQF(f,3) \\ squarefree over F_3
%2 =
[Mod(1, 3)*x^4 + Mod(2, 3) 1]

? factormodDDF(f, 3)
%3 =
[Mod(1, 3)*x^2 + Mod(2, 3) 1]  \\ two degree 1 factors

[Mod(1, 3)*x^2 + Mod(1, 3) 2]  \\ irred of degree 2

? for(i=1,10^5,factormodDDF(f,3))
time = 424 ms.
? for(i=1,10^5,factormod(f,3))  \\ full factorization is a little slower
time = 464 ms.

? liftall( factormodDDF(x^2 + 1, [3, t^2+1]) ) \\ over F_9
%6 =
[x^2 + 1 1] \\ product of two degree 1 factors

? t = ffgen(t^2+Mod(1,3)); factormodDDF(x^2 + t^0) \\ same using t_FFELT
%7 =
[x^2 + 1 1]

? factormodDDF(x^2-Mod(1,3))
%8 =
[Mod(1, 3)*x^2 + Mod(2, 3) 1]

@eprog

The library syntax is \fun{GEN}{factormodDDF}{GEN f, GEN D = NULL}.

\subsec{factormodSQF$(f,\{D\})$}\kbdsidx{factormodSQF}\label{se:factormodSQF}
Squarefree factorization of the polynomial $f$ over the finite field
defined by the domain $D$ as follows:

\item $D = p$ a prime: factor over $\F_p$;

\item $D = [T,p]$ for a prime $p$ and $T$ an irreducible polynomial over
$\F_p$: factor over $\F_p[x]/(T)$;

\item $D$ a \typ{FFELT}: factor over the attached field;

\item $D$ omitted: factor over the field of definition of $f$, which
must be a finite field.

The coefficients of $f$ must be operation-compatible with the corresponding
finite field. The result is a two-column matrix:

\item the first column contains monic squarefree pairwise coprime polynomials
dividing $f$;

\item the second column contains the power to which the polynomial in column
$1$ divides $f$;

This is somewhat faster than full factorization. The factors are ordered by
increasing exponent and the result is obviously canonical.

\bprog
? f = (x^2 + 1)^3 * (x^2-1)^2;
? factormodSQF(f, 3)  \\ over F_3
%1 =
[Mod(1, 3)*x^2 + Mod(2, 3) 2]

[Mod(1, 3)*x^2 + Mod(1, 3) 3]

? for(i=1,10^5,factormodSQF(f,3))
time = 192 ms.
? for(i=1,10^5,factormod(f,3))  \\ full factorization is slower
time = 409 ms.

? liftall( factormodSQF((x^2 + 1)^3, [3, t^2+1]) ) \\ over F_9
%4 =
[x^2 + 1 3]

? t = ffgen(t^2+Mod(1,3)); factormodSQF((x^2 + t^0)^3) \\ same using t_FFELT
%5 =
[x^2 + 1 3]

? factormodSQF(x^8 + x^7 + x^6 + x^2 + x + Mod(1,2))
%6 =
[                Mod(1, 2)*x + Mod(1, 2) 2]

[Mod(1, 2)*x^2 + Mod(1, 2)*x + Mod(1, 2) 3]
@eprog

The library syntax is \fun{GEN}{factormodSQF}{GEN f, GEN D = NULL}.

\subsec{factormodcyclo$(n, p, \{\var{single}=0\}, \{v='x\})$}\kbdsidx{factormodcyclo}\label{se:factormodcyclo}
Factors $n$-th cyclotomic polynomial $\Phi_n(x)$ mod $p$,
where $p$ is a prime number not dividing $n$.
Much faster than \kbd{factormod(polcyclo(n), p)}; the irreducible
factors should be identical and given in the same order.
If \var{single} is set, return a single irreducible factor; else (default)
return all the irreducible factors. Note that repeated calls of this
function with the \var{single} flag set may return different results because
the algorithm is probabilistic. Algorithms used are as follows.

Let $F=\Q(\zeta_n)$. Let $K$ be the splitting field of $p$ in $F$ and $e$ the
conductor of $K$. Then $\Phi_n(x)$ and $\Phi_e(x)$ have the same
number of irreducible factors mod $p$ and there is a simple algorithm
constructing irreducible factors of $\Phi_n(x)$ from irreducible
factors of $\Phi_e(x)$. So we may assume $n$ is equal to the
conductor of $K$.
Let $d$ be the order of $p$ in $(\Z/n\Z)^{\times}$ and $\varphi(n)=df$.
Then $\Phi_n(x)$ has $f$ irreducible factors $g_i(x)\;(1\leq i\leq f)$
of degree $d$ over $\F_p$ or $\Z_p$.

\item If $d$ is small, then we factor $g_i(x)$ into
$d$ linear factors $g_{ij}(x)$, $1\leq j\leq d$ in $\F_q[x]\;(q=p^d)$ and
construct $G_i(x)=\prod_{j=1}^d g_{ij}(x)\in \F_q[x]$.
Then $G_i(x)\in\F_p[x]$ and $g_i(x)=G_i(x)$.

\item If $f$ is small, then we work in $K$, which is a Galois extension of
degree $f$ over $\Q$. The Gaussian period
$\theta_k=\text{Tr}_{F/K}(\zeta_n^{k})$ is a sum of $k$-th power of roots of
$g_i(x)$ and $K=\Q(\theta_1)$.

Now, for each $k$, there is a polynomial $T_k(x)\in\Q[x]$ satisfying
$\theta_k=T_k(\theta_1)$ because all $\theta_k$ are in $K$. Let $T(x)\in\Z[x]$
be the minimal polynomial of $\theta_1$ over $\Q$. We get $\theta_1$ mod $p$
from $T(x)$ and construct $\theta_1,\cdots,\theta_d$ mod $p$ using $T_k(x)$.
Finally we recover $g_i(x)$ from $\theta_1,\cdots,\theta_d$ by Newton's
formula.

\bprog
? lift(factormodcyclo(15, 11))
%1 = [x^2 + 9*x + 4, x^2 + 4*x + 5, x^2 + 3*x + 9, x^2 + 5*x + 3]
? factormodcyclo(15, 11, 1) \\ single
%2 = Mod(1, 11)*x^2 + Mod(5, 11)*x + Mod(3, 11)
? z1 = lift(factormod(polcyclo(12345),11311)[,1]);
time = 32,498 ms.
? z2 = factormodcyclo(12345,11311);
time = 47 ms.
? z1 == z2
%4 = 1
@eprog

The library syntax is \fun{GEN}{factormodcyclo}{long n, GEN p, long single, long v = -1} where \kbd{v} is a variable number.

\subsec{ffcompomap$(f, g)$}\kbdsidx{ffcompomap}\label{se:ffcompomap}
Let $k$, $l$, $m$ be three finite fields and $f$ a (partial) map from $l$
to $m$ and $g$ a (partial) map from $k$ to $l$, return the (partial) map $f
\circ g$ from $k$ to $m$.
\bprog
a = ffgen([3,5],'a); b = ffgen([3,10],'b); c = ffgen([3,20],'c);
m = ffembed(a, b); n = ffembed(b, c);
rm = ffinvmap(m); rn = ffinvmap(n);
nm = ffcompomap(n,m);
ffmap(n,ffmap(m,a)) == ffmap(nm, a)
%5 = 1
ffcompomap(rm, rn) == ffinvmap(nm)
%6 = 1
@eprog

The library syntax is \fun{GEN}{ffcompomap}{GEN f, GEN g}.

\subsec{ffembed$(a, b)$}\kbdsidx{ffembed}\label{se:ffembed}
Given two finite fields elements $a$ and $b$, return a \var{map}
embedding the definition field of $a$ to the definition field of $b$.
Assume that the latter contains the former.
\bprog
? a = ffgen([3,5],'a);
? b = ffgen([3,10],'b);
? m = ffembed(a, b);
? A = ffmap(m, a);
? minpoly(A) == minpoly(a)
%5 = 1
@eprog

The library syntax is \fun{GEN}{ffembed}{GEN a, GEN b}.

\subsec{ffextend$(a, P, \{v\})$}\kbdsidx{ffextend}\label{se:ffextend}
Extend the field $K$ of definition of $a$ by a root of the polynomial
$P\in K[X]$ assumed to be irreducible over $K$.  Return $[r, m]$ where $r$
is a root of $P$ in the extension field $L$ and $m$ is a map from $K$ to $L$,
see \kbd{ffmap}.
If $v$ is given, the variable name is used to display the generator of $L$,
else the name of the variable of $P$ is used.
A generator of $L$ can be recovered using $b=ffgen(r)$.
The image of $P$ in $L[X]$ can be recovered using $PL=ffmap(m,P)$.
\bprog
? a = ffgen([3,5],'a);
? P = x^2-a; polisirreducible(P)
%2 = 1
? [r,m] = ffextend(a, P, 'b);
? r
%3 = b^9+2*b^8+b^7+2*b^6+b^4+1
? subst(ffmap(m, P), x, r)
%4 = 0
? ffgen(r)
%5 = b
@eprog

The library syntax is \fun{GEN}{ffextend}{GEN a, GEN P, long v = -1} where \kbd{v} is a variable number.

\subsec{fffrobenius$(m,\{n=1\})$}\kbdsidx{fffrobenius}\label{se:fffrobenius}
Return the $n$-th power of the Frobenius map over the field of definition
of $m$.
\bprog
? a = ffgen([3,5],'a);
? f = fffrobenius(a);
? ffmap(f,a) == a^3
%3 = 1
? g = fffrobenius(a, 5);
? ffmap(g,a) == a
%5 = 1
? h = fffrobenius(a, 2);
? h == ffcompomap(f,f)
%7 = 1
@eprog

The library syntax is \fun{GEN}{fffrobenius}{GEN m, long n}.

\subsec{ffgen$(k,\{v = 'x\})$}\kbdsidx{ffgen}\label{se:ffgen}
Return a generator for the finite field $k$ as a \typ{FFELT}.
The field $k$ can be given by

\item its order $q$

\item the pair $[p,f]$ where $q=p^f$

\item a monic irreducible polynomial with \typ{INTMOD} coefficients modulo a
      prime.

\item a \typ{FFELT} belonging to $k$.

If \kbd{v} is given, the variable name is used to display $g$, else the
variable of the polynomial or the \typ{FFELT} is used, else $x$ is used.

When only the order is specified, the function uses the polynomial generated
by \kbd{ffinit} and is deterministic: two calls to the function with the
same parameters will always give the same generator.

For efficiency, the characteristic is not checked to be prime; similarly
if a polynomial is given, we do not check whether it is irreducible.

To obtain a multiplicative generator, call \kbd{ffprimroot} on the result.

\bprog
? g = ffgen(16, 't);
? g.mod \\ recover the underlying polynomial.
%2 = t^4+t^3+t^2+t+1
? g.pol \\ lift g as a t_POL
%3 = t
? g.p \\ recover the characteristic
%4 = 2
? fforder(g) \\ g is not a multiplicative generator
%5 = 5
? a = ffprimroot(g) \\ recover a multiplicative generator
%6 = t^3+t^2+t
? fforder(a)
%7 = 15
@eprog

The library syntax is \fun{GEN}{ffgen}{GEN k, long v = -1} where \kbd{v} is a variable number.

To create a generator for a prime finite field, the function
\fun{GEN}{p_to_GEN}{GEN p, long v} returns \kbd{ffgen(p,v)\^{}0}.

\subsec{ffinit$(p,n,\{v='x\})$}\kbdsidx{ffinit}\label{se:ffinit}
Computes a monic polynomial of degree $n$ which is irreducible over
 $\F_p$, where $p$ is assumed to be prime. This function uses a fast variant
 of Adleman and Lenstra's algorithm.

It is useful in conjunction with \tet{ffgen}; for instance if
\kbd{P = ffinit(3,2)}, you can represent elements in $\F_{3^2}$ in term of
\kbd{g = ffgen(P,'t)}. This can be abbreviated as
\kbd{g = ffgen(3\pow2, 't)}, where the defining polynomial $P$ can be later
recovered as \kbd{g.mod}.

The library syntax is \fun{GEN}{ffinit}{GEN p, long n, long v = -1} where \kbd{v} is a variable number.

\subsec{ffinvmap$(m)$}\kbdsidx{ffinvmap}\label{se:ffinvmap}
$m$ being a map from $K$ to $L$ two finite fields, return the partial map
$p$ from $L$ to $K$ such that for all $k\in K$, $p(m(k))=k$.
\bprog
? a = ffgen([3,5],'a);
? b = ffgen([3,10],'b);
? m = ffembed(a, b);
? p = ffinvmap(m);
? u = random(a);
? v = ffmap(m, u);
? ffmap(p, v^2+v+2) == u^2+u+2
%7 = 1
? ffmap(p, b)
%8 = []
@eprog

The library syntax is \fun{GEN}{ffinvmap}{GEN m}.

\subsec{fflog$(x,g,\{o\})$}\kbdsidx{fflog}\label{se:fflog}
Discrete logarithm of the finite field element $x$ in base $g$,
i.e.~an $e$ in $\Z$ such that $g^e = o$. If
present, $o$ represents the multiplicative order of $g$, see
\secref{se:DLfun}; the preferred format for
this parameter is \kbd{[ord, factor(ord)]}, where \kbd{ord} is the
order of $g$. It may be set as a side effect of calling \tet{ffprimroot}.
The result is undefined if $e$ does not exist. This function uses

\item a combination of generic discrete log algorithms (see \tet{znlog})

\item a cubic sieve index calculus algorithm for large fields of degree at
least $5$.

\item Coppersmith's algorithm for fields of characteristic at most $5$.

\bprog
? t = ffgen(ffinit(7,5));
? o = fforder(t)
%2 = 5602   \\@com \emph{not} a primitive root.
? fflog(t^10,t)
%3 = 10
? fflog(t^10,t, o)
%4 = 10
? g = ffprimroot(t, &o);
? o   \\ order is 16806, bundled with its factorization matrix
%6 = [16806, [2, 1; 3, 1; 2801, 1]]
? fforder(g, o)
%7 = 16806
? fflog(g^10000, g, o)
%8 = 10000
@eprog

The library syntax is \fun{GEN}{fflog}{GEN x, GEN g, GEN o = NULL}.

\subsec{ffmap$(m, x)$}\kbdsidx{ffmap}\label{se:ffmap}
Given a (partial) map $m$ between two finite fields, return the image of
$x$ by $m$. The function is applied recursively to the component of vectors,
matrices and polynomials. If $m$ is a partial map that is not defined at $x$,
return $[]$.
\bprog
? a = ffgen([3,5],'a);
? b = ffgen([3,10],'b);
? m = ffembed(a, b);
? P = x^2+a*x+1;
? Q = ffmap(m,P);
? ffmap(m,poldisc(P)) == poldisc(Q)
%6 = 1
@eprog

The library syntax is \fun{GEN}{ffmap}{GEN m, GEN x}.

\subsec{ffmaprel$(m, x)$}\kbdsidx{ffmaprel}\label{se:ffmaprel}
Given a (partial) map $m$ between two finite fields, express $x$ as an
algebraic element over the codomain of $m$ in a way which is compatible
with $m$.
The function is applied recursively to the component of vectors,
matrices and polynomials.
\bprog
? a = ffgen([3,5],'a);
? b = ffgen([3,10],'b);
? m = ffembed(a, b);
? mi= ffinvmap(m);
? R = ffmaprel(mi,b)
%5 = Mod(b,b^2+(a+1)*b+(a^2+2*a+2))
@eprog
In particular, this function can be used to compute the relative minimal
polynomial, norm and trace:
\bprog
? minpoly(R)
%6 = x^2+(a+1)*x+(a^2+2*a+2)
? trace(R)
%7 = 2*a+2
? norm(R)
%8 = a^2+2*a+2
@eprog

The library syntax is \fun{GEN}{ffmaprel}{GEN m, GEN x}.

\subsec{ffnbirred$(q,n,\{\var{fl}=0\})$}\kbdsidx{ffnbirred}\label{se:ffnbirred}
Computes the number of monic irreducible polynomials over $\F_q$ of degree exactly $n$,
($\fl=0$ or omitted) or at most $n$ ($\fl=1$).

The library syntax is \fun{GEN}{ffnbirred0}{GEN q, long n, long fl}.
Also available are
 \fun{GEN}{ffnbirred}{GEN q, long n} (for $\fl=0$)
 and \fun{GEN}{ffsumnbirred}{GEN q, long n} (for $\fl=1$).

\subsec{fforder$(x,\{o\})$}\kbdsidx{fforder}\label{se:fforder}
Multiplicative order of the finite field element $x$.  If $o$ is
present, it represents a multiple of the order of the element,
see \secref{se:DLfun}; the preferred format for
this parameter is \kbd{[N, factor(N)]}, where \kbd{N} is the cardinality
of the multiplicative group of the underlying finite field.
\bprog
? t = ffgen(ffinit(nextprime(10^8), 5));
? g = ffprimroot(t, &o);  \\@com o will be useful!
? fforder(g^1000000, o)
time = 0 ms.
%5 = 5000001750000245000017150000600250008403
? fforder(g^1000000)
time = 16 ms. \\@com noticeably slower, same result of course
%6 = 5000001750000245000017150000600250008403
@eprog

The library syntax is \fun{GEN}{fforder}{GEN x, GEN o = NULL}.

\subsec{ffprimroot$(x, \{\&o\})$}\kbdsidx{ffprimroot}\label{se:ffprimroot}
Return a primitive root of the multiplicative
group of the definition field of the finite field element $x$ (not necessarily
the same as the field generated by $x$). If present, $o$ is set to
a vector \kbd{[ord, fa]}, where \kbd{ord} is the order of the group
and \kbd{fa} its factorization \kbd{factor(ord)}. This last parameter is
useful in \tet{fflog} and \tet{fforder}, see \secref{se:DLfun}.
\bprog
? t = ffgen(ffinit(nextprime(10^7), 5));
? g = ffprimroot(t, &o);
? o[1]
%3 = 100000950003610006859006516052476098
? o[2]
%4 =
[2 1]

[7 2]

[31 1]

[41 1]

[67 1]

[1523 1]

[10498781 1]

[15992881 1]

[46858913131 1]

? fflog(g^1000000, g, o)
time = 1,312 ms.
%5 = 1000000
@eprog

The library syntax is \fun{GEN}{ffprimroot}{GEN x, GEN *o = NULL}.

\subsec{gcd$(x,\{y\})$}\kbdsidx{gcd}\label{se:gcd}
Creates the greatest common divisor of $x$ and $y$.
If you also need the $u$ and $v$ such that $x*u + y*v = \gcd(x,y)$,
use the \tet{gcdext} function. $x$ and $y$ can have rather quite general
types, for instance both rational numbers. If $y$ is omitted and $x$ is a
vector, returns the $\text{gcd}$ of all components of $x$, i.e.~this is
equivalent to \kbd{content(x)}.

When $x$ and $y$ are both given and one of them is a vector/matrix type,
the GCD is again taken recursively on each component, but in a different way.
If $y$ is a vector, resp.~matrix, then the result has the same type as $y$,
and components equal to \kbd{gcd(x, y[i])}, resp.~\kbd{gcd(x, y[,i])}. Else
if $x$ is a vector/matrix the result has the same type as $x$ and an
analogous definition. Note that for these types, \kbd{gcd} is not
commutative.

The algorithm used is a naive \idx{Euclid} except for the following inputs:

\item integers: use modified right-shift binary (``plus-minus''
variant).

\item univariate polynomials with coefficients in the same number
field (in particular rational): use modular gcd algorithm.

\item general polynomials: use the \idx{subresultant algorithm} if
coefficient explosion is likely (non modular coefficients).

If $u$ and $v$ are polynomials in the same variable with \emph{inexact}
coefficients, their gcd is defined to be scalar, so that
\bprog
? a = x + 0.0; gcd(a,a)
%1 = 1
? b = y*x + O(y); gcd(b,b)
%2 = y
? c = 4*x + O(2^3); gcd(c,c)
%3 = 4
@eprog\noindent A good quantitative check to decide whether such a
gcd ``should be'' nontrivial, is to use \tet{polresultant}: a value
close to $0$ means that a small deformation of the inputs has nontrivial gcd.
You may also use \tet{gcdext}, which does try to compute an approximate gcd
$d$ and provides $u$, $v$ to check whether $u x + v y$ is close to $d$.

The library syntax is \fun{GEN}{ggcd0}{GEN x, GEN y = NULL}.
Also available are \fun{GEN}{ggcd}{GEN x, GEN y}, if \kbd{y} is not
\kbd{NULL}, and \fun{GEN}{content}{GEN x}, if $\kbd{y} = \kbd{NULL}$.

\subsec{gcdext$(x,y)$}\kbdsidx{gcdext}\label{se:gcdext}
Returns $[u,v,d]$ such that $d$ is the gcd of $x,y$,
$x*u+y*v=\gcd(x,y)$, and $u$ and $v$ minimal in a natural sense.
The arguments must be integers or polynomials. \sidx{extended gcd}
\sidx{Bezout relation}
\bprog
? [u, v, d] = gcdext(32,102)
%1 = [16, -5, 2]
? d
%2 = 2
? gcdext(x^2-x, x^2+x-2)
%3 = [-1/2, 1/2, x - 1]
@eprog

If $x,y$ are polynomials in the same variable and \emph{inexact}
coefficients, then compute $u,v,d$ such that $x*u+y*v = d$, where $d$
approximately divides both and $x$ and $y$; in particular, we do not obtain
\kbd{gcd(x,y)} which is \emph{defined} to be a scalar in this case:
\bprog
? a = x + 0.0; gcd(a,a)
%1 = 1

? gcdext(a,a)
%2 = [0, 1, x + 0.E-28]

? gcdext(x-Pi, 6*x^2-zeta(2))
%3 = [-6*x - 18.8495559, 1, 57.5726923]
@eprog\noindent For inexact inputs, the output is thus not well defined
mathematically, but you obtain explicit polynomials to check whether the
approximation is close enough for your needs.

The library syntax is \fun{GEN}{gcdext0}{GEN x, GEN y}.

\subsec{halfgcd$(x,y)$}\kbdsidx{halfgcd}\label{se:halfgcd}
Let inputs $x$ and $y$ be both integers, or both polynomials in the same
variable. Return a vector \kbd{[M, [a,b]\til]}, where $M$ is an invertible
$2\times 2$ matrix such that \kbd{M*[x,y]\til = [a,b]\til}, where $b$ is
small. More precisely,

\item polynomial case: $\det M$ has degree $0$ and we
have $$\deg a \geq \ceil{\max(\deg x,\deg y))/2} > \deg b.$$

\item integer case: $\det M = \pm 1$ and we have
$$a \geq \ceil{\sqrt{\max(|x|,|y|)}} > b.$$
Assuming $x$ and $y$ are nonnegative, then $M^{-1}$ has nonnegative
coefficients, and $\det M$ is equal to the sign of both main diagonal terms
$M[1,1]$ and $M[2,2]$.

The library syntax is \fun{GEN}{ghalfgcd}{GEN x, GEN y}.

\subsec{hilbert$(x,y,\{p\})$}\kbdsidx{hilbert}\label{se:hilbert}
\idx{Hilbert symbol} of $x$ and $y$ modulo the prime $p$, $p=0$ meaning
the place at infinity (the result is undefined if $p\neq 0$ is not prime).

It is possible to omit $p$, in which case we take $p = 0$ if both $x$
and $y$ are rational, or one of them is a real number. And take $p = q$
if one of $x$, $y$ is a \typ{INTMOD} modulo $q$ or a $q$-adic. (Incompatible
types will raise an error.)

The library syntax is \fun{long}{hilbert}{GEN x, GEN y, GEN p = NULL}.

\subsec{isfundamental$(D)$}\kbdsidx{isfundamental}\label{se:isfundamental}
True (1) if $D$ is equal to 1 or to the discriminant of a quadratic
field, false (0) otherwise. $D$ can be input in factored form as for
arithmetic functions:
\bprog
? isfundamental(factor(-8))
%1 = 1
\\ count fundamental discriminants up to 10^8
? c = 0; forfactored(d = 1, 10^8, if (isfundamental(d), c++)); c
time = 40,840 ms.
%2 = 30396325
? c = 0; for(d = 1, 10^8, if (isfundamental(d), c++)); c
time = 1min, 33,593 ms. \\ slower !
%3 = 30396325
@eprog

The library syntax is \fun{long}{isfundamental}{GEN D}.

\subsec{ispolygonal$(x,s,\{\&N\})$}\kbdsidx{ispolygonal}\label{se:ispolygonal}
True (1) if the integer $x$ is an s-gonal number, false (0) if not.
The parameter $s > 2$ must be a \typ{INT}. If $N$ is given, set it to $n$
if $x$ is the $n$-th $s$-gonal number.
\bprog
? ispolygonal(36, 3, &N)
%1 = 1
? N
@eprog

The library syntax is \fun{long}{ispolygonal}{GEN x, GEN s, GEN *N = NULL}.

\subsec{ispower$(x,\{k\},\{\&n\})$}\kbdsidx{ispower}\label{se:ispower}
If $k$ is given, returns true (1) if $x$ is a $k$-th power, false
(0) if not. What it means to be a $k$-th power depends on the type of
$x$; see \tet{issquare} for details.

If $k$ is omitted, only integers and fractions are allowed for $x$ and the
function returns the maximal $k \geq 2$ such that $x = n^k$ is a perfect
power, or 0 if no such $k$ exist; in particular \kbd{ispower(-1)},
\kbd{ispower(0)}, and \kbd{ispower(1)} all return $0$.

If a third argument $\&n$ is given and $x$ is indeed a $k$-th power, sets
$n$ to a $k$-th root of $x$.

\noindent For a \typ{FFELT} \kbd{x}, instead of omitting \kbd{k} (which is
not allowed for this type), it may be natural to set
\bprog
k = (x.p ^ x.f - 1) / fforder(x)
@eprog

The library syntax is \fun{long}{ispower}{GEN x, GEN k = NULL, GEN *n = NULL}.
Also available is
\fun{long}{gisanypower}{GEN x, GEN *pty} ($k$ omitted).

\subsec{ispowerful$(x)$}\kbdsidx{ispowerful}\label{se:ispowerful}
True (1) if $x$ is a powerful integer, false (0) if not;
an integer is powerful if and only if its valuation at all primes dividing
$x$ is greater than 1.
\bprog
? ispowerful(50)
%1 = 0
? ispowerful(100)
%2 = 1
? ispowerful(5^3*(10^1000+1)^2)
%3 = 1
@eprog

The library syntax is \fun{long}{ispowerful}{GEN x}.

\subsec{isprime$(x,\{\fl=0\})$}\kbdsidx{isprime}\label{se:isprime}
True (1) if $x$ is a prime
number, false (0) otherwise. A prime number is a positive integer having
exactly two distinct divisors among the natural numbers, namely 1 and
itself.

This routine proves or disproves rigorously that a number is prime, which can
be very slow when $x$ is indeed a large prime integer. For instance
a $1000$ digits prime should require 15 to 30 minutes with default algorithms.
Use \tet{ispseudoprime} to quickly check for compositeness. Use
\tet{primecert} in order to obtain a primality proof instead of a yes/no
answer; see also \kbd{factor}.

The function accepts vector/matrices arguments, and is then
applied componentwise.

If $\fl=0$, use a combination of

\item Baillie-Pomerance-Selfridge-Wagstaff compositeness test
(see \tet{ispseudoprime}),

\item Selfridge ``$p-1$'' test if $x-1$ is smooth enough,

\item Adleman-Pomerance-Rumely-Cohen-Lenstra (APRCL) for general
medium-sized $x$ (less than 1500 bits),

\item Atkin-Morain's Elliptic Curve Primality Prover (ECPP) for general
large $x$.

If $\fl=1$, use Selfridge-Pocklington-Lehmer ``$p-1$'' test; this requires
partially factoring various auxilliary integers and is likely to be very slow.

If $\fl=2$, use APRCL only.

If $\fl=3$, use ECPP only.

The library syntax is \fun{GEN}{gisprime}{GEN x, long flag}.

\subsec{isprimepower$(x,\{\&n\})$}\kbdsidx{isprimepower}\label{se:isprimepower}
If $x = p^k$ is a prime power ($p$ prime, $k > 0$), return $k$, else
return 0. If a second argument $\&n$ is given and $x$ is indeed
the $k$-th power of a prime $p$, sets $n$ to $p$.

The library syntax is \fun{long}{isprimepower}{GEN x, GEN *n = NULL}.

\subsec{ispseudoprime$(x,\{\fl\})$}\kbdsidx{ispseudoprime}\label{se:ispseudoprime}
True (1) if $x$ is a strong pseudo
prime (see below), false (0) otherwise. If this function returns false, $x$
is not prime; if, on the other hand it returns true, it is only highly likely
that $x$ is a prime number. Use \tet{isprime} (which is of course much
slower) to prove that $x$ is indeed prime.
The function accepts vector/matrices arguments, and is then applied
componentwise.

If $\fl = 0$, checks whether $x$ has no small prime divisors (up to $101$
included) and is a Baillie-Pomerance-Selfridge-Wagstaff pseudo prime.
Such a pseudo prime passes a Rabin-Miller test for base $2$,
followed by a Lucas test for the sequence $(P,1)$, where $P \geq 3$
is the smallest odd integer such that $P^2 - 4$ is not a square mod $x$.
(Technically, we are using an ``almost extra strong Lucas test'' that
checks whether $V_n$ is $\pm 2$, without computing $U_n$.)

There are no known composite numbers passing the above test, although it is
expected that infinitely many such numbers exist. In particular, all
composites $\leq 2^{64}$ are correctly detected (checked using
\url{http://www.cecm.sfu.ca/Pseudoprimes/index-2-to-64.html}).

If $\fl > 0$, checks whether $x$ is a strong Miller-Rabin pseudo prime  for
$\fl$ randomly chosen bases (with end-matching to catch square roots of $-1$).

The library syntax is \fun{GEN}{gispseudoprime}{GEN x, long flag}.

\subsec{ispseudoprimepower$(x,\{\&n\})$}\kbdsidx{ispseudoprimepower}\label{se:ispseudoprimepower}
If $x = p^k$ is a pseudo-prime power ($p$ pseudo-prime as per
\tet{ispseudoprime}, $k > 0$), return $k$, else
return 0. If a second argument $\&n$ is given and $x$ is indeed
the $k$-th power of a prime $p$, sets $n$ to $p$.

More precisely, $k$ is always the largest integer such that $x = n^k$ for
some integer $n$ and, when $n \leq  2^{64}$ the function returns $k > 0$ if and
only if $n$ is indeed prime. When $n > 2^{64}$ is larger than the threshold,
the function may return $1$ even though $n$ is composite: it only passed
an \kbd{ispseudoprime(n)} test.

The library syntax is \fun{long}{ispseudoprimepower}{GEN x, GEN *n = NULL}.

\subsec{issquare$(x,\{\&n\})$}\kbdsidx{issquare}\label{se:issquare}
True (1) if $x$ is a square, false (0)
if not. What ``being a square'' means depends on the type of $x$: all
\typ{COMPLEX} are squares, as well as all nonnegative \typ{REAL}; for
exact types such as \typ{INT}, \typ{FRAC} and \typ{INTMOD}, squares are
numbers of the form $s^2$ with $s$ in $\Z$, $\Q$ and $\Z/N\Z$ respectively.
\bprog
? issquare(3)          \\ as an integer
%1 = 0
? issquare(3.)         \\ as a real number
%2 = 1
? issquare(Mod(7, 8))  \\ in Z/8Z
%3 = 0
? issquare( 5 + O(13^4) )  \\ in Q_13
%4 = 0
@eprog
If $n$ is given, a square root of $x$ is put into $n$.
\bprog
? issquare(4, &n)
%1 = 1
? n
%2 = 2
@eprog
For polynomials, either we detect that the characteristic is 2 (and check
directly odd and even-power monomials) or we assume that $2$ is invertible
and check whether squaring the truncated power series for the square root
yields the original input.

For \typ{POLMOD} $x$, we only support \typ{POLMOD}s of \typ{INTMOD}s
encoding finite fields, assuming without checking that the intmod modulus
$p$ is prime and that the polmod modulus is irreducible modulo $p$.
\bprog
? issquare(Mod(Mod(2,3), x^2+1), &n)
%1 = 1
? n
%2 = Mod(Mod(2, 3)*x, Mod(1, 3)*x^2 + Mod(1, 3))
@eprog

The library syntax is \fun{long}{issquareall}{GEN x, GEN *n = NULL}.
Also available is \fun{long}{issquare}{GEN x}. Deprecated
GP-specific functions \fun{GEN}{gissquare}{GEN x} and
\fun{GEN}{gissquareall}{GEN x, GEN *pt} return \kbd{gen\_0} and \kbd{gen\_1}
instead of a boolean value.

\subsec{issquarefree$(x)$}\kbdsidx{issquarefree}\label{se:issquarefree}
True (1) if $x$ is squarefree, false (0) if not. Here $x$ can be an
integer or a polynomial with coefficients in an integral domain.
\bprog
? issquarefree(12)
%1 = 0
? issquarefree(6)
%2 = 1
? issquarefree(x^3+x^2)
%3 = 0
? issquarefree(Mod(1,4)*(x^2+x+1))    \\ Z/4Z is not a domain !
 ***   at top-level: issquarefree(Mod(1,4)*(x^2+x+1))
 ***                 ^--------------------------------
 *** issquarefree: impossible inverse in Fp_inv: Mod(2, 4).
@eprog\noindent A polynomial is declared squarefree if \kbd{gcd}$(x,x')$ is
$1$. In particular a nonzero polynomial with inexact coefficients is
considered to be squarefree. Note that this may be inconsistent with
\kbd{factor}, which first rounds the input to some exact approximation before
factoring in the apropriate domain; this is correct when the input is not
close to an inseparable polynomial (the resultant of $x$ and $x'$ is not
close to $0$).

An integer can be input in factored form as in arithmetic functions.
\bprog
? issquarefree(factor(6))
%1 = 1
\\ count squarefree integers up to 10^8
? c = 0; for(d = 1, 10^8, if (issquarefree(d), c++)); c
time = 3min, 2,590 ms.
%2 = 60792694
? c = 0; forfactored(d = 1, 10^8, if (issquarefree(d), c++)); c
time = 45,348 ms. \\ faster !
%3 = 60792694
@eprog

The library syntax is \fun{long}{issquarefree}{GEN x}.

\subsec{istotient$(x,\{\&N\})$}\kbdsidx{istotient}\label{se:istotient}
True (1) if $x = \phi(n)$ for some integer $n$, false (0)
if not.
\bprog
? istotient(14)
%1 = 0
? istotient(100)
%2 = 0
@eprog
If $N$ is given, set $N = n$ as well.
\bprog
? istotient(4, &n)
%1 = 1
? n
%2 = 10
@eprog

The library syntax is \fun{long}{istotient}{GEN x, GEN *N = NULL}.

\subsec{kronecker$(x,y)$}\kbdsidx{kronecker}\label{se:kronecker}
\idx{Kronecker symbol} $(x|y)$, where $x$ and $y$ must be of type integer. By
definition, this is the extension of \idx{Legendre symbol} to $\Z \times \Z$
by total multiplicativity in both arguments with the following special rules
for $y = 0, -1$ or $2$:

\item $(x|0) = 1$ if $|x| = 1$ and $0$ otherwise.

\item $(x|-1) = 1$ if $x \geq 0$ and $-1$ otherwise.

\item $(x|2) = 0$ if $x$ is even and $1$ if $x = 1,-1 \mod 8$ and $-1$
if $x=3,-3 \mod 8$.

The library syntax is \fun{long}{kronecker}{GEN x, GEN y}.

\subsec{lcm$(x,\{y\})$}\kbdsidx{lcm}\label{se:lcm}
Least common multiple of $x$ and $y$, i.e.~such
that $\lcm(x,y)*\gcd(x,y) = x*y$, up to units. If $y$ is omitted and $x$
is a vector, returns the $\text{lcm}$ of all components of $x$.
For integer arguments, return the nonnegative \text{lcm}.

When $x$ and $y$ are both given and one of them is a vector/matrix type,
the LCM is again taken recursively on each component, but in a different way.
If $y$ is a vector, resp.~matrix, then the result has the same type as $y$,
and components equal to \kbd{lcm(x, y[i])}, resp.~\kbd{lcm(x, y[,i])}. Else
if $x$ is a vector/matrix the result has the same type as $x$ and an
analogous definition. Note that for these types, \kbd{lcm} is not
commutative.

Note that \kbd{lcm(v)} is quite different from
\bprog
l = v[1]; for (i = 1, #v, l = lcm(l, v[i]))
@eprog\noindent
Indeed, \kbd{lcm(v)} is a scalar, but \kbd{l} may not be (if one of
the \kbd{v[i]} is a vector/matrix). The computation uses a divide-conquer tree
and should be much more efficient, especially when using the GMP
multiprecision kernel (and more subquadratic algorithms become available):
\bprog
? v = vector(10^5, i, random);
? lcm(v);
time = 546 ms.
? l = v[1]; for (i = 1, #v, l = lcm(l, v[i]))
time = 4,561 ms.
@eprog

The library syntax is \fun{GEN}{glcm0}{GEN x, GEN y = NULL}.

\subsec{logint$(x,b,\{\&z\})$}\kbdsidx{logint}\label{se:logint}
Return the largest non-negative integer $e$ so that $b^e \leq x$, where
$b > 1$ is an integer and $x \geq 1$ is a real number. If the parameter $z$
is present, set it to $b^e$.
\bprog
? logint(1000, 2)
%1 = 9
? 2^9
%2 = 512
? logint(1000, 2, &z)
%3 = 9
? z
%4 = 512
? logint(Pi^2, 2, &z)
%5 = 3
? z
%6 = 8
@eprog\noindent The number of digits used to write $x$ in base $b$ is
\kbd{1 + logint(x,b)}:
\bprog
? #digits(1000!, 10)
%5 = 2568
? logint(1000!, 10)
%6 = 2567
@eprog\noindent This function may conveniently replace
\bprog
  floor( log(x) / log(b) )
@eprog\noindent which may not give the correct answer since PARI
does not guarantee exact rounding.

The library syntax is \fun{long}{logint0}{GEN x, GEN b, GEN *z = NULL}.

\subsec{moebius$(x)$}\kbdsidx{moebius}\label{se:moebius}
\idx{Moebius} $\mu$-function of $|x|$; $x$ must be a nonzero integer.

The library syntax is \fun{long}{moebius}{GEN x}.

\subsec{nextprime$(x)$}\kbdsidx{nextprime}\label{se:nextprime}
Finds the smallest pseudoprime (see
\tet{ispseudoprime}) greater than or equal to $x$. $x$ can be of any real
type. Note that if $x$ is a pseudoprime, this function returns $x$ and not
the smallest pseudoprime strictly larger than $x$. To rigorously prove that
the result is prime, use \kbd{isprime}.
\bprog
? nextprime(2)
%1 = 2
? precprime(Pi)
%2 = 5
? nextprime(-10)
%3 = 2 \\ primes are positive
@eprog\noindent
Despite the name, please note that the function is not guaranteed to return
a prime number, although no counter-example is known at present. The return
value \emph{is} a guaranteed prime if $x \leq 2^{64}$. To rigorously prove
that the result is prime in all cases, use \kbd{isprime}.

The library syntax is \fun{GEN}{nextprime}{GEN x}.

\subsec{numdiv$(x)$}\kbdsidx{numdiv}\label{se:numdiv}
Number of divisors of $|x|$. $x$ must be of type integer.

The library syntax is \fun{GEN}{numdiv}{GEN x}.

\subsec{omega$(x)$}\kbdsidx{omega}\label{se:omega}
Number of distinct prime divisors of $|x|$. $x$ must be of type integer.
\bprog
? factor(392)
%1 =
[2 3]

[7 2]

? omega(392)
%2 = 2;  \\ without multiplicity
? bigomega(392)
%3 = 5;  \\ = 3+2, with multiplicity
@eprog

The library syntax is \fun{long}{omega}{GEN x}.

\subsec{precprime$(x)$}\kbdsidx{precprime}\label{se:precprime}
Finds the largest pseudoprime (see \tet{ispseudoprime}) less than or equal
to $x$; the input $x$ can be of any real type.
Returns 0 if $x\le1$. Note that if $x$ is a prime, this function returns $x$
and not the largest prime strictly smaller than $x$.
\bprog
? precprime(2)
%1 = 2
? precprime(Pi)
%2 = 3
? precprime(-10)
%3 = 0 \\ primes are positive
@eprog\noindent The function name comes from \emph{prec}eding \emph{prime}.
Despite the name, please note that the function is not guaranteed to return
a prime number (although no counter-example is known at present); the return
value \emph{is} a guaranteed prime if $x \leq 2^{64}$. To rigorously prove
that the result is prime in all cases, use \kbd{isprime}.

The library syntax is \fun{GEN}{precprime}{GEN x}.

\subsec{prime$(n)$}\kbdsidx{prime}\label{se:prime}
The $n^{\text{th}}$ prime number
\bprog
? prime(10^9)
%1 = 22801763489
@eprog\noindent Uses checkpointing and a naive $O(n)$ algorithm. Will need
about 30 minutes for $n$ up to $10^{11}$; make sure to start gp with
\kbd{primelimit} at least $\sqrt{p_n}$, e.g. the value
$\sqrt{n\log (n\log n)}$ is guaranteed to be sufficient.

The library syntax is \fun{GEN}{prime}{long n}.

\subsec{primecert$(N, \{\fl=0\}, \{\var{partial}=0\})$}\kbdsidx{primecert}\label{se:primecert}
If N is a prime, return a PARI Primality Certificate for the prime $N$,
as described below. Otherwise, return 0. A Primality Certificate
$c$ can be checked using \tet{primecertisvalid}$(c)$.

If $\fl = 0$ (default), return an ECPP certificate (Atkin-Morain)

If $\fl = 0$ and $\var{partial}>0$, return a (potentially) partial
ECPP certificate.

A PARI ECPP Primality Certificate for the prime $N$ is either a prime
integer $N < 2^{64}$ or a vector \kbd{C} of length $\ell$ whose $i$th
component \kbd{C[i]} is a vector $[N_i, t_i, s_i, a_i, P_i]$ of length $5$
where $N_1 = N$. It is said to be \emph{valid} if for each
$i = 1, \ldots, \ell$, all of the following conditions are satisfied

\item $N_i$ is a positive integer

\item $t_i$ is an integer such that $t_i^2 < 4N_i$

\item $s_i$ is a positive integer which divides $m_i$ where
 $m_i = N_i + 1 - t_i$

\item If we set $q_i = \dfrac{m_i}{s_i}$, then

\quad\item $q_i > (N_i^{1/4}+1)^2$

\quad\item $q_i = N_{i+1}$ if $1 \leq i < l$

\quad\item $q_\ell \leq 2^{64}$ is prime

\item $a_i$ is an integer

\quad\item \kbd{P[i]} is a vector of length $2$ representing the affine
point $P_i = (x_i, y_i)$ on the elliptic curve $E: y^2 = x^3 + a_ix + b_i$
modulo $N_i$ where $b_i = y_i^2 - x_i^3 - a_ix_i$ satisfying the following:

\quad\item $m_i P_i = \infty$

\quad\item $s_i P_i \neq \infty$

Using the following theorem, the data in the vector \kbd{C} allows to
recursively certify the primality of $N$ (and all the $q_i$) under the single
assumption that $q_\ell$ be prime.

\misctitle{Theorem} If $N$ is an integer and there exist positive integers
$m, q$ and a point $P$ on the elliptic curve $E: y^2 = x^3 + ax + b$ defined
modulo $N$ such that $q > (N^{1/4} + 1)^2$, $q$ is a prime divisor of $m$,
$mP = \infty$ and $\dfrac{m}{q}P \neq \infty$, then $N$ is prime.

A partial certificate is identical except that the condition $q_\ell \leq
2^{64}$ is replaced by $q_\ell \leq 2^{partial}$.
Such partial certificate $C$ can be extended to a full certificate by calling
$C=primecert(C)$, or to a longer partial certificate by calling
$C=primecert(C,,b)$ with $b<partial$.

\bprog
? primecert(10^35 + 69)
%1 = [[100000000000000000000000000000000069, 5468679110354
52074, 2963504668391148, 0, [60737979324046450274283740674
208692, 24368673584839493121227731392450025]], [3374383076
4501150277, -11610830419, 734208843, 0, [26740412374402652
72 4, 6367191119818901665]], [45959444779, 299597, 2331, 0
, [18022351516, 9326882 51]]]
? primecert(nextprime(2^64))
%2 = [[18446744073709551629, -8423788454, 160388, 1, [1059
8342506117936052, 2225259013356795550]]]
? primecert(6)
%3 = 0
? primecert(41)
%4 = 41

? N = 2^2000+841;
? Cp1 = primecert(N,,1500); \\ partial certificate
time = 16,018 ms.
? Cp2 = primecert(Cp1,,1000); \\ (longer) partial certificate
time = 5,890 ms.
? C = primecert(Cp2); \\ full certificate for N
time = 1,777 ms.
? primecertisvalid(C)
%9 = 1
? primecert(N);
time = 23,625 ms.
@eprog\noindent As the last command shows, attempting a succession of
partial certificates should be about as fast as a direct computation.

\smallskip

If $\fl = 1$ (very slow), return an $N-1$ certificate (Pocklington Lehmer)

A PARI $N-1$ Primality Certificate for the prime $N$ is either a prime
integer $N < 2^{64}$ or a pair $[N, C]$, where $C$ is a vector with $\ell$
elements which are either a single integer $p_i < 2^{64}$ or a
triple $[p_i,a_i,C_i]$ with $p_i > 2^{64}$ satisfying the following
properties:

\item $p_i$ is a prime divisor of $N - 1$;

\item $a_i$ is an integer such that $a_i^{N-1} \equiv 1 \pmod{N}$ and
$a_i^{(N-1)/p_i} - 1$ is coprime with $N$;

\item $C_i$ is an $N-1$ Primality Certificate for $p_i$

\item The product $F$ of the $p_i^{v_{p_i}(N-1)}$ is strictly larger than
$N^{1/3}$. Provided that all $p_i$ are indeed primes, this implies that any
divisor of $N$ is congruent to $1$ modulo $F$.

\item The Brillhart--Lehmer--Selfridge criterion is satisfied: when we write
$N = 1 + c_1 F + c_2 F^2$ in base $F$ the polynomial $1 + c_1 X + c_2 X^2$
is irreducible over $\Z$, i.e. $c_1^2 - 4c_2$ is not a square. This
implies that $N$ is prime.

This algorithm requires factoring partially $p-1$ for various prime integers
$p$ with an unfactored parted $\leq p^{2/3}$ and this may be exceedingly
slow compared to the default.

The algorithm fails if one of the pseudo-prime factors is not prime, which is
exceedingly unlikely and well worth a bug report. Note that if you monitor
the algorithm at a high enough debug level, you may see warnings about
untested integers being declared primes. This is normal: we ask for partial
factorizations (sufficient to prove primality if the unfactored part is not
too large), and \kbd{factor} warns us that the cofactor hasn't been tested.
It may or may not be tested later, and may or may not be prime. This does
not affect the validity of the whole Primality Certificate.

The library syntax is \fun{GEN}{primecert0}{GEN N, long flag, long partial}.
Also available is
\fun{GEN}{ecpp0}{GEN N, long partial} ($\fl = 0$).

\subsec{primecertexport$(\var{cert}, \{\var{format} = 0\})$}\kbdsidx{primecertexport}\label{se:primecertexport}
Returns a string suitable for print/write to display a primality certificate
from \tet{primecert}, the format of which depends on the value of \kbd{format}:

\item 0 (default): Human-readable format. See \kbd{??primecert} for the
meaning of the successive $N, t, s, a, m, q, E, P$. The integer $D$ is the
negative fundamental discriminant \kbd{coredisc}$(t^2 - 4N)$.

\item 1: Primo format 4.

\item 2: MAGMA format.

Currently, only ECPP Primality Certificates are supported.

\bprog
? cert = primecert(10^35+69);
? s = primecertexport(cert); \\ Human-readable
? print(s)
[1]
 N = 100000000000000000000000000000000069
 t = 546867911035452074
 s = 2963504668391148
a = 0
D = -3
m = 99999999999999999453132088964547996
q = 33743830764501150277
E = [0, 1]
P = [21567861682493263464353543707814204,
49167839501923147849639425291163552]
[2]
 N = 33743830764501150277
 t = -11610830419
 s = 734208843
a = 0
D = -3
m = 33743830776111980697
q = 45959444779
E = [0, 25895956964997806805]
P = [29257172487394218479, 3678591960085668324]

\\ Primo format
? s = primecertexport(cert,1); write("cert.out", s);

\\ Magma format, write to file
? s = primecertexport(cert,2); write("cert.m", s);

? cert = primecert(10^35+69, 1); \\ N-1 certificate
? primecertexport(cert)
 ***   at top-level: primecertexport(cert)
 ***                 ^---------------------
 *** primecertexport: sorry, N-1 certificate is not yet implemented.
@eprog

The library syntax is \fun{GEN}{primecertexport}{GEN cert, long format}.

\subsec{primecertisvalid$(\var{cert})$}\kbdsidx{primecertisvalid}\label{se:primecertisvalid}
Verifies if cert is a valid PARI ECPP Primality certificate, as described
in \kbd{??primecert}.
\bprog
? cert = primecert(10^35 + 69)
%1 = [[100000000000000000000000000000000069, 5468679110354
52074, 2963504668391148, 0, [60737979324046450274283740674
208692, 24368673584839493121227731392450025]], [3374383076
4501150277, -11610830419, 734208843, 0, [26740412374402652
72 4, 6367191119818901665]], [45959444779, 299597, 2331, 0
, [18022351516, 9326882 51]]]
? primecertisvalid(cert)
%2 = 1

? cert[1][1]++; \\ random perturbation
? primecertisvalid(cert)
%4 = 0  \\ no longer valid
? primecertisvalid(primecert(6))
%5 = 0
@eprog

The library syntax is \fun{long}{primecertisvalid}{GEN cert}.

\subsec{primepi$(x)$}\kbdsidx{primepi}\label{se:primepi}
The prime counting function. Returns the number of
primes $p$, $p \leq x$.
\bprog
? primepi(10)
%1 = 4;
? primes(5)
%2 = [2, 3, 5, 7, 11]
? primepi(10^11)
%3 = 4118054813
@eprog\noindent Uses checkpointing and a naive $O(x)$ algorithm;
make sure to start gp with \kbd{primelimit} at least $\sqrt{x}$.

The library syntax is \fun{GEN}{primepi}{GEN x}.

\subsec{primes$(n)$}\kbdsidx{primes}\label{se:primes}
Creates a row vector whose components are the first $n$ prime numbers.
(Returns the empty vector for $n \leq 0$.) A \typ{VEC} $n = [a,b]$ is also
allowed, in which case the primes in $[a,b]$ are returned
\bprog
? primes(10)     \\ the first 10 primes
%1 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
? primes([0,29])  \\ the primes up to 29
%2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
? primes([15,30])
%3 = [17, 19, 23, 29]
@eprog

The library syntax is \fun{GEN}{primes0}{GEN n}.

\subsec{qfbclassno$(D,\{\fl=0\})$}\kbdsidx{qfbclassno}\label{se:qfbclassno}
Ordinary class number of the quadratic order of discriminant $D$, for
``small'' values of $D$.

\item if  $D > 0$ or $\fl = 1$, use a $O(|D|^{1/2})$
algorithm (compute $L(1,\chi_D)$ with the approximate functional equation).
This is slower than \tet{quadclassunit} as soon as $|D| \approx 10^2$ or
so and is not meant to be used for large $D$.

\item if $D < 0$ and $\fl = 0$ (or omitted), use a $O(|D|^{1/4})$
algorithm (Shanks's baby-step/giant-step method). It should
be faster than \tet{quadclassunit} for small values of $D$, say
$|D| < 10^{18}$.

\misctitle{Important warning} In the latter case, this function only
implements part of \idx{Shanks}'s method (which allows to speed it up
considerably). It gives unconditionnally correct results for
$|D| < 2\cdot 10^{10}$, but may give incorrect results for larger values
if the class
group has many cyclic factors. We thus recommend to double-check results
using the function \kbd{quadclassunit}, which is about 2 to 3 times slower in
the range $|D| \in [10^{10}, 10^{18}]$, assuming GRH. We currently have no
counter-examples but they should exist: we would appreciate a bug report if
you find one.

\misctitle{Warning} Contrary to what its name implies, this routine does not
compute the number of classes of binary primitive forms of discriminant $D$,
which is equal to the \emph{narrow} class number. The two notions are the same
when $D < 0$ or the fundamental unit $\varepsilon$ has negative norm; when $D
> 0$ and $N\varepsilon > 0$, the number of classes of forms is twice the
ordinary class number. This is a problem which we cannot fix for backward
compatibility reasons. Use the following routine if you are only interested
in the number of classes of forms:
\bprog
? QFBclassno(D) = qfbclassno(D) * if (D > 0 && quadunitnorm(D) > 0, 2, 1)
? QFBclassno(136)
%1 = 4
? qfbclassno(136)
%2 = 2
? quadunitnorm(136)
%3 = 1
? bnfnarrow(bnfinit(x^2 - 136)).cyc
%4 = [4]  \\ narrow class group is cyclic ~ Z/4Z
@eprog\noindent Note that the use of \kbd{bnfnarrow} above is only valid
because $136$ is a fundamental discriminant: that function is asymptotically
faster (and returns the group structure, not only its order) but only supports
\emph{maximal} orders.
Here are a few more examples:
\bprog
? qfbclassno(400000028) \\ D > 0: slow
time = 3,140 ms.
%1 = 1
? quadclassunit(400000028).no
time = 20 ms. \\@com{ much faster, assume GRH}
%2 = 1
? qfbclassno(-400000028) \\ D < 0: fast enough
time = 0 ms.
%3 = 7253
? quadclassunit(-400000028).no
time = 0 ms.
%4 = 7253
@eprog\noindent See also \kbd{qfbhclassno}.

The library syntax is \fun{GEN}{qfbclassno0}{GEN D, long flag}.

\subsec{qfbcomp$(x,y)$}\kbdsidx{qfbcomp}\label{se:qfbcomp}
\idx{composition} of the binary quadratic forms $x$ and $y$, with
\idx{reduction} of the result.

The library syntax is \fun{GEN}{qfbcomp}{GEN x, GEN y}.

\subsec{qfbcompraw$(x,y)$}\kbdsidx{qfbcompraw}\label{se:qfbcompraw}
\idx{composition} of the binary quadratic forms $x$ and $y$, without
\idx{reduction} of the result. This is useful e.g.~to compute a generating
element of an ideal. The result is undefined if $x$ and $y$ do not have the
same discriminant.

The library syntax is \fun{GEN}{qfbcompraw}{GEN x, GEN y}.

\subsec{qfbcornacchia$(d,n)$}\kbdsidx{qfbcornacchia}\label{se:qfbcornacchia}
Solve the equation $x^2 + dy^2 = n$ in integers $x$ and $y$, where
$d > 0$ and $n$ is prime. Returns the empty vector \kbd{[]} when no solution
exists. It is also allowed to try $n = 4$ times a prime but the answer is
then guaranteed only if $d$ is $3$ mod $4$; more precisely if $d \neq 3$ mod
$4$, the algorithm may fail to find a non-primitive solution.

This function is a special case of \kbd{qfbsolve} applied to the principal
form in the imaginary quadratic order of discriminant $-4d$ (returning the
solution with non-negative $x$ and $y$). As its name implies,
\kbd{qfbcornacchia} uses Cornacchia's algorithm and runs in time quasi-linear
in $\log n$ (using \kbd{halfgcd}); in practical ranges, \kbd{qfbcornacchia}
should be two or three times faster than \kbd{qfbsolve}.
\bprog
? qfbcornacchia(1, 113)
%1 = [8, 7]
? qfbsolve(Qfb(1,0,1), 113)
%2 = [7, -8]
? qfbcornacchia(1, 4*113) \\ misses the non-primitive solution 2*[8,7]
%3 = []
? qfbcornacchia(1, 4*109) \\ finds a non-primitive solution
%4 = [20, 6]
? p = 122838793181521; isprime(p)
%5 = 1
? qfbcornacchia(24, p)
%6 = [10547339, 694995]
? Q = Qfb(1,0,24); qfbsolve(Q,p)
%7 = [10547339, 694995]
? for (i=1, 10^5, qfbsolve(Q, Mat([p,1])))
time = 799 ms.
? for (i=1, 10^5, qfbcornacchia(24,p)) \\ faster
time = 423 ms.
@eprog\noindent We used \kbd{Mat([p,1])} to indicate that $p^1$
whas the integer factorization of $p$, i.e., that $p$ is prime. Without it,
\kbd{qfbsolve} will further attempt to factor $p$ and waste a little time:
\bprog
? for (i=1, 10^5, qfbsolve(Q, p))
time = 945 ms.
@eprog

The library syntax is \fun{GEN}{qfbcornacchia}{GEN d, GEN n}.

\subsec{qfbhclassno$(x)$}\kbdsidx{qfbhclassno}\label{se:qfbhclassno}
\idx{Hurwitz class number} of $x$, when
$x$ is nonnegative and congruent to 0 or 3 modulo 4, and $0$ for other
values. For $x > 5\cdot 10^5$, we assume the GRH, and use \kbd{quadclassunit}
with default parameters.
\bprog
? qfbhclassno(1) \\ not 0 or 3 mod 4
%1 = 0
? qfbhclassno(3)
%2 = 1/3
? qfbhclassno(4)
%3 = 1/2
? qfbhclassno(23)
%4 = 3
@eprog

The library syntax is \fun{GEN}{hclassno}{GEN x}.

\subsec{qfbnucomp$(x,y,L)$}\kbdsidx{qfbnucomp}\label{se:qfbnucomp}
\idx{composition} of the primitive positive
definite binary quadratic forms $x$ and $y$ (type \typ{QFB}) using the NUCOMP
and NUDUPL algorithms of \idx{Shanks}, \`a la Atkin. $L$ is any positive
constant, but for optimal speed, one should take $L=|D/4|^{1/4}$, i.e.
\kbd{sqrtnint(abs(D)>>2,4)}, where $D$ is the common discriminant of $x$ and
$y$. When $x$ and $y$ do not have the same discriminant, the result is
undefined.

The current implementation is slower than the generic routine for small $D$,
and becomes faster when $D$ has about $45$ bits.

The library syntax is \fun{GEN}{nucomp}{GEN x, GEN y, GEN L}.
Also available is \fun{GEN}{nudupl}{GEN x, GEN L} when $x=y$.

\subsec{qfbnupow$(x,n,\{L\})$}\kbdsidx{qfbnupow}\label{se:qfbnupow}
$n$-th power of the primitive positive definite
binary quadratic form $x$ using \idx{Shanks}'s NUCOMP and NUDUPL algorithms;
if set, $L$ should be equal to \kbd{sqrtnint(abs(D)>>2,4)}, where $D < 0$ is
the discriminant of $x$.

The current implementation is slower than the generic routine for small
discriminant $D$, and becomes faster for $D \approx 2^{45}$.

The library syntax is \fun{GEN}{nupow}{GEN x, GEN n, GEN L = NULL}.

\subsec{qfbpow$(x,n)$}\kbdsidx{qfbpow}\label{se:qfbpow}
$n$-th power of the binary quadratic form
$x$, computed with \idx{reduction} (i.e.~using \kbd{qfbcomp}).

The library syntax is \fun{GEN}{qfbpow}{GEN x, GEN n}.

\subsec{qfbpowraw$(x,n)$}\kbdsidx{qfbpowraw}\label{se:qfbpowraw}
$n$-th power of the binary quadratic form
$x$, computed without doing any \idx{reduction} (i.e.~using \kbd{qfbcompraw}).
Here $n$ must be nonnegative and $n<2^{31}$.

The library syntax is \fun{GEN}{qfbpowraw}{GEN x, long n}.

\subsec{qfbprimeform$(x,p)$}\kbdsidx{qfbprimeform}\label{se:qfbprimeform}
Prime binary quadratic form of discriminant
$x$ whose first coefficient is $p$, where $|p|$ is a prime number.
By abuse of notation,
$p = \pm 1$ is also valid and returns the unit form. Returns an
error if $x$ is not a quadratic residue mod $p$, or if $x < 0$ and $p < 0$.
(Negative definite \typ{QFB} are not implemented.)

The library syntax is \fun{GEN}{primeform}{GEN x, GEN p}.

\subsec{qfbred$(x,\{\fl=0\},\{\var{isd}\},\{\var{sd}\})$}\kbdsidx{qfbred}\label{se:qfbred}
Reduces the binary quadratic form $x$ (updating Shanks's distance function
$d$ if $x = [q,d]$ is and extended indefinite form).
If $\fl$ is $1$, the function performs a single \idx{reduction} step, and
a complete reduction otherwise.

The arguments \var{isd}, \var{sd}, if present, supply the values of
$\floor{\sqrt{D}}$, and $\sqrt{D}$ respectively, where $D$
is the discriminant (this is not checked).
If $d<0$ these values are useless.

The library syntax is \fun{GEN}{qfbred0}{GEN x, long flag, GEN isd = NULL, GEN sd = NULL}.
Also available is \fun{GEN}{qfbred}{GEN x} (\fl is 0, \kbd{isd}
and \kbd{sd} are \kbd{NULL})

\subsec{qfbredsl2$(x,\{\var{isD}\})$}\kbdsidx{qfbredsl2}\label{se:qfbredsl2}
Reduction of the (real or imaginary) binary quadratic form $x$, return
$[y,g]$ where $y$ is reduced and $g$ in $\text{SL}(2,\Z)$ is such that
 $g \cdot x = y$; \var{isD}, if
present, must be equal to $\kbd{sqrtint}(D)$, where $D > 0$ is the
discriminant of $x$.

The library syntax is \fun{GEN}{qfbredsl2}{GEN x, GEN isD = NULL}.

\subsec{qfbsolve$(Q,n,\{\fl=0\})$}\kbdsidx{qfbsolve}\label{se:qfbsolve}
Solve the equation $Q(x,y)=n$ in coprime integers $x$ and $y$ (primitive
solutions), where
$Q$ is a binary quadratic form and $n$ an integer, up to the action of the
special orthogonal group $G=SO(Q,\Z)$, which is isomorphic to the group of
units of positive norm of the quadratic order of discriminant $D = \disc Q$.
If $D>0$, $G$ is infinite. If $D<-4$, $G$ is of order $2$, if $D=-3$, $G$ is
of order $6$ and if $D=-4$, $G$ is of order $4$.

Binary digits of $\fl$ mean:
1: return all solutions if set, else a single solution; return $[]$ if
a single solution is wanted (bit unset) but none exist.
2: also include imprimitive solutions.

When $\fl = 2$ (return a single solution, possibly imprimitive), the
algorithm returns a solution with minimal content; in particular, a
primitive solution exists if and only if one is returned.

The integer $n$ can be given by its factorization matrix
\kbd{\var{fa} = factor(n)} or by the pair $[n, \var{fa}]$.

\bprog
? qfbsolve(Qfb(1,0,2), 603) \\ a single primitive solution
%1 = [5, 17]

? qfbsolve(Qfb(1,0,2), 603, 1) \\ all primitive solutions
%2 = [[5, 17], [-19, -11], [19, -11], [5, -17]]

? qfbsolve(Qfb(1,0,2), 603, 2) \\ a single, possibly imprimitive solution
%3 = [5, 17] \\ actually primitive

? qfbsolve(Qfb(1,0,2), 603, 3) \\ all solutions
%4 = [[5, 17], [-19, -11], [19, -11], [5, -17], [-21, 9], [-21, -9]]

? N = 2^128+1; F = factor(N);
? qfbsolve(Qfb(1,0,1),[N,F],1)
%3 = [[-16382350221535464479,8479443857936402504],
      [18446744073709551616,-1],[-18446744073709551616,-1],
      [16382350221535464479,8479443857936402504]]
@eprog

For fixed $Q$, assuming the factorisation of $n$ is given, the algorithm
runs in probabilistic polynomial time in $\log p$, where $p$ is the largest
prime divisor of $n$, through the computation of square roots of $D$ modulo
$4\*p$). The dependency on $Q$ is more complicated: polynomial time in $\log
|D|$ if $Q$ is imaginary, but exponential time if $Q$ is real (through the
computation of a full cycle of reduced forms). In the latter case, note that
\tet{bnfisprincipal} provides a solution in heuristic subexponential time
assuming the GRH.

The library syntax is \fun{GEN}{qfbsolve}{GEN Q, GEN n, long flag}.

\subsec{quadclassunit$(D,\{\fl=0\},\{\var{tech}=[\,]\})$}\kbdsidx{quadclassunit}\label{se:quadclassunit}
\idx{Buchmann-McCurley}'s sub-exponential algorithm for computing the
class group of a quadratic order of discriminant $D$.

This function should be used instead of \tet{qfbclassno} or
\tet{quadregulator}
when $D<-10^{25}$, $D>10^{10}$, or when the \emph{structure} is wanted. It
is a special case of \tet{bnfinit}, which is slower, but more robust.

The result is a vector $v$ whose components should be accessed using
member functions:

\item \kbd{$v$.no}: the class number

\item \kbd{$v$.cyc}: a vector giving the structure of the class group as a
product of cyclic groups;

\item \kbd{$v$.gen}: a vector giving generators of those cyclic groups (as
binary quadratic forms).

\item \kbd{$v$.reg}: the regulator, computed to an accuracy which is the
maximum of an internal accuracy determined by the program and the current
default (note that once the regulator is known to a small accuracy it is
trivial to compute it to very high accuracy, see the tutorial).

The $\fl$ is obsolete and should be left alone. In older versions,
it supposedly computed the narrow class group when $D>0$, but this did not
work at all; use the general function \tet{bnfnarrow}.

Optional parameter \var{tech} is a row vector of the form $[c_1, c_2]$,
where $c_1 \leq c_2$ are nonnegative real numbers which control the execution
time and the stack size, see \ref{se:GRHbnf}. The parameter is used as a
threshold to balance the relation finding phase against the final linear
algebra. Increasing the default $c_1$ means that relations are easier
to find, but more relations are needed and the linear algebra will be
harder. The default value for $c_1$ is $0$ and means that it is taken equal
to $c_2$. The parameter $c_2$ is mostly obsolete and should not be changed,
but we still document it for completeness: we compute a tentative class
group by generators and relations using a factorbase of prime ideals
$\leq c_1 (\log |D|)^2$, then prove that ideals of norm
$\leq c_2 (\log |D|)^2$ do
not generate a larger group. By default an optimal $c_2$ is chosen, so that
the result is provably correct under the GRH --- a famous result of Bach
states that $c_2 = 6$ is fine, but it is possible to improve on this
algorithmically. You may provide a smaller $c_2$, it will be ignored
(we use the provably correct
one); you may provide a larger $c_2$ than the default value, which results
in longer computing times for equally correct outputs (under GRH).

The library syntax is \fun{GEN}{quadclassunit0}{GEN D, long flag, GEN tech = NULL, long prec}.
If you really need to experiment with the \var{tech} parameter,
it will be more convenient to use
\fun{GEN}{Buchquad}{GEN D, double c1, double c2, long prec}.

\subsec{quaddisc$(x)$}\kbdsidx{quaddisc}\label{se:quaddisc}
Discriminant of the \'etale algebra $\Q(\sqrt{x})$, where $x\in\Q^*$.
This is the same as \kbd{coredisc}$(d)$ where $d$ is the integer
squarefree part of $x$, so $x=d f^2$ with $f\in \Q^*$ and $d\in\Z$.
This returns $0$ for $x = 0$, $1$ for $x$ square and the discriminant of
the quadratic field $\Q(\sqrt{x})$ otherwise.
\bprog
? quaddisc(7)
%1 = 28
? quaddisc(-7)
%2 = -7
@eprog

The library syntax is \fun{GEN}{quaddisc}{GEN x}.

\subsec{quadgen$(D,\{v = 'w\})$}\kbdsidx{quadgen}\label{se:quadgen}
Creates the quadratic number\sidx{omega} $\omega=(a+\sqrt{D})/2$ where
$a=0$ if $D\equiv0\mod4$,
$a=1$ if $D\equiv1\mod4$, so that $(1,\omega)$ is an integral basis for the
quadratic order of discriminant $D$. $D$ must be an integer congruent to 0 or
1 modulo 4, which is not a square.
If \var{v} is given, the variable name is used to display $g$ else 'w' is used.

\bprog
? w = quadgen(5, 'w); w^2 - w - 1
%1 = 0
? w = quadgen(0, 'w)
 ***   at top-level: w=quadgen(0)
 ***                   ^----------
 *** quadgen: domain error in quadpoly: issquare(disc) = 1
@eprog

The library syntax is \fun{GEN}{quadgen0}{GEN D, long v = -1} where \kbd{v} is a variable number.

When \var{v} does not matter, the function
\fun{GEN}{quadgen}{GEN D} is also available.

\subsec{quadhilbert$(D)$}\kbdsidx{quadhilbert}\label{se:quadhilbert}
Relative equation defining the
\idx{Hilbert class field} of the quadratic field of discriminant $D$.

If $D < 0$, uses complex multiplication (\idx{Schertz}'s variant).

If $D > 0$ \idx{Stark units} are used and (in rare cases) a
vector of extensions may be returned whose compositum is the requested class
field. See \kbd{bnrstark} for details.

The library syntax is \fun{GEN}{quadhilbert}{GEN D, long prec}.

\subsec{quadpoly$(D,\{v='x\})$}\kbdsidx{quadpoly}\label{se:quadpoly}
Creates the ``canonical'' quadratic
polynomial (in the variable $v$) corresponding to the discriminant $D$,
i.e.~the minimal polynomial of $\kbd{quadgen}(D)$. $D$ must be an integer
congruent to 0 or 1 modulo 4, which is not a square.

\bprog
? quadpoly(5,'y)
%1 = y^2 - y - 1
? quadpoly(0,'y)
 ***   at top-level: quadpoly(0,'y)
 ***                 ^--------------
 *** quadpoly: domain error in quadpoly: issquare(disc) = 1
@eprog

The library syntax is \fun{GEN}{quadpoly0}{GEN D, long v = -1} where \kbd{v} is a variable number.

\subsec{quadray$(D,f)$}\kbdsidx{quadray}\label{se:quadray}
Relative equation for the ray
class field of conductor $f$ for the quadratic field of discriminant $D$
using analytic methods. A \kbd{bnf} for $x^2 - D$ is also accepted in place
of $D$.

For $D < 0$, uses the $\sigma$ function and Schertz's method.

For $D>0$, uses Stark's conjecture, and a vector of relative equations may be
returned. See \tet{bnrstark} for more details.

The library syntax is \fun{GEN}{quadray}{GEN D, GEN f, long prec}.

\subsec{quadregulator$(D)$}\kbdsidx{quadregulator}\label{se:quadregulator}
Regulator of the quadratic order of positive discriminant $D$ in time
$\tilde{O}(D^{1/2})$ using the continued fraction algorithm. Raise
an error if $D$ is not a discriminant (fundamental or not) or if $D$ is a
square. The function \kbd{quadclassunit} is asymptotically faster (and also
in practice for $D > 10^{10}$ or so) but depends on the GRH.

The library syntax is \fun{GEN}{quadregulator}{GEN D, long prec}.

\subsec{quadunit$(D,\{v = 'w\})$}\kbdsidx{quadunit}\label{se:quadunit}
A fundamental unit\sidx{fundamental units} $u$ of the real quadratic order
of discriminant $D$. The integer $D$ must be congruent to 0 or 1 modulo 4
and not a square; the result is a quadratic number (see \secref{se:quadgen}).
If $D$ is not a fundamental discriminant, the algorithm is wasteful: if $D =
df^2$ with $d$ fundamental, it will be faster to compute \kbd{quadunit}$(d)$
then raise it to the power \kbd{quadunitindex}$(d,f)$; or keep it in
factored form.

If \var{v} is given, the variable name is used to display $u$
else 'w' is used. The algorithm computes the continued fraction
of $(1 + \sqrt{D}) / 2$ or $\sqrt{D}/2$ (see GTM 138, algorithm 5.7.2).
Although the continued fraction length is only $O(\sqrt{D})$,
the function still runs in time $\tilde{O}(D)$, in part because the
output size is not polynomially bounded in terms of $\log D$.
See \kbd{bnfinit} and \kbd{bnfunits} for a better alternative for large
$D$, running in time subexponential in $\log D$ and returning the
fundamental units in compact form (as a short list of $S$-units of size
$O(\log D)^3$ raised to possibly large exponents).

The library syntax is \fun{GEN}{quadunit0}{GEN D, long v = -1} where \kbd{v} is a variable number.

When \var{v} does not matter, the function
\fun{GEN}{quadunit}{GEN D} is also available.

\subsec{quadunitindex$(D, f)$}\kbdsidx{quadunitindex}\label{se:quadunitindex}
Given a fundamental discriminant $D$, return the index of the unit group
of the order of conductor $f$ in the units of $\Q(\sqrt{D})$. This function
uses the continued fraction algorithm and has $O(D^{1/2 + \varepsilon}
f^\varepsilon)$ complexity; \kbd{quadclassunit} is asymptotically faster but
depends on the GRH.
\bprog
? quadunitindex(-3, 2)
%1 = 3
? quadunitindex(5, 2^32) \\ instantaneous
%2 = 3221225472
? quadregulator(5 * 2^64) / quadregulator(5)
time = 3min, 1,488 ms.
%3 = 3221225472.0000000000000000000000000000
@eprog\noindent The conductor $f$ can be given in factored form or as
$[f, \kbd{factor}(f)]$:
\bprog
? quadunitindex(5, [100, [2,2;5,2]])
%4 = 150
? quadunitindex(5, 100)
%5 = 150
? quadunitindex(5, [2,2;5,2])
%6 = 150
@eprog
If $D$ is not fundamental, the result is undefined; you may use the
following script instead:
\bprog
index(d, f) =
{ my([D,F] = coredisc(d, 1));
  quadunitindex(D, f * F) / quadunitindex(D, F)
}
? index(5 * 10^2, 10)
%7 = 10
@eprog

The library syntax is \fun{GEN}{quadunitindex}{GEN D, GEN f}.

\subsec{quadunitnorm$(D)$}\kbdsidx{quadunitnorm}\label{se:quadunitnorm}
Return the norm ($1$ or $-1$) of the fundamental unit of the quadratic
order of discriminant $D$. The integer $D$ must be congruent to $0$ or $1$
modulo $4$ and not a square. This is of course equal to \kbd{norm(quadunit(D))}
but faster.
\bprog
? quadunitnorm(-3) \\ the result is always 1 in the imaginary case
%1 = 1
? quadunitnorm(5)
%2 = -1
? quadunitnorm(17345)
%3 = -1
? u = quadunit(17345)
%4 = 299685042291 + 4585831442*w
? norm(u)
%5 = -1
@eprog\noindent This function computes the parity of the continued fraction
expansion and runs in time $\tilde{O}(D^{1/2})$. If $D$ is fundamental,
the function \kbd{bnfinit} is asymptotically faster but depends of the GRH.
If $D = df^2$ is not fundamental, it will usually be faster to first compute
\kbd{quadunitindex}$(d, f)$. If it is even, the result is $1$, else the result
is \kbd{quadunitnorm}$(d)$. The narrow class number of the order of
discriminant $D$ is equal to the class number if the unit norm is $1$ and to
twice the class number otherwise.

The library syntax is \fun{long}{quadunitnorm}{GEN D}.

\subsec{ramanujantau$(n,\{\var{ell}=12\})$}\kbdsidx{ramanujantau}\label{se:ramanujantau}
Compute the value of Ramanujan's tau function at an individual $n$,
assuming the truth of the GRH (to compute quickly class numbers of imaginary
quadratic fields using \tet{quadclassunit}). If \kbd{ell} is 16, 18, 20, 22,
or 26, same for the newform of level 1 and corresponding weight. Otherwise,
compute the coefficient of the trace form at $n$.
The complexity is in $\tilde{O}(n^{1/2})$ using $O(\log n)$ space.

If all values up to $N$ are required, then
$$\sum \tau(n)q^n = q \prod_{n\geq 1} (1-q^n)^{24}$$
and more generally, setting $u = \ell - 13$ and $C = 2/\zeta(-u)$ for $\ell
> 12$,
$$\sum\tau_{\ell}(n)q^n = q \prod_{n\geq 1}
 (1-q^n)^{24} \Big( 1 + C\sum_{n\ge1}n^u q^n / (1-q^n)\Big)$$
produces them in time $\tilde{O}(N)$, against $\tilde{O}(N^{3/2})$ for
individual calls to \kbd{ramanujantau}; of course the space complexity then
becomes $\tilde{O}(N)$. For other values of $\ell$,
\kbd{mfcoefs(mftraceform([1,ell]),N)} is much faster.
\bprog
? tauvec(N) = Vec(q*eta(q + O(q^N))^24);
? N = 10^4; v = tauvec(N);
time = 26 ms.
? ramanujantau(N)
%3 = -482606811957501440000
? w = vector(N, n, ramanujantau(n)); \\ much slower !
time = 13,190 ms.
? v == w
%4 = 1
@eprog

The library syntax is \fun{GEN}{ramanujantau}{GEN n, long ell}.

\subsec{randomprime$(\{N = 2^{31}\}, \{q\})$}\kbdsidx{randomprime}\label{se:randomprime}
Returns a strong pseudo prime (see \tet{ispseudoprime}) in $[2,N-1]$.
A \typ{VEC} $N = [a,b]$ is also allowed, with $a \leq b$ in which case a
pseudo prime $a \leq p \leq b$ is returned; if no prime exists in the
interval, the function will run into an infinite loop. If the upper bound
is less than $2^{64}$ the pseudo prime returned is a proven prime.

\bprog
? randomprime(100)
%1 = 71
? randomprime([3,100])
%2 = 61
? randomprime([1,1])
 ***   at top-level: randomprime([1,1])
 ***                 ^------------------
 *** randomprime: domain error in randomprime:
 ***   floor(b) - max(ceil(a),2) < 0
? randomprime([24,28]) \\ infinite loop
@eprog

If the optional parameter $q$ is an integer, return a prime congruent to $1
\mod q$; if $q$ is an intmod, return a prime in the given congruence class.
If the class contains no prime in the given interval, the function will raise
an exception if the class is not invertible, else  run into an infinite loop

\bprog
? randomprime(100, 4)  \\ 1 mod 4
%1 = 71
? randomprime(100, 4)
%2 = 13
? randomprime([10,100], Mod(2,5))
%3 = 47
? randomprime(100, Mod(0,2)) \\ silly but works
%4 = 2
? randomprime([3,100], Mod(0,2)) \\ not invertible
 ***   at top-level: randomprime([3,100],Mod(0,2))
 ***                 ^-----------------------------
 *** randomprime: elements not coprime in randomprime:
   0
   2
? randomprime(100, 97) \\ infinite loop
@eprog

The library syntax is \fun{GEN}{randomprime0}{GEN N = NULL, GEN q = NULL}.
Also available is \fun{GEN}{randomprime}{GEN N = NULL}.

\subsec{removeprimes$(\{x=[\,]\})$}\kbdsidx{removeprimes}\label{se:removeprimes}
Removes the primes listed in $x$ from
the prime number table. In particular \kbd{removeprimes(addprimes())} empties
the extra prime table. $x$ can also be a single integer. List the current
extra primes if $x$ is omitted.

The library syntax is \fun{GEN}{removeprimes}{GEN x = NULL}.

\subsec{sigma$(x,\{k=1\})$}\kbdsidx{sigma}\label{se:sigma}
Sum of the $k^{\text{th}}$ powers of the positive divisors of $|x|$. $x$
and $k$ must be of type integer.

The library syntax is \fun{GEN}{sumdivk}{GEN x, long k}.
Also available is \fun{GEN}{sumdiv}{GEN n}, for $k = 1$.

\subsec{sqrtint$(x,\{\&r\})$}\kbdsidx{sqrtint}\label{se:sqrtint}
Returns the integer square root of $x$, i.e. the largest integer $y$
such that $y^2 \leq x$, where $x$ a nonnegative real number. If $r$ is present,
set it to the remainder $r = x - y^2$, which satisfies $0\leq r < 2y + 1$.
Further, when $x$ is an integer, $r$ is an integer satisfying
$0 \leq r \leq 2y$.
\bprog
? x = 120938191237; sqrtint(x)
%1 = 347761
? sqrt(x)
%2 = 347761.68741970412747602130964414095216
? y = sqrtint(x, &r); r
%3 = 478116
? x - y^2
%4 = 478116
? sqrtint(9/4, &r) \\ not 3/2 !
%5 = 1
? r
%6 = 5/4
@eprog

The library syntax is \fun{GEN}{sqrtint0}{GEN x, GEN *r = NULL}.
Also available is \fun{GEN}{sqrtint}{GEN a}.

\subsec{sqrtnint$(x,n)$}\kbdsidx{sqrtnint}\label{se:sqrtnint}
Returns the integer $n$-th root of $x$, i.e. the largest integer $y$ such
that $y^n \leq x$, where $x$ is a nonnegative real number.
\bprog
? N = 120938191237; sqrtnint(N, 5)
%1 = 164
? N^(1/5)
%2 = 164.63140849829660842958614676939677391
? sqrtnint(Pi^2, 3)
%3 = 2
@eprog\noindent The special case $n = 2$ is \tet{sqrtint}

The library syntax is \fun{GEN}{sqrtnint}{GEN x, long n}.

\subsec{sumdedekind$(h,k)$}\kbdsidx{sumdedekind}\label{se:sumdedekind}
Returns the \idx{Dedekind sum} attached to the integers $h$ and $k$,
 corresponding to a fast implementation of
 \bprog
  s(h,k) = sum(n = 1, k-1, (n/k)*(frac(h*n/k) - 1/2))
 @eprog

The library syntax is \fun{GEN}{sumdedekind}{GEN h, GEN k}.

\subsec{sumdigits$(n,\{B=10\})$}\kbdsidx{sumdigits}\label{se:sumdigits}
Sum of digits in the integer $|n|$, when written in base $B > 1$.
\bprog
? sumdigits(123456789)
%1 = 45
? sumdigits(123456789, 2)
%1 = 16
@eprog\noindent Note that the sum of bits in $n$ is also returned by
\tet{hammingweight}. This function is much faster than
\kbd{vecsum(digits(n,B))} when $B$ is $10$ or a power of $2$, and only
slightly faster in other cases.

The library syntax is \fun{GEN}{sumdigits0}{GEN n, GEN B = NULL}.
Also available is \fun{GEN}{sumdigits}{GEN n}, for $B = 10$.

\subsec{znchar$(D)$}\kbdsidx{znchar}\label{se:znchar}
Given a datum $D$ describing a group $(\Z/N\Z)^*$ and a Dirichlet
character $\chi$, return the pair \kbd{[G, chi]}, where \kbd{G} is
\kbd{znstar(N, 1)}) and \kbd{chi} is a GP character.

The following possibilities for $D$ are supported

\item a nonzero \typ{INT} congruent to $0,1$ modulo $4$, return the real
character modulo $D$ given by the Kronecker symbol $(D/.)$;

\item a \typ{INTMOD} \kbd{Mod(m, N)}, return the Conrey character
modulo $N$ of index $m$ (see \kbd{znconreylog}).

\item a modular form space as per \kbd{mfinit}$([N,k,\chi])$ or a modular
form for such a space, return the underlying Dirichlet character $\chi$
(which may be defined modulo a divisor of $N$ but need not be primitive).

In the remaining cases, \kbd{G} is initialized by \kbd{znstar(N, 1)}.

\item a pair \kbd{[G, chi]}, where \kbd{chi} is a standard GP Dirichlet
character $c = (c_j)$ on \kbd{G} (generic character \typ{VEC} or
Conrey characters \typ{COL} or \typ{INT}); given
generators $G = \oplus (\Z/d_j\Z) g_j$, $\chi(g_j) = e(c_j/d_j)$.

\item a pair \kbd{[G, chin]}, where \kbd{chin} is a \emph{normalized}
representation $[n, \tilde{c}]$ of the Dirichlet character $c$; $\chi(g_j)
= e(\tilde{c}_j / n)$ where $n$ is minimal (order of $\chi$).

\bprog
? [G,chi] = znchar(-3);
? G.cyc
%2 = [2]
? chareval(G, chi, 2)
%3 = 1/2
?  kronecker(-3,2)
%4 = -1
? znchartokronecker(G,chi)
%5 = -3
? mf = mfinit([28, 5/2, Mod(2,7)]); [f] = mfbasis(mf);
? [G,chi] = znchar(mf); [G.mod, chi]
%7 = [7, [2]~]
? [G,chi] = znchar(f); chi
%8 = [28, [0, 2]~]
@eprog

The library syntax is \fun{GEN}{znchar}{GEN D}.

\subsec{zncharconductor$(G,\var{chi})$}\kbdsidx{zncharconductor}\label{se:zncharconductor}
Let \var{G} be attached to $(\Z/q\Z)^*$ (as per
\kbd{G = znstar(q, 1)}) and \kbd{chi} be a Dirichlet character on
$(\Z/q\Z)^*$ (see \secref{se:dirichletchar} or \kbd{??character}).
Return the conductor of \kbd{chi}:
\bprog
? G = znstar(126000, 1);
? zncharconductor(G,11)   \\ primitive
%2 = 126000
? zncharconductor(G,1)    \\ trivial character, not primitive!
%3 = 1
? zncharconductor(G,1009) \\ character mod 5^3
%4 = 125
@eprog

The library syntax is \fun{GEN}{zncharconductor}{GEN G, GEN chi}.

\subsec{znchardecompose$(G, \var{chi}, Q)$}\kbdsidx{znchardecompose}\label{se:znchardecompose}
Let $N = \prod_p p^{e_p}$ and a Dirichlet character $\chi$,
we have a decomposition $\chi = \prod_p \chi_p$ into character modulo $N$
where the conductor of $\chi_p$ divides $p^{e_p}$; it equals $p^{e_p}$ for
all $p$ if and only if $\chi$ is primitive.

Given a \var{znstar} G describing a group $(\Z/N\Z)^*$, a Dirichlet
character \kbd{chi} and an integer $Q$, return $\prod_{p \mid (Q,N)} \chi_p$.
For instance, if $Q = p$ is a prime divisor of $N$, the function returns
$\chi_p$ (as a character modulo $N$), given as a Conrey character (\typ{COL}).

\bprog
? G = znstar(40, 1);
? G.cyc
%2 = [4, 2, 2]
? chi = [2, 1, 1];
? chi2 = znchardecompose(G, chi, 2)
%4 = [1, 1, 0]~
? chi5 = znchardecompose(G, chi, 5)
%5 = [0, 0, 2]~
? znchardecompose(G, chi, 3)
%6 = [0, 0, 0]~
? c = charmul(G, chi2, chi5)
%7 = [1, 1, 2]~  \\ t_COL: in terms of Conrey generators !
? znconreychar(G,c)
%8 = [2, 1, 1]   \\ t_VEC: in terms of SNF generators
@eprog

The library syntax is \fun{GEN}{znchardecompose}{GEN G, GEN chi, GEN Q}.

\subsec{znchargauss$(G, \var{chi}, \{a=1\})$}\kbdsidx{znchargauss}\label{se:znchargauss}
Given a Dirichlet character $\chi$ on $G = (\Z/N\Z)^*$ (see
\kbd{znchar}), return the complex Gauss sum
$$g(\chi,a) = \sum_{n = 1}^N \chi(n) e(a n/N)$$
\bprog
? [G,chi] = znchar(-3); \\ quadratic Gauss sum: I*sqrt(3)
? znchargauss(G,chi)
%2 = 1.7320508075688772935274463415058723670*I
? [G,chi] = znchar(5);
? znchargauss(G,chi)  \\ sqrt(5)
%2 = 2.2360679774997896964091736687312762354
? G = znstar(300,1); chi = [1,1,12]~;
? znchargauss(G,chi) / sqrt(300) - exp(2*I*Pi*11/25)  \\ = 0
%4 = 2.350988701644575016 E-38 + 1.4693679385278593850 E-39*I
? lfuntheta([G,chi], 1)  \\ = 0
%5 = -5.79[...] E-39 - 2.71[...] E-40*I
@eprog

The library syntax is \fun{GEN}{znchargauss}{GEN G, GEN chi, GEN a = NULL, long bitprec}.

\subsec{zncharinduce$(G, \var{chi}, N)$}\kbdsidx{zncharinduce}\label{se:zncharinduce}
Let $G$ be attached to $(\Z/q\Z)^*$ (as per \kbd{G = znstar(q,1)})
and let \kbd{chi} be a Dirichlet character on $(\Z/q\Z)^*$, given by

\item a \typ{VEC}: a standard character on \kbd{bid.gen},

\item a \typ{INT} or a \typ{COL}: a Conrey index in $(\Z/q\Z)^*$ or its
Conrey logarithm;
see \secref{se:dirichletchar} or \kbd{??character}.

Let $N$ be a multiple of $q$, return the character modulo $N$ extending
\kbd{chi}. As usual for arithmetic functions, the new modulus $N$ can be
given as a \typ{INT}, via a factorization matrix or a pair
\kbd{[N, factor(N)]}, or by \kbd{znstar(N,1)}.

\bprog
? G = znstar(4, 1);
? chi = znconreylog(G,1); \\ trivial character mod 4
? zncharinduce(G, chi, 80)  \\ now mod 80
%3 = [0, 0, 0]~
? zncharinduce(G, 1, 80)  \\ same using directly Conrey label
%4 = [0, 0, 0]~
? G2 = znstar(80, 1);
? zncharinduce(G, 1, G2)  \\ same
%4 = [0, 0, 0]~

? chi = zncharinduce(G, 3, G2)  \\ extend the nontrivial character mod 4
%5 = [1, 0, 0]~
? [G0,chi0] = znchartoprimitive(G2, chi);
? G0.mod
%7 = 4
? chi0
%8 = [1]~
@eprog\noindent Here is a larger example:
\bprog
? G = znstar(126000, 1);
? label = 1009;
? chi = znconreylog(G, label)
%3 = [0, 0, 0, 14, 0]~
? [G0,chi0] = znchartoprimitive(G, label); \\ works also with 'chi'
? G0.mod
%5 = 125
? chi0 \\ primitive character mod 5^3 attached to chi
%6 = [14]~
? G0 = znstar(N0, 1);
? zncharinduce(G0, chi0, G) \\ induce back
%8 = [0, 0, 0, 14, 0]~
? znconreyexp(G, %)
%9 = 1009
@eprog

The library syntax is \fun{GEN}{zncharinduce}{GEN G, GEN chi, GEN N}.

\subsec{zncharisodd$(G, \var{chi})$}\kbdsidx{zncharisodd}\label{se:zncharisodd}
Let $G$ be attached to $(\Z/N\Z)^*$ (as per \kbd{G = znstar(N,1)})
and let \kbd{chi} be a Dirichlet character on $(\Z/N\Z)^*$, given by

\item a \typ{VEC}: a standard character on \kbd{G.gen},

\item a \typ{INT} or a \typ{COL}: a Conrey index in $(\Z/q\Z)^*$ or its
Conrey logarithm;
see \secref{se:dirichletchar} or \kbd{??character}.

Return $1$ if and only if \kbd{chi}$(-1) = -1$ and $0$ otherwise.

\bprog
? G = znstar(8, 1);
? zncharisodd(G, 1)  \\ trivial character
%2 = 0
? zncharisodd(G, 3)
%3 = 1
? chareval(G, 3, -1)
%4 = 1/2
@eprog

The library syntax is \fun{long}{zncharisodd}{GEN G, GEN chi}.

\subsec{znchartokronecker$(G, \var{chi}, \{\fl=0\})$}\kbdsidx{znchartokronecker}\label{se:znchartokronecker}
Let $G$ be attached to $(\Z/N\Z)^*$ (as per \kbd{G = znstar(N,1)})
and let \kbd{chi} be a Dirichlet character on $(\Z/N\Z)^*$, given by

\item a \typ{VEC}: a standard character on \kbd{bid.gen},

\item a \typ{INT} or a \typ{COL}: a Conrey index in $(\Z/q\Z)^*$ or its
Conrey logarithm;
see \secref{se:dirichletchar} or \kbd{??character}.

If $\fl = 0$, return the discriminant $D$ if \kbd{chi} is real equal to the
Kronecker symbol $(D/.)$ and $0$ otherwise. The discriminant $D$ is
fundamental if and only if \kbd{chi} is primitive.

If $\fl = 1$, return the fundamental discriminant attached to the
corresponding primitive character.

\bprog
? G = znstar(8,1); CHARS = [1,3,5,7]; \\ Conrey labels
? apply(t->znchartokronecker(G,t), CHARS)
%2 = [4, -8, 8, -4]
? apply(t->znchartokronecker(G,t,1), CHARS)
%3 = [1, -8, 8, -4]
@eprog

The library syntax is \fun{GEN}{znchartokronecker}{GEN G, GEN chi, long flag}.

\subsec{znchartoprimitive$(G,\var{chi})$}\kbdsidx{znchartoprimitive}\label{se:znchartoprimitive}
Let \var{G} be attached to $(\Z/q\Z)^*$ (as per
\kbd{G = znstar(q, 1)}) and \kbd{chi} be a Dirichlet character on
$(\Z/q\Z)^*$, of conductor $q_0 \mid q$.

\bprog
? G = znstar(126000, 1);
? [G0,chi0] = znchartoprimitive(G,11)
? G0.mod
%3 = 126000
? chi0
%4 = 11
? [G0,chi0] = znchartoprimitive(G,1);\\ trivial character, not primitive!
? G0.mod
%6 = 1
? chi0
%7 = []~
? [G0,chi0] = znchartoprimitive(G,1009)
? G0.mod
%4 = 125
? chi0
%5 = [14]~
@eprog\noindent Note that \kbd{znconreyconductor} is more efficient since
it can return $\chi_0$ and its conductor $q_0$ without needing to initialize
$G_0$. The price to pay is a more cryptic format and the need to
initalize $G_0$ later, but that needs to be done only once for all characters
with conductor $q_0$.

The library syntax is \fun{GEN}{znchartoprimitive}{GEN G, GEN chi}.

\subsec{znconreychar$(G,m)$}\kbdsidx{znconreychar}\label{se:znconreychar}
Given a \var{znstar} $G$ attached to $(\Z/q\Z)^*$ (as per
\kbd{G = znstar(q,1)}), this function returns the Dirichlet character
attached to $m \in (\Z/q\Z)^*$ via Conrey's logarithm, which
establishes a ``canonical'' bijection between $(\Z/q\Z)^*$ and its dual.

Let $q = \prod_p p^{e_p}$ be the factorization of $q$ into distinct primes.
For all odd  $p$ with $e_p > 0$, let $g_p$ be the element in $(\Z/q\Z)^*$
which is

\item congruent to $1$ mod $q/p^{e_p}$,

\item congruent mod $p^{e_p}$ to the smallest positive integer that generates
$(\Z/p^2\Z)^*$.

For $p = 2$, we let $g_4$ (if $2^{e_2} \geq 4$) and $g_8$ (if furthermore
($2^{e_2} \geq 8$) be the elements in $(\Z/q\Z)^*$ which are

\item congruent to $1$ mod $q/2^{e_2}$,

\item $g_4 = -1 \mod 2^{e_2}$,

\item $g_8 = 5 \mod 2^{e_2}$.

Then the $g_p$ (and the extra $g_4$ and $g_8$ if $2^{e_2}\geq 2$) are
independent generators of $(\Z/q\Z)^*$, i.e. every $m$ in $(\Z/q\Z)^*$ can be
written uniquely as $\prod_p g_p^{m_p}$, where $m_p$ is defined modulo the
order $o_p$ of $g_p$ and $p \in S_q$, the set of prime divisors of $q$
together with $4$ if $4 \mid q$ and $8$ if $8 \mid q$. Note that the $g_p$
are in general \emph{not} SNF generators as produced by \kbd{znstar} whenever
$\omega(q) \geq 2$, although their number is the same. They however allow
to handle the finite abelian group $(\Z/q\Z)^*$ in a fast and elegant way.
(Which unfortunately does not generalize to ray class groups or Hecke
characters.)

The Conrey logarithm of $m$ is the vector $(m_p)_{p\in S_q}$, obtained
via \tet{znconreylog}. The Conrey character $\chi_q(m,\cdot)$  attached to
$m$ mod $q$ maps
each $g_p$, $p\in S_q$ to $e(m_p / o_p)$, where $e(x) = \exp(2i\pi x)$.
This function returns the Conrey character expressed in the standard PARI
way in terms of the SNF generators \kbd{G.gen}.

\bprog
? G = znstar(8,1);
? G.cyc
%2 = [2, 2]  \\ Z/2 x Z/2
? G.gen
%3 = [7, 3]
? znconreychar(G,1)  \\ 1 is always the trivial character
%4 = [0, 0]
? znconreychar(G,2)  \\ 2 is not coprime to 8 !!!
  ***   at top-level: znconreychar(G,2)
  ***                 ^-----------------
  *** znconreychar: elements not coprime in Zideallog:
    2
    8
  ***   Break loop: type 'break' to go back to GP prompt
break>

? znconreychar(G,3)
%5 = [0, 1]
? znconreychar(G,5)
%6 = [1, 1]
? znconreychar(G,7)
%7 = [1, 0]
@eprog\noindent We indeed get all 4 characters of $(\Z/8\Z)^*$.

For convenience, we allow to input the \emph{Conrey logarithm} of $m$
instead of $m$:
\bprog
? G = znstar(55, 1);
? znconreychar(G,7)
%2 = [7, 0]
? znconreychar(G, znconreylog(G,7))
%3 = [7, 0]
@eprog

The library syntax is \fun{GEN}{znconreychar}{GEN G, GEN m}.

\subsec{znconreyconductor$(G,\var{chi}, \{\&\var{chi0}\})$}\kbdsidx{znconreyconductor}\label{se:znconreyconductor}
Let \var{G} be attached to $(\Z/q\Z)^*$ (as per
\kbd{G = znstar(q, 1)}) and \kbd{chi} be a Dirichlet character on
$(\Z/q\Z)^*$, given by

\item a \typ{VEC}: a standard character on \kbd{bid.gen},

\item a \typ{INT} or a \typ{COL}: a Conrey index in $(\Z/q\Z)^*$ or its
Conrey logarithm;
see \secref{se:dirichletchar} or \kbd{??character}.

Return the conductor of \kbd{chi}, as the \typ{INT} \kbd{bid.mod}
if \kbd{chi} is primitive, and as a pair \kbd{[N, faN]} (with \kbd{faN} the
factorization of $N$) otherwise.

If \kbd{chi0} is present, set it to the Conrey logarithm of the attached
primitive character.

\bprog
? G = znstar(126000, 1);
? znconreyconductor(G,11)   \\ primitive
%2 = 126000
? znconreyconductor(G,1)    \\ trivial character, not primitive!
%3 = [1, matrix(0,2)]
? N0 = znconreyconductor(G,1009, &chi0) \\ character mod 5^3
%4 = [125, Mat([5, 3])]
? chi0
%5 = [14]~
? G0 = znstar(N0, 1);      \\ format [N,factor(N)] accepted
? znconreyexp(G0, chi0)
%7 = 9
? znconreyconductor(G0, chi0) \\ now primitive, as expected
%8 = 125
@eprog\noindent The group \kbd{G0} is not computed as part of
\kbd{znconreyconductor} because it needs to be computed only once per
conductor, not once per character.

The library syntax is \fun{GEN}{znconreyconductor}{GEN G, GEN chi, GEN *chi0 = NULL}.

\subsec{znconreyexp$(G, \var{chi})$}\kbdsidx{znconreyexp}\label{se:znconreyexp}
Given a \var{znstar} $G$ attached to $(\Z/q\Z)^*$ (as per
\kbd{G = znstar(q, 1)}), this function returns the Conrey exponential of
the character \var{chi}: it returns the integer
$m \in (\Z/q\Z)^*$ such that \kbd{znconreylog(G, $m$)} is \var{chi}.

The character \var{chi} is given either as a

\item \typ{VEC}: in terms of the generators \kbd{G.gen};

\item \typ{COL}: a Conrey logarithm.

\bprog
? G = znstar(126000, 1)
? znconreylog(G,1)
%2 = [0, 0, 0, 0, 0]~
? znconreyexp(G,%)
%3 = 1
? G.cyc \\ SNF generators
%4 = [300, 12, 2, 2, 2]
? chi = [100, 1, 0, 1, 0]; \\ some random character on SNF generators
? znconreylog(G, chi)  \\ in terms of Conrey generators
%6 = [0, 3, 3, 0, 2]~
? znconreyexp(G, %)  \\ apply to a Conrey log
%7 = 18251
? znconreyexp(G, chi) \\ ... or a char on SNF generators
%8 = 18251
? znconreychar(G,%)
%9 = [100, 1, 0, 1, 0]
@eprog

The library syntax is \fun{GEN}{znconreyexp}{GEN G, GEN chi}.

\subsec{znconreylog$(G,m)$}\kbdsidx{znconreylog}\label{se:znconreylog}
Given a \var{znstar} attached to $(\Z/q\Z)^*$ (as per
\kbd{G = znstar(q,1)}), this function returns the Conrey logarithm of
$m \in (\Z/q\Z)^*$.

Let $q = \prod_p p^{e_p}$ be the factorization of $q$ into distinct primes,
where we assume $e_2 = 0$ or $e_2 \geq 2$. (If $e_2 = 1$, we can ignore $2$
from the factorization, as if we replaced $q$ by $q/2$, since $(\Z/q\Z)^*
\sim (\Z/(q/2)\Z)^*$.)

For all odd  $p$ with $e_p > 0$, let $g_p$ be the element in $(\Z/q\Z)^*$
which is

\item congruent to $1$ mod $q/p^{e_p}$,

\item congruent mod $p^{e_p}$ to the smallest positive integer that generates
$(\Z/p^2\Z)^*$.

For $p = 2$, we let $g_4$ (if $2^{e_2} \geq 4$) and $g_8$ (if furthermore
($2^{e_2} \geq 8$) be the elements in $(\Z/q\Z)^*$ which are

\item congruent to $1$ mod $q/2^{e_2}$,

\item $g_4 = -1 \mod 2^{e_2}$,

\item $g_8 = 5 \mod 2^{e_2}$.

Then the $g_p$ (and the extra $g_4$ and $g_8$ if $2^{e_2}\geq 2$) are
independent generators of $\Z/q\Z^*$, i.e. every $m$ in $(\Z/q\Z)^*$ can be
written uniquely as $\prod_p g_p^{m_p}$, where $m_p$ is defined modulo the
order $o_p$ of $g_p$ and $p \in S_q$, the set of prime divisors of $q$
together with $4$ if $4 \mid q$ and $8$ if $8 \mid q$. Note that the $g_p$
are in general \emph{not} SNF generators as produced by \kbd{znstar} whenever
$\omega(q) \geq 2$, although their number is the same. They however allow
to handle the finite abelian group $(\Z/q\Z)^*$ in a fast and elegant way.
(Which unfortunately does not generalize to ray class groups or Hecke
characters.)

The Conrey logarithm of $m$ is the vector $(m_p)_{p\in S_q}$. The inverse
function \tet{znconreyexp} recovers the Conrey label $m$ from a character.

\bprog
? G = znstar(126000, 1);
? znconreylog(G,1)
%2 = [0, 0, 0, 0, 0]~
? znconreyexp(G, %)
%3 = 1
? znconreylog(G,2)  \\ 2 is not coprime to modulus !!!
  ***   at top-level: znconreylog(G,2)
  ***                 ^-----------------
  *** znconreylog: elements not coprime in Zideallog:
    2
    126000
  ***   Break loop: type 'break' to go back to GP prompt
break>
? znconreylog(G,11) \\ wrt. Conrey generators
%4 = [0, 3, 1, 76, 4]~
? log11 = ideallog(,11,G)   \\ wrt. SNF generators
%5 = [178, 3, -75, 1, 0]~
@eprog\noindent

For convenience, we allow to input the ordinary discrete log of $m$,
$\kbd{ideallog(,m,bid)}$, which allows to convert discrete logs
from \kbd{bid.gen} generators to Conrey generators.
\bprog
? znconreylog(G, log11)
%7 = [0, 3, 1, 76, 4]~
@eprog\noindent We also allow a character (\typ{VEC}) on \kbd{bid.gen} and
return its representation on the Conrey generators.
\bprog
? G.cyc
%8 = [300, 12, 2, 2, 2]
? chi = [10,1,0,1,1];
? znconreylog(G, chi)
%10 = [1, 3, 3, 10, 2]~
? n = znconreyexp(G, chi)
%11 = 84149
? znconreychar(G, n)
%12 = [10, 1, 0, 1, 1]
@eprog

The library syntax is \fun{GEN}{znconreylog}{GEN G, GEN m}.

\subsec{zncoppersmith$(P, N, X, \{B=N\})$}\kbdsidx{zncoppersmith}\label{se:zncoppersmith}
\idx{Coppersmith}'s algorithm. $N$ being an integer and $P\in \Z[t]$,
finds in polynomial time in $\log(N)$ and $d = \text{deg}(P)$ all integers $x$
with $|x| \leq X$ such that
$$\gcd(N, P(x)) \geq B.$$
This is a famous application of the \idx{LLL} algorithm meant to help in the
factorization of $N$. Notice that $P$ may be reduced modulo $N\Z[t]$ without
affecting the situation. The parameter $X$ must not be too large: assume for
now that the leading coefficient of $P$ is coprime to $N$, then we must have
$$d \log X \log N < \log^2 B,$$ i.e., $X < N^{1/d}$ when $B = N$. Let now
$P_0$ be the gcd of the leading coefficient of $P$ and $N$. In applications to
factorization, we should have $P_0 = 1$; otherwise, either $P_0 = N$ and we can
reduce the degree of $P$, or $P_0$ is a non trivial factor of $N$. For
completeness, we nevertheless document the exact conditions that $X$ must
satisfy in this case: let $p := \log_N P_0$, $b := \log_N B$, $x := \log_N
X$, then

\item either $p \geq d / (2d-1)$ is large and we must have $x d < 2b - 1$;

\item or $p < d / (2d-1)$ and we must have both $p < b < 1 - p + p/d$
and $x(d + p(1-2d)) < (b - p)^2$. Note that this reduces to
$x d < b^2$ when $p = 0$, i.e., the condition described above.

Some $x$ larger than $X$ may be returned if you are
very lucky. The routine runs in polynomial time in $\log N$ and $d$
but the smaller $B$, or the larger $X$, the slower.
The strength of Coppersmith method is the ability to find roots modulo a
general \emph{composite} $N$: if $N$ is a prime or a prime power,
\tet{polrootsmod} or \tet{polrootspadic} will be much faster.

We shall now present two simple applications. The first one is
finding nontrivial factors of $N$, given some partial information on the
factors; in that case $B$ must obviously be smaller than the largest
nontrivial divisor of $N$.
\bprog
setrand(1); \\ to make the example reproducible
[a,b] = [10^30, 10^31]; D = 20;
p = randomprime([a,b]);
q = randomprime([a,b]); N = p*q;
\\ assume we know 0) p | N; 1) p in [a,b]; 2) the last D digits of p
p0 = p % 10^D;

? L = zncoppersmith(10^D*x + p0, N, b \ 10^D, a)
time = 1ms.
%6 = [738281386540]
? gcd(L[1] * 10^D + p0, N) == p
%7 = 1
@eprog\noindent and we recovered $p$, faster than by trying all
possibilities $ x < 10^{11}$.

The second application is an attack on RSA with low exponent, when the
message $x$ is short and the padding $P$ is known to the attacker. We use
the same RSA modulus $N$ as in the first example:
\bprog
setrand(1);
P = random(N);    \\ known padding
e = 3;            \\ small public encryption exponent
X = floor(N^0.3); \\ N^(1/e - epsilon)
x0 = random(X);   \\ unknown short message
C = lift( (Mod(x0,N) + P)^e ); \\ known ciphertext, with padding P
zncoppersmith((P + x)^3 - C, N, X)

\\ result in 244ms.
%14 = [2679982004001230401]

? %[1] == x0
%15 = 1
@eprog\noindent
We guessed an integer of the order of $10^{18}$, almost instantly.

The library syntax is \fun{GEN}{zncoppersmith}{GEN P, GEN N, GEN X, GEN B = NULL}.

\subsec{znlog$(x,g,\{o\})$}\kbdsidx{znlog}\label{se:znlog}
This functions allows two distinct modes of operation depending
on $g$:

\item if $g$ is the output of \tet{znstar} (with initialization),
we compute the discrete logarithm of $x$ with respect to the generators
contained in the structure. See \tet{ideallog} for details.

\item else $g$ is an explicit element in $(\Z/N\Z)^*$, we compute the
discrete logarithm of $x$ in $(\Z/N\Z)^*$ in base $g$. The rest of this
entry describes the latter possibility.

The result is $[]$ when $x$ is not a power of $g$, though the function may
also enter an infinite loop in this case.

If present, $o$ represents the multiplicative order of $g$, see
\secref{se:DLfun}; the preferred format for this parameter is
\kbd{[ord, factor(ord)]}, where \kbd{ord} is the order of $g$.
This provides a definite speedup when the discrete log problem is simple:
\bprog
? p = nextprime(10^4); g = znprimroot(p); o = [p-1, factor(p-1)];
? for(i=1,10^4, znlog(i, g, o))
time = 163 ms.
? for(i=1,10^4, znlog(i, g))
time = 200 ms. \\ a little slower
@eprog

The result is undefined if $g$ is not invertible mod $N$ or if the supplied
order is incorrect.

This function uses

\item a combination of generic discrete log algorithms (see below).

\item in $(\Z/N\Z)^*$ when $N$ is prime: a linear sieve index calculus
method, suitable for $N < 10^{50}$, say, is used for large prime divisors of
the order.

The generic discrete log algorithms are:

\item Pohlig-Hellman algorithm, to reduce to groups of prime order $q$,
where $q | p-1$ and $p$ is an odd prime divisor of $N$,

\item Shanks baby-step/giant-step ($q < 2^{32}$ is small),

\item Pollard rho method ($q > 2^{32}$).

The latter two algorithms require $O(\sqrt{q})$ operations in the group on
average, hence will not be able to treat cases where $q > 10^{30}$, say.
In addition, Pollard rho is not able to handle the case where there are no
solutions: it will enter an infinite loop.
\bprog
? g = znprimroot(101)
%1 = Mod(2,101)
? znlog(5, g)
%2 = 24
? g^24
%3 = Mod(5, 101)

? G = znprimroot(2 * 101^10)
%4 = Mod(110462212541120451003, 220924425082240902002)
? znlog(5, G)
%5 = 76210072736547066624
? G^% == 5
%6 = 1
? N = 2^4*3^2*5^3*7^4*11; g = Mod(13, N); znlog(g^110, g)
%7 = 110
? znlog(6, Mod(2,3))  \\ no solution
%8 = []
@eprog\noindent For convenience, $g$ is also allowed to be a $p$-adic number:
\bprog
? g = 3+O(5^10); znlog(2, g)
%1 = 1015243
? g^%
%2 = 2 + O(5^10)
@eprog

The library syntax is \fun{GEN}{znlog0}{GEN x, GEN g, GEN o = NULL}.
The function
\fun{GEN}{znlog}{GEN x, GEN g, GEN o} is also available

\subsec{znorder$(x,\{o\})$}\kbdsidx{znorder}\label{se:znorder}
$x$ must be an integer mod $n$, and the
result is the order of $x$ in the multiplicative group $(\Z/n\Z)^*$. Returns
an error if $x$ is not invertible.
The parameter o, if present, represents a nonzero
multiple of the order of $x$, see \secref{se:DLfun}; the preferred format for
this parameter is \kbd{[ord, factor(ord)]}, where \kbd{ord = eulerphi(n)}
is the cardinality of the group.

The library syntax is \fun{GEN}{znorder}{GEN x, GEN o = NULL}.

\subsec{znprimroot$(n)$}\kbdsidx{znprimroot}\label{se:znprimroot}
Returns a primitive root (generator) of $(\Z/n\Z)^*$, whenever this
latter group is cyclic ($n = 4$ or $n = 2p^k$ or $n = p^k$, where $p$ is an
odd prime and $k \geq 0$). If the group is not cyclic, the function will raise an
exception. If $n$ is a prime power, then the smallest positive primitive
root is returned. This may not be true for $n = 2p^k$, $p$ odd.

Note that this function requires factoring $p-1$ for $p$ as above,
in order to determine the exact order of elements in
$(\Z/n\Z)^*$: this is likely to be costly if $p$ is large.

The library syntax is \fun{GEN}{znprimroot}{GEN n}.

\subsec{znstar$(n,\{\fl=0\})$}\kbdsidx{znstar}\label{se:znstar}
Gives the structure of the multiplicative group $(\Z/n\Z)^*$.
The output $G$ depends on the value of \fl:

\item $\fl = 0$ (default), an abelian group structure $[h,d,g]$,
where $h = \phi(n)$ is the order (\kbd{G.no}), $d$ (\kbd{G.cyc})
is a $k$-component row-vector $d$ of integers $d_i$ such that $d_i>1$,
$d_i \mid d_{i-1}$ for $i \ge 2$ and
$$ (\Z/n\Z)^* \simeq \prod_{i=1}^k (\Z/d_i\Z), $$
and $g$ (\kbd{G.gen}) is a $k$-component row vector giving generators of
the image of the cyclic groups $\Z/d_i\Z$.

\item $\fl = 1$ the result is a \kbd{bid} structure;
this allows computing discrete logarithms using \tet{znlog} (also in the
noncyclic case!).

\bprog
? G = znstar(40)
%1 = [16, [4, 2, 2], [Mod(17, 40), Mod(21, 40), Mod(11, 40)]]
? G.no   \\ eulerphi(40)
%2 = 16
? G.cyc  \\ cycle structure
%3 = [4, 2, 2]
? G.gen  \\ generators for the cyclic components
%4 = [Mod(17, 40), Mod(21, 40), Mod(11, 40)]
? apply(znorder, G.gen)
%5 = [4, 2, 2]
@eprog\noindent For user convenience, we define \kbd{znstar(0)} as
\kbd{[2, [2], [-1]]}, corresponding to $\Z^*$, but $\fl = 1$ is not
implemented in this trivial case.

The library syntax is \fun{GEN}{znstar0}{GEN n, long flag}.

\subsec{znsubgroupgenerators$(H, \{\fl=0\})$}\kbdsidx{znsubgroupgenerators}\label{se:znsubgroupgenerators}
Finds a minimal set of generators for the subgroup of $(\Z/f\Z)^*$
given by a vector (or vectorsmall) $H$ of length $f$:
for $1\leq a\leq f$, \kbd{H[a]} is 1 or 0 according as $a\in H_F$
or $a\not\in H_F$. In most PARI functions, subgroups of an abelian group
are given as HNF left-divisors of a diagonal matrix, representing the
discrete logarithms of the subgroup generators in terms of a fixed
generators for the group cyclic components. The present function
allows to convert an enumeration of the subgroup elements to this
representation as follows:
\bprog
? G = znstar(f, 1);
? v = znsubgroupgenerators(H);
? subHNF(G, v) = mathnfmodid(Mat([znlog(h, G) | h<-v]), G.cyc);
@eprog\noindent The function \kbd{subHNF} can be applied to any
elements of $(\Z/f\Z)^*$, yielding the subgroup they generate, but using
\kbd{znsubgroupgenerators} first allows to reduce the number of discrete
logarithms to be computed.

For example, if $H=\{\,1,4,11,14\,\}\subset(\Z/15\Z)^{\times}$,
then we have
\bprog
? f = 15; H = vector(f); H[1]=H[4]=H[11]=H[14] = 1;
? v = znsubgroupgenerators(H)
%2 = [4, 11]
? G = znstar(f, 1); G.cyc
%3 = [4, 2]
? subHNF(G, v)
%4 =
[2 0]

[0 1]
? subHNF(G, [1,4,11,14])
%5 =
[2 0]

[0 1]
@eprog\noindent This function is mostly useful when $f$ is large
and $H$ has small index: if $H$ has few elements, one may just use
\kbd{subHNF} directly on the elements of $H$. For instance, let
$K = \Q(\zeta_p, \sqrt{m}) \subset L = \Q(\zeta_f)$, where $p$ is
a prime, $\sqrt{m}$ is a quadratic number and $f$ is the conductor of the
abelian extension $K/\Q$. The following GP script creates $H$ as the Galois
group of $L/K$, as a subgroub of $(\Z/fZ)^*$:
\bprog
HK(m, p, flag = 0)=
{ my(d = quaddisc(m), f = lcm(d, p), H);
  H = vectorsmall(f, a, a % p == 1 && kronecker(d,a) > 0);
  [f, znsubgroupgenerators(H,flag)];
}
? [f, v] = HK(36322, 5)
time = 193 ms.
%1 = [726440, [41, 61, 111, 131]]
? G = znstar(f,1); G.cyc;
%2 = [1260, 12, 2, 2, 2, 2]
? A = subHNF(G, v)
%3 =
[2 0 1 1 0 1]

[0 4 0 0 0 2]

[0 0 1 0 0 0]

[0 0 0 1 0 0]

[0 0 0 0 1 0]

[0 0 0 0 0 1]
\\ Double check
? p = 5; d = quaddisc(36322);
? w = select(a->a % p == 1 && kronecker(d,a) > 0, [1..f]); #w
time = 133 ms.
%5 = 30240  \\ w enumerates the elements of H
? subHNF(G, w) == A \\ same result, about twice slower
time = 242 ms.
%6 = 1
@eprog\noindent
This shows that $K=\Q(\sqrt{36322},\zeta_5)$ is contained in
$\Q(\zeta_{726440})$ and $H=\langle 41, 61, 111, 131 \rangle$.
Note that $H=\langle 41\rangle\langle 61\rangle\langle 111 \rangle
\langle 131\rangle$ is not a direct product. If $\fl=1$, then the function
finds generators which decompose $H$ to direct factors:
\bprog
? HK(36322, 5, 1)
%3 = [726440, [41, 31261, 324611, 506221]]
@eprog\noindent This time
$H=\langle 41\rangle\times \langle 31261\rangle \times
\langle 324611 \rangle \times \langle 506221 \rangle$.

The library syntax is \fun{GEN}{znsubgroupgenerators}{GEN H, long flag}.

\section{Polynomials and power series}

We group here all functions which are specific to polynomials or power
series. Many other functions which can be applied on these objects are
described in the other sections. Also, some of the functions described here
can be applied to other types.

\subsec{O$(p\hbox{\kbd{\pow}}e)$}\kbdsidx{O}\label{se:O}
If $p$ is an integer
greater than $2$, returns a $p$-adic $0$ of precision $e$. In all other
cases, returns a power series zero with precision given by $e v$, where $v$
is the $X$-adic valuation of $p$ with respect to its main variable.

The library syntax is \fun{GEN}{ggrando}{}.
\fun{GEN}{zeropadic}{GEN p, long e} for a $p$-adic and
\fun{GEN}{zeroser}{long v, long e} for a power series zero in variable $v$.

\subsec{bezoutres$(A,B,\{v\})$}\kbdsidx{bezoutres}\label{se:bezoutres}
Deprecated alias for \kbd{polresultantext}

The library syntax is \fun{GEN}{polresultantext0}{GEN A, GEN B, long v = -1} where \kbd{v} is a variable number.

\subsec{deriv$(x,\{v\})$}\kbdsidx{deriv}\label{se:deriv}
Derivative of $x$ with respect to the main
variable if $v$ is omitted, and with respect to $v$ otherwise. The derivative
of a scalar type is zero, and the derivative of a vector or matrix is done
componentwise. One can use $x'$ as a shortcut if the derivative is with
respect to the main variable of $x$; and also use $x''$, etc., for multiple
derivatives altough \kbd{derivn} is often preferrable.

By definition, the main variable of a \typ{POLMOD} is the main variable among
the coefficients from its two polynomial components (representative and
modulus); in other words, assuming a polmod represents an element of
$R[X]/(T(X))$, the variable $X$ is a mute variable and the derivative is
taken with respect to the main variable used in the base ring $R$.

\bprog
? f = (x/y)^5;
? deriv(f)
%2 = 5/y^5*x^4
? f'
%3 = 5/y^5*x^4
? deriv(f, 'x) \\ same since 'x is the main variable
%4 = 5/y^5*x^4
? deriv(f, 'y)
%5 = -5/y^6*x^5
@eprog

This function also operates on closures, in which case the variable
must be omitted. It returns a closure performing a numerical
differentiation as per \kbd{derivnum}:
\bprog
? f(x) = x^2;
? g = deriv(f)
? g(1)
%3 = 2.0000000000000000000000000000000000000
? f(x) = sin(exp(x));
? deriv(f)(0)
%5 = 0.54030230586813971740093660744297660373
? cos(1)
%6 = 0.54030230586813971740093660744297660373
@eprog

The library syntax is \fun{GEN}{deriv}{GEN x, long v = -1} where \kbd{v} is a variable number.

\subsec{derivn$(x,n,\{v\})$}\kbdsidx{derivn}\label{se:derivn}
$n$-th derivative of $x$ with respect to the main
variable if $v$ is omitted, and with respect to $v$ otherwise; the integer
$n$ must be nonnegative. The derivative
of a scalar type is zero, and the derivative of a vector or matrix is done
componentwise. One can use $x'$, $x''$, etc., as a shortcut if the
derivative is with respect to the main variable of $x$.

By definition, the main variable of a \typ{POLMOD} is the main variable among
the coefficients from its two polynomial components (representative and
modulus); in other words, assuming a polmod represents an element of
$R[X]/(T(X))$, the variable $X$ is a mute variable and the derivative is
taken with respect to the main variable used in the base ring $R$.

\bprog
? f = (x/y)^5;
? derivn(f, 2)
%2 = 20/y^5*x^3
? f''
%3 = 20/y^5*x^3
? derivn(f, 2, 'x) \\ same since 'x is the main variable
%4 = 20/y^5*x^3
? derivn(f, 2, 'y)
%5 = 30/y^7*x^5
@eprog

This function also operates on closures, in which case the variable
must be omitted. It returns a closure performing a numerical
differentiation as per \kbd{derivnum}:
\bprog
? f(x) = x^10;
? g = derivn(f, 5)
? g(1)
%3 = 30240.000000000000000000000000000000000

? derivn(zeta, 2)(0)
%4 = -2.0063564559085848512101000267299604382
? zeta''(0)
%5 = -2.0063564559085848512101000267299604382
@eprog

The library syntax is \fun{GEN}{derivn}{GEN x, long n, long v = -1} where \kbd{v} is a variable number.

\subsec{diffop$(x,v,d,\{n=1\})$}\kbdsidx{diffop}\label{se:diffop}
Let $v$ be a vector of variables, and $d$ a vector of the same length,
return the image of $x$ by the $n$-power ($1$ if n is not given) of the
differential operator $D$ that assumes the value \kbd{d[i]} on the variable
\kbd{v[i]}. The value of $D$ on a scalar type is zero, and $D$ applies
componentwise to a vector or matrix. When applied to a \typ{POLMOD}, if no
value is provided for the variable of the modulus, such value is derived
using the implicit function theorem.

\misctitle{Examples}
This function can be used to differentiate formal expressions:
if $E=\exp(X^2)$ then we have $E'=2*X*E$. We derivate $X*exp(X^2)$
as follows:
\bprog
? diffop(E*X,[X,E],[1,2*X*E])
%1 = (2*X^2 + 1)*E
@eprog
Let \kbd{Sin} and \kbd{Cos} be two function such that
$\kbd{Sin}^2+\kbd{Cos}^2=1$ and $\kbd{Cos}'=-\kbd{Sin}$. We can differentiate
$\kbd{Sin}/\kbd{Cos}$ as follows,
PARI inferring the value of $\kbd{Sin}'$ from the equation:
\bprog
? diffop(Mod('Sin/'Cos,'Sin^2+'Cos^2-1),['Cos],[-'Sin])
%1 = Mod(1/Cos^2, Sin^2 + (Cos^2 - 1))
@eprog
Compute the Bell polynomials (both complete and partial) via the Faa di Bruno
formula:
\bprog
Bell(k,n=-1)=
{ my(x, v, dv, var = i->eval(Str("X",i)));

  v = vector(k, i, if (i==1, 'E, var(i-1)));
  dv = vector(k, i, if (i==1, 'X*var(1)*'E, var(i)));
  x = diffop('E,v,dv,k) / 'E;
  if (n < 0, subst(x,'X,1), polcoef(x,n,'X));
}
@eprog

The library syntax is \fun{GEN}{diffop0}{GEN x, GEN v, GEN d, long n}.

For $n=1$, the function \fun{GEN}{diffop}{GEN x, GEN v, GEN d} is also
available.

\subsec{eval$(x)$}\kbdsidx{eval}\label{se:eval}
Replaces in $x$ the formal variables by the values that
have been assigned to them after the creation of $x$. This is mainly useful
in GP, and not in library mode. Do not confuse this with substitution (see
\kbd{subst}).

If $x$ is a character string, \kbd{eval($x$)} executes $x$ as a GP
command, as if directly input from the keyboard, and returns its
output.
\bprog
? x1 = "one"; x2 = "two";
? n = 1; eval(Str("x", n))
%2 = "one"
? f = "exp"; v = 1;
? eval(Str(f, "(", v, ")"))
%4 = 2.7182818284590452353602874713526624978
@eprog\noindent Note that the first construct could be implemented in a
simpler way by using a vector \kbd{x = ["one","two"]; x[n]}, and the second
by using a closure \kbd{f = exp; f(v)}. The final example is more interesting:
\bprog
? genmat(u,v) = matrix(u,v,i,j, eval( Str("x",i,j) ));
? genmat(2,3)   \\ generic 2 x 3 matrix
%2 =
[x11 x12 x13]

[x21 x22 x23]
@eprog

A syntax error in the evaluation expression raises an \kbd{e\_SYNTAX}
exception, which can be trapped as usual:
\bprog
? 1a
 ***   syntax error, unexpected variable name, expecting $end or ';': 1a
 ***                                                                   ^-
? E(expr) =
  {
    iferr(eval(expr),
          e, print("syntax error"),
          errname(e) == "e_SYNTAX");
  }
? E("1+1")
%1 = 2
? E("1a")
syntax error
@eprog
\synt{geval}{GEN x}.

\subsec{factorpadic$(\var{pol},p,r)$}\kbdsidx{factorpadic}\label{se:factorpadic}
$p$-adic factorization
of the polynomial \var{pol} to precision $r$, the result being a
two-column matrix as in \kbd{factor}. Note that this is not the same
as a factorization over $\Z/p^r\Z$ (polynomials over that ring do not form a
unique factorization domain, anyway), but approximations in $\Q/p^r\Z$ of
the true factorization in $\Q_p[X]$.
\bprog
? factorpadic(x^2 + 9, 3,5)
%1 =
[(1 + O(3^5))*x^2 + O(3^5)*x + (3^2 + O(3^5)) 1]
? factorpadic(x^2 + 1, 5,3)
%2 =
[  (1 + O(5^3))*x + (2 + 5 + 2*5^2 + O(5^3)) 1]

[(1 + O(5^3))*x + (3 + 3*5 + 2*5^2 + O(5^3)) 1]
@eprog\noindent
The factors are normalized so that their leading coefficient is a power of
$p$. The method used is a modified version of the \idx{round 4} algorithm of
\idx{Zassenhaus}.

If \var{pol} has inexact \typ{PADIC} coefficients, this is not always
well-defined; in this case, the polynomial is first made integral by dividing
out the $p$-adic content,  then lifted to $\Z$ using \tet{truncate}
coefficientwise.
Hence we actually factor exactly a polynomial which is only $p$-adically
close to the input. To avoid pitfalls, we advise to only factor polynomials
with exact rational coefficients.

\synt{factorpadic}{GEN f,GEN p, long r} . The function \kbd{factorpadic0} is
deprecated, provided for backward compatibility.

\subsec{fft$(w,P)$}\kbdsidx{fft}\label{se:fft}
Let $w=[1,z,\ldots,z^{N-1}]$ from some primitive $N$-roots of unity $z$
where $N$ is a power of $2$, and $P$ be a polynomial $< N$,
return the unnormalized discrete Fourier transform of $P$,
$\{ P(w[i]), 1 \leq i \leq N\}$. Also allow $P$ to be a vector
$[p_0,\dots,p_n]$ representing the polynomial $\sum p_i X^i$.
Composing \kbd{fft} and \kbd{fftinv} returns $N$ times the original input
coefficients.
\bprog
? w = rootsof1(4); fft(w, x^3+x+1)
%1 = [3, 1, -1, 1]
? fftinv(w, %)
%2 = [4, 4, 0, 4]
? Polrev(%) / 4
%3 = x^3 + x + 1
? w = powers(znprimroot(5),3); fft(w, x^3+x+1)
%4 = [Mod(3,5),Mod(1,5),Mod(4,5),Mod(1,5)]
? fftinv(w, %)
%5 = [Mod(4,5),Mod(4,5),Mod(0,5),Mod(4,5)]
@eprog

The library syntax is \fun{GEN}{FFT}{GEN w, GEN P}.

\subsec{fftinv$(w,P)$}\kbdsidx{fftinv}\label{se:fftinv}
Let $w=[1,z,\ldots,z^{N-1}]$ from some primitive $N$-roots of unity $z$
where $N$ is a power of $2$, and $P$ be a polynomial $< N$,
return the unnormalized discrete Fourier transform of $P$,
$\{ P(1 / w[i]), 1 \leq i \leq N\}$. Also allow $P$ to be a vector
$[p_0,\dots,p_n]$ representing the polynomial $\sum p_i X^i$. Composing
\kbd{fft} and \kbd{fftinv} returns $N$ times the original input coefficients.
\bprog
? w = rootsof1(4); fft(w, x^3+x+1)
%1 = [3, 1, -1, 1]
? fftinv(w, %)
%2 = [4, 4, 0, 4]
? Polrev(%) / 4
%3 = x^3 + x + 1

? N = 512; w = rootsof1(N); T = random(1000 * x^(N-1));
? U = fft(w, T);
time = 3 ms.
? V = vector(N, i, subst(T, 'x, w[i]));
time = 65 ms.
? exponent(V - U)
%7 = -97
? round(Polrev(fftinv(w,U) / N)) == T
%8 = 1
@eprog

The library syntax is \fun{GEN}{FFTinv}{GEN w, GEN P}.

\subsec{intformal$(x,\{v\})$}\kbdsidx{intformal}\label{se:intformal}
\idx{formal integration} of $x$ with respect to the variable $v$ (wrt.
the main variable if $v$ is omitted). Since PARI cannot represent
logarithmic or arctangent terms, any such term in the result will yield an
error:
\bprog
 ? intformal(x^2)
 %1 = 1/3*x^3
 ? intformal(x^2, y)
 %2 = y*x^2
 ? intformal(1/x)
   ***   at top-level: intformal(1/x)
   ***                 ^--------------
   *** intformal: domain error in intformal: residue(series, pole) != 0
@eprog
The argument $x$ can be of any type. When $x$ is a rational function, we
assume that the base ring is an integral domain of characteristic zero.

  By  definition,   the main variable of a \typ{POLMOD} is the main variable
among the  coefficients  from  its  two  polynomial  components
(representative and modulus); in other words, assuming a polmod represents an
element of $R[X]/(T(X))$, the variable $X$ is a mute variable and the
integral is taken with respect to the main variable used in the base ring $R$.
In particular, it is meaningless to integrate with respect to the main
variable of \kbd{x.mod}:
\bprog
? intformal(Mod(1,x^2+1), 'x)
*** intformal: incorrect priority in intformal: variable x = x
@eprog

The library syntax is \fun{GEN}{integ}{GEN x, long v = -1} where \kbd{v} is a variable number.

\subsec{padicappr$(\var{pol},a)$}\kbdsidx{padicappr}\label{se:padicappr}
Vector of $p$-adic roots of the polynomial \var{pol} congruent to the
$p$-adic number $a$ modulo $p$, and with the same $p$-adic precision as $a$.
The number $a$ can be an ordinary $p$-adic number (type \typ{PADIC}, i.e.~an
element of $\Z_p$) or can be an integral element of a finite
\emph{unramified} extension $\Q_p[X]/(T)$ of $\Q_p$, given as a \typ{POLMOD}
\kbd{Mod}$(A,T)$ at least one of whose coefficients is a \typ{PADIC} and $T$
irreducible modulo $p$. In this case, the result is the vector of roots
belonging to the same extension of $\Q_p$ as $a$. The polynomial \var{pol}
should have exact coefficients; if not, its coefficients are first rounded
to $\Q$ or $\Q[X]/(T)$ and this is the polynomial whose roots we consider.

The library syntax is \fun{GEN}{padicappr}{GEN pol, GEN a}.
Also available is \fun{GEN}{Zp_appr}{GEN f, GEN a} when $a$ is a
\typ{PADIC}.

\subsec{padicfields$(p, N, \{\fl=0\})$}\kbdsidx{padicfields}\label{se:padicfields}
Returns a vector of polynomials generating all the extensions of degree
$N$ of the field $\Q_p$ of $p$-adic rational numbers; $N$ is
allowed to be a 2-component vector $[n,d]$, in which case we return the
extensions of degree $n$ and discriminant $p^d$.

The list is minimal in the sense that two different polynomials generate
nonisomorphic extensions; in particular, the number of polynomials is the
number of classes of nonisomorphic extensions. If $P$ is a polynomial in this
list, $\alpha$ is any root of $P$ and $K = \Q_p(\alpha)$, then $\alpha$
is the sum of a uniformizer and a (lift of a) generator of the residue field
of $K$; in particular, the powers of $\alpha$ generate the ring of $p$-adic
integers of $K$.

If $\fl = 1$, replace each polynomial $P$ by a vector $[P, e, f, d, c]$
where $e$ is the ramification index, $f$ the residual degree, $d$ the
valuation of the discriminant, and $c$ the number of conjugate fields.
If $\fl = 2$, only return the \emph{number} of extensions in a fixed
algebraic closure (Krasner's formula), which is much faster.

The library syntax is \fun{GEN}{padicfields0}{GEN p, GEN N, long flag}.
Also available is
\fun{GEN}{padicfields}{GEN p, long n, long d, long flag}, which computes
extensions of $\Q_p$ of degree $n$ and discriminant $p^d$.

\subsec{polchebyshev$(n,\{\fl=1\},\{a='x\})$}\kbdsidx{polchebyshev}\label{se:polchebyshev}
Returns the $n^{\text{th}}$
\idx{Chebyshev} polynomial of the first kind $T_n$ ($\fl=1$) or the second
kind $U_n$ ($\fl=2$), evaluated at $a$ (\kbd{'x} by default). Both series of
polynomials satisfy the 3-term relation
$$ P_{n+1} = 2xP_n - P_{n-1}, $$
and are determined by the initial conditions $U_0 = T_0 = 1$, $T_1 = x$,
$U_1 = 2x$. In fact $T_n' = n U_{n-1}$ and, for all complex numbers $z$, we
have $T_n(\cos z) = \cos (nz)$ and $U_{n-1}(\cos z) = \sin(nz)/\sin z$.
If $n \geq 0$, then these polynomials have degree $n$.  For $n < 0$,
$T_n$ is equal to $T_{-n}$ and $U_n$ is equal to $-U_{-2-n}$.
In particular, $U_{-1} = 0$.

The library syntax is \fun{GEN}{polchebyshev_eval}{long n, long flag, GEN a = NULL}.
Also available are
\fun{GEN}{polchebyshev}{long n, long flag, long v},
\fun{GEN}{polchebyshev1}{long n, long v} and
\fun{GEN}{polchebyshev2}{long n, long v} for $T_n$ and $U_n$ respectively.

\subsec{polclass$(D, \{\var{inv} = 0\}, \{x = 'x\})$}\kbdsidx{polclass}\label{se:polclass}
Return a polynomial in $\Z[x]$ generating the Hilbert class field for the
imaginary quadratic discriminant $D$.  If $inv$ is 0 (the default),
use the modular $j$-function and return the classical Hilbert polynomial,
otherwise use a class invariant. The following invariants correspond to
the different values of $inv$, where $f$ denotes Weber's function
\kbd{weber}, and $w_{p,q}$ the double eta quotient given by
$w_{p,q} = \dfrac{ \eta(x/p)\*\eta(x/q) }{ \eta(x)\*\eta(x/{pq}) }$

The invariants $w_{p,q}$ are not allowed unless they satisfy the following
technical conditions ensuring they do generate the Hilbert class
field and not a strict subfield:

\item if $p\neq q$, we need them both noninert, prime to the conductor of
$\Z[\sqrt{D}]$. Let $P, Q$ be prime ideals  above $p$ and $q$; if both are
unramified, we further require that $P^{\pm 1} Q^{\pm 1}$ be all distinct in
the class group of $\Z[\sqrt{D}]$; if both are ramified, we require that $PQ
\neq 1$ in the class group.

\item if $p = q$, we want it split and prime to the conductor and
the prime ideal above it must have order $\neq 1, 2, 4$ in the class group.

\noindent Invariants are allowed under the additional conditions on $D$
listed below.

\item 0 : $j$

\item 1 : $f$, $D = 1 \mod 8$ and $D = 1,2 \mod 3$;

\item 2 : $f^2$, $D = 1 \mod 8$ and $D = 1,2 \mod 3$;

\item 3 : $f^3$, $D = 1 \mod 8$;

\item 4 : $f^4$, $D = 1 \mod 8$ and $D = 1,2 \mod 3$;

\item 5 : $\gamma_2= j^{1/3}$, $D = 1,2 \mod 3$;

\item 6 : $w_{2,3}$, $D = 1 \mod 8$ and $D = 1,2 \mod 3$;

\item 8 : $f^8$, $D = 1 \mod 8$ and $D = 1,2 \mod 3$;

\item 9 : $w_{3,3}$, $D = 1 \mod 2$ and $D = 1,2 \mod 3$;

\item 10: $w_{2,5}$, $D \neq 60 \mod 80$ and $D = 1,2 \mod 3$;

\item 14: $w_{2,7}$, $D = 1 \mod 8$;

\item 15: $w_{3,5}$, $D = 1,2 \mod 3$;

\item 21: $w_{3,7}$, $D = 1 \mod 2$ and $21$ does not divide $D$

\item 23: $w_{2,3}^2$, $D = 1,2 \mod 3$;

\item 24: $w_{2,5}^2$, $D = 1,2 \mod 3$;

\item 26: $w_{2,13}$, $D \neq 156 \mod 208$;

\item 27: $w_{2,7}^2$, $D\neq 28 \mod 112$;

\item 28: $w_{3,3}^2$, $D = 1,2 \mod 3$;

\item 35: $w_{5,7}$, $D = 1,2 \mod 3$;

\item 39: $w_{3,13}$, $D = 1 \mod 2$ and $D = 1,2 \mod 3$;

The algorithm for computing the polynomial does not use the floating point
approach, which would evaluate a precise modular function in a precise
complex argument. Instead, it relies on a faster Chinese remainder based
approach modulo small primes, in which the class invariant is only defined
algebraically by the modular polynomial relating the modular function to $j$.
So in fact, any of the several roots of the modular polynomial may actually
be the class invariant, and more precise assertions cannot be made.

For instance, while \kbd{polclass(D)} returns the minimal polynomial of
$j(\tau)$ with $\tau$ (any) quadratic integer for the discriminant $D$,
the polynomial returned by \kbd{polclass(D, 5)} can be the minimal polynomial
of any of $\gamma_2 (\tau)$, $\zeta_3 \gamma_2 (\tau)$ or
$\zeta_3^2 \gamma_2 (\tau)$, the three roots of the modular polynomial
$j = \gamma_2^3$, in which $j$ has been specialised to $j (\tau)$.

The modular polynomial is given by
$j = {(f^{24}-16)^3 \over f^{24}}$ for Weber's function $f$.

For the double eta quotients of level $N = p q$, all functions are covered
such that the modular curve $X_0^+ (N)$, the function field of which is
generated by the functions invariant under $\Gamma^0 (N)$ and the
Fricke--Atkin--Lehner involution, is of genus $0$ with function field
generated by (a power of) the double eta quotient $w$.
This ensures that the full Hilbert class field (and not a proper subfield)
is generated by class invariants from these double eta quotients.
Then the modular polynomial is of degree $2$ in $j$, and
of degree $\psi (N) = (p+1)(q+1)$ in $w$.

\bprog
? polclass(-163)
%1 = x + 262537412640768000
? polclass(-51, , 'z)
%2 = z^2 + 5541101568*z + 6262062317568
? polclass(-151,1)
x^7 - x^6 + x^5 + 3*x^3 - x^2 + 3*x + 1
@eprog

The library syntax is \fun{GEN}{polclass}{GEN D, long inv, long x = -1} where \kbd{x} is a variable number.

\subsec{polcoef$(x,n,\{v\})$}\kbdsidx{polcoef}\label{se:polcoef}
Coefficient of degree $n$ of the polynomial $x$, with respect to the
main variable if $v$ is omitted, with respect to $v$ otherwise.  If $n$
is greater than the degree, the result is zero.

Naturally applies to scalars (polynomial of degree $0$), as well as to
rational functions whose denominator is a monomial. It also applies to power
series: if $n$ is less than the valuation, the result is zero. If it is
greater than the largest significant degree, then an error message is issued.

The library syntax is \fun{GEN}{polcoef}{GEN x, long n, long v = -1} where \kbd{v} is a variable number.

\subsec{polcoeff$(x,n,\{v\})$}\kbdsidx{polcoeff}\label{se:polcoeff}
Deprecated alias for polcoef.

The library syntax is \fun{GEN}{polcoef}{GEN x, long n, long v = -1} where \kbd{v} is a variable number.

\subsec{polcyclo$(n,\{a = 'x\})$}\kbdsidx{polcyclo}\label{se:polcyclo}
$n$-th cyclotomic polynomial, evaluated at $a$ (\kbd{'x} by default). The
integer $n$ must be positive.

Algorithm used: reduce to the case where $n$ is squarefree; to compute the
cyclotomic polynomial, use $\Phi_{np}(x)=\Phi_n(x^p)/\Phi(x)$; to compute
it evaluated, use $\Phi_n(x) = \prod_{d\mid n} (x^d-1)^{\mu(n/d)}$. In the
evaluated case, the algorithm assumes that $a^d - 1$ is either $0$ or
invertible, for all $d\mid n$. If this is not the case (the base ring has
zero divisors), use \kbd{subst(polcyclo(n),x,a)}.

The library syntax is \fun{GEN}{polcyclo_eval}{long n, GEN a = NULL}.
The variant \fun{GEN}{polcyclo}{long n, long v} returns the $n$-th
cyclotomic polynomial in variable $v$.

\subsec{polcyclofactors$(f)$}\kbdsidx{polcyclofactors}\label{se:polcyclofactors}
Returns a vector of polynomials, whose product is the product of
distinct cyclotomic polynomials dividing $f$.
\bprog
? f = x^10+5*x^8-x^7+8*x^6-4*x^5+8*x^4-3*x^3+7*x^2+3;
? v = polcyclofactors(f)
%2 = [x^2 + 1, x^2 + x + 1, x^4 - x^3 + x^2 - x + 1]
? apply(poliscycloprod, v)
%3 = [1, 1, 1]
? apply(poliscyclo, v)
%4 = [4, 3, 10]
@eprog\noindent In general, the polynomials are products of cyclotomic
polynomials and not themselves irreducible:
\bprog
? g = x^8+2*x^7+6*x^6+9*x^5+12*x^4+11*x^3+10*x^2+6*x+3;
? polcyclofactors(g)
%2 = [x^6 + 2*x^5 + 3*x^4 + 3*x^3 + 3*x^2 + 2*x + 1]
? factor(%[1])
%3 =
[            x^2 + x + 1 1]

[x^4 + x^3 + x^2 + x + 1 1]
@eprog

The library syntax is \fun{GEN}{polcyclofactors}{GEN f}.

\subsec{poldegree$(x,\{v\})$}\kbdsidx{poldegree}\label{se:poldegree}
Degree of the polynomial $x$ in the main variable if $v$ is omitted, in
the variable $v$ otherwise.

The degree of $0$ is \kbd{-oo}. The degree of a nonzero scalar is $0$.
Finally, when $x$ is a nonzero polynomial or rational function, returns the
ordinary degree of $x$. Raise an error otherwise.

The library syntax is \fun{GEN}{gppoldegree}{GEN x, long v = -1} where \kbd{v} is a variable number.
Also available is
\fun{long}{poldegree}{GEN x, long v}, which returns \tet{-LONG_MAX} if $x = 0$
and the degree as a \kbd{long} integer.

\subsec{poldisc$(\var{pol},\{v\})$}\kbdsidx{poldisc}\label{se:poldisc}
Discriminant of the polynomial
\var{pol} in the main variable if $v$ is omitted, in $v$ otherwise. Uses a
modular algorithm over $\Z$ or $\Q$, and the \idx{subresultant algorithm}
otherwise.
\bprog
? T = x^4 + 2*x+1;
? poldisc(T)
%2 = -176
? poldisc(T^2)
%3 = 0
@eprog

For convenience, the function also applies to types \typ{QUAD} and
\typ{QFB}:
\bprog
? z = 3*quadgen(8) + 4;
? poldisc(z)
%2 = 8
? q = Qfb(1,2,3);
? poldisc(q)
%4 = -8
@eprog

The library syntax is \fun{GEN}{poldisc0}{GEN pol, long v = -1} where \kbd{v} is a variable number.

\subsec{poldiscfactors$(T,\{\fl=0\})$}\kbdsidx{poldiscfactors}\label{se:poldiscfactors}
Given a polynomial $T$ with integer coefficients, return
$[D, \var{faD}]$ where $D$ is the discriminant of $T$ and
\var{faD} is a cheap partial factorization of $|D|$: entries in its first
column are coprime and not perfect powers but need not be primes.
The factors are obtained by a combination of trial division, testing for
perfect powers, factorizations in coprimes, and computing Euclidean
remainder sequences for $(T,T')$ modulo composite factors $d$ of $D$
(which is likely to produce $0$-divisors in $\Z/d\Z$).
If \fl\ is $1$, finish the factorization using \kbd{factorint}.
\bprog
? T = x^3 - 6021021*x^2 + 12072210077769*x - 8092423140177664432;
? [D,faD] = poldiscfactors(T); print(faD); D
[3, 3; 7, 2; 373, 2; 500009, 2; 24639061, 2]
%2 = -27937108625866859018515540967767467

? T = x^3 + 9*x^2 + 27*x - 125014250689643346789780229390526092263790263725;
? [D,faD] = poldiscfactors(T); print(faD)
[2, 6; 3, 3; 125007125141751093502187, 4]
? [D,faD] = poldiscfactors(T, 1); print(faD)
[2, 6; 3, 3; 500009, 12; 1000003, 4]
@eprog

The library syntax is \fun{GEN}{poldiscfactors}{GEN T, long flag}.

\subsec{poldiscreduced$(f)$}\kbdsidx{poldiscreduced}\label{se:poldiscreduced}
Reduced discriminant vector of the
(integral, monic) polynomial $f$. This is the vector of elementary divisors
of $\Z[\alpha]/f'(\alpha)\Z[\alpha]$, where $\alpha$ is a root of the
polynomial $f$. The components of the result are all positive, and their
product is equal to the absolute value of the discriminant of~$f$.

The library syntax is \fun{GEN}{reduceddiscsmith}{GEN f}.

\subsec{polgraeffe$(f)$}\kbdsidx{polgraeffe}\label{se:polgraeffe}
Returns the \idx{Graeffe} transform $g$ of $f$, such that $g(x^2) = f(x)
f(-x)$.

The library syntax is \fun{GEN}{polgraeffe}{GEN f}.

\subsec{polhensellift$(A, B, p, e)$}\kbdsidx{polhensellift}\label{se:polhensellift}
Given a prime $p$, an integral polynomial $A$ whose leading coefficient
is a $p$-unit, a vector $B$ of integral polynomials that are monic and
pairwise relatively prime modulo $p$, and whose product is congruent to
$A/\text{lc}(A)$ modulo $p$, lift the elements of $B$ to polynomials whose
product is congruent to $A$ modulo $p^e$.

More generally, if $T$ is an integral polynomial irreducible mod $p$, and
$B$ is a factorization of $A$ over the finite field $\F_p[t]/(T)$, you can
lift it to $\Z_p[t]/(T, p^e)$ by replacing the $p$ argument with $[p,T]$:
\bprog
? { T = t^3 - 2; p = 7; A = x^2 + t + 1;
    B = [x + (3*t^2 + t + 1), x + (4*t^2 + 6*t + 6)];
    r = polhensellift(A, B, [p, T], 6) }
%1 = [x + (20191*t^2 + 50604*t + 75783), x + (97458*t^2 + 67045*t + 41866)]
? liftall( r[1] * r[2] * Mod(Mod(1,p^6),T) )
%2 = x^2 + (t + 1)
@eprog

The library syntax is \fun{GEN}{polhensellift}{GEN A, GEN B, GEN p, long e}.

\subsec{polhermite$(n,\{a='x\},\{\fl=0\})$}\kbdsidx{polhermite}\label{se:polhermite}
$n^{\text{th}}$ \idx{Hermite} polynomial $H_n$ evaluated at $a$
(\kbd{'x} by default), i.e.
$$ H_n(x) = (-1)^n\*e^{x^2} \dfrac{d^n}{dx^n}e^{-x^2}.$$
If \fl\ is nonzero and $n > 0$, return $[H_{n-1}(a), H_n(a)]$.
\bprog
? polhermite(5)
%1 = 32*x^5 - 160*x^3 + 120*x
? polhermite(5, -2) \\ H_5(-2)
%2 = 16
? polhermite(5,,1)
%3 = [16*x^4 - 48*x^2 + 12, 32*x^5 - 160*x^3 + 120*x]
? polhermite(5,-2,1)
%4 = [76, 16]
@eprog

The library syntax is \fun{GEN}{polhermite_eval0}{long n, GEN a = NULL, long flag}.
The variant \fun{GEN}{polhermite}{long n, long v} returns the $n$-th
Hermite polynomial in variable $v$. To obtain $H_n(a)$,
use \fun{GEN}{polhermite_eval}{long n, GEN a}.

\subsec{polinterpolate$(X,\{Y\},\{t = 'x\},\{\&e\})$}\kbdsidx{polinterpolate}\label{se:polinterpolate}
Given the data vectors $X$ and $Y$ of the same length $n$
($X$ containing the $x$-coordinates, and $Y$ the corresponding
$y$-coordinates), this function finds the \idx{interpolating polynomial}
$P$ of minimal degree passing through these points and evaluates it at~$t$.
If $Y$ is omitted, the polynomial $P$ interpolates the $(i,X[i])$.

\bprog
? v = [1, 2, 4, 8, 11, 13];
? P = polinterpolate(v) \\ formal interpolation
%1 = 7/120*x^5 - 25/24*x^4 + 163/24*x^3 - 467/24*x^2 + 513/20*x - 11
? [ subst(P,'x,a) | a <- [1..6] ]
%2 = [1, 2, 4, 8, 11, 13]
? polinterpolate(v,, 10) \\ evaluate at 10
%3 = 508
? subst(P, x, 10)
%4 = 508

? P = polinterpolate([1,2,4], [9,8,7])
%5 = 1/6*x^2 - 3/2*x + 31/3
? [subst(P, 'x, a) | a <- [1,2,4]]
%6 = [9, 8, 7]
? P = polinterpolate([1,2,4], [9,8,7], 0)
%7 = 31/3
@eprog\noindent If the goal is to extrapolate a function at a unique point,
it is more efficient to use the $t$ argument rather than interpolate formally
then evaluate:
\bprog
? x0 = 1.5;
? v = vector(20, i,random([-10,10]));
? for(i=1,10^3, subst(polinterpolate(v),'x, x0))
time = 352 ms.
? for(i=1,10^3, polinterpolate(v,,x0))
time = 111 ms.

? v = vector(40, i,random([-10,10]));
? for(i=1,10^3, subst(polinterpolate(v), 'x, x0))
time = 3,035 ms.
? for(i=1,10^3, polinterpolate(v,, x0))
time = 436 ms.
@eprog\noindent The threshold depends on the base field. Over small prime
finite fields, interpolating formally first is more efficient
\bprog
? bench(p, N, T = 10^3) =
  { my (v = vector(N, i, random(Mod(0,p))));
    my (x0 = Mod(3, p), t1, t2);
    gettime();
    for(i=1, T, subst(polinterpolate(v), 'x, x0));
    t1 = gettime();
    for(i=1, T, polinterpolate(v,, x0));
    t2 = gettime(); [t1, t2];
  }
? p = 101;
? bench(p, 4, 10^4) \\ both methods are equivalent
%3 = [39, 40]
? bench(p, 40) \\ with 40 points formal is much faster
%4 = [45, 355]
@eprog\noindent As the cardinality increases, formal interpolation requires
more points to become interesting:
\bprog
? p = nextprime(2^128);
? bench(p, 4) \\ formal is slower
%3 = [16, 9]
? bench(p, 10) \\ formal has become faster
%4 = [61, 70]
? bench(p, 100) \\ formal is much faster
%5 = [1682, 9081]

? p = nextprime(10^500);
? bench(p, 4) \\ formal is slower
%7 = [72, 354]
? bench(p, 20) \\ formal is still slower
%8 = [1287, 962]
? bench(p, 40) \\ formal has become faster
%9 = [3717, 4227]
? bench(p, 100) \\ faster but relatively less impressive
%10 = [16237, 32335]
@eprog

If $t$ is a complex numeric value and $e$ is present, $e$ will contain an
error estimate on the returned value. More precisely, let $P$ be the
interpolation polynomial on the given $n$ points; there exist a subset
of $n-1$ points and $Q$ the attached interpolation polynomial
such that $e = \kbd{exponent}(P(t) - Q(t))$ (Neville's algorithm).
\bprog
? f(x) = 1 / (1 + 25*x^2);
? x0 = 975/1000;
? test(X) =
  { my (P, e);
    P = polinterpolate(X, [f(x) | x <- X], x0, &e);
    [ exponent(P - f(x0)), e ];
  }
\\ equidistant nodes vs. Chebyshev nodes
? test( [-10..10] / 10 )
%4 = [6, 5]
? test( polrootsreal(polchebyshev(21)) )
%5 = [-15, -10]

? test( [-100..100] / 100 )
%7 = [93, 97] \\ P(x0) is way different from f(x0)
? test( polrootsreal(polchebyshev(201)) )
%8 = [-60, -55]
@eprog\noindent This is an example of Runge's phenomenon: increasing the
number of equidistant nodes makes extrapolation much worse. Note that the
error estimate is not a guaranteed upper bound (cf \%4), but is reasonably
tight in practice.

\misctitle{Numerical stability} The interpolation is performed in
a numerically stable way using $\prod_{j\neq i} (X[i] - X[j])$ instead of
$Q'(X[i])$ with $Q = \prod_i (x - X[i])$. Centering the interpolation
points $X[i]$ around $0$, thereby reconstructing $P(x - m)$, for a suitable
$m$ will further reduce the numerical error.

The library syntax is \fun{GEN}{polint}{GEN X, GEN Y = NULL, GEN t = NULL, GEN *e = NULL}.

\subsec{poliscyclo$(f)$}\kbdsidx{poliscyclo}\label{se:poliscyclo}
Returns 0 if $f$ is not a cyclotomic polynomial, and $n > 0$ if $f =
\Phi_n$, the $n$-th cyclotomic polynomial.
\bprog
? poliscyclo(x^4-x^2+1)
%1 = 12
? polcyclo(12)
%2 = x^4 - x^2 + 1
? poliscyclo(x^4-x^2-1)
%3 = 0
@eprog

The library syntax is \fun{long}{poliscyclo}{GEN f}.

\subsec{poliscycloprod$(f)$}\kbdsidx{poliscycloprod}\label{se:poliscycloprod}
Returns 1 if $f$ is a product of cyclotomic polynomial, and $0$
otherwise.
\bprog
? f = x^6+x^5-x^3+x+1;
? poliscycloprod(f)
%2 = 1
? factor(f)
%3 =
[  x^2 + x + 1 1]

[x^4 - x^2 + 1 1]
? [ poliscyclo(T) | T <- %[,1] ]
%4 = [3, 12]
? polcyclo(3) * polcyclo(12)
%5 = x^6 + x^5 - x^3 + x + 1
@eprog

The library syntax is \fun{long}{poliscycloprod}{GEN f}.

\subsec{polisirreducible$(\var{pol})$}\kbdsidx{polisirreducible}\label{se:polisirreducible}
\var{pol} being a polynomial (univariate in the present version \vers),
returns 1 if \var{pol} is nonconstant and irreducible, 0 otherwise.
Irreducibility is checked over the smallest base field over which \var{pol}
seems to be defined.

The library syntax is \fun{long}{polisirreducible}{GEN pol}.

\subsec{pollaguerre$(n,\{a=0\},\{b='x\},\{\fl=0\})$}\kbdsidx{pollaguerre}\label{se:pollaguerre}
$n^{\text{th}}$ \idx{Laguerre polynomial} $L^{(a)}_n$ of degree $n$ and
parameter $a$ evaluated at $b$ (\kbd{'x} by default), i.e.
$$ L_n^{(a)}(x) =
   \dfrac{x^{-a}e^x}{n!} \dfrac{d^n}{dx^n}\big(e^{-x}x^{n+a}\big).$$
If \fl\ is $1$, return $[L^{(a)}_{n-1}(b), L_n^{(a)}(b)]$.

The library syntax is \fun{GEN}{pollaguerre_eval0}{long n, GEN a = NULL, GEN b = NULL, long flag}.
To obtain the $n$-th Laguerre polynomial in variable $v$,
use \fun{GEN}{pollaguerre}{long n, GEN a, GEN b, long v}. To obtain
$L^{(a)}_n(b)$, use \fun{GEN}{pollaguerre_eval}{long n, GEN a, GEN b}.

\subsec{pollead$(x,\{v\})$}\kbdsidx{pollead}\label{se:pollead}
Leading coefficient of the polynomial or power series $x$. This is
 computed with respect to the main variable of $x$ if $v$ is omitted, with
 respect to the variable $v$ otherwise.

The library syntax is \fun{GEN}{pollead}{GEN x, long v = -1} where \kbd{v} is a variable number.

\subsec{pollegendre$(n,\{a='x\},\{\fl=0\})$}\kbdsidx{pollegendre}\label{se:pollegendre}
$n^{\text{th}}$ \idx{Legendre polynomial} $P_n$ evaluated at $a$ (\kbd{'x}
by default), where
$$P_n(x) = \dfrac{1}{2^n n!} \dfrac{d^n}{dx^n}(x^2-1)^n\;.$$
If \fl\ is 1, return $[P_{n-1}(a), P_n(a)]$.

The library syntax is \fun{GEN}{pollegendre_eval0}{long n, GEN a = NULL, long flag}.
To obtain the $n$-th Legendre polynomial $P_n$ in variable $v$,
use \fun{GEN}{pollegendre}{long n, long v}. To obtain $P_n(a)$,
use \fun{GEN}{pollegendre_eval}{long n, GEN a}.

\subsec{polmodular$(L, \{\var{inv} = 0\}, \{x = 'x\}, \{y = 'y\}, \{\var{derivs} = 0\})$}\kbdsidx{polmodular}\label{se:polmodular}
Return the modular polynomial of prime level $L$ in variables $x$ and $y$
for the modular function specified by \kbd{inv}.  If \kbd{inv} is 0 (the
default), use the modular $j$ function, if \kbd{inv} is 1 use the
Weber-$f$ function, and if \kbd{inv} is 5 use $\gamma_2 =
\sqrt[3]{j}$.
See \kbd{polclass} for the full list of invariants.
If $x$ is given as \kbd{Mod(j, p)} or an element $j$ of
a finite field (as a \typ{FFELT}), then return the modular polynomial of
level $L$ evaluated at $j$.  If $j$ is from a finite field and
\kbd{derivs} is nonzero, then return a triple where the
last two elements are the first and second derivatives of the modular
polynomial evaluated at $j$.
\bprog
? polmodular(3)
%1 = x^4 + (-y^3 + 2232*y^2 - 1069956*y + 36864000)*x^3 + ...
? polmodular(7, 1, , 'J)
%2 = x^8 - J^7*x^7 + 7*J^4*x^4 - 8*J*x + J^8
? polmodular(7, 5, 7*ffgen(19)^0, 'j)
%3 = j^8 + 4*j^7 + 4*j^6 + 8*j^5 + j^4 + 12*j^2 + 18*j + 18
? polmodular(7, 5, Mod(7,19), 'j)
%4 = Mod(1, 19)*j^8 + Mod(4, 19)*j^7 + Mod(4, 19)*j^6 + ...

? u = ffgen(5)^0; T = polmodular(3,0,,'j)*u;
? polmodular(3, 0, u,'j,1)
%6 = [j^4 + 3*j^2 + 4*j + 1, 3*j^2 + 2*j + 4, 3*j^3 + 4*j^2 + 4*j + 2]
? subst(T,x,u)
%7 = j^4 + 3*j^2 + 4*j + 1
? subst(T',x,u)
%8 = 3*j^2 + 2*j + 4
? subst(T'',x,u)
%9 = 3*j^3 + 4*j^2 + 4*j + 2
@eprog

The library syntax is \fun{GEN}{polmodular}{long L, long inv, GEN x = NULL, long y = -1, long derivs} where \kbd{y} is a variable number.

\subsec{polrecip$(\var{pol})$}\kbdsidx{polrecip}\label{se:polrecip}
Reciprocal polynomial of \var{pol} with respect to its main variable,
i.e.~the coefficients of the result are in reverse order; \var{pol} must be
a polynomial.
\bprog
? polrecip(x^2 + 2*x + 3)
%1 = 3*x^2 + 2*x + 1
? polrecip(2*x + y)
%2 = y*x + 2
@eprog

The library syntax is \fun{GEN}{polrecip}{GEN pol}.

\subsec{polresultant$(x,y,\{v\},\{\fl=0\})$}\kbdsidx{polresultant}\label{se:polresultant}
Resultant of the two
polynomials $x$ and $y$ with exact entries, with respect to the main
variables of $x$ and $y$ if $v$ is omitted, with respect to the variable $v$
otherwise. The algorithm assumes the base ring is a domain. If you also need
the $u$ and $v$ such that $x*u + y*v = \text{Res}(x,y)$, use the
\tet{polresultantext} function.

If $\fl=0$ (default), uses the algorithm best suited to the inputs,
either the \idx{subresultant algorithm} (Lazard/Ducos variant, generic case),
a modular algorithm (inputs in $\Q[X]$) or Sylvester's matrix (inexact
inputs).

If $\fl=1$, uses the determinant of Sylvester's matrix instead; this should
always be slower than the default.

If $x$ or $y$ are multivariate with a huge \emph{polynomial} content, it
is advisable to remove it before calling this function. Compare:
\bprog
? a = polcyclo(7) * ((t+1)/(t+2))^100;
? b = polcyclo(11)* ((t+2)/(t+3))^100);
? polresultant(a,b);
time = 3,833 ms.
? ca = content(a); cb = content(b); \
  polresultant(a/ca,b/cb)*ca^poldegree(b)*cb*poldegree(a); \\ instantaneous
@eprog\noindent The function only removes rational denominators and does
not compute automatically the content because it is generically small and
potentially \emph{very} expensive (e.g. in multivariate contexts).
The choice is yours, depending on your application.

The library syntax is \fun{GEN}{polresultant0}{GEN x, GEN y, long v = -1, long flag} where \kbd{v} is a variable number.

\subsec{polresultantext$(A,B,\{v\})$}\kbdsidx{polresultantext}\label{se:polresultantext}
Finds polynomials $U$ and $V$ such that $A*U + B*V = R$, where $R$ is
the resultant of $U$ and $V$ with respect to the main variables of $A$ and
$B$ if $v$ is omitted, and with respect to $v$ otherwise. Returns the row
vector $[U,V,R]$. The algorithm used (subresultant) assumes that the base
ring is a domain.
\bprog
? A = x*y; B = (x+y)^2;
? [U,V,R] = polresultantext(A, B)
%2 = [-y*x - 2*y^2, y^2, y^4]
? A*U + B*V
%3 = y^4
? [U,V,R] = polresultantext(A, B, y)
%4 = [-2*x^2 - y*x, x^2, x^4]
? A*U+B*V
%5 = x^4
@eprog

The library syntax is \fun{GEN}{polresultantext0}{GEN A, GEN B, long v = -1} where \kbd{v} is a variable number.
Also available is
\fun{GEN}{polresultantext}{GEN x, GEN y}.

\subsec{polroots$(T)$}\kbdsidx{polroots}\label{se:polroots}
Complex roots of the polynomial $T$, given as a column vector where each
root is repeated according to its multiplicity and given as floating point
complex numbers at the current \kbd{realprecision}:
\bprog
? polroots(x^2)
%1 = [0.E-38 + 0.E-38*I, 0.E-38 + 0.E-38*I]~

? polroots(x^3+1)
%2 = [-1.00... + 0.E-38*I, 0.50... - 0.866...*I, 0.50... + 0.866...*I]~
@eprog

The algorithm used is a modification of Sch\"onhage\sidx{Sch\"onage}'s
root-finding algorithm, due to and originally implemented by Gourdon.
It runs in polynomial time in $\text{deg}(T)$ and the precision.
If furthermore $T$ has rational coefficients, roots are guaranteed to the
required relative accuracy. If the input polynomial $T$ is exact, then
the ordering of the roots does not depend on the precision: they are ordered
by increasing $|\Im z|$, then by increasing $\Re z$; in case of tie
(conjugates), the root with negative imaginary part comes first.

The library syntax is \fun{GEN}{roots}{GEN T, long prec}.

\subsec{polrootsbound$(T, \{\var{tau} = 0.01\})$}\kbdsidx{polrootsbound}\label{se:polrootsbound}
Return a sharp upper bound $B$ for the modulus of
the largest complex root of the polynomial $T$ with complex coefficients
with relative error $\tau$. More precisely, we have $|z| \leq B$ for all roots
and there exist one root such that $|z_0| \geq B \exp(-2\tau)$. Much faster
than either polroots or polrootsreal.
\bprog
? T=poltchebi(500);
? vecmax(abs(polroots(T)))
time = 5,706 ms.
%2 = 0.99999506520185816611184481744870013191
? vecmax(abs(polrootsreal(T)))
time = 1,972 ms.
%3 = 0.99999506520185816611184481744870013191
? polrootsbound(T)
time = 217 ms.
%4 = 1.0098792554165905155
? polrootsbound(T, log(2)/2) \\ allow a factor 2, much faster
time = 51 ms.
%5 = 1.4065759938190154354
? polrootsbound(T, 1e-4)
time = 504 ms.
%6 = 1.0000920717983847741
? polrootsbound(T, 1e-6)
time = 810 ms.
%7 = 0.9999960628901692905
? polrootsbound(T, 1e-10)
time = 1,351 ms.
%8 = 0.9999950652993869760
@eprog

The library syntax is \fun{GEN}{polrootsbound}{GEN T, GEN tau = NULL}.

\subsec{polrootsff$(x,\{p\},\{a\})$}\kbdsidx{polrootsff}\label{se:polrootsff}
Obsolete, kept for backward compatibility: use factormod.

The library syntax is \fun{GEN}{polrootsff}{GEN x, GEN p = NULL, GEN a = NULL}.

\subsec{polrootsmod$(f,\{D\})$}\kbdsidx{polrootsmod}\label{se:polrootsmod}
Vector of roots of the polynomial $f$ over the finite field defined
by the domain $D$ as follows:

\item $D = p$ a prime: factor over $\F_p$;

\item $D = [T,p]$ for a prime $p$ and $T(y)$ an irreducible polynomial over
$\F_p$: factor over $\F_p[y]/(T)$ (as usual the main variable of $T$
must have lower priority than the main variable of $f$);

\item $D$ a \typ{FFELT}: factor over the attached field;

\item $D$ omitted: factor over the field of definition of $f$, which
must be a finite field.

\noindent Multiple roots are \emph{not} repeated.
\bprog
? polrootsmod(x^2-1,2)
%1 = [Mod(1, 2)]~
? polrootsmod(x^2+1,3)
%2 = []~
? polrootsmod(x^2+1, [y^2+1,3])
%3 = [Mod(Mod(1, 3)*y, Mod(1, 3)*y^2 + Mod(1, 3)),
      Mod(Mod(2, 3)*y, Mod(1, 3)*y^2 + Mod(1, 3))]~
? polrootsmod(x^2 + Mod(1,3))
%4 = []~
? liftall( polrootsmod(x^2 + Mod(Mod(1,3),y^2+1)) )
%5 = [y, 2*y]~
? t = ffgen(y^2+Mod(1,3)); polrootsmod(x^2 + t^0)
%6 = [y, 2*y]~
@eprog

The library syntax is \fun{GEN}{polrootsmod}{GEN f, GEN D = NULL}.

\subsec{polrootspadic$(f,p,r)$}\kbdsidx{polrootspadic}\label{se:polrootspadic}
Vector of $p$-adic roots of the polynomial \var{pol}, given to
$p$-adic precision $r$; the integer $p$ is assumed to be a prime.
Multiple roots are
\emph{not} repeated. Note that this is not the same as the roots in
$\Z/p^r\Z$, rather it gives approximations in $\Z/p^r\Z$ of the true roots
living in $\Q_p$:
\bprog
? polrootspadic(x^3 - x^2 + 64, 2, 4)
%1 = [2^3 + O(2^4), 2^3 + O(2^4), 1 + O(2^4)]~
? polrootspadic(x^3 - x^2 + 64, 2, 5)
%2 = [2^3 + O(2^5), 2^3 + 2^4 + O(2^5), 1 + O(2^5)]~
@eprog\noindent As the second commands show, the first two roots \emph{are}
distinct in $\Q_p$, even though they are equal modulo $2^4$.

More generally, if $T$ is an integral polynomial irreducible
mod $p$ and $f$ has coefficients in $\Q[t]/(T)$, the argument $p$
may be replaced by the vector $[T,p]$; we then return the roots of $f$ in
the unramified extension $\Q_p[t]/(T)$.
\bprog
? polrootspadic(x^3 - x^2 + 64*y, [y^2+y+1,2], 5)
%3 = [Mod((2^3 + O(2^5))*y + (2^3 + O(2^5)), y^2 + y + 1),
      Mod((2^3 + 2^4 + O(2^5))*y + (2^3 + 2^4 + O(2^5)), y^2 + y + 1),
      Mod(1 + O(2^5), y^2 + y + 1)]~
@eprog

If \var{pol} has inexact \typ{PADIC} coefficients, this need not
well-defined; in this case, the polynomial is first made integral by
dividing out the $p$-adic content, then lifted to $\Z$ using \tet{truncate}
coefficientwise. Hence the roots given are approximations of the roots of an
exact polynomial which is $p$-adically close to the input. To avoid pitfalls,
we advise to only factor polynomials with exact rational coefficients.

The library syntax is \fun{GEN}{polrootspadic}{GEN f, GEN p, long r}.

\subsec{polrootsreal$(T, \{\var{ab}\})$}\kbdsidx{polrootsreal}\label{se:polrootsreal}
Real roots of the polynomial $T$ with real coefficients, multiple
roots being included according to their multiplicity. If the polynomial
does not have rational coefficients, it is first rescaled and rounded.
The roots are given to a relative accuracy of \kbd{realprecision}.
If argument \var{ab} is
present, it must be a vector $[a,b]$ with two components (of type
\typ{INT}, \typ{FRAC} or \typ{INFINITY}) and we restrict to roots belonging
to that closed interval.
\bprog
? \p9
? polrootsreal(x^2-2)
%1 = [-1.41421356, 1.41421356]~
? polrootsreal(x^2-2, [1,+oo])
%2 = [1.41421356]~
? polrootsreal(x^2-2, [2,3])
%3 = []~
? polrootsreal((x-1)*(x-2), [2,3])
%4 = [2.00000000]~
@eprog\noindent
The algorithm used is a modification of Uspensky's method (relying on
Descartes's rule of sign), following Rouillier and Zimmerman's article
``Efficient isolation of a polynomial real roots''
(\url{http://hal.inria.fr/inria-00072518/}). Barring bugs, it is guaranteed
to converge and to give the roots to the required accuracy.

\misctitle{Remark} If the polynomial $T$ is of the
form $Q(x^h)$ for some $h\geq 2$ and \var{ab} is omitted, the routine will
apply the algorithm to $Q$ (restricting to nonnegative roots when $h$ is
even), then take $h$-th roots. On the other hand, if you want to specify
\var{ab}, you should apply the routine to $Q$ yourself and a suitable
interval $[a',b']$ using approximate $h$-th roots adapted to your problem:
the function will not perform this change of variables if \var{ab} is present.

The library syntax is \fun{GEN}{realroots}{GEN T, GEN ab = NULL, long prec}.

\subsec{polsturm$(T,\{\var{ab}\})$}\kbdsidx{polsturm}\label{se:polsturm}
Number of distinct real roots of the real polynomial \var{T}. If
the argument \var{ab} is present, it must be a vector $[a,b]$ with
two real components (of type \typ{INT}, \typ{REAL}, \typ{FRAC}
or  \typ{INFINITY}) and we count roots belonging to that closed interval.

If possible, you should stick to exact inputs, that is avoid \typ{REAL}s in
$T$ and the bounds $a,b$: the result is then guaranteed and we use a fast
algorithm (Uspensky's method, relying on Descartes's rule of sign, see
\tet{polrootsreal}). Otherwise, the polynomial is rescaled and rounded first
and the result may be wrong due to that initial error. If only $a$ or $b$ is
inexact, on the other hand, the interval is first thickened using rational
endpoints and the result remains guaranteed unless there exist a root
\emph{very} close to a nonrational endpoint (which may be missed or unduly
included).
\bprog
? T = (x-1)*(x-2)*(x-3);
? polsturm(T)
%2 = 3
? polsturm(T, [-oo,2])
%3 = 2
? polsturm(T, [1/2,+oo])
%4 = 3
? polsturm(T, [1, Pi])  \\ Pi inexact: not recommended !
%5 = 3
? polsturm(T*1., [0, 4])  \\ T*1. inexact: not recommended !
%6 = 3
? polsturm(T^2, [0, 4])  \\ not squarefree: roots are not repeated!
%7 = 3
@eprog
%\syn{NO}

The library syntax is \fun{long}{RgX_sturmpart}{GEN T, GEN ab} or
\fun{long}{sturm}{GEN T} (for the case \kbd{ab = NULL}). The function
\fun{long}{sturmpart}{GEN T, GEN a, GEN b} is obsolete and deprecated.

\subsec{polsubcyclo$(n,d,\{v='x\})$}\kbdsidx{polsubcyclo}\label{se:polsubcyclo}
Gives polynomials (in variable $v$) defining the (Abelian) subextensions
of degree $d$ of the cyclotomic field $\Q(\zeta_n)$, where $d\mid \phi(n)$.

If there is exactly one such extension the output is a polynomial, else it is
a vector of polynomials, possibly empty. To get a vector in all cases,
use \kbd{concat([], polsubcyclo(n,d))}.

Each such polynomial is the minimal polynomial for a Gaussian period
$\text{Tr}_{\Q(\zeta_f)/L} (\zeta_f)$, where $L$ is the degree $d$
subextension of $\Q(\zeta_n)$ and $f | n$ is its conductor. In
Galois-theoretic terms, $L = \Q(\zeta_n)^H$, where $H$ runs through all index
$d$ subgroups of $(\Z/n\Z)^*$.

The function \tet{galoissubcyclo} allows to specify exactly which
sub-Abelian extension should be computed by giving $H$.

\misctitle{Complexity} Ignoring logarithmic factors, \kbd{polsubcyclo} runs
in time $O(n)$. The function \kbd{polsubcyclofast} returns different, less
canonical, polynomials but runs in time $O(d^4)$, again ignoring logarithmic
factors; thus it can handle much larger values of $n$.

The library syntax is \fun{GEN}{polsubcyclo}{long n, long d, long v = -1} where \kbd{v} is a variable number.

\subsec{polsubcyclofast$(n,d,\{s=0\},\{\var{exact}=0\})$}\kbdsidx{polsubcyclofast}\label{se:polsubcyclofast}
If $1 \leq d\leq 6$ or a prime, finds an equation for the subfields of
$\Q(\zeta_n)$ with Galois group $C_d$; the special value $d = -4$ provides the
subfields with group $V_4=C_2\times C_2$. Contrary to \kbd{polsubcyclo}, the
output is always a (possibly empty) vector of polynomials. If $s = 0$ (default)
all signatures, otherwise $s = 1$ (resp., $-1$) for totally real
(resp., totally complex). Set \kbd{exact = 1} for subfields of conductor $n$.

The argument $n$ can be given as in arithmetic functions: as an integer, as a
factorization matrix, or (preferred) as a pair $[N, \kbd{factor}(N)]$.

\misctitle{Comparison with \kbd{polsubcyclo}} First \kbd{polsubcyclofast}
does not usually return Gaussian periods, but ad hoc polynomials which do
generate the same field. Roughly speaking (ignoring
logarithmic factors), the complexity of \kbd{polsubcyclo} is independent of
$d$ and the complexity of \kbd{polsubcyclofast} is independent of $n$.
Ignoring logarithmic factors, \kbd{polsubcylo} runs in time $O(n)$ and
\kbd{polsubcyclofast} in time $O(d^4)$.
So the latter is \emph{much} faster than \kbd{polsubcyclo} if $n$ is large,
but gets slower as $d$ increases and becomes unusable for $d \geq 40$ or so.

\bprog
? polsubcyclo(10^7+19,7);
time = 1,852 ms.
? polsubcyclofast(10^7+19,7);
time = 15 ms.

? polsubcyclo(10^17+21,5); \\ won't finish
 *** polsubcyclo: user interrupt after 2h
? polsubcyclofast(10^17+21,5);
time = 3 ms.

? polsubcyclofast(10^17+3,7);
time = 26 ms.

? polsubcyclo(10^6+117,13);
time = 193 ms.
? polsubcyclofast(10^6+117,13);
time = 50 ms.

? polsubcyclofast(10^6+199,19);
time = 202 ms.
? polsubcyclo(10^6+199,19); \\ about as fast
time = 3191ms.

? polsubcyclo(10^7+271,19);
time = 2,067 ms.
? polsubcyclofast(10^7+271,19);
time = 201 ms.
@eprog

The library syntax is \fun{GEN}{polsubcyclofast}{GEN n, long d, long s, long exact}.

\subsec{polsylvestermatrix$(x,y)$}\kbdsidx{polsylvestermatrix}\label{se:polsylvestermatrix}
Forms the Sylvester matrix
corresponding to the two polynomials $x$ and $y$, where the coefficients of
the polynomials are put in the columns of the matrix (which is the natural
direction for solving equations afterwards). The use of this matrix can be
essential when dealing with polynomials with inexact entries, since
polynomial Euclidean division doesn't make much sense in this case.

The library syntax is \fun{GEN}{sylvestermatrix}{GEN x, GEN y}.

\subsec{polsym$(x,n)$}\kbdsidx{polsym}\label{se:polsym}
Creates the column vector of the \idx{symmetric powers} of the roots of the
polynomial $x$ up to power $n$, using Newton's formula.

The library syntax is \fun{GEN}{polsym}{GEN x, long n}.

\subsec{poltchebi$(n,\{v='x\})$}\kbdsidx{poltchebi}\label{se:poltchebi}
Deprecated alias for \kbd{polchebyshev}

The library syntax is \fun{GEN}{polchebyshev1}{long n, long v = -1} where \kbd{v} is a variable number.

\subsec{polteichmuller$(T,p,r)$}\kbdsidx{polteichmuller}\label{se:polteichmuller}
Given $T \in \F_p[X]$ return the polynomial $P\in \Z_p[X]$ whose roots
(resp.~leading coefficient) are the Teichmuller lifts of the roots
(resp.~leading coefficient) of $T$, to $p$-adic precision $r$. If $T$ is
monic, $P$ is the reduction modulo $p^r$ of the unique monic polynomial
congruent to $T$ modulo $p$ such that $P(X^p) = 0 \pmod{P(X),p^r}$.
\bprog
? T = ffinit(3, 3, 't)
%1 = Mod(1,3)*t^3 + Mod(1,3)*t^2 + Mod(1,3)*t + Mod(2,3)
? P = polteichmuller(T,3,5)
%2 = t^3 + 166*t^2 + 52*t + 242
? subst(P, t, t^3) % (P*Mod(1,3^5))
%3 = Mod(0, 243)
? [algdep(a+O(3^5),2) | a <- Vec(P)]
%4 = [x - 1, 5*x^2 + 1, x^2 + 4*x + 4, x + 1]
@eprog\noindent When $T$ is monic and irreducible mod $p$, this provides
a model $\Q_p[X]/(P)$ of the unramified extension $\Q_p[X] / (T)$ where
the Frobenius has the simple form $X \mod P \mapsto X^p \mod P$.

The library syntax is \fun{GEN}{polteichmuller}{GEN T, ulong p, long r}.

\subsec{poltomonic$(T,\{\&L\})$}\kbdsidx{poltomonic}\label{se:poltomonic}
Let $T \in \Q[x]$ be a nonzero polynomial; return $U$ monic in $\Z[x]$
such that $U(x) = C T(x/L)$ for some $C,L\in \Q$. If the pointer argument
\kbd{\&L} is present, set \kbd{L} to $L$.
\bprog
? poltomonic(9*x^2 - 1/2)
%1 = x^2 - 2
? U = poltomonic(9*x^2 - 1/2, &L)
%2 = x^2 - 2
? L
%3 = 6
? U / subst(9*x^2 - 1/2, x, x/L)
%4 = 4
@eprog

This function does not compute discriminants or maximal orders and runs
with complexity almost linear in the input size. If $T$ is already monic with
integer coefficient, \kbd{poltomonic} may still transform it if $\Z[x]/(T)$
is contained in a trivial subring of the maximal order, generated by $L x$:
\bprog
? poltomonic(x^2 + 4, &L)
%5 = x^2 + 1
? L
%6 = 1/2
@eprog\noindent If $T$ is irreducible, the functions \kbd{polredabs}
(exponential time) and \kbd{polredbest} (polynomial time) also find a monic
integral generating polynomial for the number field $\Q[x]/(T)$, with
explicit guarantees on its size, but are orders of magnitude slower.

The library syntax is \fun{GEN}{poltomonic}{GEN T, GEN *L = NULL}.

\subsec{polzagier$(n,m)$}\kbdsidx{polzagier}\label{se:polzagier}
Creates Zagier's polynomial $P_n^{(m)}$ used in
the functions \kbd{sumalt} and \kbd{sumpos} (with $\fl=1$), see
``Convergence acceleration of alternating series'', Cohen et al.,
\emph{Experiment.~Math.}, vol.~9, 2000, pp.~3--12.

If $m < 0$ or $m \ge n$, $P_n^{(m)} = 0$.
We have
$P_n := P_n^{(0)}$ is $T_n(2x-1)$, where $T_n$ is the Legendre polynomial of
the second kind. For $n > m > 0$, $P_n^{(m)}$ is the $m$-th difference with
step $2$ of the sequence $n^{m+1}P_n$; in this case, it satisfies
$$2 P_n^{(m)}(sin^2 t) = \dfrac{d^{m+1}}{dt^{m+1}}(\sin(2t)^m \sin(2(n-m)t)).$$

%@article {MR2001m:11222,
%    AUTHOR = {Cohen, Henri and Rodriguez Villegas, Fernando and Zagier, Don},
%     TITLE = {Convergence acceleration of alternating series},
%   JOURNAL = {Experiment. Math.},
%    VOLUME = {9},
%      YEAR = {2000},
%    NUMBER = {1},
%     PAGES = {3--12},
%}

The library syntax is \fun{GEN}{polzag}{long n, long m}.

\subsec{seralgdep$(s,p,r)$}\kbdsidx{seralgdep}\label{se:seralgdep}
\sidx{algebraic dependence} finds a linear relation between powers $(1,s,
\dots, s^p)$ of the series $s$, with polynomial coefficients of degree
$\leq r$. In case no relation is found, return $0$.
\bprog
? s = 1 + 10*y - 46*y^2 + 460*y^3 - 5658*y^4 + 77740*y^5 + O(y^6);
? seralgdep(s, 2, 2)
%2 = -x^2 + (8*y^2 + 20*y + 1)
? subst(%, x, s)
%3 = O(y^6)
? seralgdep(s, 1, 3)
%4 = (-77*y^2 - 20*y - 1)*x + (310*y^3 + 231*y^2 + 30*y + 1)
? seralgdep(s, 1, 2)
%5 = 0
@eprog\noindent The series main variable must not be $x$, so as to be able
to express the result as a polynomial in $x$.

The library syntax is \fun{GEN}{seralgdep}{GEN s, long p, long r}.

\subsec{serconvol$(x,y)$}\kbdsidx{serconvol}\label{se:serconvol}
Convolution (or \idx{Hadamard product}) of the
two power series $x$ and $y$; in other words if $x=\sum a_k*X^k$ and $y=\sum
b_k*X^k$ then $\kbd{serconvol}(x,y)=\sum a_k*b_k*X^k$.

The library syntax is \fun{GEN}{convol}{GEN x, GEN y}.

\subsec{serdiffdep$(s,p,r)$}\kbdsidx{serdiffdep}\label{se:serdiffdep}
Finds a linear relation between the derivatives $(s, s', \dots, s^p)$ of
the series $s$ and $1$, with polynomial coefficients of degree $\leq r$. In
case no relation is found, return $0$, otherwise return $[E,P]$ such that
$E(d)(S)=P$ where $d$ is the standard derivation.
\bprog
? S = sum(i=0, 50, binomial(3*i,i)*T^i) + O(T^51);
? serdiffdep(S, 3, 3)
%2 = [(27*T^2 - 4*T)*x^2 + (54*T - 2)*x + 6, 0]
? (27*T^2 - 4*T)*S'' + (54*T - 2)*S' + 6*S
%3 = O(T^50)

? S = exp(T^2) + T^2;
? serdiffdep(S, 3, 3)
%5 = [x-2*T, -2*T^3+2*T]
? S'-2*T*S
%6 = 2*T-2*T^3+O(T^17)
@eprog \noindent The series main variable must not be $x$, so as to be able
to express the result as a polynomial in $x$.

The library syntax is \fun{GEN}{serdiffdep}{GEN s, long p, long r}.

\subsec{serlaplace$(x)$}\kbdsidx{serlaplace}\label{se:serlaplace}
$x$ must be a power series with nonnegative
exponents or a polynomial. If $x=\sum (a_k/k!)*X^k$ then the result is $\sum
a_k*X^k$.

The library syntax is \fun{GEN}{laplace}{GEN x}.

\subsec{serreverse$(s)$}\kbdsidx{serreverse}\label{se:serreverse}
Reverse power series of $s$, i.e. the series $t$ such that $t(s) = x$;
$s$ must be a power series whose valuation is exactly equal to one.
\bprog
? \ps 8
? t = serreverse(tan(x))
%2 = x - 1/3*x^3 + 1/5*x^5 - 1/7*x^7 + O(x^8)
? tan(t)
%3 = x + O(x^8)
@eprog

The library syntax is \fun{GEN}{serreverse}{GEN s}.

\subsec{subst$(x,y,z)$}\kbdsidx{subst}\label{se:subst}
Replace the simple variable $y$ by the argument $z$ in the ``polynomial''
expression $x$. If $z$ is a vector, return the vector of the evaluated
expressions \kbd{subst(x, y, z[i])}.

Every type is allowed for $x$, but if it is not a genuine
polynomial (or power series, or rational function), the substitution will be
done as if the scalar components were polynomials of degree zero. In
particular, beware that:

\bprog
? subst(1, x, [1,2; 3,4])
%1 =
[1 0]

[0 1]

? subst(1, x, Mat([0,1]))
  ***   at top-level: subst(1,x,Mat([0,1])
  ***                 ^--------------------
  *** subst: forbidden substitution by a non square matrix.
@eprog\noindent
If $x$ is a power series, $z$ must be either a polynomial, a power
series, or a rational function. If $x$ is a vector,
matrix or list, the substitution is applied to each individual entry.

Use the function \kbd{substvec} to replace several variables at once,
or the function \kbd{substpol} to replace a polynomial expression.

The library syntax is \fun{GEN}{gsubst}{GEN x, long y, GEN z} where \kbd{y} is a variable number.

\subsec{substpol$(x,y,z)$}\kbdsidx{substpol}\label{se:substpol}
Replace the ``variable'' $y$ by the argument $z$ in the ``polynomial''
expression $x$. Every type is allowed for $x$, but the same behavior
as \kbd{subst} above apply.

The difference with \kbd{subst} is that $y$ is allowed to be any polynomial
here. The substitution is done moding out all components of $x$
(recursively) by $y - t$, where $t$ is a new free variable of lowest
priority. Then substituting $t$ by $z$ in the resulting expression. For
instance
\bprog
? substpol(x^4 + x^2 + 1, x^2, y)
%1 = y^2 + y + 1
? substpol(x^4 + x^2 + 1, x^3, y)
%2 = x^2 + y*x + 1
? substpol(x^4 + x^2 + 1, (x+1)^2, y)
%3 = (-4*y - 6)*x + (y^2 + 3*y - 3)
@eprog

The library syntax is \fun{GEN}{gsubstpol}{GEN x, GEN y, GEN z}.
Further, \fun{GEN}{gdeflate}{GEN T, long v, long d} attempts to
write $T(x)$ in the form $t(x^d)$, where $x=$\kbd{pol\_x}$(v)$, and returns
\kbd{NULL} if the substitution fails (for instance in the example \kbd{\%2}
above).

\subsec{substvec$(x,v,w)$}\kbdsidx{substvec}\label{se:substvec}
$v$ being a vector of monomials of degree 1 (variables),
$w$ a vector of expressions of the same length, replace in the expression
$x$ all occurrences of $v_i$ by $w_i$. The substitutions are done
simultaneously; more precisely, the $v_i$ are first replaced by new
variables in $x$, then these are replaced by the $w_i$:
\bprog
? substvec([x,y], [x,y], [y,x])
%1 = [y, x]
? substvec([x,y], [x,y], [y,x+y])
%2 = [y, x + y]     \\ not [y, 2*y]
@eprog\noindent As in \kbd{subst}, variables may be replaced
by a vector of values, in which case the cartesian product is returned:
\bprog
? substvec([x,y], [x,y], [[1,2], 3])
%3 = [[1, 3], [2, 3]]
? substvec([x,y], [x,y], [[1,2], [3,4]])
%4 = [[1, 3], [2, 3], [1, 4], [2, 4]]
@eprog

The library syntax is \fun{GEN}{gsubstvec}{GEN x, GEN v, GEN w}.

\subsec{sumformal$(f,\{v\})$}\kbdsidx{sumformal}\label{se:sumformal}
\idx{formal sum} of the polynomial expression $f$ with respect to the
main variable if $v$ is omitted, with respect to the variable $v$ otherwise;
it is assumed that the base ring has characteristic zero. In other words,
considering $f$ as a polynomial function in the variable $v$,
returns $F$, a polynomial in $v$ vanishing at $0$, such that $F(b) - F(a)
= sum_{v = a+1}^b f(v)$:
\bprog
? sumformal(n)  \\ 1 + ... + n
%1 = 1/2*n^2 + 1/2*n
? f(n) = n^3+n^2+1;
? F = sumformal(f(n))  \\ f(1) + ... + f(n)
%3 = 1/4*n^4 + 5/6*n^3 + 3/4*n^2 + 7/6*n
? sum(n = 1, 2000, f(n)) == subst(F, n, 2000)
%4 = 1
? sum(n = 1001, 2000, f(n)) == subst(F, n, 2000) - subst(F, n, 1000)
%5 = 1
? sumformal(x^2 + x*y + y^2, y)
%6 = y*x^2 + (1/2*y^2 + 1/2*y)*x + (1/3*y^3 + 1/2*y^2 + 1/6*y)
? x^2 * y + x * sumformal(y) + sumformal(y^2) == %
%7 = 1
@eprog

The library syntax is \fun{GEN}{sumformal}{GEN f, long v = -1} where \kbd{v} is a variable number.

\subsec{taylor$(x,t,\{d=\var{seriesprecision}\})$}\kbdsidx{taylor}\label{se:taylor}
Taylor expansion around $0$ of $x$ with respect to
the simple variable $t$. $x$ can be of any reasonable type, for example a
rational function. Contrary to \tet{Ser}, which takes the valuation into
account, this function adds $O(t^d)$ to all components of $x$.
\bprog
? taylor(x/(1+y), y, 5)
%1 = (y^4 - y^3 + y^2 - y + 1)*x + O(y^5)
? Ser(x/(1+y), y, 5)
 ***   at top-level: Ser(x/(1+y),y,5)
 ***                 ^----------------
 *** Ser: main variable must have higher priority in gtoser.
@eprog

The library syntax is \fun{GEN}{tayl}{GEN x, long t, long precdl} where \kbd{t} is a variable number.

\subsec{thue$(\var{tnf},a,\{\var{sol}\})$}\kbdsidx{thue}\label{se:thue}
Returns all solutions of the equation
$P(x,y)=a$ in integers $x$ and $y$, where \var{tnf} was created with
$\kbd{thueinit}(P)$. If present, \var{sol} must contain the solutions of
$\Norm(x)=a$ modulo units of positive norm in the number field
defined by $P$ (as computed by \kbd{bnfisintnorm}). If there are infinitely
many solutions, an error is issued.

It is allowed to input directly the polynomial $P$ instead of a \var{tnf},
in which case, the function first performs \kbd{thueinit(P,0)}. This is
very wasteful if more than one value of $a$ is required.

If \var{tnf} was computed without assuming GRH (flag $1$ in \tet{thueinit}),
then the result is unconditional. Otherwise, it depends in principle of the
truth of the GRH, but may still be unconditionally correct in some
favorable cases. The result is conditional on the GRH if
$a\neq \pm 1$ and $P$ has a single irreducible rational factor, whose
attached tentative class number $h$ and regulator $R$ (as computed
assuming the GRH) satisfy

\item $h > 1$,

\item $R/0.2 > 1.5$.

Here's how to solve the Thue equation $x^{13} - 5y^{13} = - 4$:
\bprog
? tnf = thueinit(x^13 - 5);
? thue(tnf, -4)
%1 = [[1, 1]]
@eprog\noindent In this case, one checks that \kbd{bnfinit(x\pow13 -5).no}
is $1$. Hence, the only solution is $(x,y) = (1,1)$ and the result is
unconditional. On the other hand:
\bprog
? P = x^3-2*x^2+3*x-17; tnf = thueinit(P);
? thue(tnf, -15)
%2 = [[1, 1]]  \\ a priori conditional on the GRH.
? K = bnfinit(P); K.no
%3 = 3
? K.reg
%4 = 2.8682185139262873674706034475498755834
@eprog
This time the result is conditional. All results computed using this
particular \var{tnf} are likewise conditional, \emph{except} for a right-hand
side of $\pm 1$.
The above result is in fact correct, so we did not just disprove the GRH:
\bprog
? tnf = thueinit(x^3-2*x^2+3*x-17, 1 /*unconditional*/);
? thue(tnf, -15)
%4 = [[1, 1]]
@eprog
Note that reducible or nonmonic polynomials are allowed:
\bprog
? tnf = thueinit((2*x+1)^5 * (4*x^3-2*x^2+3*x-17), 1);
? thue(tnf, 128)
%2 = [[-1, 0], [1, 0]]
@eprog\noindent Reducible polynomials are in fact much easier to handle.

\misctitle{Note} When $P$ is irreducible without a real root, the default
strategy is to use brute force enumeration in time $|a|^{1/\deg P}$ and
avoid computing a tough \var{bnf} attached to $P$, see \kbd{thueinit}.
Besides reusing a quantity you might need for other purposes, the
default argument \emph{sol} can also be used to use a different strategy
and prove that there are no solutions; of course you need to compute a
\var{bnf} on you own to obtain \emph{sol}. If there \emph{are} solutions
this won't help unless $P$ is quadratic, since the enumeration will be
performed in any case.

The library syntax is \fun{GEN}{thue}{GEN tnf, GEN a, GEN sol = NULL}.

\subsec{thueinit$(P,\{\fl=0\})$}\kbdsidx{thueinit}\label{se:thueinit}
Initializes the \var{tnf} corresponding to $P$, a nonconstant
univariate polynomial with integer coefficients.
The result is meant to be used in conjunction with \tet{thue} to solve Thue
equations $P(X / Y)Y^{\deg P} = a$, where $a$ is an integer. Accordingly,
$P$ must either have at least two distinct irreducible factors over $\Q$,
or have one irreducible factor $T$ with degree $>2$ or two conjugate
complex roots: under these (necessary and sufficient) conditions, the
equation has finitely many integer solutions.
\bprog
? S = thueinit(t^2+1);
? thue(S, 5)
%2 = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]
? S = thueinit(t+1);
 ***   at top-level: thueinit(t+1)
 ***                 ^-------------
 *** thueinit: domain error in thueinit: P = t + 1
@eprog\noindent The hardest case is when $\deg P > 2$ and $P$ is irreducible
with at least one real root. The routine then uses Bilu-Hanrot's algorithm.

If $\fl$ is nonzero, certify results unconditionally. Otherwise, assume
\idx{GRH}, this being much faster of course. In the latter case, the result
may still be unconditionally correct, see \tet{thue}. For instance in most
cases where $P$ is reducible (not a pure power of an irreducible), \emph{or}
conditional computed class groups are trivial \emph{or} the right hand side
is $\pm1$, then results are unconditional.

\misctitle{Note} The general philosophy is to disprove the existence of large
solutions then to enumerate bounded solutions naively. The implementation
will overflow when there exist huge solutions and the equation has degree
$> 2$ (the quadratic imaginary case is special, since we can stick to
\kbd{bnfisintnorm}, there are no fundamental units):
\bprog
? thue(t^3+2, 10^30)
 ***   at top-level: L=thue(t^3+2,10^30)
 ***                   ^-----------------
 *** thue: overflow in thue (SmallSols): y <= 80665203789619036028928.
? thue(x^2+2, 10^30)  \\ quadratic case much easier
%1 = [[-1000000000000000, 0], [1000000000000000, 0]]
@eprog

\misctitle{Note} It is sometimes possible to circumvent the above, and in any
case obtain an important speed-up, if you can write $P = Q(x^d)$ for some $d >
1$ and $Q$ still satisfying the \kbd{thueinit} hypotheses. You can then solve
the equation attached to $Q$ then eliminate all solutions $(x,y)$ such that
either $x$ or $y$ is not a $d$-th power.
\bprog
? thue(x^4+1, 10^40); \\ stopped after 10 hours
? filter(L,d) =
    my(x,y); [[x,y] | v<-L, ispower(v[1],d,&x)&&ispower(v[2],d,&y)];
? L = thue(x^2+1, 10^40);
? filter(L, 2)
%4 = [[0, 10000000000], [10000000000, 0]]
@eprog\noindent The last 2 commands use less than 20ms.

\misctitle{Note} When $P$ is irreducible without a real root, the equation
can be solved unconditionnally in time $|a|^{1/\deg P}$. When this
latter quantity is huge and the equation has no solutions, this fact
may still be ascertained via arithmetic conditions but this now implies
solving norm equations, computing a \var{bnf} and possibly assuming the GRH.
When there is no real root, the code does not compute a \var{bnf}
(with certification if $\fl = 1$) if it expects this to be an ``easy''
computation (because the result would only be used for huge values of $a$).
See \kbd{thue} for a way to compute an expensive \var{bnf} on your own and
still get a result where this default cheap strategy fails.

The library syntax is \fun{GEN}{thueinit}{GEN P, long flag, long prec}.

\section{Vectors, matrices, linear algebra and sets}
\label{se:linear_algebra}

Note that most linear algebra functions operating on subspaces defined by
generating sets (such as \tet{mathnf}, \tet{qflll}, etc.) take matrices as
arguments. As usual, the generating vectors are taken to be the
\emph{columns} of the given matrix.

Since PARI does not have a strong typing system, scalars live in
unspecified commutative base rings. It is very difficult to write
robust linear algebra routines in such a general setting. We thus
assume that the base ring is a domain and work over its field of
fractions. If the base ring is \emph{not} a domain, one gets an error as soon
as a nonzero pivot turns out to be noninvertible. Some functions,
e.g.~\kbd{mathnf} or \kbd{mathnfmod}, specifically assume that the base ring is
$\Z$.

\subsec{algdep$(z,k,\{\fl=0\})$}\kbdsidx{algdep}\label{se:algdep}
\sidx{algebraic dependence}
$z$ being real/complex, or $p$-adic, finds a polynomial (in the variable
\kbd{'x}) of degree at most
$k$, with integer coefficients, having $z$ as approximate root. Note that the
polynomial which is obtained is not necessarily the ``correct'' one. In fact
it is not even guaranteed to be irreducible. One can check the closeness
either by a polynomial evaluation (use \tet{subst}), or by computing the
roots of the polynomial given by \kbd{algdep} (use \tet{polroots} or
\tet{polrootspadic}).

Internally, \tet{lindep}$([1,z,\ldots,z^k], \fl)$ is used. A nonzero value of
$\fl$ may improve on the default behavior if the input number is known to a
\emph{huge} accuracy, and you suspect the last bits are incorrect: if $\fl > 0$
the computation is done with an accuracy of $\fl$ decimal  digits; to get
meaningful results, the parameter $\fl$ should be smaller than the number of
correct decimal digits in the input. But default values are usually
sufficient, so try without $\fl$ first:
\bprog
? \p200
? z = 2^(1/6)+3^(1/5);
? algdep(z, 30);      \\ right in 63ms
? algdep(z, 30, 100); \\ wrong in 39ms
? algdep(z, 30, 170); \\ right in 61ms
? algdep(z, 30, 200); \\ wrong in 146ms
? \p250
? z = 2^(1/6)+3^(1/5); \\ recompute to new, higher, accuracy !
? algdep(z, 30);      \\ right in 68ms
? algdep(z, 30, 200); \\ right in 68ms
? \p500
? algdep(2^(1/6)+3^(1/5), 30); \\ right in 138ms
? \p1000
? algdep(2^(1/6)+3^(1/5), 30); \\ right in 276s
@eprog\noindent
The changes in \kbd{realprecision} only affect the quality of the
initial approximation to $2^{1/6} + 3^{1/5}$, \kbd{algdep} itself uses
exact operations. The size of its operands depend on the accuracy of the
input of course: a more accurate input means slower operations.

Proceeding by increments of 5 digits of accuracy, \kbd{algdep} with default
flag produces its first correct result at 195 digits, and from then on a
steady stream of correct results:
\bprog
  \\ assume T contains the correct result, for comparison
  forstep(d=100, 250, 5, \
    localprec(d);        \
    print(d, " ", algdep(2^(1/6)+3^(1/5),30) == T))
@eprog\noindent
This example is the test case studied in a 2000 paper by Borwein and
Lisonek: Applications of integer relation algorithms, \emph{Discrete Math.},
{\bf 217}, p.~65--82. The version of PARI tested there was 1.39, which
succeeded reliably from precision 265 on, in about 1000 as much time as the
current version (on slower hardware of course).

Note that this function does not work if $z$ is a power series. The function
\kbd{seralgdep} can be used in this case to find linear relations wich
polynomial coefficients between powers of $z$.

The library syntax is \fun{GEN}{algdep0}{GEN z, long k, long flag}.
Also available is \fun{GEN}{algdep}{GEN z, long k} ($\fl=0$).

\subsec{bestapprnf$(V,T,\{\var{rootT}\})$}\kbdsidx{bestapprnf}\label{se:bestapprnf}
$T$ being an integral polynomial and $V$ being a scalar, vector, or
matrix with complex coefficients, return a reasonable approximation of $V$
with polmods modulo $T$. $T$ can also be any number field structure, in which
case the minimal polynomial attached to the structure (\kbd{$T$}.pol) is
used. The \var{rootT} argument, if present, must be an element of
\kbd{polroots($T$)} (or \kbd{$T$}.pol), i.e.~a complex root of $T$ fixing an embedding of
$\Q[x]/(T)$ into $\C$.
\bprog
? bestapprnf(sqrt(5), polcyclo(5))
%1 = Mod(-2*x^3 - 2*x^2 - 1, x^4 + x^3 + x^2 + x + 1)
? bestapprnf(sqrt(5), polcyclo(5), exp(4*I*Pi/5))
%2 = Mod(2*x^3 + 2*x^2 + 1, x^4 + x^3 + x^2 + x + 1)
@eprog\noindent When the output has huge rational coefficients, try to
increase the working \kbd{realbitprecision}: if the answer does not
stabilize, consider that the reconstruction failed.
Beware that if $T$ is not Galois over $\Q$, some embeddings
may not allow to reconstruct $V$:
\bprog
? T = x^3-2; vT = polroots(T); z = 3*2^(1/3)+1;
? bestapprnf(z, T, vT[1])
%2 = Mod(3*x + 1, x^3 - 2)
? bestapprnf(z, T, vT[2])
%3 = 4213714286230872/186454048314072  \\ close to 3*2^(1/3) + 1
@eprog

The library syntax is \fun{GEN}{bestapprnf}{GEN V, GEN T, GEN rootT = NULL, long prec}.

\subsec{charpoly$(A,\{v='x\},\{\fl=5\})$}\kbdsidx{charpoly}\label{se:charpoly}
\idx{characteristic polynomial}
of $A$ with respect to the variable $v$, i.e.~determinant of $v*I-A$ if $A$
is a square matrix.
\bprog
? charpoly([1,2;3,4]);
%1 = x^2 - 5*x - 2
? charpoly([1,2;3,4],, 't)
%2 = t^2 - 5*t - 2
@eprog\noindent
If $A$ is not a square matrix, the function returns the characteristic
polynomial of the map ``multiplication by $A$'' if $A$ is a scalar:
\bprog
? charpoly(Mod(x+2, x^3-2))
%1 = x^3 - 6*x^2 + 12*x - 10
? charpoly(I)
%2 = x^2 + 1
? charpoly(quadgen(5))
%3 = x^2 - x - 1
? charpoly(ffgen(ffinit(2,4)))
%4 = Mod(1, 2)*x^4 + Mod(1, 2)*x^3 + Mod(1, 2)*x^2 + Mod(1, 2)*x + Mod(1, 2)
@eprog

The value of $\fl$ is only significant for matrices, and we advise to stick
to the default value. Let $n$ be the dimension of $A$.

If $\fl=0$, same method (Le Verrier's) as for computing the adjoint matrix,
i.e.~using the traces of the powers of $A$. Assumes that $n!$ is
invertible; uses $O(n^4)$ scalar operations.

If $\fl=1$, uses Lagrange interpolation which is usually the slowest method.
Assumes that $n!$ is invertible; uses $O(n^4)$ scalar operations.

If $\fl=2$, uses the Hessenberg form. Assumes that the base ring is a field.
Uses $O(n^3)$ scalar operations, but suffers from coefficient explosion
unless the base field is finite or $\R$.

If $\fl=3$, uses Berkowitz's division free algorithm, valid over any
ring (commutative, with unit). Uses $O(n^4)$ scalar operations.

If $\fl=4$, $x$ must be integral. Uses a modular algorithm: Hessenberg form
for various small primes, then Chinese remainders.

If $\fl=5$ (default), uses the ``best'' method given $x$.
This means we use Berkowitz unless the base ring is $\Z$ (use $\fl=4$)
or a field where coefficient explosion does not occur,
e.g.~a finite field or the reals (use $\fl=2$).

The library syntax is \fun{GEN}{charpoly0}{GEN A, long v = -1, long flag} where \kbd{v} is a variable number.
Also available are
\fun{GEN}{charpoly}{GEN x, long v} ($\fl=5$),
\fun{GEN}{caract}{GEN A, long v} ($\fl=1$),
\fun{GEN}{carhess}{GEN A, long v} ($\fl=2$),
\fun{GEN}{carberkowitz}{GEN A, long v} ($\fl=3$) and
\fun{GEN}{caradj}{GEN A, long v, GEN *pt}. In this
last case, if \var{pt} is not \kbd{NULL}, \kbd{*pt} receives the address of
the adjoint matrix of $A$ (see \tet{matadjoint}), so both can be obtained at
once.

\subsec{concat$(x,\{y\})$}\kbdsidx{concat}\label{se:concat}
Concatenation of $x$ and $y$. If $x$ or $y$ is
not a vector or matrix, it is considered as a one-dimensional vector. All
types are allowed for $x$ and $y$, but the sizes must be compatible. Note
that matrices are concatenated horizontally, i.e.~the number of rows stays
the same. Using transpositions, one can concatenate them vertically,
but it is often simpler to use \tet{matconcat}.
\bprog
? x = matid(2); y = 2*matid(2);
? concat(x,y)
%2 =
[1 0 2 0]

[0 1 0 2]
? concat(x~,y~)~
%3 =
[1 0]

[0 1]

[2 0]

[0 2]
? matconcat([x;y])
%4 =
[1 0]

[0 1]

[2 0]

[0 2]
@eprog\noindent
To concatenate vectors sideways (i.e.~to obtain a two-row or two-column
matrix), use \tet{Mat} instead, or \tet{matconcat}:
\bprog
? x = [1,2];
? y = [3,4];
? concat(x,y)
%3 = [1, 2, 3, 4]

? Mat([x,y]~)
%4 =
[1 2]

[3 4]
? matconcat([x;y])
%5 =
[1 2]

[3 4]
@eprog
Concatenating a row vector to a matrix having the same number of columns will
add the row to the matrix (top row if the vector is $x$, i.e.~comes first, and
bottom row otherwise).

The empty matrix \kbd{[;]} is considered to have a number of rows compatible
with any operation, in particular concatenation. (Note that this is
\emph{not} the case for empty vectors \kbd{[~]} or \kbd{[~]\til}.)

If $y$ is omitted, $x$ has to be a row vector or a list, in which case its
elements are concatenated, from left to right, using the above rules.
\bprog
? concat([1,2], [3,4])
%1 = [1, 2, 3, 4]
? a = [[1,2]~, [3,4]~]; concat(a)
%2 =
[1 3]

[2 4]

? concat([1,2; 3,4], [5,6]~)
%3 =
[1 2 5]

[3 4 6]
? concat([%, [7,8]~, [1,2,3,4]])
%5 =
[1 2 5 7]

[3 4 6 8]

[1 2 3 4]
@eprog

The library syntax is \fun{GEN}{gconcat}{GEN x, GEN y = NULL}.
\fun{GEN}{gconcat1}{GEN x} is a shortcut for \kbd{gconcat(x,NULL)}.

\subsec{dirpowers$(n,x)$}\kbdsidx{dirpowers}\label{se:dirpowers}
For nonnegative $n$ and complex number $x$, return the vector with $n$
components $[1^x,2^x,\dots,n^x]$.
\bprog
? dirpowers(5, 2)
%1 = [1, 4, 9, 16, 25]
? dirpowers(5, 1/2)
%2 = [1, 1.414..., 1.732..., 2.000..., 2.236...]
@eprog\noindent When $n \le 0$, the function returns the empty vector \kbd{[]}.

The library syntax is \fun{GEN}{dirpowers}{long n, GEN x, long prec}.

\subsec{forqfvec$(v,q,b,\var{expr})$}\kbdsidx{forqfvec}\label{se:forqfvec}
$q$ being a square and symmetric integral matrix representing a positive
definite quadratic form, evaluate \kbd{expr} for all pairs of nonzero
vectors $(-v,v)$ such that $q(v)\leq b$. The formal variable $v$ runs
through representatives of all such pairs in turn.
\bprog
? forqfvec(v, [3,2;2,3], 3, print(v))
[0, 1]~
[1, 0]~
[-1, 1]~
@eprog

The library syntax is \fun{void}{forqfvec0}{GEN v, GEN q = NULL, GEN b}.
The following functions are also available:
\fun{void}{forqfvec}{void *E, long (*fun)(void *, GEN, GEN, double), GEN q, GEN b}:
Evaluate \kbd{fun(E,U,v,m)} on all $v$ such that $q(U\*v)<b$, where $U$ is a
\typ{MAT}, $v$ is a \typ{VECSMALL} and $m=q(v)$ is a C double. The function
\kbd{fun} must return $0$, unless \kbd{forqfvec} should stop, in which case,
it should return $1$.

\fun{void}{forqfvec1}{void *E, long (*fun)(void *, GEN), GEN q, GEN b}:
Evaluate \kbd{fun(E,v)} on all $v$ such that $q(v)<b$, where $v$ is a
\typ{COL}. The function \kbd{fun} must return $0$, unless \kbd{forqfvec}
should stop, in which case, it should return $1$.

\subsec{lindep$(v,\{\fl=0\})$}\kbdsidx{lindep}\label{se:lindep}
\sidx{linear dependence} finds a small nontrivial integral linear
combination between components of $v$. If none can be found return an empty
vector.

If $v$ is a vector with real/complex entries we use a floating point
(variable precision) LLL algorithm. If $\fl = 0$ the accuracy is chosen
internally using a crude heuristic. If $\fl > 0$ the computation is done with
an accuracy of $\fl$ decimal digits. To get meaningful results in the latter
case, the parameter $\fl$ should be smaller than the number of correct
decimal digits in the input.

\bprog
? lindep([sqrt(2), sqrt(3), sqrt(2)+sqrt(3)])
%1 = [-1, -1, 1]~
@eprog

If $v$ is $p$-adic, $\fl$ is ignored and the algorithm LLL-reduces a
suitable (dual) lattice.
\bprog
? lindep([1, 2 + 3 + 3^2 + 3^3 + 3^4 + O(3^5)])
%2 = [1, -2]~
@eprog

If $v$ is a matrix (or a vector of column vectors, or a vector of row
vectors), $\fl$ is ignored and the function returns a non trivial kernel
vector if one exists, else an empty vector.
\bprog
? lindep([1,2,3;4,5,6;7,8,9])
%3 = [1, -2, 1]~
? lindep([[1,0], [2,0]])
%4 = [2, -1]~
? lindep([[1,0], [0,1]])
%5 = []~
@eprog

If $v$ contains polynomials or power series over some base field, finds a
linear relation with coefficients in the field.
\bprog
? lindep([x*y, x^2 + y, x^2*y + x*y^2, 1])
%4 = [y, y, -1, -y^2]~
@eprog\noindent For better control, it is preferable to use \typ{POL} rather
than \typ{SER} in the input, otherwise one gets a linear combination which is
$t$-adically small, but not necessarily $0$. Indeed, power series are first
converted to the minimal absolute accuracy occurring among the entries of $v$
(which can cause some coefficients to be ignored), then truncated to
polynomials:
\bprog
? v = [t^2+O(t^4), 1+O(t^2)]; L=lindep(v)
%1 = [1, 0]~
? v*L
%2 = t^2+O(t^4)  \\ small but not 0
@eprog

The library syntax is \fun{GEN}{lindep0}{GEN v, long flag}.

\subsec{matadjoint$(M,\{\fl=0\})$}\kbdsidx{matadjoint}\label{se:matadjoint}
\idx{adjoint matrix} of $M$, i.e.~a matrix $N$
of cofactors of $M$, satisfying $M*N=\det(M)*\Id$. $M$ must be a
(not necessarily invertible) square matrix of dimension $n$.
If $\fl$ is 0 or omitted, we try to use Leverrier-Faddeev's algorithm,
which assumes that $n!$ invertible. If it fails or $\fl = 1$,
compute $T = \kbd{charpoly}(M)$ independently first and return
$(-1)^{n-1} (T(x)-T(0))/x$ evaluated at $M$.
\bprog
? a = [1,2,3;3,4,5;6,7,8] * Mod(1,4);
? matadjoint(a)
%2 =
[Mod(1, 4) Mod(1, 4) Mod(2, 4)]

[Mod(2, 4) Mod(2, 4) Mod(0, 4)]

[Mod(1, 4) Mod(1, 4) Mod(2, 4)]
@eprog\noindent
Both algorithms use $O(n^4)$ operations in the base ring. Over a field,
they are usually slower than computing the characteristic polynomial or
the inverse of $M$ directly.

The library syntax is \fun{GEN}{matadjoint0}{GEN M, long flag}.
Also available are
\fun{GEN}{adj}{GEN x} (\fl=0) and
\fun{GEN}{adjsafe}{GEN x} (\fl=1).

\subsec{matcompanion$(x)$}\kbdsidx{matcompanion}\label{se:matcompanion}
The left companion matrix to the nonzero polynomial $x$.

The library syntax is \fun{GEN}{matcompanion}{GEN x}.

\subsec{matconcat$(v)$}\kbdsidx{matconcat}\label{se:matconcat}
Returns a \typ{MAT} built from the entries of $v$, which may
be a \typ{VEC} (concatenate horizontally), a \typ{COL} (concatenate
vertically), or a \typ{MAT} (concatenate vertically each column, and
concatenate vertically the resulting matrices). The entries of $v$ are always
considered as matrices: they can themselves be \typ{VEC} (seen as a row
matrix), a \typ{COL} seen as a column matrix), a \typ{MAT}, or a scalar (seen
as an $1 \times 1$ matrix).
\bprog
? A=[1,2;3,4]; B=[5,6]~; C=[7,8]; D=9;
? matconcat([A, B]) \\ horizontal
%1 =
[1 2 5]

[3 4 6]
? matconcat([A, C]~) \\ vertical
%2 =
[1 2]

[3 4]

[7 8]
? matconcat([A, B; C, D]) \\ block matrix
%3 =
[1 2 5]

[3 4 6]

[7 8 9]
@eprog\noindent
If the dimensions of the entries to concatenate do not match up, the above
rules are extended as follows:

\item each entry $v_{i,j}$ of $v$ has a natural length and height: $1 \times
1$ for a scalar, $1 \times n$ for a \typ{VEC} of length $n$, $n \times 1$
for a \typ{COL}, $m \times n$ for an $m\times n$ \typ{MAT}

\item let $H_i$ be the maximum over $j$ of the lengths of the $v_{i,j}$,
let $L_j$ be the maximum over $i$ of the heights of the $v_{i,j}$.
The dimensions of the $(i,j)$-th block in the concatenated matrix are
$H_i \times L_j$.

\item a scalar $s = v_{i,j}$ is considered as $s$ times an identity matrix
of the block dimension $\min (H_i,L_j)$

\item blocks are extended by 0 columns on the right and 0 rows at the
bottom, as needed.

\bprog
? matconcat([1, [2,3]~, [4,5,6]~]) \\ horizontal
%4 =
[1 2 4]

[0 3 5]

[0 0 6]
? matconcat([1, [2,3], [4,5,6]]~) \\ vertical
%5 =
[1 0 0]

[2 3 0]

[4 5 6]
? matconcat([B, C; A, D]) \\ block matrix
%6 =
[5 0 7 8]

[6 0 0 0]

[1 2 9 0]

[3 4 0 9]
? U=[1,2;3,4]; V=[1,2,3;4,5,6;7,8,9];
? matconcat(matdiagonal([U, V])) \\ block diagonal
%7 =
[1 2 0 0 0]

[3 4 0 0 0]

[0 0 1 2 3]

[0 0 4 5 6]

[0 0 7 8 9]
@eprog

The library syntax is \fun{GEN}{matconcat}{GEN v}.

\subsec{matdet$(x,\{\fl=0\})$}\kbdsidx{matdet}\label{se:matdet}
Determinant of the square matrix $x$.

If $\fl=0$, uses an appropriate algorithm depending on the coefficients:

\item integer entries: modular method due to Dixon, Pernet and Stein.

\item real or $p$-adic entries: classical Gaussian elimination using maximal
pivot.

\item intmod entries: classical Gaussian elimination using first nonzero
pivot.

\item other cases: Gauss-Bareiss.

If $\fl=1$, uses classical Gaussian elimination with appropriate pivoting
strategy (maximal pivot for real or $p$-adic coefficients). This is usually
worse than the default.

The library syntax is \fun{GEN}{det0}{GEN x, long flag}.
Also available are \fun{GEN}{det}{GEN x} ($\fl=0$),
\fun{GEN}{det2}{GEN x} ($\fl=1$) and \fun{GEN}{ZM_det}{GEN x} for integer
entries.

\subsec{matdetint$(B)$}\kbdsidx{matdetint}\label{se:matdetint}
Let $B$ be an $m\times n$ matrix with integer coefficients. The
\emph{determinant} $D$ of the lattice generated by the columns of $B$ is
the square root of $\det(B^T B)$ if $B$ has maximal rank $m$, and $0$
otherwise.

This function uses the Gauss-Bareiss algorithm to compute a positive
\emph{multiple} of $D$. When $B$ is square, the function actually returns
$D = |\det B|$.

This function is useful in conjunction with \kbd{mathnfmod}, which needs to
know such a multiple. If the rank is maximal but the matrix is nonsquare,
you can obtain $D$ exactly using
\bprog
  matdet( mathnfmod(B, matdetint(B)) )
@eprog\noindent
Note that as soon as one of the dimensions gets large ($m$ or $n$ is larger
than 20, say), it will often be much faster to use \kbd{mathnf(B, 1)} or
\kbd{mathnf(B, 4)} directly.

The library syntax is \fun{GEN}{detint}{GEN B}.

\subsec{matdetmod$(x,d)$}\kbdsidx{matdetmod}\label{se:matdetmod}
Given a matrix $x$ with \typ{INT} entries and $d$ an arbitrary positive
integer, return the determinant of $x$ modulo $d$.

\bprog
? A = [4,2,3; 4,5,6; 7,8,9]

? matdetmod(A,27)
%2 = 9
@eprog Note that using the generic function \kbd{matdet} on a matrix with
\typ{INTMOD} entries uses Gaussian reduction and will fail in general when
the modulus is not prime.
\bprog
? matdet(A * Mod(1,27))
 ***   at top-level: matdet(A*Mod(1,27))
 ***                 ^------------------
 *** matdet: impossible inverse in Fl_inv: Mod(3, 27).
@eprog

The library syntax is \fun{GEN}{matdetmod}{GEN x, GEN d}.

\subsec{matdiagonal$(x)$}\kbdsidx{matdiagonal}\label{se:matdiagonal}
$x$ being a vector, creates the diagonal matrix
whose diagonal entries are those of $x$.
\bprog
? matdiagonal([1,2,3]);
%1 =
[1 0 0]

[0 2 0]

[0 0 3]
@eprog\noindent Block diagonal matrices are easily created using
\tet{matconcat}:
\bprog
? U=[1,2;3,4]; V=[1,2,3;4,5,6;7,8,9];
? matconcat(matdiagonal([U, V]))
%1 =
[1 2 0 0 0]

[3 4 0 0 0]

[0 0 1 2 3]

[0 0 4 5 6]

[0 0 7 8 9]
@eprog

The library syntax is \fun{GEN}{diagonal}{GEN x}.

\subsec{mateigen$(x,\{\fl=0\})$}\kbdsidx{mateigen}\label{se:mateigen}
Returns the (complex) eigenvectors of $x$ as columns of a matrix.
If $\fl=1$, return $[L,H]$, where $L$ contains the
eigenvalues and $H$ the corresponding eigenvectors; multiple eigenvalues are
repeated according to the eigenspace dimension (which may be less
than the eigenvalue multiplicity in the characteristic polynomial).

This function first computes the characteristic polynomial of $x$ and
approximates its complex roots $(\lambda_i)$, then tries to compute the
eigenspaces as kernels of the $x - \lambda_i$. This algorithm is
ill-conditioned and is likely to miss kernel vectors if some roots of the
characteristic polynomial are close, in particular if it has multiple roots.
\bprog
? A = [13,2; 10,14]; mateigen(A)
%1 =
[-1/2 2/5]

[   1   1]
? [L,H] = mateigen(A, 1);
? L
%3 = [9, 18]
? H
%4 =
[-1/2 2/5]

[   1   1]
? A * H == H * matdiagonal(L)
%5 = 1
@eprog\noindent
For symmetric matrices, use \tet{qfjacobi} instead; for Hermitian matrices,
compute
\bprog
 A = real(x);
 B = imag(x);
 y = matconcat([A, -B; B, A]);
@eprog\noindent and apply \kbd{qfjacobi} to $y$.

The library syntax is \fun{GEN}{mateigen}{GEN x, long flag, long prec}.
Also available is \fun{GEN}{eigen}{GEN x, long prec} ($\fl = 0$)

\subsec{matfrobenius$(M,\{\fl\},\{v='x\})$}\kbdsidx{matfrobenius}\label{se:matfrobenius}
Returns the Frobenius form of
the square matrix \kbd{M}. If $\fl=1$, returns only the elementary divisors as
a vector of polynomials in the variable \kbd{v}.  If $\fl=2$, returns a
two-components vector [F,B] where \kbd{F} is the Frobenius form and \kbd{B} is
the basis change so that $M=B^{-1}FB$.

The library syntax is \fun{GEN}{matfrobenius}{GEN M, long flag, long v = -1} where \kbd{v} is a variable number.

\subsec{mathess$(x)$}\kbdsidx{mathess}\label{se:mathess}
Returns a matrix similar to the square matrix $x$, which is in upper Hessenberg
form (zero entries below the first subdiagonal).

The library syntax is \fun{GEN}{hess}{GEN x}.

\subsec{mathilbert$(n)$}\kbdsidx{mathilbert}\label{se:mathilbert}
$x$ being a \kbd{long}, creates the
\idx{Hilbert matrix}of order $x$, i.e.~the matrix whose coefficient
($i$,$j$) is $1/ (i+j-1)$.

The library syntax is \fun{GEN}{mathilbert}{long n}.

\subsec{mathnf$(M,\{\fl=0\})$}\kbdsidx{mathnf}\label{se:mathnf}
Let $R$ be a Euclidean ring, equal to $\Z$ or to $K[X]$ for some field
$K$. If $M$ is a (not necessarily square) matrix with entries in $R$, this
routine finds the \emph{upper triangular} \idx{Hermite normal form} of $M$.
If the rank of $M$ is equal to its number of rows, this is a square
matrix. In general, the columns of the result form a basis of the $R$-module
spanned by the columns of $M$.

The values of $\fl$ are:

\item 0 (default): only return the Hermite normal form $H$

\item 1 (complete output): return $[H,U]$, where $H$ is the Hermite
normal form of $M$, and $U$ is a transformation matrix such that $MU=[0|H]$.
The matrix $U$ belongs to $\text{GL}(R)$. When $M$ has a large kernel, the
entries of $U$ are in general huge.

\noindent For these two values, we use a naive algorithm, which behaves well
in small dimension only. Larger values correspond to different algorithms,
are restricted to \emph{integer} matrices, and all output the unimodular
matrix $U$. From now on all matrices have integral entries.

\item $\fl=4$, returns $[H,U]$ as in ``complete output'' above, using a
variant of \idx{LLL} reduction along the way. The matrix $U$ is provably
small in the $L_2$ sense, and often close to optimal; but the
reduction is in general slow, although provably polynomial-time.

If $\fl=5$, uses Batut's algorithm and output $[H,U,P]$, such that $H$ and
$U$ are as before and $P$ is a permutation of the rows such that $P$ applied
to $MU$ gives $H$. This is in general faster than $\fl=4$ but the matrix $U$
is usually worse; it is heuristically smaller than with the default algorithm.

When the matrix is dense and the dimension is large (bigger than 100, say),
$\fl = 4$ will be fastest. When $M$ has maximal rank, then
\bprog
  H = mathnfmod(M, matdetint(M))
@eprog\noindent will be even faster. You can then recover $U$ as $M^{-1}H$.

\bprog
? M = matrix(3,4,i,j,random([-5,5]))
%1 =
[ 0 2  3  0]

[-5 3 -5 -5]

[ 4 3 -5  4]

? [H,U] = mathnf(M, 1);
? U
%3 =
[-1 0 -1 0]

[ 0 5  3 2]

[ 0 3  1 1]

[ 1 0  0 0]

? H
%5 =
[19 9 7]

[ 0 9 1]

[ 0 0 1]

? M*U
%6 =
[0 19 9 7]

[0  0 9 1]

[0  0 0 1]
@eprog

For convenience, $M$ is allowed to be a \typ{VEC}, which is then
automatically converted to a \typ{MAT}, as per the \tet{Mat} function.
For instance to solve the generalized extended gcd problem, one may use
\bprog
? v = [116085838, 181081878, 314252913,10346840];
? [H,U] = mathnf(v, 1);
? U
%2 =
[ 103 -603    15  -88]

[-146   13 -1208  352]

[  58  220   678 -167]

[-362 -144   381 -101]
? v*U
%3 = [0, 0, 0, 1]
@eprog\noindent This also allows to input a matrix as a \typ{VEC} of
\typ{COL}s of the same length (which \kbd{Mat} would concatenate to
the \typ{MAT} having those columns):
\bprog
? v = [[1,0,4]~, [3,3,4]~, [0,-4,-5]~]; mathnf(v)
%1 =
[47 32 12]

[ 0  1  0]

[ 0  0  1]
@eprog

The library syntax is \fun{GEN}{mathnf0}{GEN M, long flag}.
Also available are \fun{GEN}{hnf}{GEN M} ($\fl=0$) and
\fun{GEN}{hnfall}{GEN M} ($\fl=1$). To reduce \emph{huge} relation matrices
(sparse with small entries, say dimension $400$ or more), you can use the
pair \kbd{hnfspec} / \kbd{hnfadd}. Since this is quite technical and the
calling interface may change, they are not documented yet. Look at the code
in \kbd{basemath/hnf\_snf.c}.

\subsec{mathnfmod$(x,d)$}\kbdsidx{mathnfmod}\label{se:mathnfmod}
If $x$ is a (not necessarily square) matrix of
maximal rank with integer entries, and $d$ is a multiple of the (nonzero)
determinant of the lattice spanned by the columns of $x$, finds the
\emph{upper triangular} \idx{Hermite normal form} of $x$.

If the rank of $x$ is equal to its number of rows, the result is a square
matrix. In general, the columns of the result form a basis of the lattice
spanned by the columns of $x$. Even when $d$ is known, this is in general
slower than \kbd{mathnf} but uses much less memory.

The library syntax is \fun{GEN}{hnfmod}{GEN x, GEN d}.

\subsec{mathnfmodid$(x,d)$}\kbdsidx{mathnfmodid}\label{se:mathnfmodid}
Outputs the (upper triangular)
\idx{Hermite normal form} of $x$ concatenated with the diagonal
matrix with diagonal $d$. Assumes that $x$ has integer entries.
Variant: if $d$ is an integer instead of a vector, concatenate $d$ times the
identity matrix.
\bprog
? m=[0,7;-1,0;-1,-1]
%1 =
[ 0  7]

[-1  0]

[-1 -1]
? mathnfmodid(m, [6,2,2])
%2 =
[2 1 1]

[0 1 0]

[0 0 1]
? mathnfmodid(m, 10)
%3 =
[10 7 3]

[ 0 1 0]

[ 0 0 1]
@eprog

The library syntax is \fun{GEN}{hnfmodid}{GEN x, GEN d}.

\subsec{mathouseholder$(Q,v)$}\kbdsidx{mathouseholder}\label{se:mathouseholder}
\sidx{Householder transform}applies a sequence $Q$ of Householder
transforms, as returned by \kbd{matqr}$(M,1)$ to the vector or matrix $v$.
\bprog
? m = [2,1; 3,2]; \\ some random matrix
? [Q,R] = matqr(m);
? Q
%3 =
[-0.554... -0.832...]

[-0.832... 0.554...]

? R
%4 =
[-3.605... -2.218...]

[0         0.277...]

? v = [1, 2]~; \\ some random vector
? Q * v
%6 = [-2.218..., 0.277...]~

? [q,r] = matqr(m, 1);
? exponent(r - R) \\ r is the same as R
%8 = -128
? q \\ but q has a different structure
%9 = [[0.0494..., [5.605..., 3]]]]
? mathouseholder(q, v) \\ applied to v
%10 = [-2.218..., 0.277...]~
@eprog\noindent The point of the Householder structure is that it efficiently
represents the linear operator $v \mapsto Q \* v$ in a more stable way
than expanding the matrix $Q$:
\bprog
? m = mathilbert(20); v = vectorv(20,i,i^2+1);
? [Q,R] = matqr(m);
? [q,r] = matqr(m, 1);
? \p100
? [q2,r2] = matqr(m, 1); \\ recompute at higher accuracy
? exponent(R - r)
%5 = -127
? exponent(R - r2)
%6 = -127
? exponent(mathouseholder(q,v) - mathouseholder(q2,v))
%7 = -119
? exponent(Q*v - mathouseholder(q2,v))
%8 = 9
@eprog\noindent We see that $R$ is OK with or without a flag to \kbd{matqr}
but that multiplying by $Q$ is considerably less precise than applying the
sequence of Householder transforms encoded by $q$.

The library syntax is \fun{GEN}{mathouseholder}{GEN Q, GEN v}.

\subsec{matid$(n)$}\kbdsidx{matid}\label{se:matid}
Creates the $n\times n$ identity matrix.

The library syntax is \fun{GEN}{matid}{long n}.

\subsec{matimage$(x,\{\fl=0\})$}\kbdsidx{matimage}\label{se:matimage}
Gives a basis for the image of the
matrix $x$ as columns of a matrix. A priori the matrix can have entries of
any type. If $\fl=0$, use standard Gauss pivot. If $\fl=1$, use
\kbd{matsupplement} (much slower: keep the default flag!).

The library syntax is \fun{GEN}{matimage0}{GEN x, long flag}.
Also available is \fun{GEN}{image}{GEN x} ($\fl=0$).

\subsec{matimagecompl$(x)$}\kbdsidx{matimagecompl}\label{se:matimagecompl}
Gives the vector of the column indices which
are not extracted by the function \kbd{matimage}, as a permutation
(\typ{VECSMALL}). Hence the number of
components of \kbd{matimagecompl(x)} plus the number of columns of
\kbd{matimage(x)} is equal to the number of columns of the matrix $x$.

The library syntax is \fun{GEN}{imagecompl}{GEN x}.

\subsec{matimagemod$(x,d,\&U)$}\kbdsidx{matimagemod}\label{se:matimagemod}
Gives a Howell basis (unique representation for submodules of~$(\Z/d\Z)^n$)
for the image of the matrix $x$ modulo $d$ as columns of a matrix $H$. The
matrix $x$ must have \typ{INT} entries, and $d$ can be an arbitrary positive
integer. If $U$ is present, set it to a matrix such that~$AU = H$.

\bprog
? A = [2,1;0,2];
? matimagemod(A,6,&U)
%2 =
[1 0]

[0 2]

? U
%3 =
[5 1]

[3 4]

? (A*U)%6
%4 =
[1 0]

[0 2]
@eprog

\misctitle{Caveat} In general the number of columns of the Howell form is not
the minimal number of generators of the submodule. Example:

\bprog
? matimagemod([1;2],4)
%5 =
[2 1]

[0 2]
@eprog

\misctitle{Caveat 2} In general the matrix $U$ is not invertible, even if~$A$
and~$H$ have the same size. Example:

\bprog
? matimagemod([4,1;0,4],8,&U)
%6 =
[2 1]

[0 4]

? U
%7 =
[0 0]

[2 1]
@eprog

The library syntax is \fun{GEN}{matimagemod}{GEN x, GEN d, GEN *U = NULL}.

\subsec{matindexrank$(M)$}\kbdsidx{matindexrank}\label{se:matindexrank}
$M$ being a matrix of rank $r$, returns a vector with two
\typ{VECSMALL} components $y$ and $z$ of length $r$ giving a list of rows
and columns respectively (starting from 1) such that the extracted matrix
obtained from these two vectors using $\tet{vecextract}(M,y,z)$ is
invertible. The vectors $y$ and $z$ are sorted in increasing order.

The library syntax is \fun{GEN}{indexrank}{GEN M}.

\subsec{matintersect$(x,y)$}\kbdsidx{matintersect}\label{se:matintersect}
$x$ and $y$ being two matrices with the same number of rows, finds a
basis of the vector space equal to the intersection of the spaces spanned by
the columns of $x$ and $y$ respectively. For efficiency, the columns of $x$
(resp.~$y$) should be independent.

The faster function \tet{idealintersect} can be used to intersect
fractional ideals (projective $\Z_K$ modules of rank $1$); the slower but
more general function \tet{nfhnf} can be used to intersect general
$\Z_K$-modules.

The library syntax is \fun{GEN}{intersect}{GEN x, GEN y}.

\subsec{matinverseimage$(x,y)$}\kbdsidx{matinverseimage}\label{se:matinverseimage}
Given a matrix $x$ and
a column vector or matrix $y$, returns a preimage $z$ of $y$ by $x$ if one
exists (i.e such that $x z = y$), an empty vector or matrix otherwise. The
complete inverse image is $z + \text{Ker} x$, where a basis of the kernel of
$x$ may be obtained by \kbd{matker}.
\bprog
? M = [1,2;2,4];
? matinverseimage(M, [1,2]~)
%2 = [1, 0]~
? matinverseimage(M, [3,4]~)
%3 = []~    \\@com no solution
? matinverseimage(M, [1,3,6;2,6,12])
%4 =
[1 3 6]

[0 0 0]
? matinverseimage(M, [1,2;3,4])
%5 = [;]    \\@com no solution
? K = matker(M)
%6 =
[-2]

[1]
@eprog

The library syntax is \fun{GEN}{inverseimage}{GEN x, GEN y}.

\subsec{matinvmod$(x,d)$}\kbdsidx{matinvmod}\label{se:matinvmod}
Computes a left inverse of the matrix~$x$ modulo~$d$. The matrix $x$ must
have \typ{INT} entries, and $d$ can be an arbitrary positive integer.

\bprog
? A = [3,1,2;1,2,1;3,1,1];
? U = matinvmod(A,6)
%2 =
[1 1 3]

[2 3 5]

[1 0 5]

? (U*A)%6
%3 =
[1 0 0]

[0 1 0]

[0 0 1]
? matinvmod(A,5)
 ***   at top-level: matinvmod(A,5)
 ***                 ^--------------
 *** matinvmod: impossible inverse in gen_inv: 0.
@eprog

The library syntax is \fun{GEN}{matinvmod}{GEN x, GEN d}.

\subsec{matisdiagonal$(x)$}\kbdsidx{matisdiagonal}\label{se:matisdiagonal}
Returns true (1) if $x$ is a diagonal matrix, false (0) if not.

The library syntax is \fun{GEN}{isdiagonal}{GEN x}.

\subsec{matker$(x,\{\fl=0\})$}\kbdsidx{matker}\label{se:matker}
Gives a basis for the kernel of the matrix $x$ as columns of a matrix.
The matrix can have entries of any type, provided they are compatible with
the generic arithmetic operations ($+$, $\times$ and $/$).

If $x$ is known to have integral entries, set $\fl=1$.

The library syntax is \fun{GEN}{matker0}{GEN x, long flag}.
Also available are \fun{GEN}{ker}{GEN x} ($\fl=0$),
\fun{GEN}{ZM_ker}{GEN x} ($\fl=1$).

\subsec{matkerint$(x,\{\fl=0\})$}\kbdsidx{matkerint}\label{se:matkerint}
Gives an \idx{LLL}-reduced $\Z$-basis
for the lattice equal to the kernel of the matrix $x$ with rational entries.
\fl{} is deprecated, kept for backward compatibility. The function
\kbd{matsolvemod} allows to solve more general linear systems over $\Z$.

The library syntax is \fun{GEN}{matkerint0}{GEN x, long flag}.
Use directly \fun{GEN}{kerint}{GEN x} if $x$ is known to have
integer entries, and \tet{Q_primpart} first otherwise.

\subsec{matkermod$(x,d,\&\var{im})$}\kbdsidx{matkermod}\label{se:matkermod}
Gives a Howell basis (unique representation for submodules of~$(\Z/d\Z)^n$,
cf. \kbd{matimagemod}) for the kernel of the matrix $x$ modulo $d$ as columns
of a matrix. The matrix $x$ must have \typ{INT} entries, and $d$ can be an
arbitrary positive integer. If $im$ is present, set it to a basis of the image
of~$x$ (which is computed on the way).

\bprog
? A = [1,2,3;5,1,4]
%1 =
[1 2 3]

[5 1 4]

? K = matkermod(A,6)
%2 =
[2 1]

[2 1]

[0 3]

? (A*K)%6
%3 =
[0 0]

[0 0]
@eprog

The library syntax is \fun{GEN}{matkermod}{GEN x, GEN d, GEN *im = NULL}.

\subsec{matmuldiagonal$(x,d)$}\kbdsidx{matmuldiagonal}\label{se:matmuldiagonal}
Product of the matrix $x$ by the diagonal
matrix whose diagonal entries are those of the vector $d$. Equivalent to,
but much faster than $x*\kbd{matdiagonal}(d)$.

The library syntax is \fun{GEN}{matmuldiagonal}{GEN x, GEN d}.

\subsec{matmultodiagonal$(x,y)$}\kbdsidx{matmultodiagonal}\label{se:matmultodiagonal}
Product of the matrices $x$ and $y$ assuming that the result is a
diagonal matrix. Much faster than $x*y$ in that case. The result is
undefined if $x*y$ is not diagonal.

The library syntax is \fun{GEN}{matmultodiagonal}{GEN x, GEN y}.

\subsec{matpascal$(n,\{q\})$}\kbdsidx{matpascal}\label{se:matpascal}
Creates as a matrix the lower triangular
\idx{Pascal triangle} of order $x+1$ (i.e.~with binomial coefficients
up to $x$). If $q$ is given, compute the $q$-Pascal triangle (i.e.~using
$q$-binomial coefficients).

The library syntax is \fun{GEN}{matqpascal}{long n, GEN q = NULL}.
Also available is \fun{GEN}{matpascal}{GEN x}.

\subsec{matpermanent$(x)$}\kbdsidx{matpermanent}\label{se:matpermanent}
Permanent of the square matrix $x$ using Ryser's formula in Gray code
order.
\bprog
? n = 20; m = matrix(n,n,i,j, i!=j);
? matpermanent(m)
%2 = 895014631192902121
? n! * sum(i=0,n, (-1)^i/i!)
%3 = 895014631192902121
@eprog\noindent This function runs in time $O(2^n n)$ for a matrix of size
$n$ and is not implemented for $n$ large.

The library syntax is \fun{GEN}{matpermanent}{GEN x}.

\subsec{matqr$(M,\{\fl=0\})$}\kbdsidx{matqr}\label{se:matqr}
Returns $[Q,R]$, the \idx{QR-decomposition} of the square invertible
matrix $M$ with real entries: $Q$ is orthogonal and $R$ upper triangular. If
$\fl=1$, the orthogonal matrix is returned as a sequence of Householder
transforms: applying such a sequence is stabler and faster than
multiplication by the corresponding $Q$ matrix.\sidx{Householder transform}
More precisely, if
\bprog
  [Q,R] = matqr(M);
  [q,r] = matqr(M, 1);
@eprog\noindent then $r = R$ and \kbd{mathouseholder}$(q, M)$ is
(close to) $R$; furthermore
\bprog
  mathouseholder(q, matid(#M)) == Q~
@eprog\noindent the inverse of $Q$. This function raises an error if the
precision is too low or $x$ is singular.

The library syntax is \fun{GEN}{matqr}{GEN M, long flag, long prec}.

\subsec{matrank$(x)$}\kbdsidx{matrank}\label{se:matrank}
Rank of the matrix $x$.

The library syntax is \fun{long}{rank}{GEN x}.

\subsec{matreduce$(m)$}\kbdsidx{matreduce}\label{se:matreduce}
Let $m$ be a factorization matrix, i.e., a 2-column matrix whose
columns contains arbitrary ``generators'' and integer ``exponents''
respectively. Returns the canonical form of $m$: the
first column is sorted with unique elements and the second one contains the
merged ``exponents'' (exponents of identical entries in the first column  of
$m$ are added, rows attached to $0$ exponents are deleted). The generators are
sorted with respect to the universal \kbd{cmp} routine; in particular, this
function is the identity on true integer factorization matrices, but not on
other factorizations (in products of polynomials or maximal ideals, say). It
is idempotent.

For convenience, this function also allows a vector $m$, which is handled as a
factorization with all exponents equal to $1$, as in \kbd{factorback}.

\bprog
? A=[x,2;y,4]; B=[x,-2; y,3; 3, 4]; C=matconcat([A,B]~)
%1 =
[x  2]

[y  4]

[x -2]

[y  3]

[3  4]

? matreduce(C)
%2 =
[3 4]

[y 7]

? matreduce([x,x,y,x,z,x,y]) \\ vector argument
%3 =
[x 4]

[y 2]

[z 1]
@eprog

The library syntax is \fun{GEN}{matreduce}{GEN m}.

\subsec{matrix$(m,\{n=m\},\{X\},\{Y\},\{\var{expr}=0\})$}\kbdsidx{matrix}\label{se:matrix}
Creation of the
$m\times n$ matrix whose coefficients are given by the expression
\var{expr}. There are two formal parameters in \var{expr}, the first one
($X$) corresponding to the rows, the second ($Y$) to the columns, and $X$
goes from 1 to $m$, $Y$ goes from 1 to $n$. If one of the last 3 parameters
is omitted, fill the matrix with zeroes. If $n$ is omitted, return a
square $m \times m$ matrix.
%\syn{NO}

\subsec{matrixqz$(A,\{p=0\})$}\kbdsidx{matrixqz}\label{se:matrixqz}
$A$ being an $m\times n$ matrix in $M_{m,n}(\Q)$, let
$\text{Im}_\Q A$ (resp.~$\text{Im}_\Z A$) the $\Q$-vector space
(resp.~the $\Z$-module) spanned by the columns of $A$. This function has
varying behavior depending on the sign of $p$:

If $p \geq 0$, $A$ is assumed to have maximal rank $n\leq m$. The function
returns a matrix $B\in M_{m,n}(\Z)$, with $\text{Im}_\Q B = \text{Im}_\Q A$,
such that the GCD of all its $n\times n$ minors is coprime to
$p$; in particular, if $p = 0$ (default), this GCD is $1$.

If $p=-1$, returns a basis of the lattice $\Z^n \cap \text{Im}_\Z A$.

If $p=-2$, returns a basis of the lattice $\Z^n \cap \text{Im}_\Q A$.

\misctitle{Caveat} ($p=-1$ or $-2$) For efficiency reason, we do not compute
the HNF of the resulting basis.

\bprog
? minors(x) = vector(#x[,1], i, matdet(x[^i,]));
? A = [3,1/7; 5,3/7; 7,5/7]; minors(A)
%1 = [4/7, 8/7, 4/7]   \\ determinants of all 2x2 minors
? B = matrixqz(A)
%2 =
[3 1]

[5 2]

[7 3]
? minors(%)
%3 = [1, 2, 1]   \\ B integral with coprime minors
? matrixqz(A,-1)
%4 =
[3 1]

[5 3]

[7 5]

? matrixqz(A,-2)
%5 =
[3 1]

[5 2]

[7 3]

@eprog

The library syntax is \fun{GEN}{matrixqz0}{GEN A, GEN p = NULL}.

\subsec{matsize$(x)$}\kbdsidx{matsize}\label{se:matsize}
$x$ being a vector or matrix, returns a row vector
with two components, the first being the number of rows (1 for a row vector),
the second the number of columns (1 for a column vector).

The library syntax is \fun{GEN}{matsize}{GEN x}.

\subsec{matsnf$(X,\{\fl=0\})$}\kbdsidx{matsnf}\label{se:matsnf}
If $X$ is a (singular or nonsingular) matrix outputs the vector of
\idx{elementary divisors} of $X$, i.e.~the diagonal of the
\idx{Smith normal form} of $X$, normalized so that $d_n \mid d_{n-1} \mid
\ldots \mid d_1$. $X$ must have integer or polynomial entries; in the latter
case, $X$ must be a square matrix.

The binary digits of \fl\ mean:

1 (complete output): if set, outputs $[U,V,D]$, where $U$ and $V$ are two
unimodular matrices such that $UXV$ is the diagonal matrix $D$. Otherwise
output only the diagonal of $D$. If $X$ is not a square matrix, then $D$
will be a square diagonal matrix padded with zeros on the left or the top.

4 (cleanup): if set, cleans up the output. This means that elementary
divisors equal to $1$ will be deleted, i.e.~outputs a shortened vector $D'$
instead of $D$. If complete output was required, returns $[U',V',D']$ so
that $U'XV' = D'$ holds. If this flag is set, $X$ is allowed to be of the
form `vector of elementary divisors' or $[U,V,D]$ as would normally be
output with the cleanup flag unset.

If $v$ is an output from \kbd{matsnf} and $p$ is a power of an irreducible
element, then \kbd{snfrank(v, p)} returns the $p$-rank of the attached
module.

\bprog
? X = [27,0; 0,3; 1,1; 0,0]; matsnf(X)
%1 = [0, 0, 3, 1]
? [U,V,D] = v = matsnf(X, 1); U*X*V == D
%2
? U
%3 =
[0 0   0 1]

[1 9 -27 0]

[0 1   0 0]

[0 0   1 0]

? V
%4 =
[-1 1]

[ 1 0]

? snfrank(v, 3)
%5 = 3
@eprog\noindent Continuing the same example after cleanup:
\bprog
? [U,V,D] = v = matsnf(X, 1+4); U*X*V == D
%6 = 1

? D
%7 =
[0]

[0]

[3]

? snfrank(v, 3)
%8 = 3

? snfrank(v, 2)
%9 = 2
@eprog

The library syntax is \fun{GEN}{matsnf0}{GEN X, long flag}.

\subsec{matsolve$(M,B)$}\kbdsidx{matsolve}\label{se:matsolve}
Let $M$ be a left-invertible matrix and $B$ a column vector
such that there exists a solution $X$ to the system of linear equations
$MX = B$; return the (unique) solution $X$. This has the same effect as, but
is faster, than $M^{-1}*B$. Uses Dixon $p$-adic lifting method if $M$ and
$B$ are integral and Gaussian elimination otherwise. When there is no
solution, the function returns an $X$ such that $MX - B$ is nonzero
although it has at least $\#M$ zero entries:
\bprog
? M = [1,2;3,4;5,6];
? B = [4,6,8]~; X = matsolve(M, B)
%2 = [-2, 3]~
? M*X == B
%3 = 1
? B = [1,2,4]~; X = matsolve(M, [1,2,4]~)
%4 = [0, 1/2]~
? M*X - B
%5 = [0, 0, -1]~
@eprog\noindent Raises an exception if $M$ is not left-invertible, even if
there is a solution:
\bprog
? M = [1,1;1,1]; matsolve(M, [1,1]~)
 ***   at top-level: matsolve(M,[1,1]~)
 ***                 ^------------------
 *** matsolve: impossible inverse in gauss: [1, 1; 1, 1].
@eprog\noindent The function also works when $B$ is a matrix and we return
the unique matrix solution $X$ provided it exists. Again, if there is no
solution, the function returns an $X$ such that $MX - B$ is nonzero
although it has at least $\#M$ zero rows.

The library syntax is \fun{GEN}{gauss}{GEN M, GEN B}.

\subsec{matsolvemod$(M,D,B,\{\fl=0\})$}\kbdsidx{matsolvemod}\label{se:matsolvemod}
$M$ being any integral matrix,
$D$ a column vector of nonnegative integer moduli, and $B$ an integral
column vector, gives an integer solution to the system of congruences
$\sum_i m_{i,j}x_j\equiv b_i\pmod{d_i}$ if one exists, otherwise returns
zero. Note that we explicitly allow $d_i = 0$ corresponding to an equality
in $\Z$. Shorthand notation: $B$ (resp.~$D$) can be given as a single integer,
in which case all the $b_i$ (resp.~$d_i$) above are taken to be equal to $B$
(resp.~$D$). Again, $D = 0$ solves the linear system of equations over $\Z$.
\bprog
? M = [1,2;3,4];
? matsolvemod(M, [3,4]~, [1,2]~)
%2 = [10, 0]~
? matsolvemod(M, 3, 1) \\ M X = [1,1]~ over F_3
%3 = [2, 1]~
? matsolvemod(M, [3,0]~, [1,2]~) \\ x + 2y = 1 (mod 3), 3x + 4y = 2 (in Z)
%4 = [6, -4]~
? matsolvemod(M, 0, [1,2]~) \\ no solution in Z for x + 2y = 1, 3x + 4y = 2
@eprog
If $\fl=1$, all solutions are returned in the form of a two-component row
vector $[x,u]$, where $x$ is an integer solution to the system of
congruences and $u$ is a matrix whose columns give a basis of the homogeneous
system (so that all solutions can be obtained by adding $x$ to any linear
combination of columns of $u$). If no solution exists, returns zero.

The library syntax is \fun{GEN}{matsolvemod}{GEN M, GEN D, GEN B, long flag}.
Also available are \fun{GEN}{gaussmodulo}{GEN M, GEN D, GEN B}
($\fl=0$) and \fun{GEN}{gaussmodulo2}{GEN M, GEN D, GEN B} ($\fl=1$).

\subsec{matsupplement$(x)$}\kbdsidx{matsupplement}\label{se:matsupplement}
Assuming that the columns of the matrix $x$
are linearly independent (if they are not, an error message is issued), finds
a square invertible matrix whose first columns are the columns of $x$,
i.e.~supplement the columns of $x$ to a basis of the whole space.
\bprog
? matsupplement([1;2])
%1 =
[1 0]

[2 1]
@eprog
Raises an error if $x$ has 0 columns, since (due to a long standing design
bug), the dimension of the ambient space (the number of rows) is unknown in
this case:
\bprog
? matsupplement(matrix(2,0))
  ***   at top-level: matsupplement(matrix
  ***                 ^--------------------
  *** matsupplement: sorry, suppl [empty matrix] is not yet implemented.
@eprog

The library syntax is \fun{GEN}{suppl}{GEN x}.

\subsec{mattranspose$(x)$}\kbdsidx{mattranspose}\label{se:mattranspose}
Transpose of $x$ (also $x\til$).
This has an effect only on vectors and matrices.

The library syntax is \fun{GEN}{gtrans}{GEN x}.

\subsec{minpoly$(A,\{v='x\})$}\kbdsidx{minpoly}\label{se:minpoly}
\idx{minimal polynomial}
of $A$ with respect to the variable $v$., i.e. the monic polynomial $P$
of minimal degree (in the variable $v$) such that $P(A) = 0$.

The library syntax is \fun{GEN}{minpoly}{GEN A, long v = -1} where \kbd{v} is a variable number.

\subsec{norml2$(x)$}\kbdsidx{norml2}\label{se:norml2}
Square of the $L^2$-norm of $x$. More precisely,
if $x$ is a scalar, $\kbd{norml2}(x)$ is defined to be the square
of the complex modulus of $x$ (real \typ{QUAD}s are not supported).
If $x$ is a polynomial, a (row or column) vector or a matrix, \kbd{norml2($x$)} is
defined recursively as $\sum_i \kbd{norml2}(x_i)$, where $(x_i)$ run through
the components of $x$. In particular, this yields the usual $\sum |x_i|^2$
(resp.~$\sum |x_{i,j}|^2$) if $x$ is a polynomial or vector (resp.~matrix) with
complex components.

\bprog
? norml2( [ 1, 2, 3 ] )      \\ vector
%1 = 14
? norml2( [ 1, 2; 3, 4] )   \\ matrix
%2 = 30
? norml2( 2*I + x )
%3 = 5
? norml2( [ [1,2], [3,4], 5, 6 ] )   \\ recursively defined
%4 = 91
@eprog

The library syntax is \fun{GEN}{gnorml2}{GEN x}.

\subsec{normlp$(x,\{p=\var{oo}\})$}\kbdsidx{normlp}\label{se:normlp}
$L^p$-norm of $x$; sup norm if $p$ is omitted or \kbd{+oo}. More precisely,
if $x$ is a scalar, \kbd{normlp}$(x, p)$ is defined to be \kbd{abs}$(x)$.
If $x$ is a polynomial, a (row or column) vector or a matrix:

\item  if $p$ is omitted or \kbd{+oo}, then \kbd{normlp($x$)} is defined
recursively as $\max_i \kbd{normlp}(x_i))$, where $(x_i)$ run through the
components of~$x$. In particular, this yields the usual sup norm if $x$ is a
polynomial or vector with complex components.

\item otherwise, \kbd{normlp($x$, $p$)} is defined recursively as $(\sum_i
\kbd{normlp}^p(x_i,p))^{1/p}$. In particular, this yields the usual $(\sum
|x_i|^p)^{1/p}$ if $x$ is a polynomial or vector with complex components.

\bprog
? v = [1,-2,3]; normlp(v)      \\ vector
%1 = 3
? normlp(v, +oo)               \\ same, more explicit
%2 = 3
? M = [1,-2;-3,4]; normlp(M)   \\ matrix
%3 = 4
? T = (1+I) + I*x^2; normlp(T)
%4 = 1.4142135623730950488016887242096980786
? normlp([[1,2], [3,4], 5, 6])   \\ recursively defined
%5 = 6

? normlp(v, 1)
%6 = 6
? normlp(M, 1)
%7 = 10
? normlp(T, 1)
%8 = 2.4142135623730950488016887242096980786
@eprog

The library syntax is \fun{GEN}{gnormlp}{GEN x, GEN p = NULL, long prec}.

\subsec{powers$(x,n,\{\var{x0}\})$}\kbdsidx{powers}\label{se:powers}
For nonnegative $n$, return the vector with $n+1$ components
$[1,x,\dots,x^n]$ if \kbd{x0} is omitted, and $[x_0, x_0*x, ..., x_0*x^n]$
otherwise.
\bprog
? powers(Mod(3,17), 4)
%1 = [Mod(1, 17), Mod(3, 17), Mod(9, 17), Mod(10, 17), Mod(13, 17)]
? powers(Mat([1,2;3,4]), 3)
%2 = [[1, 0; 0, 1], [1, 2; 3, 4], [7, 10; 15, 22], [37, 54; 81, 118]]
? powers(3, 5, 2)
%3 = [2, 6, 18, 54, 162, 486]
@eprog\noindent When $n < 0$, the function returns the empty vector \kbd{[]}.

The library syntax is \fun{GEN}{gpowers0}{GEN x, long n, GEN x0 = NULL}.
Also available is
\fun{GEN}{gpowers}{GEN x, long n} when \kbd{x0} is \kbd{NULL}.

\subsec{qfauto$(G,\{\var{fl}\})$}\kbdsidx{qfauto}\label{se:qfauto}
$G$ being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, outputs the automorphism group of the
associate lattice.
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension grows. $G$ can also be given by an
\kbd{qfisominit} structure.
See \kbd{qfisominit} for the meaning of \var{fl}.

The output is a two-components vector $[o,g]$ where $o$ is the group order
and $g$ is the list of generators (as a vector). For each generator $H$,
the equality $G={^t}H\*G\*H$ holds.

The interface of this function is experimental and will likely change in the
future.

This function implements an algorithm of Plesken and Souvignier, following
Souvignier's implementation.
\bprog
? K = matkerint(Mat(concat([vector(23,i,2*i+1), 51, 145])));
? M = matdiagonal(vector(25,i,if(i==25,-1,1)));
? L24 = K~ * M * K; \\ the Leech lattice
? [o,g] = qfauto(L24); o
%4 = 8315553613086720000
? #g
%5 = 2
@eprog

The library syntax is \fun{GEN}{qfauto0}{GEN G, GEN fl = NULL}.
The function \fun{GEN}{qfauto}{GEN G, GEN fl} is also available
where $G$ is a vector of \kbd{zm} matrices.

\subsec{qfautoexport$(\var{qfa},\{\fl\})$}\kbdsidx{qfautoexport}\label{se:qfautoexport}
\var{qfa} being an automorphism group as output by
\tet{qfauto}, export the underlying matrix group as a string suitable
for (no flags or $\fl=0$) GAP or ($\fl=1$) Magma. The following example
computes the size of the matrix group using GAP:
\bprog
? G = qfauto([2,1;1,2])
%1 = [12, [[-1, 0; 0, -1], [0, -1; 1, 1], [1, 1; 0, -1]]]
? s = qfautoexport(G)
%2 = "Group([[-1, 0], [0, -1]], [[0, -1], [1, 1]], [[1, 1], [0, -1]])"
? extern("echo \"Order("s");\" | gap -q")
%3 = 12
@eprog

The library syntax is \fun{GEN}{qfautoexport}{GEN qfa, long flag}.

\subsec{qfbil$(x,y,\{q\})$}\kbdsidx{qfbil}\label{se:qfbil}
This function is obsolete, use \kbd{qfeval}.

The library syntax is \fun{GEN}{qfbil}{GEN x, GEN y, GEN q = NULL}.

\subsec{qfeval$(\{q\},x,\{y\})$}\kbdsidx{qfeval}\label{se:qfeval}
Evaluate the quadratic form $q$ (given by a symmetric matrix)
at the vector $x$; if $y$ is present, evaluate the polar form at $(x,y)$;
if $q$ omitted, use the standard Euclidean scalar product, corresponding to
the identity matrix.

Roughly equivalent to \kbd{x\til * q * y}, but a little faster and
more convenient (does not distinguish between column and row vectors):
\bprog
? x = [1,2,3]~; y = [-1,3,1]~; q = [1,2,3;2,2,-1;3,-1,9];
? qfeval(q,x,y)
%2 = 23
? for(i=1,10^6, qfeval(q,x,y))
time = 661ms
? for(i=1,10^6, x~*q*y)
time = 697ms
@eprog\noindent The speedup is noticeable for the quadratic form,
compared to \kbd{x\til * q * x}, since we save almost half the
operations:
\bprog
? for(i=1,10^6, qfeval(q,x))
time = 487ms
@eprog\noindent The special case $q = \text{Id}$ is handled faster if we
omit $q$ altogether:
\bprog
? qfeval(,x,y)
%6 = 8
? q = matid(#x);
? for(i=1,10^6, qfeval(q,x,y))
time = 529 ms.
? for(i=1,10^6, qfeval(,x,y))
time = 228 ms.
? for(i=1,10^6, x~*y)
time = 274 ms.
@eprog

We also allow \typ{MAT}s of compatible dimensions for $x$,
and return \kbd{x\til * q * x} in this case as well:
\bprog
? M = [1,2,3;4,5,6;7,8,9]; qfeval(,M) \\ Gram matrix
%5 =
[66  78  90]

[78  93 108]

[90 108 126]

? q = [1,2,3;2,2,-1;3,-1,9];
? for(i=1,10^6, qfeval(q,M))
time = 2,008 ms.
? for(i=1,10^6, M~*q*M)
time = 2,368 ms.

? for(i=1,10^6, qfeval(,M))
time = 1,053 ms.
? for(i=1,10^6, M~*M)
time = 1,171 ms.
@eprog

If $q$ is a \typ{QFB}, it is implicitly converted to the
attached symmetric \typ{MAT}. This is done more
efficiently than by direct conversion, since we avoid introducing a
denominator $2$ and rational arithmetic:
\bprog
? q = Qfb(2,3,4); x = [2,3];
? qfeval(q, x)
%2 = 62
? Q = Mat(q)
%3 =
 [  2 3/2]

 [3/2   4]
? qfeval(Q, x)
%4 = 62
? for (i=1, 10^6, qfeval(q,x))
time = 758 ms.
? for (i=1, 10^6, qfeval(Q,x))
time = 1,110 ms.
@eprog
Finally, when $x$ is a \typ{MAT} with \emph{integral} coefficients, we allow
a \typ{QFB} for $q$ and return the binary
quadratic form $q \circ M$. Again, the conversion to \typ{MAT} is less
efficient in this case:
\bprog
? q = Qfb(2,3,4); Q = Mat(q); x = [1,2;3,4];
? qfeval(q, x)
%2 = Qfb(47, 134, 96)
? qfeval(Q,x)
%3 =
[47 67]

[67 96]
? for (i=1, 10^6, qfeval(q,x))
time = 701 ms.
? for (i=1, 10^6, qfeval(Q,x))
time = 1,639 ms.
@eprog

The library syntax is \fun{GEN}{qfeval0}{GEN q = NULL, GEN x, GEN y = NULL}.

\subsec{qfgaussred$(q)$}\kbdsidx{qfgaussred}\label{se:qfgaussred}
\idx{decomposition into squares} of the
quadratic form represented by the symmetric matrix $q$. The result is a
matrix whose diagonal entries are the coefficients of the squares, and the
off-diagonal entries on each line represent the bilinear forms. More
precisely, if $(a_{ij})$ denotes the output, one has
$$ q(x) = \sum_i a_{ii} (x_i + \sum_{j \neq i} a_{ij} x_j)^2 $$
\bprog
? qfgaussred([0,1;1,0])
%1 =
[1/2 1]

[-1 -1/2]
@eprog\noindent This means that $2xy = (1/2)(x+y)^2 - (1/2)(x-y)^2$.
Singular matrices are supported, in which case some diagonal coefficients
will vanish:
\bprog
? qfgaussred([1,1;1,1])
%1 =
[1 1]

[1 0]
@eprog\noindent This means that $x^2 + 2xy + y^2 = (x+y)^2$.

The library syntax is \fun{GEN}{qfgaussred}{GEN q}.
\fun{GEN}{qfgaussred_positive}{GEN q} assumes that $q$ is
 positive definite and is a little faster; returns \kbd{NULL} if a vector
 with negative norm occurs (non positive matrix or too many rounding errors).

\subsec{qfisom$(G,H,\{\var{fl}\},\{\var{grp}\})$}\kbdsidx{qfisom}\label{se:qfisom}
$G$, $H$ being square and symmetric matrices with integer entries representing
positive definite quadratic forms, return an invertible matrix $S$ such that
$G={^t}S\*H\*S$. This defines a isomorphism between the corresponding lattices.
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension grows.
See \kbd{qfisominit} for the meaning of \var{fl}.
If \var{grp} is given it must be the automorphism group of $H$. It will be used
to speed up the computation.

$G$ can also be given by an \kbd{qfisominit} structure which is preferable if
several forms $H$ need to be compared to $G$.

This function implements an algorithm of Plesken and Souvignier, following
Souvignier's implementation.

The library syntax is \fun{GEN}{qfisom0}{GEN G, GEN H, GEN fl = NULL, GEN grp = NULL}.
Also available is \fun{GEN}{qfisom}{GEN G, GEN H, GEN fl, GEN grp}
where $G$ is a vector of \kbd{zm}, and $H$ is a \kbd{zm}, and $grp$ is
either \kbd{NULL} or a vector of \kbd{zm}.

\subsec{qfisominit$(G,\{\var{fl}\},\{m\})$}\kbdsidx{qfisominit}\label{se:qfisominit}
$G$ being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, return an \kbd{isom} structure allowing to
compute isomorphisms between $G$ and other quadratic forms faster.

The interface of this function is experimental and will likely change in future
release.

If present, the optional parameter \var{fl} must be a \typ{VEC} with two
components. It allows to specify the invariants used, which can make the
computation faster or slower. The components are

\item \kbd{fl[1]} Depth of scalar product combination to use.

\item \kbd{fl[2]} Maximum level of Bacher polynomials to use.

If present, $m$ must be the set of vectors of norm up to the maximal of the
diagonal entry of $G$, either as a matrix or as given by \kbd{qfminim}.
Otherwise this function computes the minimal vectors so it become very
lengthy as the dimension of $G$ grows.

The library syntax is \fun{GEN}{qfisominit0}{GEN G, GEN fl = NULL, GEN m = NULL}.
Also available is
\fun{GEN}{qfisominit}{GEN F, GEN fl}
where $F$ is a vector of \kbd{zm}.

\subsec{qfjacobi$(A)$}\kbdsidx{qfjacobi}\label{se:qfjacobi}
Apply Jacobi's eigenvalue algorithm to the real symmetric matrix $A$.
This returns $[L, V]$, where

\item $L$ is the vector of (real) eigenvalues of $A$, sorted in increasing
order,

\item $V$ is the corresponding orthogonal matrix of eigenvectors of $A$.

\bprog
? \p19
? A = [1,2;2,1]; mateigen(A)
%1 =
[-1 1]

[ 1 1]
? [L, H] = qfjacobi(A);
? L
%3 = [-1.000000000000000000, 3.000000000000000000]~
? H
%4 =
[ 0.7071067811865475245 0.7071067811865475244]

[-0.7071067811865475244 0.7071067811865475245]
? norml2( (A-L[1])*H[,1] )       \\ approximate eigenvector
%5 = 9.403954806578300064 E-38
? norml2(H*H~ - 1)
%6 = 2.350988701644575016 E-38   \\ close to orthogonal
@eprog

The library syntax is \fun{GEN}{jacobi}{GEN A, long prec}.

\subsec{qflll$(x,\{\fl=0\})$}\kbdsidx{qflll}\label{se:qflll}
\idx{LLL} algorithm applied to the
\emph{columns} of the matrix $x$. The columns of $x$ may be linearly
dependent. The result is by default a unimodular transformation matrix $T$
such that $x \cdot T$ is an LLL-reduced basis of the lattice generated by
the column vectors of $x$. Note that if $x$ is not of maximal rank $T$ will
not be square. The LLL parameters are $(0.51,0.99)$, meaning that the
Gram-Schmidt coefficients for the final basis satisfy $|\mu_{i,j}| \leq
0.51$, and the Lov\'{a}sz's constant is $0.99$.

If $\fl=0$ (default), assume that $x$ has either exact (integral or
rational) or real floating point entries. The matrix is rescaled, converted
to integers and the behavior is then as in $\fl = 1$.

If $\fl=1$, assume that $x$ is integral. Computations involving Gram-Schmidt
vectors are approximate, with precision varying as needed (Lehmer's trick,
as generalized by Schnorr). Adapted from Nguyen and Stehl\'e's algorithm
and Stehl\'e's code (\kbd{fplll-1.3}).

If $\fl=2$, $x$ should be an integer matrix whose columns are linearly
independent. Returns a partially reduced basis for $x$, using an unpublished
algorithm by Peter Montgomery: a basis is said to be \emph{partially reduced}
if $|v_i \pm v_j| \geq |v_i|$ for any two distinct basis vectors $v_i, \,
v_j$. This is faster than $\fl=1$, esp. when one row is huge compared
to the other rows (knapsack-style), and should quickly produce relatively
short vectors. The resulting basis is \emph{not} LLL-reduced in general.
If LLL reduction is eventually desired, avoid this partial reduction:
applying LLL to the partially reduced matrix is significantly \emph{slower}
than starting from a knapsack-type lattice.

If $\fl=3$, as $\fl=1$, but the reduction is performed in place: the
routine returns $x \cdot T$. This is usually faster for knapsack-type
lattices.

If $\fl=4$, as $\fl=1$, returning a vector $[K, T]$ of matrices: the
columns of $K$ represent a basis of the integer kernel of $x$
(not LLL-reduced in general) and $T$ is the transformation
matrix such that $x\cdot T$ is an LLL-reduced $\Z$-basis of the image
of the matrix $x$.

If $\fl=5$, case as case $4$, but $x$ may have polynomial coefficients.

If $\fl=8$, same as case $0$, but $x$ may have polynomial coefficients.

\bprog
? \p500
  realprecision = 500 significant digits
? a = 2*cos(2*Pi/97);
? C = 10^450;
? v = powers(a,48); b = round(matconcat([matid(48),C*v]~));
? p = b * qflll(b)[,1]; \\ tiny linear combination of powers of 'a'
   time = 4,470 ms.
? exponent(v * p / C)
%5 = -1418
? p3 = qflll(b,3)[,1]; \\ compute in place, faster
   time = 3,790 ms.
? p3 == p \\ same result
%7 = 1
? p2 = b * qflll(b,2)[,1]; \\ partial reduction: faster, not as good
   time = 343 ms.
? exponent(v * p2 / C)
%9 = -1190
@eprog

The library syntax is \fun{GEN}{qflll0}{GEN x, long flag}.
Also available are \fun{GEN}{lll}{GEN x} ($\fl=0$),
\fun{GEN}{lllint}{GEN x} ($\fl=1$), and \fun{GEN}{lllkerim}{GEN x} ($\fl=4$).

\subsec{qflllgram$(G,\{\fl=0\})$}\kbdsidx{qflllgram}\label{se:qflllgram}
Same as \kbd{qflll}, except that the
matrix $G = \kbd{x\til * x}$ is the Gram matrix of some lattice vectors $x$,
and not the coordinates of the vectors themselves. In particular, $G$ must
now be a square symmetric real matrix, corresponding to a positive
quadratic form (not necessarily definite: $x$ needs not have maximal rank).
The result is a unimodular
transformation matrix $T$ such that $x \cdot T$ is an LLL-reduced basis of
the lattice generated by the column vectors of $x$. See \tet{qflll} for
further details about the LLL implementation.

If $\fl=0$ (default), assume that $G$ has either exact (integral or
rational) or real floating point entries. The matrix is rescaled, converted
to integers and the behavior is then as in $\fl = 1$.

If $\fl=1$, assume that $G$ is integral. Computations involving Gram-Schmidt
vectors are approximate, with precision varying as needed (Lehmer's trick,
as generalized by Schnorr). Adapted from Nguyen and Stehl\'e's algorithm
and Stehl\'e's code (\kbd{fplll-1.3}).

$\fl=4$: $G$ has integer entries, gives the kernel and reduced image of $x$.

$\fl=5$: same as $4$, but $G$ may have polynomial coefficients.

The library syntax is \fun{GEN}{qflllgram0}{GEN G, long flag}.
Also available are \fun{GEN}{lllgram}{GEN G} ($\fl=0$),
\fun{GEN}{lllgramint}{GEN G} ($\fl=1$), and \fun{GEN}{lllgramkerim}{GEN G}
($\fl=4$).

\subsec{qfminim$(x,\{B\},\{m\},\{\fl=0\})$}\kbdsidx{qfminim}\label{se:qfminim}
$x$ being a square and symmetric matrix of dimension $d$ representing
a positive definite quadratic form, this function deals with the vectors of
$x$ whose norm is less than or equal to $B$, enumerated using the
Fincke-Pohst algorithm, storing at most $m$ pairs of vectors: only one
vector is given for each pair $\pm v$. There is no limit if $m$ is omitted:
beware that this may be a huge vector! The vectors are returned in no
particular order.

The function searches for the minimal nonzero vectors if $B$ is omitted.
The behavior is undefined if $x$ is not positive definite (a ``precision too
low'' error is most likely, although more precise error messages are
possible). The precise behavior depends on $\fl$.

\item If $\fl=0$ (default), return $[N, M, V]$, where $N$ is the number of
vectors enumerated (an even number, possibly larger than $2m$), $M \leq B$
is the maximum norm found, and $V$ is a matrix whose columns are found
vectors.

\item If $\fl=1$, ignore $m$ and return $[M,v]$, where $v$ is a nonzero
vector of length $M \leq B$. If no nonzero vector has length $\leq B$,
return $[]$. If no explicit $B$ is provided, return a vector of smallish
norm, namely the vector of smallest length (usually the first one but not
always) in an LLL-reduced basis for $x$.

In these two cases, $x$ must have integral \emph{small} entries: more
precisely, we definitely must have $d\cdot \|x\|_\infty^2 < 2^{53}$ but
even that may not be enough. The implementation uses low precision floating
point computations for maximal speed and gives incorrect results when $x$
has large entries. That condition is checked in the code and the routine
raises an error if large rounding errors occur. A more robust, but much
slower, implementation is chosen if the following flag is used:

\item If $\fl=2$, $x$ can have non integral real entries, but this is also
useful when $x$ has large integral entries. Return $[N, M, V]$ as in case
$\fl = 0$, where $M$ is returned as a floating point number. If $x$ is
inexact and $B$ is omitted, the ``minimal'' vectors in $V$ only have
approximately the same norm (up to the internal working accuracy).
This version is very robust but still offers no hard and fast guarantee
about the result: it involves floating point operations performed at a high
floating point precision depending on your input, but done without rigorous
tracking of roundoff errors (as would be provided by interval arithmetic for
instance). No example is known where the input is exact but the function
returns a wrong result.

\bprog
? x = matid(2);
? qfminim(x)  \\@com 4 minimal vectors of norm 1: $\pm[0,1]$, $\pm[1,0]$
%2 = [4, 1, [0, 1; 1, 0]]
? { x = \\ The Leech lattice
[4, 2, 0, 0, 0,-2, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1, 0,-1, 0, 0, 0,-2;
 2, 4,-2,-2, 0,-2, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0,-1, 0, 1,-1,-1;
 0,-2, 4, 0,-2, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 0, 0, 1,-1,-1, 0, 0;
 0,-2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1,-1, 0, 1,-1, 1, 0;
 0, 0,-2, 0, 4, 0, 0, 0, 1,-1, 0, 0, 1, 0, 0, 0,-2, 0, 0,-1, 1, 1, 0, 0;
-2, -2,0, 0, 0, 4,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,-1, 1, 1;
 0, 0, 0, 0, 0,-2, 4,-2, 0, 0, 0, 0, 0, 1, 0, 0, 0,-1, 0, 0, 0, 1,-1, 0;
 0, 0, 0, 0, 0, 0,-2, 4, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0,-1,-1,-1, 0, 1, 0;
 0, 0, 0, 0, 1,-1, 0, 0, 4, 0,-2, 0, 1, 1, 0,-1, 0, 1, 0, 0, 0, 0, 0, 0;
 0, 0, 0, 0,-1, 0, 0, 0, 0, 4, 0, 0, 1, 1,-1, 1, 0, 0, 0, 1, 0, 0, 1, 0;
 0, 0, 0, 0, 0, 0, 0, 0,-2, 0, 4,-2, 0,-1, 0, 0, 0,-1, 0,-1, 0, 0, 0, 0;
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 4,-1, 1, 0, 0,-1, 1, 0, 1, 1, 1,-1, 0;
 1, 0,-1, 1, 1, 0, 0,-1, 1, 1, 0,-1, 4, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1,-1;
-1,-1, 1,-1, 0, 0, 1, 0, 1, 1,-1, 1, 0, 4, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1;
 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 1, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0;
 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 1, 0, 4, 0, 0, 0, 0, 1, 1, 0, 0;
 0, 0, 1, 0,-2, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 4, 1, 1, 1, 0, 0, 1, 1;
 1, 0, 0, 1, 0, 0,-1, 0, 1, 0,-1, 1, 1, 0, 0, 0, 1, 4, 0, 1, 1, 0, 1, 0;
 0, 0, 0,-1, 0, 1, 0,-1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 4, 0, 1, 1, 0, 1;
-1, -1,1, 0,-1, 1, 0,-1, 0, 1,-1, 1, 0, 1, 0, 0, 1, 1, 0, 4, 0, 0, 1, 1;
 0, 0,-1, 1, 1, 0, 0,-1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 4, 1, 0, 1;
 0, 1,-1,-1, 1,-1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 4, 0, 1;
 0,-1, 0, 1, 0, 1,-1, 1, 0, 1, 0,-1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 4, 1;
-2,-1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 4]; }
? qfminim(x,,0)  \\ 0: don't store minimal vectors
time = 121 ms.
%4 = [196560, 4, [;]] \\ 196560 minimal vectors of norm 4
? qfminim(x)  \\ store all minimal vectors !
time = 821 ms.
? qfminim(x,,0,2); \\ safe algorithm. Slower and unnecessary here.
time = 5,540 ms.
%6 = [196560, 4.000061035156250000, [;]]
? qfminim(x,,,2); \\ safe algorithm; store all minimal vectors
time = 6,602 ms.
@eprog\noindent\sidx{Leech lattice}\sidx{minimal vector}
In this example, storing 0 vectors limits memory use; storing all of them
requires a \kbd{parisize} about 50MB. All minimal vectors are nevertheless
enumerated in both cases of course, which means the speedup is likely to be
marginal.

The library syntax is \fun{GEN}{qfminim0}{GEN x, GEN B = NULL, GEN m = NULL, long flag, long prec}.
Also available are
\fun{GEN}{minim}{GEN x, GEN B = NULL, GEN m = NULL} ($\fl=0$),
\fun{GEN}{minim2}{GEN x, GEN B = NULL, GEN m = NULL} ($\fl=1$).
\fun{GEN}{minim_raw}{GEN x, GEN B = NULL, GEN m = NULL} (do not perform LLL
reduction on x and return \kbd{NULL} on accuracy error).
\fun{GEN}{minim_zm}{GEN x, GEN B = NULL, GEN m = NULL} ($\fl=0$, return vectors as
\typ{VECSMALL} to save memory)

\subsec{qfminimize$(G)$}\kbdsidx{qfminimize}\label{se:qfminimize}
Given a square symmetric matrix $G$ with rational coefficients, and
non-zero determinant, of dimension $n \geq 1$, return \kbd{[H,U]} such that
\kbd{H = c*U\til*G*U} for some rational $c$, and $H$ integral with minimal
determinant. The coefficients of $U$ are usually nonintegral.
\bprog
? G = matdiagonal([650, -104329, -104329]);
? [H,U]=qfminimize(G); H
%2 = [-1,0,0;0,-1,0;0,0,1]
? U
%3 = [0,0,1/5;5/323,-1/323,0;-1/323,-5/323,0]
? U~*G*U
%4 = [-26,0,0;0,-26,0;0,0,26]
@eprog
Hence $c = 26$ in this example.

The library syntax is \fun{GEN}{qfminimize}{GEN G}.

\subsec{qfnorm$(x,\{q\})$}\kbdsidx{qfnorm}\label{se:qfnorm}
This function is obsolete, use \kbd{qfeval}.

The library syntax is \fun{GEN}{qfnorm}{GEN x, GEN q = NULL}.

\subsec{qforbits$(G,V)$}\kbdsidx{qforbits}\label{se:qforbits}
Return the orbits of $V$ under the action of the group
of linear transformation generated by the set $G$.
It is assumed that $G$ contains minus identity, and only one vector
in $\{v, -v\}$ should be given.
If $G$ does not stabilize $V$, the function return $0$.

In the example below, we compute representatives and lengths of the orbits of
the vectors of norm $\leq 3$ under the automorphisms of the lattice $\Z^6$.
\bprog
?  Q=matid(6); G=qfauto(Q); V=qfminim(Q,3);
?  apply(x->[x[1],#x],qforbits(G,V))
%2 = [[[0,0,0,0,0,1]~,6],[[0,0,0,0,1,-1]~,30],[[0,0,0,1,-1,-1]~,80]]
@eprog

The library syntax is \fun{GEN}{qforbits}{GEN G, GEN V}.

\subsec{qfparam$(G, \var{sol}, \{\fl = 0\})$}\kbdsidx{qfparam}\label{se:qfparam}
Coefficients of binary quadratic forms that parametrize the
solutions of the ternary quadratic form $G$, using the particular
solution~\var{sol}.
\fl{} is optional and can be 1, 2, or 3, in which case the \fl-th form is
reduced. The default is \fl=0 (no reduction).
\bprog
? G = [1,0,0;0,1,0;0,0,-34];
? M = qfparam(G, qfsolve(G))
%2 =
[ 3 -10 -3]

[-5  -6  5]

[ 1   0  1]
@eprog
Indeed, the solutions can be parametrized as
$$(3x^2 - 10xy - 3y^2)^2  + (-5x^2 - 6xy + 5y^2)^2 -34(x^2 + y^2)^2 = 0.$$
\bprog
? v = y^2 * M*[1,x/y,(x/y)^2]~
%3 = [3*x^2 - 10*y*x - 3*y^2, -5*x^2 - 6*y*x + 5*y^2, -x^2 - y^2]~
? v~*G*v
%4 = 0
@eprog

The library syntax is \fun{GEN}{qfparam}{GEN G, GEN sol, long flag}.

\subsec{qfperfection$(G)$}\kbdsidx{qfperfection}\label{se:qfperfection}
$G$ being a square and symmetric matrix with integer entries
representing a positive definite quadratic form, outputs the perfection rank
of the form. That is, gives the rank of the family of the $s$ symmetric
matrices $vv^t$, where $v$ runs through the minimal vectors.

A form is perfect if and only if its perfection rank is $d(d+1)/2$ where
$d$ is the dimension of $G$.

The algorithm computes the minimal vectors and its runtime is exponential
in $d$.

The library syntax is \fun{GEN}{qfperfection}{GEN G}.

\subsec{qfrep$(q,B,\{\fl=0\})$}\kbdsidx{qfrep}\label{se:qfrep}
$q$ being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, count the vectors representing successive
integers.

\item If $\fl = 0$, count all vectors. Outputs the vector whose $i$-th
entry, $1 \leq i \leq B$ is half the number of vectors $v$ such that $q(v)=i$.

\item If $\fl = 1$, count vectors of even norm. Outputs the vector
whose $i$-th entry, $1 \leq i \leq B$ is half the number of vectors such
that $q(v) = 2i$.

\bprog
? q = [2, 1; 1, 3];
? qfrep(q, 5)
%2 = Vecsmall([0, 1, 2, 0, 0]) \\ 1 vector of norm 2, 2 of norm 3, etc.
? qfrep(q, 5, 1)
%3 = Vecsmall([1, 0, 0, 1, 0]) \\ 1 vector of norm 2, 0 of norm 4, etc.
@eprog\noindent
This routine uses a naive algorithm based on \tet{qfminim}, and
will fail if any entry becomes larger than $2^{31}$ (or $2^{63}$).

The library syntax is \fun{GEN}{qfrep0}{GEN q, GEN B, long flag}.

\subsec{qfsign$(x)$}\kbdsidx{qfsign}\label{se:qfsign}
Returns $[p,m]$ the signature of the quadratic form represented by the
symmetric matrix $x$. Namely, $p$ (resp.~$m$) is the number of positive
(resp.~negative) eigenvalues of $x$. The result is computed using Gaussian
reduction.

The library syntax is \fun{GEN}{qfsign}{GEN x}.

\subsec{qfsolve$(G)$}\kbdsidx{qfsolve}\label{se:qfsolve}
Given a square symmetric matrix $G$ of dimension $n \geq 1$, solve over
$\Q$ the quadratic equation $X^tGX = 0$. The matrix $G$ must have rational
coefficients. The solution might be a single nonzero column vector
(\typ{COL}) or a matrix (whose columns generate a totally isotropic
subspace).

If no solution exists, returns an integer, that can be a prime $p$ such that
there is no local solution at $p$, or $-1$ if there is no real solution,
or $-2$ if $n = 2$ and $-\det G$ is not a square (which implies there is a
real solution, but no local solution at some $p$ dividing $\det G$).
\bprog
? G = [1,0,0;0,1,0;0,0,-34];
? qfsolve(G)
%1 = [-3, -5, 1]~
? qfsolve([1,0; 0,2])
%2 = -1   \\ no real solution
? qfsolve([1,0,0;0,3,0; 0,0,-2])
%3 = 3    \\ no solution in Q_3
? qfsolve([1,0; 0,-2])
%4 = -2   \\ no solution, n = 2
@eprog

The library syntax is \fun{GEN}{qfsolve}{GEN G}.

\subsec{setbinop$(f,X,\{Y\})$}\kbdsidx{setbinop}\label{se:setbinop}
The set whose elements are the f(x,y), where x,y run through X,Y.
respectively. If $Y$ is omitted, assume that $X = Y$ and that $f$ is symmetric:
$f(x,y) = f(y,x)$ for all $x,y$ in $X$.
\bprog
? X = [1,2,3]; Y = [2,3,4];
? setbinop((x,y)->x+y, X,Y) \\ set X + Y
%2 = [3, 4, 5, 6, 7]
? setbinop((x,y)->x-y, X,Y) \\ set X - Y
%3 = [-3, -2, -1, 0, 1]
? setbinop((x,y)->x+y, X)   \\ set 2X = X + X
%2 = [2, 3, 4, 5, 6]
@eprog

The library syntax is \fun{GEN}{setbinop}{GEN f, GEN X, GEN Y = NULL}.

\subsec{setdelta$(x,y)$}\kbdsidx{setdelta}\label{se:setdelta}
Symmetric difference of the two sets $x$ and $y$ (see \kbd{setisset}).
If $x$ or $y$ is not a set, the result is undefined.

The library syntax is \fun{GEN}{setdelta}{GEN x, GEN y}.

\subsec{setintersect$(x,y)$}\kbdsidx{setintersect}\label{se:setintersect}
Intersection of the two sets $x$ and $y$ (see \kbd{setisset}).
If $x$ or $y$ is not a set, the result is undefined.

The library syntax is \fun{GEN}{setintersect}{GEN x, GEN y}.

\subsec{setisset$(x)$}\kbdsidx{setisset}\label{se:setisset}
Returns true (1) if $x$ is a set, false (0) if
not. In PARI, a set is a row vector whose entries are strictly
increasing with respect to a (somewhat arbitrary) universal comparison
function. To convert any object into a set (this is most useful for
vectors, of course), use the function \kbd{Set}.
\bprog
? a = [3, 1, 1, 2];
? setisset(a)
%2 = 0
? Set(a)
%3 = [1, 2, 3]
@eprog

The library syntax is \fun{long}{setisset}{GEN x}.

\subsec{setminus$(x,y)$}\kbdsidx{setminus}\label{se:setminus}
Difference of the two sets $x$ and $y$ (see \kbd{setisset}),
i.e.~set of elements of $x$ which do not belong to $y$.
If $x$ or $y$ is not a set, the result is undefined.

The library syntax is \fun{GEN}{setminus}{GEN x, GEN y}.

\subsec{setsearch$(S,x,\{\fl=0\})$}\kbdsidx{setsearch}\label{se:setsearch}
Determines whether $x$ belongs to the set $S$ (see \kbd{setisset}).

We first describe the default behavior, when $\fl$ is zero or omitted. If $x$
belongs to the set $S$, returns the index $j$ such that $S[j]=x$, otherwise
returns 0.
\bprog
? T = [7,2,3,5]; S = Set(T);
? setsearch(S, 2)
%2 = 1
? setsearch(S, 4)      \\ not found
%3 = 0
? setsearch(T, 7)      \\ search in a randomly sorted vector
%4 = 0 \\ WRONG !
@eprog\noindent
If $S$ is not a set, we also allow sorted lists with
respect to the \tet{cmp} sorting function, without repeated entries,
as per \tet{listsort}$(L,1)$; otherwise the result is undefined.
\bprog
? L = List([1,4,2,3,2]); setsearch(L, 4)
%1 = 0 \\ WRONG !
? listsort(L, 1); L    \\ sort L first
%2 = List([1, 2, 3, 4])
? setsearch(L, 4)
%3 = 4                 \\ now correct
@eprog\noindent
If $\fl$ is nonzero, this function returns the index $j$ where $x$ should be
inserted, and $0$ if it already belongs to $S$. This is meant to be used for
dynamically growing (sorted) lists, in conjunction with \kbd{listinsert}.
\bprog
? L = List([1,5,2,3,2]); listsort(L,1); L
%1 = List([1,2,3,5])
? j = setsearch(L, 4, 1)  \\ 4 should have been inserted at index j
%2 = 4
? listinsert(L, 4, j); L
%3 = List([1, 2, 3, 4, 5])
@eprog

The library syntax is \fun{long}{setsearch}{GEN S, GEN x, long flag}.

\subsec{setunion$(x,y)$}\kbdsidx{setunion}\label{se:setunion}
Union of the two sets $x$ and $y$ (see \kbd{setisset}).
If $x$ or $y$ is not a set, the result is undefined.

The library syntax is \fun{GEN}{setunion}{GEN x, GEN y}.

\subsec{snfrank$(D,q)$}\kbdsidx{snfrank}\label{se:snfrank}
Assuming that $D$ is a Smith normal form
(i.e. vector of elementary divisors) for some module and $q$ a power of an
irreducible element or $0$, return the minimal number of generators for
$D/qD$. For instance, if $q=p^n$ where $p$ is a prime number, this is the
dimension of $(p^{n-1}D)/p^nD$ as an $\F_p$-vector space.

\bprog
? snfrank([4,4,2], 2)
%1 = 3
? snfrank([4,4,2], 4)
%2 = 2
? snfrank([4,4,2], 8)
%3 = 0
? snfrank([4,4,2], 0)
%4 = 3
@eprog\noindent The function also works for $K[x]$-modules:
\bprog
? D=matsnf([-x-5,-1,-1,0; 0,x^2+10*x+26,-1,-x-5; 1,-x-5,-x-5,1; -1,0,0,1]);
? snfrank(D, x^2 + 10*x + 27)
%6 = 2
? A=matdiagonal([x-1,x^2+1,x-1,(x^2+1)^2,x,(x-1)^2]); D=matsnf(A);
? snfrank(D,x-1)
%8 = 3
? snfrank(D,(x-1)^2)
%9 = 1
? snfrank(D,(x-1)^3)
%9 = 0
? snfrank(D,x^2+1)
%10 = 2
@eprog\noindent Finally this function supports any output from \kbd{matsnf}
(e.g., with transformation matrices included, with or without cleanup).

The library syntax is \fun{long}{snfrank}{GEN D, GEN q}.

\subsec{trace$(x)$}\kbdsidx{trace}\label{se:trace}
This applies to quite general $x$. If $x$ is not a
matrix, it is equal to the sum of $x$ and its conjugate, except for polmods
where it is the trace as an algebraic number.

For $x$ a square matrix, it is the ordinary trace. If $x$ is a
nonsquare matrix (but not a vector), an error occurs.

The library syntax is \fun{GEN}{gtrace}{GEN x}.

\subsec{vecextract$(x,y,\{z\})$}\kbdsidx{vecextract}\label{se:vecextract}
Extraction of components of the vector or matrix $x$ according to $y$.
In case $x$ is a matrix, its components are the \emph{columns} of $x$. The
parameter $y$ is a component specifier, which is either an integer, a string
describing a range, or a vector.

If $y$ is an integer, it is considered as a mask: the binary bits of $y$ are
read from right to left, but correspond to taking the components from left to
right. For example, if $y=13=(1101)_2$ then the components 1,3 and 4 are
extracted.

If $y$ is a vector (\typ{VEC}, \typ{COL} or \typ{VECSMALL}), which must have
integer entries, these entries correspond to the component numbers to be
extracted, in the order specified.

If $y$ is a string, it can be

\item a single (nonzero) index giving a component number (a negative
index means we start counting from the end).

\item a range of the form \kbd{"$a$..$b$"}, where $a$ and $b$ are
indexes as above. Any of $a$ and $b$ can be omitted; in this case, we take
as default values $a = 1$ and $b = -1$, i.e.~ the first and last components
respectively. We then extract all components in the interval $[a,b]$, in
reverse order if $b < a$.

In addition, if the first character in the string is \kbd{\pow}, the
complement of the given set of indices is taken.

If $z$ is not omitted, $x$ must be a matrix. $y$ is then the \emph{row}
specifier, and $z$ the \emph{column} specifier, where the component specifier
is as explained above.

\bprog
? v = [a, b, c, d, e];
? vecextract(v, 5)         \\@com mask
%1 = [a, c]
? vecextract(v, [4, 2, 1]) \\@com component list
%2 = [d, b, a]
? vecextract(v, "2..4")    \\@com interval
%3 = [b, c, d]
? vecextract(v, "-1..-3")  \\@com interval + reverse order
%4 = [e, d, c]
? vecextract(v, "^2")      \\@com complement
%5 = [a, c, d, e]
? vecextract(matid(3), "2..", "..")
%6 =
[0 1 0]

[0 0 1]
@eprog
The range notations \kbd{v[i..j]} and \kbd{v[\pow i]} (for \typ{VEC} or
\typ{COL}) and \kbd{M[i..j, k..l]} and friends (for \typ{MAT}) implement a
subset of the above, in a simpler and \emph{faster} way, hence should be
preferred in most common situations. The following features are not
implemented in the range notation:

\item reverse order,

\item omitting either $a$ or $b$ in \kbd{$a$..$b$}.

The library syntax is \fun{GEN}{extract0}{GEN x, GEN y, GEN z = NULL}.

\subsec{vecprod$(v)$}\kbdsidx{vecprod}\label{se:vecprod}
Return the product of the components of the vector $v$. Return $1$ on an
empty vector.
\bprog
? vecprod([1,2,3])
%1 = 6
? vecprod([])
%2 = 1
@eprog

The library syntax is \fun{GEN}{vecprod}{GEN v}.

\subsec{vecsearch$(v,x,\{\var{cmpf}\})$}\kbdsidx{vecsearch}\label{se:vecsearch}
Determines whether $x$ belongs to the sorted vector or list $v$: return
the (positive) index where $x$ was found, or $0$ if it does not belong to
$v$.

If the comparison function cmpf is omitted, we assume that $v$ is sorted in
increasing order, according to the standard comparison function \kbd{lex},
thereby restricting the possible types for $x$ and the elements of $v$
(integers, fractions, reals, and vectors of such). We also transparently
allow a \typ{VECSMALL} $x$ in this case, for the natural ordering of the
integers.

If \kbd{cmpf} is present, it is understood as a comparison function and we
assume that $v$ is sorted according to it, see \tet{vecsort} for how to
encode comparison functions.
\bprog
? v = [1,3,4,5,7];
? vecsearch(v, 3)
%2 = 2
? vecsearch(v, 6)
%3 = 0 \\ not in the list
? vecsearch([7,6,5], 5) \\ unsorted vector: result undefined
%4 = 0
@eprog\noindent Note that if we are sorting with respect to a key
which is expensive to compute (e.g. a discriminant), one should rather
precompute all keys, sort that vector and search in the vector of keys,
rather than searching in the original vector with respect to a comparison
function.

By abuse of notation, $x$ is also allowed to be a matrix, seen as a vector
of its columns; again by abuse of notation, a \typ{VEC} is considered
as part of the matrix, if its transpose is one of the matrix columns.
\bprog
? v = vecsort([3,0,2; 1,0,2]) \\ sort matrix columns according to lex order
%1 =
[0 2 3]

[0 2 1]
? vecsearch(v, [3,1]~)
%2 = 3
? vecsearch(v, [3,1])  \\ can search for x or x~
%3 = 3
? vecsearch(v, [1,2])
%4 = 0 \\ not in the list
@eprog\noindent

The library syntax is \fun{long}{vecsearch}{GEN v, GEN x, GEN cmpf = NULL}.

\subsec{vecsort$(x,\{\var{cmpf}\},\{\fl=0\})$}\kbdsidx{vecsort}\label{se:vecsort}
Sorts the vector $x$ in ascending order, using a mergesort method.
$x$ must be a list, vector or matrix (seen as a vector of its columns).
Note that mergesort is stable, hence the initial ordering of ``equal''
entries (with respect to the sorting criterion) is not changed.

If \kbd{cmpf} is omitted, we use the standard comparison function
\kbd{lex}, thereby restricting the possible types for the elements of $x$
(integers, fractions or reals and vectors of those). We also transparently
allow a \typ{VECSMALL} $x$ in this case, for the standard ordering on the
integers.

If \kbd{cmpf} is present, it is understood as a comparison function and we
sort according to it. The following possibilities exist:

\item an integer $k$: sort according to the value of the $k$-th
subcomponents of the components of~$x$.

\item a vector: sort lexicographically according to the components listed in
the vector. For example, if $\kbd{cmpf}=\kbd{[2,1,3]}$, sort with respect to
the second component, and when these are equal, with respect to the first,
and when these are equal, with respect to the third.

\item a comparison function: \typ{CLOSURE} with two arguments $x$ and $y$,
and returning a real number which is $<0$, $>0$ or $=0$ if $x<y$, $x>y$ or
$x=y$ respectively.

\item a key: \typ{CLOSURE} with one argument $x$ and returning
the value $f(x)$ with respect to which we sort.

\bprog
? vecsort([3,0,2; 1,0,2]) \\ sort columns according to lex order
%1 =
[0 2 3]

[0 2 1]
? vecsort(v, (x,y)->y-x)            \\@com reverse sort
? vecsort(v, (x,y)->abs(x)-abs(y))  \\@com sort by increasing absolute value
? vecsort(v, abs)  \\@com sort by increasing absolute value, using key
? cmpf(x,y) = my(dx = poldisc(x), dy = poldisc(y)); abs(dx) - abs(dy);
? v = [x^2+1, x^3-2, x^4+5*x+1] vecsort(v, cmpf) \\@com comparison function
? vecsort(v, x->abs(poldisc(x)))  \\@com key
@eprog\noindent
The \kbd{abs} and \kbd{cmpf} examples show how to use a named function
instead of an anonymous function. It is preferable to use a \var{key}
whenever possible rather than include it in the comparison function as above
since the key is evaluated $O(n)$ times instead of $O(n\log n)$,
where $n$ is the number of entries.

A direct approach is also possible and equivalent to using a sorting key:
\bprog
? T = [abs(poldisc(x)) | x<-v];
? perm = vecsort(T,,1); \\@com indirect sort
? vecextract(v, perm)
@eprog\noindent This also provides the vector $T$ of all keys, which is
interesting for instance in later \tet{vecsearch} calls: it is more
efficient to sort $T$ (\kbd{T = vecextract(T, perm)}) then search for a key
in $T$ rather than to search in $v$ using a comparison function or a key.
Note also that \tet{mapisdefined} is often easier to use and faster than
\kbd{vecsearch}.

\noindent The binary digits of \fl\ mean:

\item 1: indirect sorting of the vector $x$, i.e.~if $x$ is an
$n$-component vector, returns a permutation of $[1,2,\dots,n]$ which
applied to the components of $x$ sorts $x$ in increasing order.
For example, \kbd{vecextract(x, vecsort(x,,1))} is equivalent to
\kbd{vecsort(x)}.

\item 4: use descending instead of ascending order.

\item 8: remove ``duplicate'' entries with respect to the sorting function
(keep the first occurring entry).  For example:
\bprog
  ? vecsort([Pi,Mod(1,2),z], (x,y)->0, 8)   \\@com make everything compare equal
  %1 = [3.141592653589793238462643383]
  ? vecsort([[2,3],[0,1],[0,3]], 2, 8)
  %2 = [[0, 1], [2, 3]]
@eprog

The library syntax is \fun{GEN}{vecsort0}{GEN x, GEN cmpf = NULL, long flag}.

\subsec{vecsum$(v)$}\kbdsidx{vecsum}\label{se:vecsum}
Return the sum of the components of the vector $v$. Return $0$ on an
empty vector.
\bprog
? vecsum([1,2,3])
%1 = 6
? vecsum([])
%2 = 0
@eprog

The library syntax is \fun{GEN}{vecsum}{GEN v}.

\subsec{vector$(n,\{X\},\{\var{expr}=0\})$}\kbdsidx{vector}\label{se:vector}
Creates a row vector (type
\typ{VEC}) with $n$ components whose components are the expression
\var{expr} evaluated at the integer points between 1 and $n$. If the last
two arguments are omitted, fills the vector with zeroes.
\bprog
? vector(3,i, 5*i)
%1 = [5, 10, 15]
? vector(3)
%2 = [0, 0, 0]
@eprog

The variable $X$ is lexically scoped to each evaluation of \var{expr}.  Any
change to $X$ within \var{expr} does not affect subsequent evaluations, it
still runs 1 to $n$.  A local change allows for example different indexing:
\bprog
vector(10, i, i=i-1; f(i)) \\ i = 0, ..., 9
vector(10, i, i=2*i; f(i)) \\ i = 2, 4, ..., 20
@eprog\noindent
This per-element scope for $X$ differs from \kbd{for} loop evaluations,
as the following example shows:
\bprog
n = 3
v = vector(n); vector(n, i, i++)            ----> [2, 3, 4]
v = vector(n); for (i = 1, n, v[i] = i++)   ----> [2, 0, 4]
@eprog\noindent
%\syn{NO}

\subsec{vectorsmall$(n,\{X\},\{\var{expr}=0\})$}\kbdsidx{vectorsmall}\label{se:vectorsmall}
Creates a row vector of small integers (type \typ{VECSMALL}) with $n$
components whose components are the expression \var{expr} evaluated at the
integer points between 1 and $n$.
%\syn{NO}

\subsec{vectorv$(n,\{X\},\{\var{expr}=0\})$}\kbdsidx{vectorv}\label{se:vectorv}
As \tet{vector}, but returns a column vector (type \typ{COL}).
%\syn{NO}

\section{Transcendental functions}\label{se:trans}

Since the values of transcendental functions cannot be exactly represented,
these functions will always return an inexact object: a real number,
a complex number, a $p$-adic number or a power series.  All these objects
have a certain finite precision.

As a general rule, which of course in some cases may have exceptions,
transcendental functions operate in the following way:

\item If the argument is either a real number or an inexact complex number
(like \kbd{1.0 + I} or \kbd{Pi*I} but not \kbd{2 - 3*I}), then the
computation is done with the precision of the argument.
In the example below, we see that changing the precision to $50$ digits does
not matter, because $x$ only had a precision of $19$ digits.
\bprog
? \p 15
   realprecision = 19 significant digits (15 digits displayed)
? x = Pi/4
%1 = 0.785398163397448
? \p 50
   realprecision = 57 significant digits (50 digits displayed)
? sin(x)
%2 = 0.7071067811865475244
@eprog

Note that even if the argument is real, the result may be complex
(e.g.~$\text{acos}(2.0)$ or $\text{acosh}(0.0)$). See each individual
function help for the definition of the branch cuts and choice of principal
value.

\item If the argument is either an integer, a rational, an exact complex
number or a quadratic number, it is first converted to a real
or complex number using the current \idx{precision}, which can be
view and manipulated using the defaults \tet{realprecision} (in decimal
digits) or \tet{realbitprecision} (in bits). This precision can be changed
indifferently

\item in decimal digits: use \b{p} or \kbd{default(realprecision,...)}.

\item in bits: use \b{pb} or \kbd{default(realbitprecision,...)}.

After this conversion, the computation proceeds as above for real or complex
arguments.

In library mode, the \kbd{realprecision} does not matter; instead the
precision is taken from the \kbd{prec} parameter which every transcendental
function has. As in \kbd{gp}, this \kbd{prec} is not used when the argument
to a function is already inexact. Note that the argument \var{prec} stands
for the length in words of a real number, including codewords. Hence we must
have $\var{prec} \geq 3$. (Some functions allow a \kbd{bitprec} argument
instead which allow finer granularity.)

Some accuracies attainable on 32-bit machines cannot be attained
on 64-bit machines for parity reasons. For example the default \kbd{gp} accuracy
is 28 decimal digits on 32-bit machines, corresponding to \var{prec} having
the value 5, but this cannot be attained on 64-bit machines.

\item If the argument is a polmod (representing an algebraic number),
then the function is evaluated for every possible complex embedding of that
algebraic number.  A column vector of results is returned, with one component
for each complex embedding.  Therefore, the number of components equals
the degree of the \typ{POLMOD} modulus.

\item If the argument is an intmod or a $p$-adic, at present only a
few functions like \kbd{sqrt} (square root), \kbd{sqr} (square), \kbd{log},
\kbd{exp}, powering, \kbd{teichmuller} (Teichm\"uller character) and
\kbd{agm} (arithmetic-geometric mean) are implemented.

Note that in the case of a $2$-adic number, $\kbd{sqr}(x)$ may not be
identical to $x*x$: for example if $x = 1+O(2^5)$ and $y = 1+O(2^5)$ then
$x*y = 1+O(2^5)$ while $\kbd{sqr}(x) = 1+O(2^6)$. Here, $x * x$ yields the
same result as $\kbd{sqr}(x)$ since the two operands are known to be
\emph{identical}. The same statement holds true for $p$-adics raised to the
power $n$, where $v_p(n) > 0$.

\misctitle{Remark} If we wanted to be strictly consistent with
the PARI philosophy, we should have $x*y = (4 \mod 8)$ and $\kbd{sqr}(x) =
(4 \mod 32)$ when both $x$ and $y$ are congruent to $2$ modulo $4$.
However, since intmod is an exact object, PARI assumes that the modulus
must not change, and the result is hence $(0\, \mod\, 4)$ in both cases. On
the other hand, $p$-adics are not exact objects, hence are treated
differently.

\item If the argument is a polynomial, a power series or a rational function,
it is, if necessary, first converted to a power series using the current
series precision, held in the default \tet{seriesprecision}. This precision
(the number of significant terms) can be changed using \b{ps} or
\kbd{default(seriesprecision,...)}. Then the Taylor series expansion of the
function around $X=0$ (where $X$ is the main variable) is computed to a
number of terms depending on the number of terms of the argument and the
function being computed.

Under \kbd{gp} this again is transparent to the user. When programming in
library mode, however, it is \emph{strongly} advised to perform an explicit
conversion to a power series first, as in
\bprog
  x = gtoser(x, gvar(x), seriesprec)
@eprog\noindent
where the number of significant terms \kbd{seriesprec} can be specified
explicitly. If you do not do this, a global variable \kbd{precdl} is used
instead, to convert polynomials and rational functions to a power series with
a reasonable number of terms; tampering with the value of this global
variable is \emph{deprecated} and strongly discouraged.

\item If the argument is a vector or a matrix, the result is the
componentwise evaluation of the function. In particular, transcendental
functions on square matrices, which are not implemented in the present
version \vers, will have a different name if they are implemented some day.

\subsec{Catalan}\kbdsidx{Catalan}\label{se:Catalan}
Catalan's constant $G = \sum_{n>=0}\dfrac{(-1)^n}{(2n+1)^2}=0.91596\cdots$.
Note that \kbd{Catalan} is one of the few reserved names which cannot be
used for user variables.

The library syntax is \fun{GEN}{mpcatalan}{long prec}.

\subsec{Euler}\kbdsidx{Euler}\label{se:Euler}
Euler's constant $\gamma=0.57721\cdots$. Note that
\kbd{Euler} is one of the few reserved names which cannot be used for
user variables.

The library syntax is \fun{GEN}{mpeuler}{long prec}.

\subsec{I}\kbdsidx{I}\label{se:I}
The complex number $\sqrt{-1}$.

The library syntax is \fun{GEN}{gen_I}{}.

\subsec{Pi}\kbdsidx{Pi}\label{se:Pi}
The constant $\pi$ ($3.14159\cdots$). Note that \kbd{Pi} is one of the few
reserved names which cannot be used for user variables.

The library syntax is \fun{GEN}{mppi}{long prec}.

\subsec{abs$(x)$}\kbdsidx{abs}\label{se:abs}
Absolute value of $x$ (modulus if $x$ is complex).
Rational functions are not allowed. Contrary to most transcendental
functions, an exact argument is \emph{not} converted to a real number before
applying \kbd{abs} and an exact result is returned if possible.
\bprog
? abs(-1)
%1 = 1
? abs(3/7 + 4/7*I)
%2 = 5/7
? abs(1 + I)
%3 = 1.414213562373095048801688724
@eprog\noindent
If $x$ is a polynomial, returns $-x$ if the leading coefficient is
real and negative else returns $x$. For a power series, the constant
coefficient is considered instead.

The library syntax is \fun{GEN}{gabs}{GEN x, long prec}.

\subsec{acos$(x)$}\kbdsidx{acos}\label{se:acos}
Principal branch of $\cos^{-1}(x) = -i \log (x + i\sqrt{1-x^2})$.
In particular, $\Re(\text{acos}(x))\in [0,\pi]$ and if $x\in \R$ and $|x|>1$,
then $\text{acos}(x)$ is complex. The branch cut is in two pieces:
$]-\infty,-1]$ , continuous with quadrant II, and $[1,+\infty[$, continuous
with quadrant IV. We have $\text{acos}(x) = \pi/2 - \text{asin}(x)$ for all
$x$.

The library syntax is \fun{GEN}{gacos}{GEN x, long prec}.

\subsec{acosh$(x)$}\kbdsidx{acosh}\label{se:acosh}
Principal branch of $\cosh^{-1}(x) = 2
 \log(\sqrt{(x+1)/2} + \sqrt{(x-1)/2})$. In particular,
$\Re(\text{acosh}(x))\geq 0$ and
$\Im(\text{acosh}(x))\in ]-\pi,\pi]$; if $x\in \R$ and $x<1$, then
$\text{acosh}(x)$ is complex.

The library syntax is \fun{GEN}{gacosh}{GEN x, long prec}.

\subsec{agm$(x,y)$}\kbdsidx{agm}\label{se:agm}
Arithmetic-geometric mean of $x$ and $y$. In the
case of complex or negative numbers, the optimal AGM is returned
(the largest in absolute value over all choices of the signs of the square
roots).  $p$-adic or power series arguments are also allowed. Note that
a $p$-adic agm exists only if $x/y$ is congruent to 1 modulo $p$ (modulo
16 for $p=2$). $x$ and $y$ cannot both be vectors or matrices.

The library syntax is \fun{GEN}{agm}{GEN x, GEN y, long prec}.

\subsec{airy$(z)$}\kbdsidx{airy}\label{se:airy}
Airy $[Ai,Bi]$ functions of argument $z$.
\bprog
? [A,B] = airy(1);
? A
%2 = 0.13529241631288141552414742351546630617
? B
%3 = 1.2074235949528712594363788170282869954
@eprog\noindent

The library syntax is \fun{GEN}{airy}{GEN z, long prec}.

\subsec{arg$(x)$}\kbdsidx{arg}\label{se:arg}
Argument of the complex number $x$, such that $-\pi < \arg(x) \le \pi$.

The library syntax is \fun{GEN}{garg}{GEN x, long prec}.

\subsec{asin$(x)$}\kbdsidx{asin}\label{se:asin}
Principal branch of $\sin^{-1}(x) = -i \log(ix + \sqrt{1 - x^2})$.
In particular, $\Re(\text{asin}(x))\in [-\pi/2,\pi/2]$ and if $x\in \R$ and
$|x|>1$ then $\text{asin}(x)$ is complex. The branch cut is in two pieces:
$]-\infty,-1]$, continuous with quadrant II, and $[1,+\infty[$ continuous
with quadrant IV. The function satisfies $i \text{asin}(x) =
\text{asinh}(ix)$.

The library syntax is \fun{GEN}{gasin}{GEN x, long prec}.

\subsec{asinh$(x)$}\kbdsidx{asinh}\label{se:asinh}
Principal branch of $\sinh^{-1}(x) = \log(x + \sqrt{1+x^2})$. In
particular $\Im(\text{asinh}(x))\in [-\pi/2,\pi/2]$.
The branch cut is in two pieces: $]-i \infty ,-i]$, continuous with quadrant
III and $[+i,+i \infty[$, continuous with quadrant I.

The library syntax is \fun{GEN}{gasinh}{GEN x, long prec}.

\subsec{atan$(x)$}\kbdsidx{atan}\label{se:atan}
Principal branch of $\text{tan}^{-1}(x) = \log ((1+ix)/(1-ix)) /
2i$. In particular the real part of $\text{atan}(x)$ belongs to
$]-\pi/2,\pi/2[$.
The branch cut is in two pieces:
$]-i\infty,-i[$, continuous with quadrant IV, and $]i,+i \infty[$ continuous
with quadrant II. The function satisfies $\text{atan}(x) =
-i\text{atanh}(ix)$ for all $x\neq \pm i$.

The library syntax is \fun{GEN}{gatan}{GEN x, long prec}.

\subsec{atanh$(x)$}\kbdsidx{atanh}\label{se:atanh}
Principal branch of $\text{tanh}^{-1}(x) = \log ((1+x)/(1-x)) / 2$. In
particular the imaginary part of $\text{atanh}(x)$ belongs to
$[-\pi/2,\pi/2]$; if $x\in \R$ and $|x|>1$ then $\text{atanh}(x)$ is complex.

The library syntax is \fun{GEN}{gatanh}{GEN x, long prec}.

\subsec{besselh1$(\var{nu},x)$}\kbdsidx{besselh1}\label{se:besselh1}
$H^1$-Bessel function of index \var{nu} and argument $x$.

The library syntax is \fun{GEN}{hbessel1}{GEN nu, GEN x, long prec}.

\subsec{besselh2$(\var{nu},x)$}\kbdsidx{besselh2}\label{se:besselh2}
$H^2$-Bessel function of index \var{nu} and argument $x$.

The library syntax is \fun{GEN}{hbessel2}{GEN nu, GEN x, long prec}.

\subsec{besseli$(\var{nu},x)$}\kbdsidx{besseli}\label{se:besseli}
$I$-Bessel function of index \var{nu} and
argument $x$. If $x$ converts to a power series, the initial factor
$(x/2)^\nu/\Gamma(\nu+1)$ is omitted (since it cannot be represented in PARI
when $\nu$ is not integral).

The library syntax is \fun{GEN}{ibessel}{GEN nu, GEN x, long prec}.

\subsec{besselj$(\var{nu},x)$}\kbdsidx{besselj}\label{se:besselj}
$J$-Bessel function of index \var{nu} and
argument $x$. If $x$ converts to a power series, the initial factor
$(x/2)^\nu/\Gamma(\nu+1)$ is omitted (since it cannot be represented in PARI
when $\nu$ is not integral).

The library syntax is \fun{GEN}{jbessel}{GEN nu, GEN x, long prec}.

\subsec{besseljh$(n,x)$}\kbdsidx{besseljh}\label{se:besseljh}
$J$-Bessel function of half integral index.
More precisely, $\kbd{besseljh}(n,x)$ computes $J_{n+1/2}(x)$ where $n$
must be of type integer, and $x$ is any element of $\C$. In the
present version \vers, this function is not very accurate when $x$ is small.

The library syntax is \fun{GEN}{jbesselh}{GEN n, GEN x, long prec}.

\subsec{besseljzero$(\var{nu},\{k=1\})$}\kbdsidx{besseljzero}\label{se:besseljzero}
$k$-th zero of the $J$-Bessel function of index \var{nu}, close
to $\pi(\nu/2 + k - 1/4)$, usually noted $j_{\nu,k}$.
\bprog
? besseljzero(0) \\ @com{first zero of $J_0$}
%1 = 2.4048255576957727686216318793264546431
? besselj(0, %)
%2 = 7.1951595399463653939930598011247182898 E-41
? besseljzero(0, 2) \\ @com{second zero}
%3 = 5.5200781102863106495966041128130274252
? besseljzero(I) \\ @com{also works for complex orders, here $J_i$}
%4 = 2.5377... + 1.4753...*I
@eprog\noindent The function uses a Newton iteration due to Temme.
If $\nu$ is real and nonnegative, the result is guaranteed and we really
return the $k$-th positive zero of $J_\nu$. For general $\nu$, the result
is not well defined, we just use Newton iteration with $\pi(\nu/2 + k - 1/4)$
as a starting value. (N.B. Using this method for large real $\nu$ would give
completely different results than the $j_{\nu,k}$ unless $k$ is large enough.)

The library syntax is \fun{GEN}{besseljzero}{GEN nu, long k, long bitprec}.

\subsec{besselk$(\var{nu},x)$}\kbdsidx{besselk}\label{se:besselk}
$K$-Bessel function of index \var{nu} and argument $x$.

The library syntax is \fun{GEN}{kbessel}{GEN nu, GEN x, long prec}.

\subsec{besseln$(\var{nu},x)$}\kbdsidx{besseln}\label{se:besseln}
Deprecated alias for \kbd{bessely}.

The library syntax is \fun{GEN}{ybessel}{GEN nu, GEN x, long prec}.

\subsec{bessely$(\var{nu},x)$}\kbdsidx{bessely}\label{se:bessely}
$Y$-Bessel function of index \var{nu} and argument $x$.

The library syntax is \fun{GEN}{ybessel}{GEN nu, GEN x, long prec}.

\subsec{besselyzero$(\var{nu},\{k=1\})$}\kbdsidx{besselyzero}\label{se:besselyzero}
$k$-th zero of the $Y$-Bessel function of index \var{nu}, close
to $\pi(\nu/2 + k - 3/4)$, usually noted $y_{\nu,k}$.
\bprog
? besselyzero(0) \\ @com{first zero of $Y_0$}
%1 = 0.89357696627916752158488710205833824123
? bessely(0, %)
%2 = 1.8708573650996561952 E-39
? besselyzero(0, 2) \\ @com{second zero}
%3 = 3.9576784193148578683756771869174012814
? besselyzero(I) \\ @com{also works for complex orders, here $Y_i$}
%4 = 1.03930... + 1.3266...*I
@eprog\noindent The function uses a Newton iteration due to Temme.
If $\nu$ is real and nonnegative, the result is guaranteed and we really
return the $k$-th positive zero of $Y_\nu$. For general $\nu$, the result
is not well defined, we just use Newton iteration with $\pi(\nu/2 + k - 3/4)$
as a starting value. (N.B. Using this method for large real $\nu$ would give
completely different results than the $y_{\nu,k}$ unless $k$ is large enough.)

The library syntax is \fun{GEN}{besselyzero}{GEN nu, long k, long bitprec}.

\subsec{cos$(x)$}\kbdsidx{cos}\label{se:cos}
Cosine of $x$.
Note that, for real $x$, cosine and sine can be obtained simultaneously as
\bprog
cs(x) = my(z = exp(I*x)); [real(z), imag(z)];
@eprog and for general complex $x$ as
\bprog
cs2(x) = my(z = exp(I*x), u = 1/z); [(z+u)/2, (z-u)/2];
@eprog Note that the latter function suffers from catastrophic cancellation
when $z^2 \approx \pm1$.

The library syntax is \fun{GEN}{gcos}{GEN x, long prec}.

\subsec{cosh$(x)$}\kbdsidx{cosh}\label{se:cosh}
Hyperbolic cosine of $x$.

The library syntax is \fun{GEN}{gcosh}{GEN x, long prec}.

\subsec{cotan$(x)$}\kbdsidx{cotan}\label{se:cotan}
Cotangent of $x$.

The library syntax is \fun{GEN}{gcotan}{GEN x, long prec}.

\subsec{cotanh$(x)$}\kbdsidx{cotanh}\label{se:cotanh}
Hyperbolic cotangent of $x$.

The library syntax is \fun{GEN}{gcotanh}{GEN x, long prec}.

\subsec{dilog$(x)$}\kbdsidx{dilog}\label{se:dilog}
Principal branch of the dilogarithm of $x$,
i.e.~analytic continuation of the power series
$\text{Li}_2(x)=\sum_{n\ge1}x^n/n^2$.

The library syntax is \fun{GEN}{dilog}{GEN x, long prec}.

\subsec{eint1$(x,\{n\})$}\kbdsidx{eint1}\label{se:eint1}
Exponential integral $\int_x^\infty \dfrac{e^{-t}}{t}\,dt =
\kbd{incgam}(0, x)$, where the latter expression extends the function
definition from real $x > 0$ to all complex $x \neq 0$.

If $n$ is present, we must have $x > 0$; the function returns the
$n$-dimensional vector $[\kbd{eint1}(x),\dots,\kbd{eint1}(nx)]$. Contrary to
other transcendental functions, and to the default case ($n$ omitted), the
values are correct up to a bounded \emph{absolute}, rather than relative,
error $10^{-n}$, where $n$ is \kbd{precision}$(x)$ if $x$ is a \typ{REAL}
and defaults to \kbd{realprecision} otherwise. (In the most important
application, to the computation of $L$-functions via approximate functional
equations, those values appear as weights in long sums and small individual
relative errors are less useful than controlling the absolute error.) This is
faster than repeatedly calling \kbd{eint1($i$ * x)}, but less precise.

The library syntax is \fun{GEN}{veceint1}{GEN x, GEN n = NULL, long prec}.
Also available is \fun{GEN}{eint1}{GEN x, long prec}.

\subsec{ellE$(k)$}\kbdsidx{ellE}\label{se:ellE}
Complete elliptic integral of the second kind
$$E(k)=\int_0^{\pi/2}(1-k^2\sin(t)^2)^{1/2}\,dt$$ for the
complex parameter $k$ using the agm.

In particular, the perimeter of an ellipse of semi-major and semi-minor axes
$a$ and $b$ is given by
\bprog
  e = sqrt(1 - (b/a)^2); \\ eccentricity
  4 * a * ellE(e)  \\ perimeter
@eprog

The library syntax is \fun{GEN}{ellE}{GEN k, long prec}.

\subsec{ellK$(k)$}\kbdsidx{ellK}\label{se:ellK}
Complete elliptic integral of the first kind
$$K(k)=\int_0^{\pi/2}(1-k^2\sin(t)^2)^{-1/2}\,dt$$ for the
complex parameter $k$ using the agm.

The library syntax is \fun{GEN}{ellK}{GEN k, long prec}.

\subsec{erfc$(x)$}\kbdsidx{erfc}\label{se:erfc}
Complementary error function, analytic continuation of
$(2/\sqrt\pi)\int_x^\infty e^{-t^2}\,dt
= \text{sign(x)}\kbd{incgam}(1/2,x^2)/\sqrt\pi$ for real $x \neq 0$.
The latter expression extends the function definition from real $x$ to
complex $x$ with positive real part (or zero real part and positive
imaginary part). This is extended to the whole complex plane by
the functional equation $\kbd{erfc}(-x) = 2 - \kbd{erfc}(x)$.
\bprog
? erfc(0)
%1 = 1.0000000000000000000000000000000000000
? erfc(1)
%2 = 0.15729920705028513065877936491739074071
? erfc(1+I)
%3 = -0.31615128169794764488027108024367036903
     - 0.19045346923783468628410886196916244244*I
@eprog

The library syntax is \fun{GEN}{gerfc}{GEN x, long prec}.

\subsec{eta$(z,\{\fl=0\})$}\kbdsidx{eta}\label{se:eta}
Variants of \idx{Dedekind}'s $\eta$ function.
If $\fl = 0$, return $\prod_{n=1}^\infty(1-q^n)$, where $q$ depends on $x$
in the following way:

\item $q = e^{2i\pi x}$ if $x$ is a \emph{complex number} (which must then
have positive imaginary part); notice that the factor $q^{1/24}$ is
missing!

\item $q = x$ if $x$ is a \typ{PADIC}, or can be converted to a
\emph{power series} (which must then have positive valuation).

If $\fl$ is nonzero, $x$ is converted to a complex number and we return the
true $\eta$ function, $q^{1/24}\prod_{n=1}^\infty(1-q^n)$,
where $q = e^{2i\pi x}$.

The library syntax is \fun{GEN}{eta0}{GEN z, long flag, long prec}.

Also available is \fun{GEN}{trueeta}{GEN x, long prec} ($\fl=1$).

\subsec{exp$(x)$}\kbdsidx{exp}\label{se:exp}
Exponential of $x$.
$p$-adic arguments with positive valuation are accepted.

The library syntax is \fun{GEN}{gexp}{GEN x, long prec}.
For a \typ{PADIC} $x$, the function
\fun{GEN}{Qp_exp}{GEN x} is also available.

\subsec{expm1$(x)$}\kbdsidx{expm1}\label{se:expm1}
Return $\exp(x)-1$, computed in a way that is also accurate
when the real part of $x$ is near $0$.
A naive direct computation would suffer from catastrophic cancellation;
PARI's direct computation of $\exp(x)$ alleviates this well known problem at
the expense of computing $\exp(x)$ to a higher accuracy when $x$ is small.
Using \kbd{expm1} is recommended instead:
\bprog
? default(realprecision, 10000); x = 1e-100;
? a = expm1(x);
time = 4 ms.
? b = exp(x)-1;
time = 4 ms.
? default(realprecision, 10040); x = 1e-100;
? c = expm1(x);  \\ reference point
? abs(a-c)/c  \\ relative error in expm1(x)
%7 = 1.4027986153764843997 E-10019
? abs(b-c)/c  \\ relative error in exp(x)-1
%8 = 1.7907031188259675794 E-9919
@eprog\noindent As the example above shows, when $x$ is near $0$,
\kbd{expm1} is more accurate than \kbd{exp(x)-1}.

The library syntax is \fun{GEN}{gexpm1}{GEN x, long prec}.

\subsec{gamma$(s)$}\kbdsidx{gamma}\label{se:gamma}
For $s$ a complex number, evaluates Euler's gamma
function\sidx{gamma-function}, which is the analytic continuation of
$$\Gamma(s)=\int_0^\infty t^{s-1}\exp(-t)\,dt,\quad \Re(s) > 0.$$
Error if $s$ is a nonpositive integer, where $\Gamma$ has a (simple) pole.
\bprog
? gamma(5)  \\ @com $\Gamma(n) = (n-1)!$ for a positive integer $n$
%1 = 24.000000000000000000000000000000000000
? gamma(0)
 ***   at top-level: gamma(0)
 ***                 ^--------
 *** gamma: domain error in gamma: argument = nonpositive integer

? gamma(x + O(x^3))
%2 = x^-1 - 0.57721566490153286060651209008240243104 + O(x)
@eprog

For $s$ a \typ{PADIC}, evaluates the Morita gamma function at $s$, that
is the unique continuous $p$-adic function on the $p$-adic integers
extending $\Gamma_p(k)=(-1)^k \prod_{j<k}'j$, where the prime means that $p$
does not divide $j$.
\bprog
? gamma(1/4 + O(5^10))
%1= 1 + 4*5 + 3*5^4 + 5^6 + 5^7 + 4*5^9 + O(5^10)
? algdep(%,4)
%2 = x^4 + 4*x^2 + 5
@eprog

The library syntax is \fun{GEN}{ggamma}{GEN s, long prec}.
For a \typ{PADIC} $x$, the function \fun{GEN}{Qp_gamma}{GEN x} is
also available.

\subsec{gammah$(x)$}\kbdsidx{gammah}\label{se:gammah}
Gamma function evaluated at the argument $x+1/2$.

The library syntax is \fun{GEN}{ggammah}{GEN x, long prec}.

\subsec{gammamellininv$(G,t,\{m=0\})$}\kbdsidx{gammamellininv}\label{se:gammamellininv}
Returns the value at $t$ of the inverse Mellin transform
$G$ initialized by \tet{gammamellininvinit}. If the optional parameter
$m$ is present, return the $m$-th derivative $G^{(m)}(t)$.

\bprog
? G = gammamellininvinit([0]);
? gammamellininv(G, 2) - 2*exp(-Pi*2^2)
%2 = -4.484155085839414627 E-44
@eprog

The shortcut
\bprog
  gammamellininv(A,t,m)
@eprog\noindent for
\bprog
  gammamellininv(gammamellininvinit(A,m), t)
@eprog\noindent is available.

The library syntax is \fun{GEN}{gammamellininv}{GEN G, GEN t, long m, long bitprec}.

\subsec{gammamellininvasymp$(A,n,\{m=0\})$}\kbdsidx{gammamellininvasymp}\label{se:gammamellininvasymp}
Return the first $n$ terms of the asymptotic expansion at infinity
of the $m$-th derivative $K^{(m)}(t)$ of the inverse Mellin transform of the
function
$$f(s) = \Gamma_\R(s+a_1)\*\ldots\*\Gamma_\R(s+a_d)\;,$$
where \kbd{A} is the vector $[a_1,\ldots,a_d]$ and
$\Gamma_\R(s)=\pi^{-s/2}\*\Gamma(s/2)$ (Euler's \kbd{gamma}).
The result is a vector
$[M[1]...M[n]]$ with M[1]=1, such that
$$K^{(m)}(t)=\sqrt{2^{d+1}/d}t^{a+m(2/d-1)}e^{-d\pi t^{2/d}}
   \sum_{n\ge0} M[n+1] (\pi t^{2/d})^{-n} $$
with $a=(1-d+\sum_{1\le j\le d}a_j)/d$. We also allow $A$ to be the output of
\kbd{gammamellininvinit}.

The library syntax is \fun{GEN}{gammamellininvasymp}{GEN A, long precdl, long n}.

\subsec{gammamellininvinit$(A,\{m=0\})$}\kbdsidx{gammamellininvinit}\label{se:gammamellininvinit}
Initialize data for the computation by \tet{gammamellininv} of
the $m$-th derivative of the inverse Mellin transform of the function
$$f(s) = \Gamma_\R(s+a_1)\*\ldots\*\Gamma_\R(s+a_d)$$
where \kbd{A} is the vector $[a_1,\ldots,a_d]$ and
$\Gamma_\R(s)=\pi^{-s/2}\*\Gamma(s/2)$ (Euler's \kbd{gamma}). This is the
special case of Meijer's $G$ functions used to compute $L$-values via the
approximate functional equation. By extension, $A$ is allowed to be an
\kbd{Ldata} or an \kbd{Linit}, understood as the inverse Mellin transform
of the $L$-function gamma factor.

\misctitle{Caveat} Contrary to the PARI convention, this function
guarantees an \emph{absolute} (rather than relative) error bound.

For instance, the inverse Mellin transform of $\Gamma_\R(s)$ is
$2\exp(-\pi z^2)$:
\bprog
? G = gammamellininvinit([0]);
? gammamellininv(G, 2) - 2*exp(-Pi*2^2)
%2 = -4.484155085839414627 E-44
@eprog
The inverse Mellin transform of $\Gamma_\R(s+1)$ is
$2 z\exp(-\pi z^2)$, and its second derivative is
$ 4\pi z \exp(-\pi z^2)(2\pi z^2 - 3)$:
\bprog
? G = gammamellininvinit([1], 2);
? a(z) = 4*Pi*z*exp(-Pi*z^2)*(2*Pi*z^2-3);
? b(z) = gammamellininv(G,z);
? t(z) = b(z) - a(z);
? t(3/2)
%3 = -1.4693679385278593850 E-39
@eprog

The library syntax is \fun{GEN}{gammamellininvinit}{GEN A, long m, long bitprec}.

\subsec{hypergeom$(\{N\},\{D\},z)$}\kbdsidx{hypergeom}\label{se:hypergeom}
General hypergeometric function, where \kbd{N} and \kbd{D} are
the vector of parameters in the numerator and denominator respectively,
evaluated at the complex argument $z$.

This function implements hypergeometric functions
$$_pF_q((a_i)_{1\le i\le p},(b_j)_{1\le j\le q};z)
   = \sum_{n\ge0}\dfrac{\prod_{1\le i\le p}(a_i)_n}{\prod_{1\le j\le q}(b_j)_n}
      \dfrac{z^n}{n!}\;,$$
where $(a)_n=a(a+1)\cdots(a+n-1)$ is the rising Pochammer symbol. For this
to make sense, none of the $b_j$ must be a negative or zero integer. The
corresponding general GP command is
\bprog
  hypergeom([a1,a2,...,ap], [b1,b2,...,bq], z)
@eprog\noindent Whenever $p = 1$ or $q = 1$, a one-element vector can be
replaced by the element it contains. Whenever $p = 0$ or $q = 0$, an empty
vector can be omitted. For instance hypergeom(,b,z) computes $_0F_1(;b;z)$.

We distinguish three kinds of such functions according to their radius
of convergence $R$:

\item $q\ge p$: $R = \infty$.

\item $q=p-1$: $R=1$. Nonetheless, by integral representations, $_pF_q$
can be analytically continued outside the disc of convergence.

\item $q\le p-2$: $R=0$. By integral representations, one can make sense of
the function in a suitable domain.

The list of implemented functions and their domain of validity in
our implementation is as follows:

\kbd{F01}: \kbd{hypergeom(,a,z)} (or \kbd{[a]}).
This is essentially a Bessel function and computed as such. $R=\infty$.

\kbd{F10}: \kbd{hypergeom(a,,z)}
 This is $(1-z)^{-a}$.

\kbd{F11}: \kbd{hypergeom(a,b,z)} is the Kummer confluent hypergeometric
function, computed by summing the series. $R=\infty$

\kbd{F20}: \kbd{hypergeom([a,b],,z)}. $R=0$, computed as
$$\dfrac{1}{\Gamma(a)}\int_0^\infty t^{a-1}(1-zt)^{-b}e^{-t}\,dt\;.$$

\kbd{F21}: \kbd{hypergeom([a,b],c,z)} (or \kbd{[c]}).
$R=1$, extended by
$$\dfrac{\Gamma(c)}{\Gamma(b)\Gamma(c-b)}
   \int_0^1 t^{b-1}(1-t)^{c-b-1}(1-zt)^a\,dt\;.$$
This is Gauss's Hypergeometric function, and almost all of the implementation
work is done for this function.

\kbd{F31}: \kbd{hypergeom([a,b,c],d,z)} (or \kbd{[d]}). $R=0$, computed as
$$\dfrac{1}{\Gamma(a)}\int_0^\infty t^{a-1}e^{-t}{}_2F_1(b,c;d;tz)\,dt\;.$$

\kbd{F32}: \kbd{hypergeom([a,b,c],[d,e],z)}. $R=1$, extended by
$$\dfrac{\Gamma(e)}{\Gamma(c)\Gamma(e-c)}
   \int_0^1t^{c-1}(1-t)^{e-c-1}{}_2F_1(a,b;d;tz)\,dt\;.$$

For other inputs: if $R=\infty$ or $R=1$ and $|z| < 1- \varepsilon$ is not
too close to the circle of convergence, we simply sum the series.

\bprog
? hypergeom([3,2], 3.4, 0.7)   \\ 2F1(3,2; 3.4; 0.7)
%1 = 7.9999999999999999999999999999999999999
? a=5/3; T1=hypergeom([1,1,1],[a,a],1)  \\ 3F2(1,1,1; a,a; 1)
%2 = 3.1958592952314032651578713968927593818
? T2=hypergeom([2,1,1],[a+1,a+1],1)
%3 = 1.6752931349345765309211012564734179541
? T3=hypergeom([2*a-1,1,1],[a+1,a+1],1)
%4 = 1.9721037126267142061807688820853354440
? T1 + (a-1)^2/(a^2*(2*a-3)) * (T2-2*(a-1)*T3) \\
  - gamma(a)^2/((2*a-3)*gamma(2*a-2))
%5 = -1.880790961315660013 E-37 \\ ~ 0

@eprog\noindent This identity is due to Bercu.

The library syntax is \fun{GEN}{hypergeom}{GEN N = NULL, GEN D = NULL, GEN z, long prec}.

\subsec{hyperu$(a,b,z)$}\kbdsidx{hyperu}\label{se:hyperu}
$U$-confluent hypergeometric function with complex
parameters $a, b, z$. Note that $_2F_0(a,b,z) = (-z)^{-a}U(a, a+1-b, -1/z)$,
\bprog
? hyperu(1, 3/2, I)
%1 = 0.23219... - 0.80952...*I
? -I * hypergeom([1, 1+1-3/2], [], -1/I)
%2 = 0.23219... - 0.80952...*I
@eprog

The library syntax is \fun{GEN}{hyperu}{GEN a, GEN b, GEN z, long prec}.

\subsec{incgam$(s,x,\{g\})$}\kbdsidx{incgam}\label{se:incgam}
Incomplete gamma function $\int_x^\infty e^{-t}t^{s-1}\,dt$, extended by
analytic continuation to all complex $x, s$ not both $0$. The relative error
is bounded in terms of the precision of $s$ (the accuracy of $x$ is ignored
when determining the output precision). When $g$ is given, assume that
$g=\Gamma(s)$. For small $|x|$, this will speed up the computation.

The library syntax is \fun{GEN}{incgam0}{GEN s, GEN x, GEN g = NULL, long prec}.
Also available is \fun{GEN}{incgam}{GEN s, GEN x, long prec}.

\subsec{incgamc$(s,x)$}\kbdsidx{incgamc}\label{se:incgamc}
Complementary incomplete gamma function.
The arguments $x$ and $s$ are complex numbers such that $s$ is not a pole of
$\Gamma$ and $|x|/(|s|+1)$ is not much larger than 1 (otherwise the
convergence is very slow). The result returned is $\int_0^x
e^{-t}t^{s-1}\,dt$.

The library syntax is \fun{GEN}{incgamc}{GEN s, GEN x, long prec}.

\subsec{lambertw$(y,\{\var{branch}=0\})$}\kbdsidx{lambertw}\label{se:lambertw}
Lambert $W$ function, solution of the implicit equation $xe^x=y$.

\item For real inputs $y$:
If \kbd{branch = 0}, principal branch $W_0$ defined for $y\ge-\exp(-1)$.
If \kbd{branch = -1}, branch $W_{-1}$ defined for $-\exp(-1)\le y<0$.

\item For $p$-adic inputs: gives a solution of $x\exp(x)=y$ if $x$ has
positive valuation, of $x+\log(x)=\log(y)$ otherwise.

\misctitle{Caveat}
Complex values of $y$ are also supported but experimental. The other
branches $W_k$ for $k$ not equal to $0$ or $-1$ (set \kbd{branch} to $k$)
are also experimental.

For $k\ge1$, $W_{-1-k}(x)=\overline{W_k(x)}$, and $\Im(W_k(x))$ is
close to $(\pi/2)(4k-\text{sign}(x))$.

The library syntax is \fun{GEN}{glambertW}{GEN y, long branch, long prec}.

\subsec{lerchphi$(z, s, a)$}\kbdsidx{lerchphi}\label{se:lerchphi}
Lerch transcendent $\Phi(z,s,a)=\sum_{n\ge0}z^n(n+a)^{-s}$ and
analytically continued, for reasonable values of the arguments.

The library syntax is \fun{GEN}{lerchphi}{GEN z, GEN s, GEN a, long prec}.

\subsec{lerchzeta$(s, a, \var{lam})$}\kbdsidx{lerchzeta}\label{se:lerchzeta}
Lerch zeta function
$$L(s,a,\lambda)=\sum_{n\ge0}e^{2\pi i\lambda n}(n+a)^{-s}$$
and analytically continued, for reasonable values of the arguments.

The library syntax is \fun{GEN}{lerchzeta}{GEN s, GEN a, GEN lam, long prec}.

\subsec{lngamma$(x)$}\kbdsidx{lngamma}\label{se:lngamma}
Principal branch of the logarithm of the gamma function of $x$. This
function is analytic on the complex plane with nonpositive integers
removed, and can have much larger arguments than \kbd{gamma} itself.

For $x$ a power series such that $x(0)$ is not a pole of \kbd{gamma},
compute the Taylor expansion. (PARI only knows about regular power series
and can't include logarithmic terms.)
\bprog
? lngamma(1+x+O(x^2))
%1 = -0.57721566490153286060651209008240243104*x + O(x^2)
? lngamma(x+O(x^2))
 ***   at top-level: lngamma(x+O(x^2))
 ***                 ^-----------------
 *** lngamma: domain error in lngamma: valuation != 0
? lngamma(-1+x+O(x^2))
 *** lngamma: Warning: normalizing a series with 0 leading term.
 ***   at top-level: lngamma(-1+x+O(x^2))
 ***                 ^--------------------
 *** lngamma: domain error in intformal: residue(series, pole) != 0
@eprog
For $x$ a \typ{PADIC}, return the $p$-adic $\log\Gamma_p$ function, which
is the $p$-adic logarithm of Morita's gamma function for $x \in \Z_p$,
and Diamond's function if $|x| > 1$.
\bprog
? lngamma(5+O(5^7))
%2 = 4*5^2 + 4*5^3 + 5^4 + 2*5^5 + O(5^6)
? log(gamma(5+O(5^7)))
%3 = 4*5^2 + 4*5^3 + 5^4 + 2*5^5 + O(5^6)
? lngamma(1/5+O(5^4))
%4 = 4*5^-1 + 4 + 2*5 + 5^2 + 5^3 + O(5^4)
? gamma(1/5+O(5^4))
 ***   at top-level: gamma(1/5+O(5^4))
 ***                 ^-----------------
 *** gamma: domain error in gamma: v_p(x) < 0
@eprog

The library syntax is \fun{GEN}{glngamma}{GEN x, long prec}.

\subsec{log$(x)$}\kbdsidx{log}\label{se:log}
Principal branch of the natural logarithm of
$x \in \C^*$, i.e.~such that $\Im(\log(x))\in{} ]-\pi,\pi]$.
The branch cut lies
along the negative real axis, continuous with quadrant 2, i.e.~such that
$\lim_{b\to 0^+} \log (a+bi) = \log a$ for $a \in\R^*$. The result is complex
(with imaginary part equal to $\pi$) if $x\in \R$ and $x < 0$. In general,
the algorithm uses the formula
$$\log(x) \approx {\pi\over 2\text{agm}(1, 4/s)} - m \log 2, $$
if $s = x 2^m$ is large enough. (The result is exact to $B$ bits provided
$s > 2^{B/2}$.) At low accuracies, the series expansion near $1$ is used.

$p$-adic arguments are also accepted for $x$, with the convention that
$\log(p)=0$. Hence in particular $\exp(\log(x))/x$ is not in general equal to
1 but to a $(p-1)$-th root of unity (or $\pm1$ if $p=2$) times a power of $p$.

The library syntax is \fun{GEN}{glog}{GEN x, long prec}.
For a \typ{PADIC} $x$, the function
\fun{GEN}{Qp_log}{GEN x} is also available.

\subsec{log1p$(x)$}\kbdsidx{log1p}\label{se:log1p}
Return $\log(1+x)$, computed in a way that is also accurate
when the real part of $x$ is near $0$. This is the reciprocal function
of \kbd{expm1}$(x) = \exp(x)-1$.
\bprog
? default(realprecision, 10000); x = Pi*1e-100;
? (expm1(log1p(x)) - x) / x
%2 = -7.668242895059371866 E-10019
? (log1p(expm1(x)) - x) / x
%3 = -7.668242895059371866 E-10019
@eprog\noindent When $x$ is small, this function is both faster and more
accurate than $\log(1+x)$:
\bprog
? \p38
? x = 1e-20;
? localprec(100); c = log1p(x); \\ reference point
? a = log1p(x); abs((a - c)/c)
%6 = 0.E-38
? b = log(1+x); abs((b - c)/c)  \\ slightly less accurate
%7 = 1.5930919111324522770 E-38
? for (i=1,10^5,log1p(x))
time = 81 ms.
? for (i=1,10^5,log(1+x))
time = 100 ms. \\ slower, too
@eprog

The library syntax is \fun{GEN}{glog1p}{GEN x, long prec}.

\subsec{polylog$(m,x,\{\fl=0\})$}\kbdsidx{polylog}\label{se:polylog}
One of the different polylogarithms, depending on \fl:

If $\fl=0$ or is omitted: $m^\text{th}$ polylogarithm of $x$, i.e.~analytic
continuation of the power series $\text{Li}_m(x)=\sum_{n\ge1}x^n/n^m$
($x < 1$). Uses the functional equation linking the values at $x$ and $1/x$
to restrict to the case $|x|\leq 1$, then the power series when
$|x|^2\le1/2$, and the power series expansion in $\log(x)$ otherwise.

Using $\fl$, computes a modified $m^\text{th}$ polylogarithm of $x$.
We use Zagier's notations; let $\Re_m$ denote $\Re$ or $\Im$ depending
on whether $m$ is odd or even:

If $\fl=1$: compute $\tilde D_m(x)$, defined for $|x|\le1$ by
$$\Re_m\left(\sum_{k=0}^{m-1} \dfrac{(-\log|x|)^k}{k!}\text{Li}_{m-k}(x)
+\dfrac{(-\log|x|)^{m-1}}{m!}\log|1-x|\right).$$

If $\fl=2$: compute $D_m(x)$, defined for $|x|\le1$ by
$$\Re_m\left(\sum_{k=0}^{m-1}\dfrac{(-\log|x|)^k}{k!}\text{Li}_{m-k}(x)
-\dfrac{1}{2}\dfrac{(-\log|x|)^m}{m!}\right).$$

If $\fl=3$: compute $P_m(x)$, defined for $|x|\le1$ by
$$\Re_m\left(\sum_{k=0}^{m-1}\dfrac{2^kB_k}{k!}(\log|x|)^k\text{Li}_{m-k}(x)
-\dfrac{2^{m-1}B_m}{m!}(\log|x|)^m\right).$$

These three functions satisfy the functional equation
$f_m(1/x) = (-1)^{m-1}f_m(x)$.

The library syntax is \fun{GEN}{polylog0}{long m, GEN x, long flag, long prec}.
Also available is
\fun{GEN}{gpolylog}{long m, GEN x, long prec} (\fl = 0).

\subsec{polylogmult$(s,\{z\},\{t=0\})$}\kbdsidx{polylogmult}\label{se:polylogmult}
For $s$ a vector of positive integers and $z$ a vector of complex
numbers of the same length, returns the multiple polylogarithm value (MPV)
$$\zeta(s_1,\dots, s_r; z_1,\dots,z_r)
   = \sum_{n_1>\dots>n_r>0} \prod_{1\le i\le r}z_i^{n_i}/n_i^{s_i}.$$
If $z$ is omitted, assume $z=[1,\dots,1]$, i.e., Multiple Zeta Value.
More generally, return Yamamoto's interpolation between ordinary multiple
polylogarithms ($t = 0$) and star polylogarithms ($t = 1$, using the
condition $n_1\ge \dots \ge n_r > 0$), evaluated at $t$.

We must have $|z_1\cdots z_i|\le1$ for all $i$, and if $s_1=1$ we
must have $z_1\ne1$.
\bprog
? 8*polylogmult([2,1],[-1,1]) - zeta(3)
%1 = 0.E-38
@eprog\noindent
\misctitle{Warning} The algorithm used converges when the $z_i$ are
$\pm 1$. It may not converge as some $z_i \neq 1$ becomes too close to $1$,
even at roots of $1$ of moderate order:
\bprog
? polylogmult([2,1], (99+20*I)/101 * [1,1])
 *** polylogmult: sorry, polylogmult in this range is not yet implemented.
? polylogmult([2,1], exp(I*Pi/20)* [1,1])
 *** polylogmult: sorry, polylogmult in this range is not yet implemented.
@eprog\noindent More precisely, if $y_i := 1 / (z_1\cdots z_i)$ and
$$ v := \min_{i < j; y_i \neq 1} |(1 - y_i) y_j| > 1/4$$
then the algorithm computes the value up to a $2^{-b}$ absolute error
in $O(k^2N)$ operations on floating point numbers of $O(N)$ bits,
where $k = \sum_i s_i$ is the weight and $N = b / \log_2 (4v)$.

The library syntax is \fun{GEN}{polylogmult_interpolate}{GEN s, GEN z = NULL, GEN t = NULL, long prec}.
Also available is
 \fun{GEN}{polylogmult}{GEN s, GEN z, long prec} ($t$ is \kbd{NULL}).

\subsec{psi$(x)$}\kbdsidx{psi}\label{se:psi}
The $\psi$-function of $x$, i.e.~the logarithmic derivative
$\Gamma'(x)/\Gamma(x)$.

The library syntax is \fun{GEN}{gpsi}{GEN x, long prec}.

\subsec{rootsof1$(N)$}\kbdsidx{rootsof1}\label{se:rootsof1}
Return the column vector $v$ of all complex $N$-th roots of $1$, where $N$
is a positive integer. In other words,
$v[k] = \exp(2I(k-1)\pi/N)$ for $k = 1, \dots, N$. Rational components
(e.g., the roots $\pm1$ and $\pm I$) are given exactly, not as floating point
numbers:
\bprog
? rootsof1(4)
%1 = [1, I, -1, -I]~
? rootsof1(3)
%2 = [1, -1/2 + 0.866025...*I, -1/2 - 0.866025...*I]~
@eprog

The library syntax is \fun{GEN}{grootsof1}{long N, long prec}.

\subsec{sin$(x)$}\kbdsidx{sin}\label{se:sin}
Sine of $x$.
Note that, for real $x$, cosine and sine can be obtained simultaneously as
\bprog
cs(x) = my(z = exp(I*x)); [real(z), imag(z)];
@eprog and for general complex $x$ as
\bprog
cs2(x) = my(z = exp(I*x), u = 1/z); [(z+u)/2, (z-u)/2];
@eprog Note that the latter function suffers from catastrophic cancellation
when $z^2 \approx \pm1$.

The library syntax is \fun{GEN}{gsin}{GEN x, long prec}.

\subsec{sinc$(x)$}\kbdsidx{sinc}\label{se:sinc}
Cardinal sine of $x$, i.e. $\sin(x)/x$ if $x\neq 0$, $1$ otherwise.
Note that this function also allows to compute
$$(1-\cos(x)) / x^2 = \kbd{sinc}(x/2)^2 / 2$$
accurately near $x = 0$.

The library syntax is \fun{GEN}{gsinc}{GEN x, long prec}.

\subsec{sinh$(x)$}\kbdsidx{sinh}\label{se:sinh}
Hyperbolic sine of $x$.

The library syntax is \fun{GEN}{gsinh}{GEN x, long prec}.

\subsec{sqr$(x)$}\kbdsidx{sqr}\label{se:sqr}
Square of $x$. This operation is not completely
straightforward, i.e.~identical to $x * x$, since it can usually be
computed more efficiently (roughly one-half of the elementary
multiplications can be saved). Also, squaring a $2$-adic number increases
its precision. For example,
\bprog
? (1 + O(2^4))^2
%1 = 1 + O(2^5)
? (1 + O(2^4)) * (1 + O(2^4))
%2 = 1 + O(2^4)
@eprog\noindent
Note that this function is also called whenever one multiplies two objects
which are known to be \emph{identical}, e.g.~they are the value of the same
variable, or we are computing a power.
\bprog
? x = (1 + O(2^4)); x * x
%3 = 1 + O(2^5)
? (1 + O(2^4))^4
%4 = 1 + O(2^6)
@eprog\noindent
(note the difference between \kbd{\%2} and \kbd{\%3} above).

The library syntax is \fun{GEN}{gsqr}{GEN x}.

\subsec{sqrt$(x)$}\kbdsidx{sqrt}\label{se:sqrt}
Principal branch of the square root of $x$, defined as $\sqrt{x} =
\exp(\log x / 2)$. In particular, we have
$\text{Arg}(\text{sqrt}(x))\in{} ]-\pi/2, \pi/2]$, and if $x\in \R$ and $x<0$,
then the result is complex with positive imaginary part.

Intmod a prime $p$, \typ{PADIC} and \typ{FFELT} are allowed as arguments. In
the first 2 cases (\typ{INTMOD}, \typ{PADIC}), the square root (if it
exists) which is returned is the one whose first $p$-adic digit is in the
interval $[0,p/2]$. For other arguments, the result is undefined.

The library syntax is \fun{GEN}{gsqrt}{GEN x, long prec}.
For a \typ{PADIC} $x$, the function
\fun{GEN}{Qp_sqrt}{GEN x} is also available.

\subsec{sqrtn$(x,n,\{\&z\})$}\kbdsidx{sqrtn}\label{se:sqrtn}
Principal branch of the $n$th root of $x$,
i.e.~such that $\text{Arg}(\text{sqrtn}(x))\in{} ]-\pi/n, \pi/n]$. Intmod
a prime and $p$-adics are allowed as arguments.

If $z$ is present, it is set to a suitable root of unity allowing to
recover all the other roots. If it was not possible, z is
set to zero. In the case this argument is present and no $n$th root exist,
$0$ is returned instead of raising an error.
\bprog
? sqrtn(Mod(2,7), 2)
%1 = Mod(3, 7)
? sqrtn(Mod(2,7), 2, &z); z
%2 = Mod(6, 7)
? sqrtn(Mod(2,7), 3)
  ***   at top-level: sqrtn(Mod(2,7),3)
  ***                 ^-----------------
  *** sqrtn: nth-root does not exist in gsqrtn.
? sqrtn(Mod(2,7), 3,  &z)
%2 = 0
? z
%3 = 0
@eprog

The following script computes all roots in all possible cases:
\bprog
sqrtnall(x,n)=
{ my(V,r,z,r2);
  r = sqrtn(x,n, &z);
  if (!z, error("Impossible case in sqrtn"));
  if (type(x) == "t_INTMOD" || type(x)=="t_PADIC",
    r2 = r*z; n = 1;
    while (r2!=r, r2*=z;n++));
  V = vector(n); V[1] = r;
  for(i=2, n, V[i] = V[i-1]*z);
  V
}
addhelp(sqrtnall,"sqrtnall(x,n):compute the vector of nth-roots of x");
@eprog\noindent

The library syntax is \fun{GEN}{gsqrtn}{GEN x, GEN n, GEN *z = NULL, long prec}.
If $x$ is a \typ{PADIC}, the function
\fun{GEN}{Qp_sqrtn}{GEN x, GEN n, GEN *z} is also available.

\subsec{tan$(x)$}\kbdsidx{tan}\label{se:tan}
Tangent of $x$.

The library syntax is \fun{GEN}{gtan}{GEN x, long prec}.

\subsec{tanh$(x)$}\kbdsidx{tanh}\label{se:tanh}
Hyperbolic tangent of $x$.

The library syntax is \fun{GEN}{gtanh}{GEN x, long prec}.

\subsec{teichmuller$(x,\{\var{tab}\})$}\kbdsidx{teichmuller}\label{se:teichmuller}
Teichm\"uller character of the $p$-adic number $x$, i.e. the unique
$(p-1)$-th root of unity congruent to $x / p^{v_p(x)}$ modulo $p$.
If $x$ is of the form $[p,n]$, for a prime $p$ and integer $n$,
return the lifts to $\Z$ of the images of $i + O(p^n)$ for
$i = 1, \dots, p-1$, i.e. all roots of $1$ ordered  by residue class modulo
$p$. Such a vector can be fed back to \kbd{teichmuller}, as the
optional argument \kbd{tab}, to speed up later computations.

\bprog
? z = teichmuller(2 + O(101^5))
%1 = 2 + 83*101 + 18*101^2 + 69*101^3 + 62*101^4 + O(101^5)
? z^100
%2 = 1 + O(101^5)
? T = teichmuller([101, 5]);
? teichmuller(2 + O(101^5), T)
%4 = 2 + 83*101 + 18*101^2 + 69*101^3 + 62*101^4 + O(101^5)
@eprog\noindent As a rule of thumb, if more than
$$p \,/\, 2(\log_2(p) + \kbd{hammingweight}(p))$$
values of \kbd{teichmuller} are to be computed, then it is worthwile to
initialize:
\bprog
? p = 101; n = 100; T = teichmuller([p,n]); \\ instantaneous
? for(i=1,10^3, vector(p-1, i, teichmuller(i+O(p^n), T)))
time = 60 ms.
? for(i=1,10^3, vector(p-1, i, teichmuller(i+O(p^n))))
time = 1,293 ms.
? 1 + 2*(log(p)/log(2) + hammingweight(p))
%8 = 22.316[...]
@eprog\noindent Here the precomputation induces a speedup by a factor
$1293/ 60 \approx 21.5$.

\misctitle{Caveat}
If the accuracy of \kbd{tab} (the argument $n$ above) is lower than the
precision of $x$, the \emph{former} is used, i.e. the cached value is not
refined to higher accuracy. It the accuracy of \kbd{tab} is larger, then
the precision of $x$ is used:
\bprog
? Tlow = teichmuller([101, 2]); \\ lower accuracy !
? teichmuller(2 + O(101^5), Tlow)
%10 = 2 + 83*101 + O(101^5)  \\ no longer a root of 1

? Thigh = teichmuller([101, 10]); \\ higher accuracy
? teichmuller(2 + O(101^5), Thigh)
%12 = 2 + 83*101 + 18*101^2 + 69*101^3 + 62*101^4 + O(101^5)
@eprog

The library syntax is \fun{GEN}{teichmuller}{GEN x, GEN tab = NULL}.

Also available are the functions \fun{GEN}{teich}{GEN x} (\kbd{tab} is
\kbd{NULL}) as well as
\fun{GEN}{teichmullerinit}{long p, long n}.

\subsec{theta$(q,z)$}\kbdsidx{theta}\label{se:theta}
Jacobi sine theta-function
$$ \theta_1(z, q) = 2q^{1/4} \sum_{n\geq 0} (-1)^n q^{n(n+1)} \sin((2n+1)z).$$

The library syntax is \fun{GEN}{theta}{GEN q, GEN z, long prec}.

\subsec{thetanullk$(q,k)$}\kbdsidx{thetanullk}\label{se:thetanullk}
$k$-th derivative at $z=0$ of $\kbd{theta}(q,z)$.

The library syntax is \fun{GEN}{thetanullk}{GEN q, long k, long prec}.

\fun{GEN}{vecthetanullk}{GEN q, long k, long prec} returns the vector
of all $\dfrac{d^i\theta}{dz^i}(q,0)$ for all odd $i = 1, 3, \dots, 2k-1$.
\fun{GEN}{vecthetanullk_tau}{GEN tau, long k, long prec} returns
\kbd{vecthetanullk\_tau} at $q = \exp(2i\pi \kbd{tau})$.

\subsec{weber$(x,\{\fl=0\})$}\kbdsidx{weber}\label{se:weber}
One of Weber's three $f$ functions.
If $\fl=0$, returns
$$f(x)=\exp(-i\pi/24)\cdot\eta((x+1)/2)\,/\,\eta(x) \quad\hbox{such that}\quad
j=(f^{24}-16)^3/f^{24}\,,$$
where $j$ is the elliptic $j$-invariant  (see the function \kbd{ellj}).
If $\fl=1$, returns
$$f_1(x)=\eta(x/2)\,/\,\eta(x)\quad\hbox{such that}\quad
j=(f_1^{24}+16)^3/f_1^{24}\,.$$
Finally, if $\fl=2$, returns
$$f_2(x)=\sqrt{2}\eta(2x)\,/\,\eta(x)\quad\hbox{such that}\quad
j=(f_2^{24}+16)^3/f_2^{24}.$$
Note the identities $f^8=f_1^8+f_2^8$ and $ff_1f_2=\sqrt2$.

The library syntax is \fun{GEN}{weber0}{GEN x, long flag, long prec}.
Also available are \fun{GEN}{weberf}{GEN x, long prec},
\fun{GEN}{weberf1}{GEN x, long prec} and \fun{GEN}{weberf2}{GEN x, long prec}.

\subsec{zeta$(s)$}\kbdsidx{zeta}\label{se:zeta}
For $s \neq 1$ a complex number, Riemann's zeta
function \sidx{Riemann zeta-function} $\zeta(s)=\sum_{n\ge1}n^{-s}$,
computed using the \idx{Euler-Maclaurin} summation formula, except
when $s$ is of type integer, in which case it is computed using
Bernoulli numbers\sidx{Bernoulli numbers} for $s\le0$ or $s>0$ and
even, and using modular forms for $s>0$ and odd. Power series
are also allowed:
\bprog
? zeta(2) - Pi^2/6
%1 = 0.E-38
? zeta(1+x+O(x^3))
%2 = 1.0000000000000000000000000000000000000*x^-1 + \
     0.57721566490153286060651209008240243104 + O(x)
@eprog

For $s\neq 1$ a $p$-adic number, Kubota-Leopoldt zeta function at $s$, that
is the unique continuous $p$-adic function on the $p$-adic integers
that interpolates the values of $(1 - p^{-k}) \zeta(k)$ at negative
integers $k$ such that $k \equiv 1 \pmod{p-1}$ (resp. $k$ is odd) if
$p$ is odd (resp. $p = 2$). Power series are not allowed in this case.
\bprog
? zeta(-3+O(5^10))
%1 = 4*5^-1 + 4 + 3*5 + 4*5^3 + 4*5^5 + 4*5^7 + O(5^9)))))
? (1-5^3) * zeta(-3)
%2 = -1.0333333333333333333333333333333333333
? bestappr(%)
%3 = -31/30
? zeta(-3+O(5^10)) - (-31/30)
%4 = O(5^9)
@eprog

The library syntax is \fun{GEN}{gzeta}{GEN s, long prec}.

\subsec{zetahurwitz$(s,x,\{\var{der}=0\})$}\kbdsidx{zetahurwitz}\label{se:zetahurwitz}
Hurwitz zeta function $\zeta(s,x)=\sum_{n\ge0}(n+x)^{-s}$ and
analytically continued, with $s\ne1$ and $x$ not a negative or zero
integer. Note that $\zeta(s,1) = \zeta(s)$. $s$ can also be a polynomial,
rational function, or power series. If \kbd{der} is positive, compute the
\kbd{der}'th derivative with respect to $s$. Note that the derivative
with respect to $x$ is simply $-s\zeta(s+1,x)$.
\bprog
? zetahurwitz(Pi,Pi)
%1 = 0.056155444497585099925180502385781494484
? zetahurwitz(2,1) - zeta(2)
%2 = -2.350988701644575016 E-38
? zetahurwitz(Pi,3) - (zeta(Pi)-1-1/2^Pi)
%3 = -2.2040519077917890774 E-39
? zetahurwitz(-7/2,1) - zeta(-7/2)
%4 = -2.295887403949780289 E-41
? zetahurwitz(-2.3,Pi+I*log(2))
%5 = -5.1928369229555125820137832704455696057\
    - 6.1349660138824147237884128986232049582*I
? zetahurwitz(-1+x^2+O(x^3),1)
%6 = -0.083333333333333333333333333333333333333\
     - 0.16542114370045092921391966024278064276*x^2 + O(x^3)
? zetahurwitz(1+x+O(x^4),2)
%7 = 1.0000000000000000000000000000000000000*x^-1\
   - 0.42278433509846713939348790991759756896\
   + 0.072815845483676724860586375874901319138*x + O(x^2)
? zetahurwitz(2,1,2) \\ zeta''(2)
%8 = 1.9892802342989010234208586874215163815
@eprog

The library syntax is \fun{GEN}{zetahurwitz}{GEN s, GEN x, long der, long bitprec}.

\subsec{zetamult$(s,\{t=0\})$}\kbdsidx{zetamult}\label{se:zetamult}
For $s$ a vector of positive integers such that $s[1] \geq 2$,
returns the multiple zeta value (MZV)
$$\zeta(s_1,\dots, s_k) = \sum_{n_1>\dots>n_k>0} n_1^{-s_1}\dots n_k^{-s_k}$$
of length $k$ and weight $\sum_i s_i$.
More generally, return Yamamoto's $t$-MZV interpolation evaluated at $t$:
for $t = 0$, this is the ordinary MZV; for $t = 1$, we obtain the MZSV
star value, with $\geq$ instead of strict inequalities;
and of course, for $t = \kbd{'x}$ we obtain Yamamoto's one-variable polynomial.
\bprog
? zetamult([2,1]) - zeta(3) \\ Euler's identity
%1 = 0.E-38
? zetamult([2,1], 1)   \\ star value
%2 = 2.4041138063191885707994763230228999815
? zetamult([2,1], 'x)
%3 = 1.20205[...]*x + 1.20205[...]
@eprog\noindent
If the bit precision is $B$, this function runs in time $\tilde{O}(k(B+k)^2)$
if $t = 0$, and $\tilde{O}(kB^3)$ otherwise.

In addition to the above format (\kbd{avec}), the function
also accepts a binary word format \kbd{evec} (each $s_i$ is replaced
by $s_i$ bits, all of them 0 but the last one) giving the MZV
representation as an iterated integral, and an \kbd{index} format
(if $e$ is the positive integer attached the \kbd{evec} vector of
bits, the index is the integer $e + 2^{k-2}$). The function
\kbd{zetamultconvert} allows to pass from one format to the other; the
function \kbd{zetamultall} computes simultaneously all MZVs of weight
$\sum_{i\leq k} s_i$ up to $n$.

The library syntax is \fun{GEN}{zetamult_interpolate}{GEN s, GEN t = NULL, long prec}.
Also available is \fun{GEN}{zetamult}{GEN s, long prec} for $t = 0$.

\subsec{zetamultall$(k,\{\fl=0\})$}\kbdsidx{zetamultall}\label{se:zetamultall}
List of all multiple zeta values (MZVs) for weight $s_1 + \dots + s_r$
up to $k$. Binary digits of $\fl$ mean : 0 = star values if set;
1 = values up to to duality if set (see \kbd{zetamultdual}, ignored if
star values); 2 = values of weight $k$ if set (else all values up to weight
$k$); 3 = return the 2-component vector \kbd{[Z, M]}, where $M$ is the vector
of the corresponding indices $m$, i.e., such that
\kbd{zetamult(M[i])} = \kbd{Z[i]}. Note that it is necessary to use
\kbd{zetamultconvert} to have the corresponding \kbd{avec} $(s_1,\dots, s_r)$.

With default flag $\fl = 0$, the function returns a vector with $2^{k-1}-1$
components whose $i$-th entry is the MZV of \kbd{index} $i$ (see
\kbd{zetamult}). If the bit precision is $B$, this function runs in time
$O(2^k k B^2)$ for an output of size $O(2^k B)$.

\bprog
? Z = zetamultall(5); #Z \\ 2^4 - 1 MZVs of weight <= 5
%1 = 15
? Z[10]
%2 = 0.22881039760335375976874614894168879193
? zetamultconvert(10)
%3 = Vecsmall([3, 2]) \\ @com{index $10$ corresponds to $\zeta(3,2)$}
? zetamult(%)  \\ double check
%4 = 0.22881039760335375976874614894168879193
? zetamult(10) \\ we can use the index directly
%5 = 0.22881039760335375976874614894168879193
@eprog\noindent If we use flag bits 1 and 2, we avoid unnecessary
computations and copying, saving a potential factor 4: half the values
are in lower weight and computing up to duality save another rough factor 2.
Unfortunately, the indexing now no longer corresponds to the new shorter
vector of MZVs:
\bprog
? Z = zetamultall(5, 2); #Z \\ up to duality
%6 = 9
? Z = zetamultall(5, 2); #Z \\ only weight 5
%7 = 8
? Z = zetamultall(5, 2 + 4); #Z \\ both
%8 = 4
@eprog\noindent So how to recover the value attached to index 10 ? Flag
bit 3 returns the actual indices used:
\bprog
? [Z, M] = zetamultall(5, 2 + 8); M \\ other indices were not included
%9 = Vecsmall([1, 2, 4, 5, 6, 8, 9, 10, 12])
? Z[8] \\ index m = 10 is now in M[8]
%10 = 0.22881039760335375976874614894168879193
? [Z, M] = zetamultall(5, 2 + 4 + 8); M
%11 = Vecsmall([8, 9, 10, 12])
? Z[3] \\ index m = 10 is now in M[3]
%12 = 0.22881039760335375976874614894168879193
@eprog\noindent The following construction automates the above
programmatically, looking up the MZVs of index $10$ ($=\zeta(3,2)$) in all
cases, without inspecting the various index sets $M$ visually:
\bprog
? Z[vecsearch(M, 10)] \\ works in all the above settings
%13 = 0.22881039760335375976874614894168879193
@eprog

The library syntax is \fun{GEN}{zetamultall}{long k, long flag, long prec}.

\subsec{zetamultconvert$(a,\{\var{fl}=1\})$}\kbdsidx{zetamultconvert}\label{se:zetamultconvert}
\kbd{a} being either an \kbd{evec}, \kbd{avec}, or index \kbd{m},
converts into \kbd{evec} (\kbd{fl=0}), \kbd{avec} (\kbd{fl=1}), or
index \kbd{m} (\kbd{fl=2}).
\bprog
? zetamultconvert(10)
%1 = Vecsmall([3, 2])
? zetamultconvert(13)
%2 = Vecsmall([2, 2, 1])
? zetamultconvert(10, 0)
%3 = Vecsmall([0, 0, 1, 0, 1])
? zetamultconvert(13, 0)
%4 = Vecsmall([0, 1, 0, 1, 1])
@eprog\noindent The last two lines imply that $[3,2]$ and $[2,2,1]$
are dual (reverse order of bits and swap $0$ and $1$ in \kbd{evec} form).
Hence they have the same zeta value:
\bprog
? zetamult([3,2])
%5 = 0.22881039760335375976874614894168879193
? zetamult([2,2,1])
%6 = 0.22881039760335375976874614894168879193
@eprog

The library syntax is \fun{GEN}{zetamultconvert}{GEN a, long fl}.

\subsec{zetamultdual$(s)$}\kbdsidx{zetamultdual}\label{se:zetamultdual}
$s$ being either an \kbd{evec}, \kbd{avec}, or index \kbd{m},
return the dual sequence in \kbd{avec} format.
The dual of a sequence of  length $r$ and weight $k$ has length $k-r$ and
weight $k$. Duality is an involution and zeta values attached to
dual sequences are the same:
\bprog
? zetamultdual([4])
%1 = Vecsmall([2, 1, 1])
? zetamultdual(%)
%2 = Vecsmall([4])
? zetamult(%1) - zetamult(%2)
%3 = 0.E-38
@eprog
In \kbd{evec} form, duality simply reverses the order of bits and swaps $0$
and $1$:
\bprog
? zetamultconvert([4], 0)
%4 = Vecsmall([0, 0, 0, 1])
? zetamultconvert([2,1,1], 0)
%5 = Vecsmall([0, 1, 1, 1])
@eprog

The library syntax is \fun{GEN}{zetamultdual}{GEN s}.

\section{Sums, products, integrals and similar functions}
\label{se:sums}

Although the \kbd{gp} calculator is programmable, it is useful to have
a number of preprogrammed loops, including sums, products, and a certain
number of recursions. Also, a number of functions from numerical analysis
like numerical integration and summation of series will be described here.

One of the parameters in these loops must be the control variable, hence a
simple variable name. In the descriptions, the letter $X$ will always denote
any simple variable name, and represents the formal parameter used in the
function. The expression to be summed, integrated, etc. is any legal PARI
expression, including of course expressions using loops.

\misctitle{Library mode}
Since it is easier to program directly the loops in library mode, these
functions are mainly useful for GP programming. On the other hand, numerical
routines code a function (to be integrated, summed, etc.) with two parameters
named
\bprog
  GEN (*eval)(void*,GEN)
  void *E;  \\ context: eval(E, x) must evaluate your function at x.
@eprog\noindent
see the Libpari manual for details.

\misctitle{Numerical integration}\sidx{numerical integration}
The ``double exponential'' (DE) univariate
integration method is implemented in \tet{intnum} and its variants. Romberg
integration is still available under the name \tet{intnumromb}, but
superseded. It is possible to compute numerically integrals to thousands of
decimal places in reasonable time, as long as the integrand is regular. It is
also reasonable to compute numerically integrals in several variables,
although more than two becomes lengthy. The integration domain may be
noncompact, and the integrand may have reasonable singularities at
endpoints. To use \kbd{intnum}, you must split the integral into a sum
of subintegrals where the function has no singularities except at the
endpoints. Polynomials in logarithms are not considered singular, and
neglecting these logs, singularities are assumed to be algebraic (asymptotic
to $C(x-a)^{-\alpha}$ for some $\alpha > -1$ when $x$ is
close to $a$), or to correspond to simple discontinuities of some (higher)
derivative of the function. For instance, the point $0$ is a singularity of
$\text{abs}(x)$.

Assume the bitprecision is $b$, so we try to achieve an absolute error less
than $2^{-b}$. DE methods use $O(b \log b)$ function evaluations and should
work for both compact and non-compact intervals as long as the integrand is
the restriction of an analytic function to a suitable domain and its behaviour
at infinity is correctly described.
When integrating regular functions on a \emph{compact} interval, away from
poles of the integrand, Gauss-Legendre integration (\tet{intnumgauss})
is the best choice, using $O(b)$ function evaluations. To integrate
oscillating functions on non-compact interval, the slower but robust
\tet{intnumosc} is available, performing Gaussian integration on intervals of
length the half-period (or quasi-period) and using Sidi's $mW$ algorithm to
extrapolate their sum. If poles are close to the integration interval,
Gaussian integration may run into difficulties and it is then advisable to
split the integral using \kbd{intnum} to get away from poles, then
\kbd{intnumosc} for the remainder.

For maximal efficiency, abscissas and integration
weights can be precomputed, respectively using \tet{intnuminit} ($O(b^2)$)
or \tet{intnumgaussinit} ($O(b^3)$).

\misctitle{Numerical summation}\sidx{numerical summation}

Many numerical summation methods are available to approximate
$\sum_{n\geq n_0} f(n)$ at accuracy $2^{-b}$: the overall best choice should
be \tet{sumnum}, which uses Euler-MacLaurin (and $O(b\log b)$ function
evaluations); initialization time (\tet{sumnuminit}) is $O(b^3)$.
Also available are

\item Abel-Plana summation (\tet{sumnumap}),
also $O(b\log b)$ function evaluations and $O(b^3)$ initialization
(\tet{sumnumapinit}) with a larger implied constant;

\item Lagrange summation (\tet{sumnumlagrange}) uses $O(b)$ evaluations
but more brittle and the asymptotic behaviour of $f$ must be correctly
indicated. Initialization (\tet{sumnumlagrangeinit}) can vary from $O(b^2)$
to $O(b^3)$ depending on the asymptotic behaviour.

\item Sidi summation (\tet{sumnumsidi}) uses $O(b)$ evaluations and should
be more robust than Lagrange summation. No initialization is needed.

\item Monien summation (\tet{sumnummonien}) uses $O(b/\log b)$ evaluations
but is even more brittle than Lagrange and also has a $O(b^3)$ initialization
(\kbd{summonieninit}).

\item To sum rational functions, use \tet{sumnumrat}.

All the function so far require $f$ to be be the restriction to integers
of a regular function on the reals, and even on the complex numbers for
Monien summation. The following algorithms allow functions defined
only on the integers, under asumptions that are hard to verify. They are
best used heuristically since they in fact are often valid when those
asumptions do not hold, and for instance often yield a result for divergent
series (e.g., Borel resummation).

\item To sum alternating series, use \tet{sumalt}, which requires
$O(b)$ function evaluations.

\item To sum functions of a fixed sign, \tet{sumpos}
uses van Wijngarten's trick to reduce to an alternating series,
for a cost of $O(b\log b)$ function evaluations but beware that $f$ must be
evaluated at large integers, of the order of $2^{b/\alpha}$ if we assume
that $f(n) = O(1 / n^{\alpha+1})$ for some $\alpha > 0$.

\subsec{asympnum$(\var{expr},\{\var{alpha} = 1\})$}\kbdsidx{asympnum}\label{se:asympnum}
Asymptotic expansion of \var{expr}, corresponding to a sequence $u(n)$,
assuming it has the shape
$$u(n) \approx \sum_{i \geq 0} a_i n^{-i\alpha}$$
with rational coefficients $a_i$ with reasonable height; the algorithm
is heuristic and performs repeated calls to limitnum, with
\kbd{alpha} as in \kbd{limitnum}. As in \kbd{limitnum}, $u(n)$ may be
given either by a closure $n\mapsto u(n)$ or as a closure $N\mapsto
[u(1),\dots,u(N)]$, the latter being often more efficient.
\bprog
? f(n) = n! / (n^n*exp(-n)*sqrt(n));
? asympnum(f)
%2 = []   \\ failure !
? localprec(57); l = limitnum(f)
%3 = 2.5066282746310005024157652848110452530
? asympnum(n->f(n)/l) \\ normalize
%4 =  [1, 1/12, 1/288, -139/51840, -571/2488320, 163879/209018880,
       5246819/75246796800]
@eprog\noindent and we indeed get a few terms of Stirling's expansion. Note
that it definitely helps to normalize with a limit computed to higher
accuracy (as a rule of thumb, multiply the bit accuracy by $1.612$):
\bprog
? l = limitnum(f)
? asympnum(n->f(n) / l) \\ failure again !!!
%6 = []
@eprog\noindent We treat again the example of the Motzkin numbers $M_n$ given
in \kbd{limitnum}:
\bprog
\\ [M_k, M_{k*2}, ..., M_{k*N}] / (3^n / n^(3/2))
? vM(N, k = 1) =
{ my(q = k*N, V);
   if (q == 1, return ([1/3]));
   V = vector(q); V[1] = V[2] = 1;
   for(n = 2, q - 1,
     V[n+1] = ((2*n + 1)*V[n] + 3*(n - 1)*V[n-1]) / (n + 2));
   f = (n -> 3^n / n^(3/2));
   return (vector(N, n, V[n*k] / f(n*k)));
}
? localprec(100); l = limitnum(n->vM(n,10)); \\ 3/sqrt(12*Pi)
? \p38
? asympnum(n->vM(n,10)/l)
%2 = [1, -3/32, 101/10240, -1617/1638400, 505659/5242880000, ...]
@eprog

If \kbd{alpha} is not a rational number, loss of accuracy is
expected, so it should be precomputed to double accuracy, say:
\bprog
? \p38
? asympnum(n->log(1+1/n^Pi),Pi)
%1 = [0, 1, -1/2, 1/3, -1/4, 1/5]
? localprec(76); a = Pi;
? asympnum(n->log(1+1/n^Pi), a) \\ more terms
%3 = [0, 1, -1/2, 1/3, -1/4, 1/5, -1/6, 1/7, -1/8, 1/9, -1/10, 1/11, -1/12]
? asympnum(n->log(1+1/sqrt(n)),1/2) \\ many more terms
%4 = 49
@eprog The expression is evaluated for $n = 1, 2, \dots, N$
for an $N = O(B)$ if the current bit accuracy is $B$. If it is not defined
for one of these values, translate or rescale accordingly:
\bprog
? asympnum(n->log(1-1/n))  \\ can't evaluate at n = 1 !
 ***   at top-level: asympnum(n->log(1-1/n))
 ***                 ^-----------------------
 ***   in function asympnum: log(1-1/n)
 ***                         ^----------
 *** log: domain error in log: argument = 0
? asympnum(n->-log(1-1/(2*n)))
%5 = [0, 1/2, 1/8, 1/24, ...]
? asympnum(n->-log(1-1/(n+1)))
%6 = [0, 1, -1/2, 1/3, -1/4, ...]
@eprog\noindent

\synt{asympnum}{void *E, GEN (*u)(void *,GEN,long), GEN alpha, long prec}, where \kbd{u(E, n, prec)} must return either $u(n)$ or $[u(1),\dots,u(n)]$
in precision \kbd{prec}. Also available is
\fun{GEN}{asympnum0}{GEN u, GEN alpha, long prec}, where $u$ is a closure
as above or a vector of sufficient length.

\subsec{asympnumraw$(\var{expr},N,\{\var{alpha} = 1\})$}\kbdsidx{asympnumraw}\label{se:asympnumraw}
Return the $N+1$ first terms of asymptotic expansion of \var{expr},
corresponding to a sequence $u(n)$, as floating point numbers. Assume
that the expansion has the shape
$$u(n) \approx \sum_{i \geq 0} a_i n^{-i\alpha}$$
and return approximation of $[a_0, a_1,\dots, a_N]$.
The algorithm is heuristic and performs repeated calls to limitnum, with
\kbd{alpha} as in \kbd{limitnum}. As in \kbd{limitnum}, $u(n)$ may be
given either by a closure $n\mapsto u(n)$ or as a closure $N\mapsto
[u(1),\dots,u(N)]$, the latter being often more efficient. This function
is related to, but  more flexible than, \kbd{asympnum}, which requires
rational asymptotic expansions.
\bprog
? f(n) = n! / (n^n*exp(-n)*sqrt(n));
? asympnum(f)
%2 = []   \\ failure !
? v = asympnumraw(f, 10);
? v[1] - sqrt(2*Pi)
%4 = 0.E-37
? bestappr(v / v[1], 2^60)
%5 =  [1, 1/12, 1/288, -139/51840, -571/2488320, 163879/209018880,...]
@eprog\noindent and we indeed get a few terms of Stirling's expansion (the
first 9 terms are correct).
If $u(n)$ has an asymptotic expansion in $n^{-\alpha}$ with $\alpha$ not an
integer, the default $alpha=1$ is inaccurate:
\bprog
? f(n) = (1+1/n^(7/2))^(n^(7/2));
? v1 = asympnumraw(f,10);
? v1[1] - exp(1)
%8 = 4.62... E-12
? v2 = asympnumraw(f,10,7/2);
? v2[1] - exp(1)
%7 0.E-37
@eprog\noindent
As in \kbd{asympnum}, if \kbd{alpha} is not a rational number,
loss of accuracy is expected, so it should be precomputed to double
accuracy, say.

\synt{asympnumraw}{void *E, GEN (*u)(void *,GEN,long), long N, GEN alpha, long prec}, where \kbd{u(E, n, prec)} must return either $u(n)$ or
$[u(1),\dots,u(n)]$ in precision \kbd{prec}.
Also available is
\fun{GEN}{asympnumraw0}{GEN u, GEN alpha, long prec} where $u$ is either
a closure as above or a vector of sufficient length.

\subsec{contfraceval$(\var{CF},t,\{\var{lim}=-1\})$}\kbdsidx{contfraceval}\label{se:contfraceval}
Given a continued fraction \kbd{CF} output by \kbd{contfracinit}, evaluate
the first \kbd{lim} terms of the continued fraction at \kbd{t} (all
terms if \kbd{lim} is negative or omitted; if positive, \kbd{lim} must be
less than or equal to the length of \kbd{CF}.

The library syntax is \fun{GEN}{contfraceval}{GEN CF, GEN t, long lim}.

\subsec{contfracinit$(M,\{\var{lim} = -1\})$}\kbdsidx{contfracinit}\label{se:contfracinit}
Given $M$ representing the power series $S=\sum_{n\ge0} M[n+1]z^n$,
transform it into a continued fraction in Euler form, using the
quotient-difference algorithm; restrict to
$n\leq \kbd{lim}$ if latter is nonnegative. $M$ can be a vector, a power
series, a polynomial; if the limiting parameter \kbd{lim} is present, a
rational function is also allowed (and converted to a power series of that
accuracy).

The result is a 2-component vector $[A,B]$ such that
$S = M[1] / (1+A[1]z+B[1]z^2/(1+A[2]z+B[2]z^2/(1+\dots 1/(1+A[lim/2]z))))$.
Does not work if any coefficient of $M$ vanishes, nor for series for
which certain partial denominators vanish.

The library syntax is \fun{GEN}{contfracinit}{GEN M, long lim}.
Also available is
\fun{GEN}{quodif}{GEN M, long n}
which returns the standard continued fraction, as a vector $C$ such that
$S = c[1] / (1 + c[2]z / (1+c[3]z/(1+\dots...c[lim]z)))$.

\subsec{derivnum$(X=a,\var{expr},\{\var{ind}=1\})$}\kbdsidx{derivnum}\label{se:derivnum}
Numerical derivation of \var{expr} with respect to $X$ at $X=a$. The
order of derivation is 1 by default.

\bprog
? derivnum(x=0, sin(exp(x))) - cos(1)
%1 = 0.E-38
@eprog
A clumsier approach, which would not work in library mode, is
\bprog
? f(x) = sin(exp(x))
? f'(0) - cos(1)
%2 = 0.E-38
@eprog

\item When $a$ is a numerical type (integer, rational number, real number or
\typ{COMPLEX} of such), performs numerical derivation.

\item When $a$ is a (polynomial, rational function or) power series, compute
\kbd{derivnum(t=a,f)} as $f'(a) = (f(a))'/a'$:
\bprog
? derivnum(x = 1 + t, sqrt(x))
%1 = 1/2 - 1/4*t + 3/16*t^2 - 5/32*t^3 + ... + O(t^16)
? derivnum(x = 1/(1 + t), sqrt(x))
%2 = 1/2 + 1/4*t - 1/16*t^2 + 1/32*t^3 + ... + O(t^16)
? derivnum(x = 1 + t + O(t^17), sqrt(x))
%3 = 1/2 - 1/4*t + 3/16*t^2 - 5/32*t^3 + ... + O(t^16)
@eprog

If the parameter \var{ind} is present, it can be

\item a nonnegative integer $m$, in which case we return $f^{(m)}(x)$;

\item or a vector of orders, in which case we return the vector of
derivatives.

\bprog
? derivnum(x = 0, exp(sin(x)), 16) \\ 16-th derivative
%1 = -52635599.000000000000000000000000000000

? round( derivnum(x = 0, exp(sin(x)), [0..13]) )  \\ 0-13-th derivatives
%2 = [1, 1, 1, 0, -3, -8, -3, 56, 217, 64, -2951, -12672, 5973, 309376]
@eprog

\synt{derivfunk}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN ind, long prec}.
Also available is
\fun{GEN}{derivfun}{void *E, GEN (*eval)(void *, GEN), GEN a, long prec}.
If $a$ is a numerical type (\typ{INT}, \typ{FRAC}, \typ{REAL} or
\typ{COMPLEX} of such, we have
\fun{GEN}{derivnumk}{void *E, GEN (*eval)(void *, GEN, long), GEN a, GEN ind, long prec}
and
\fun{GEN}{derivnum}{void *E, GEN (*eval)(void *, GEN, long prec), GEN a, long prec}

\subsec{intcirc$(X=a,R,\var{expr},\{\var{tab}\})$}\kbdsidx{intcirc}\label{se:intcirc}
Numerical
integration of $(2i\pi)^{-1}\var{expr}$ with respect to $X$ on the circle
$|X-a| = R$.
In other words, when \var{expr} is a meromorphic
function, sum of the residues in the corresponding disk; \var{tab} is as in
\kbd{intnum}, except that if computed with \kbd{intnuminit} it should be with
the endpoints \kbd{[-1, 1]}.

\bprog
? \p105
? intcirc(s=1, 0.5, zeta(s)) - 1
time = 496 ms.
%1 = 1.2883911040127271720 E-101 + 0.E-118*I
@eprog

\synt{intcirc}{void *E, GEN (*eval)(void*,GEN), GEN a,GEN R,GEN tab, long prec}.

\subsec{intfuncinit$(t=a,b,f,\{m=0\})$}\kbdsidx{intfuncinit}\label{se:intfuncinit}
Initialize tables for use with integral transforms (such as Fourier,
Laplace or Mellin transforms) in order to compute
$$ \int_a^b f(t) k(t,z) \, dt $$
for some kernel $k(t,z)$.
The endpoints $a$ and $b$ are coded as in \kbd{intnum}, $f$ is the
function to which the integral transform is to be applied and the
nonnegative integer $m$ is as in \kbd{intnum}: multiply the number of
sampling points roughly by $2^m$, hopefully increasing the accuracy. This
function is particularly useful when the function $f$ is hard to compute,
such as a gamma product.

\misctitle{Limitation} The endpoints $a$ and $b$ must be at infinity,
with the same asymptotic behavior. Oscillating types are not supported.
This is easily overcome by integrating vectors of functions, see example
below.

\misctitle{Examples}

\item numerical Fourier transform
$$F(z) = \int_{-\infty}^{+\infty} f(t)e^{-2i\pi z t}\, dt. $$
First the easy case, assume that $f$ decrease exponentially:
\bprog
   f(t) = exp(-t^2);
   A = [-oo,1];
   B = [+oo,1];
   \p200
   T = intfuncinit(t = A,B , f(t));
   F(z) =
   { my(a = -2*I*Pi*z);
     intnum(t = A,B, exp(a*t), T);
   }
   ? F(1) - sqrt(Pi)*exp(-Pi^2)
   %1 = -1.3... E-212
@eprog\noindent
Now the harder case, $f$ decrease slowly: we must specify the oscillating
behavior. Thus, we cannot precompute usefully since everything depends on
the point we evaluate at:
\bprog
   f(t) = 1 / (1+ abs(t));
   \p200
   \\ Fourier cosine transform
   FC(z) =
   { my(a = 2*Pi*z);
     intnum(t = [-oo, a*I], [+oo, a*I], cos(a*t)*f(t));
   }
   FC(1)
@eprog
\item Fourier coefficients: we must integrate over a period, but
\kbd{intfuncinit} does not support finite endpoints.
The solution is to integrate a vector of functions !
\bprog
FourierSin(f, T, k) =  \\ first k sine Fourier coeffs
{
  my (w = 2*Pi/T);
  my (v = vector(k+1));
  intnum(t = -T/2, T/2,
     my (z = exp(I*w*t));
     v[1] = z;
     for (j = 2, k, v[j] = v[j-1]*z);
     f(t) * imag(v)) * 2/T;
}
FourierSin(t->sin(2*t), 2*Pi, 10)
@eprog\noindent The same technique can be used instead of \kbd{intfuncinit}
to integrate $f(t) k(t,z)$ whenever the list of $z$-values is known
beforehand.

Note that the above code includes an unrelated optimization: the
$\sin(j w t)$ are computed as imaginary parts of $\exp(i j w t)$ and the
latter by successive multiplications.

\item numerical Mellin inversion
$$F(z) = (2i\pi)^{-1} \int_{c -i\infty}^{c+i\infty} f(s)z^{-s}\, ds
 = (2\pi)^{-1} \int_{-\infty}^{+\infty}
    f(c + i t)e^{-\log z(c + it)}\, dt. $$
We take $c = 2$ in the program below:
\bprog
   f(s) = gamma(s)^3;  \\ f(c+it) decrease as exp(-3Pi|t|/2)
   c = 2; \\ arbitrary
   A = [-oo,3*Pi/2];
   B = [+oo,3*Pi/2];
   T = intfuncinit(t=A,B, f(c + I*t));
   F(z) =
   { my (a = -log(z));
     intnum(t=A,B, exp(a*I*t), T)*exp(a*c) / (2*Pi);
   }
@eprog

\synt{intfuncinit}{void *E, GEN (*eval)(void*,GEN), GEN a,GEN b,long m, long prec}.

\subsec{intnum$(X=a,b,\var{expr},\{\var{tab}\})$}\kbdsidx{intnum}\label{se:intnum}
Numerical integration
of \var{expr} on $]a,b[$ with respect to $X$, using the
double-exponential method, and thus $O(D\log D)$ evaluation of
the integrand in precision $D$. The integrand may have values
belonging to a vector space over the real numbers; in particular, it can be
complex-valued or vector-valued. But it is assumed that the function is
regular on $]a,b[$. If the endpoints $a$ and $b$ are finite and the
function is regular there, the situation is simple:
\bprog
? intnum(x = 0,1, x^2)
%1 = 0.3333333333333333333333333333
? intnum(x = 0,Pi/2, [cos(x), sin(x)])
%2 = [1.000000000000000000000000000, 1.000000000000000000000000000]
@eprog\noindent
An endpoint equal to $\pm\infty$ is coded as \kbd{+oo} or \kbd{-oo}, as
expected:
\bprog
? intnum(x = 1,+oo, 1/x^2)
%3 = 1.000000000000000000000000000
@eprog\noindent
In basic usage, it is assumed that the function does not decrease
exponentially fast at infinity:
\bprog
? intnum(x=0,+oo, exp(-x))
  ***   at top-level: intnum(x=0,+oo,exp(-
  ***                 ^--------------------
  *** exp: overflow in expo().
@eprog\noindent
We shall see in a moment how to avoid that last problem, after describing
the last \emph{optional} argument \var{tab}.

\misctitle{The \var{tab} argument} The routine uses weights $w_i$, which are
mostly independent of the function
being integrated, evaluated at many sampling points $x_i$ and
approximates the integral by $\sum w_i f(x_i)$. If \var{tab} is

\item a nonnegative integer $m$, we multiply the number of sampling points
by $2^m$, hopefully increasing accuracy. Note that the running time
increases roughly by a factor $2^m$. One may try consecutive values of $m$
until they give the same value up to an accepted error.

\item a set of integration tables containing precomputed $x_i$ and $w_i$
as output by \tet{intnuminit}. This is useful if several integrations of
the same type are performed (on the same kind of interval and functions,
for a given accuracy): we skip a precomputation of $O(D\log D)$
elementary functions in accuracy $D$, whose running time has the same order
of magnitude as the evaluation of the integrand. This is in particular
useful for multivariate integrals.

\misctitle{Specifying the behavior at endpoints} This is done as follows.
An endpoint $a$ is either given as such (a scalar,
real or complex, \kbd{oo} or \kbd{-oo} for $\pm\infty$), or as a two
component vector $[a,\alpha]$, to indicate the behavior of the integrand in a
neighborhood of $a$.

If $a$ is finite, the code $[a,\alpha]$ means the function has a
singularity of the form $(x-a)^{\alpha}$, up to logarithms. (If $\alpha \ge
0$, we only assume the function is regular, which is the default assumption.)
If a wrong singularity exponent is used, the result will lose decimals:
\bprog
? c = -9/10;
? intnum(x=0, 1, x^c)         \\@com assume $x^{-9/10}$ is regular at 0
%1 = 9.9999839078827082322596783301939063944
? intnum(x=[0,c], 1, x^c)  \\@com no, it's not
%2 = 10.000000000000000000000000000000000000
? intnum(x=[0,c/2], 1, x^c) \\@com using a wrong exponent is bad
%3 = 9.9999999997122749095442279375719919769
@eprog

If $a$ is $\pm\infty$, which is coded as \kbd{+oo} or \kbd{-oo},
the situation is more complicated, and $[\pm\kbd{oo},\alpha]$ means:

\item $\alpha=0$ (or no $\alpha$ at all, i.e. simply $\pm\kbd{oo}$)
assumes that the integrand tends to zero moderately quickly, at least as
$O(x^{-2})$ but not exponentially fast.

\item $\alpha>0$ assumes that the function tends to zero exponentially fast
approximately as $\exp(-\alpha|x|)$. This includes oscillating but quickly
decreasing functions such as $\exp(-x)\sin(x)$.
\bprog
? intnum(x=0, +oo, exp(-2*x))
  ***   at top-level: intnum(x=0,+oo,exp(-
  ***                 ^--------------------
  *** exp: exponent (expo) overflow
? intnum(x=0, [+oo, 2], exp(-2*x))  \\@com OK!
%1 = 0.50000000000000000000000000000000000000
? intnum(x=0, [+oo, 3], exp(-2*x))  \\@com imprecise exponent, still OK !
%2 = 0.50000000000000000000000000000000000000
? intnum(x=0, [+oo, 10], exp(-2*x)) \\@com wrong exponent $\Rightarrow$ disaster
%3 = 0.49999999999952372962457451698256707393
@eprog\noindent As the last exemple shows, the exponential decrease rate
\emph{must} be indicated to avoid overflow, but the method is robust enough
for a rough guess to be acceptable.

\item $\alpha<-1$ assumes that the function tends to $0$ slowly, like
$x^{\alpha}$. Here the algorithm is less robust and it is essential to give a
sharp $\alpha$, unless $\alpha \le -2$ in which case we use
the default algorithm as if $\alpha$ were missing (or equal to $0$).
\bprog
? intnum(x=1, +oo, x^(-3/2))         \\ default
%1 = 1.9999999999999999999999999999646391207
? intnum(x=1, [+oo,-3/2], x^(-3/2))  \\ precise decrease rate
%2 = 2.0000000000000000000000000000000000000
? intnum(x=1, [+oo,-11/10], x^(-3/2)) \\ worse than default
%3 = 2.0000000000000000000000000089298011973
@eprog

\smallskip The last two codes are reserved for oscillating functions.
Let $k > 0$ real, and $g(x)$ a nonoscillating function tending slowly to $0$
(e.g. like a negative power of $x$), then

\item $\alpha=k * I$ assumes that the function behaves like $\cos(kx)g(x)$.

\item $\alpha=-k* I$ assumes that the function behaves like $\sin(kx)g(x)$.

\noindent Here it is critical to give the exact value of $k$. If the
oscillating part is not a pure sine or cosine, one must expand it into a
Fourier series, use the above codings, and sum the resulting contributions.
Otherwise you will get nonsense. Note that $\cos(kx)$, and similarly
$\sin(kx)$, means that very function, and not a translated version such as
$\cos(kx+a)$. Note that the (slower) function \kbd{intnumosc} is more robust
and should be able to integrate much more general quasi-periodic functions
such as fractional parts or Bessel $J$ and $Y$ functions.

\bprog
? \pb1664
? exponent(intnum(x=0,+oo, sinc(x)) - Pi/2)
time = 308 ms.
%1 = 5 \\ junk
? exponent(intnum(x=0,[+oo,-I], sinc(x)) - Pi/2)
time = 493 ms.
%2 = -1663 \\ perfect when k is given
? exponent(intnum(x=0,[+oo,-0.999*I], sinc(x)) - Pi/2)
time = 604 ms.
%3 = -14 \\ junk when k is off

\\ intnumosc requires the half-period
? exponent(intnumosc(x=0, sinc(x), Pi) - Pi/2)
time = 20,570 ms.
%4 = -1663 \\ slower but perfect
? exponent(intnumosc(x=0, sinc(x), Pi, 1) - Pi/2)
time = 7,976 ms.
%4 = -1663 \\ also perfect in fast unsafe mode
? exponent(intnumosc(x=0, sinc(x), Pi+0.001, 1) - Pi/2)
time = 23,115 ms.
%5 = -1278 \\ loses some accuracy when period is off, but much less
@eprog

\misctitle{Note} If $f(x)=\cos(kx)g(x)$ where $g(x)$ tends to zero
exponentially fast as $\exp(-\alpha x)$, it is up to the user to choose
between $[\pm\kbd{oo},\alpha]$ and $[\pm\kbd{oo},k* I]$, but a good rule of
thumb is that
if the oscillations are weaker than the exponential decrease, choose
$[\pm\kbd{oo},\alpha]$, otherwise choose $[\pm\kbd{oo},k*I]$, although the
latter can reasonably be used in all cases, while the former cannot. To take
a specific example, in most inverse Mellin transforms, the integrand is a
product of an exponentially decreasing and an oscillating factor. If we
choose the oscillating type of integral we perhaps obtain the best results,
at the expense of having to recompute our functions for a different value of
the variable $z$ giving the transform, preventing us to use a function such
as \kbd{intfuncinit}. On the other hand using the exponential type of
integral, we obtain less accurate results, but we skip expensive
recomputations. See \kbd{intfuncinit} for more explanations.

\misctitle{Power series limits}
The limits $a$ and $b$ can be power series of nonnegative valuation,
giving a power series expansion for the integral -- provided it exists.
\bprog
? intnum(t=0,X + O(X^3), exp(t))
%4 = 1.000...*X - 0.5000...*X^2 + O(X^3)
? bestappr( intnum(t=0,X + O(X^17), exp(t)) )- exp(X) + 1
%5 = O(X^17)
@eprog\noindent The valuation of the limit cannot be negative
since $\int_0^{1/X}(1+t^2)^{-1}\, dt = \pi/2 - \kbd{sign}(X)+O(X^2)$.

Polynomials and rational functions are also allowed and
converted to power series using current \kbd{seriesprecision}:
\bprog
? bestappr( intnum(t=1,1+X, 1/t) )
%6 = X - 1/2*X^2 + 1/3*X^3 - 1/4*X^4 + [...] + 1/15*X^15 + O(X^16)
@eprog\noindent
The function does not work if the integral is singular with the constant
coefficient of the series as limit:
\bprog
? intnum(t=X^2+O(X^4),1, 1/sqrt(t))
%8 = 2.000... - 6.236608109630992528 E28*X^2 + O(X^4)
@eprog\noindent
however you can use
\bprog
? intnum(t=[X^2+O(X^4),-1/2],1, 1/sqrt(t))
%10 = 2.000000000000000000000000000-2.000000000000000000000000000*X^2+O(X^4)
@eprog\noindent whis is translated internally to
\bprog
? intnum(t=[0,-1/2],1, 1/sqrt(t))-intnum(t=[0,-1/2],X^2+O(X^4), 1/sqrt(t))
@eprog\noindent
For this form the argument \var{tab} can be used only as an integer, not a
table precomputed by \kbd{intnuminit}.

\smallskip

We shall now see many examples to get a feeling for what the various
parameters achieve. All examples below assume precision is set to $115$
decimal digits. We first type
\bprog
? \p 115
@eprog

\misctitle{Apparent singularities} In many cases, apparent singularities
can be ignored. For instance, if $f(x) = 1
/(\exp(x)-1) - \exp(-x)/x$, then $\int_0^\infty f(x)\,dx=\gamma$, Euler's
constant \kbd{Euler}. But

\bprog
? f(x) = 1/(exp(x)-1) - exp(-x)/x
? intnum(x = 0, [oo,1],  f(x)) - Euler
%1 = 0.E-115
@eprog\noindent
But close to $0$ the function $f$ is computed with an enormous loss of
accuracy, and we are in fact lucky that it get multiplied by weights which are
sufficiently close to $0$ to hide this:
\bprog
? f(1e-200)
%2 = -3.885337784451458142 E84
@eprog

A more robust solution is to define the function differently near special
points, e.g. by a Taylor expansion
\bprog
? F = truncate( f(t + O(t^10)) ); \\@com expansion around t = 0
? poldegree(F)
%4 = 7
? g(x) = if (x > 1e-18, f(x), subst(F,t,x)); \\@com note that $7 \cdot 18 > 105$
? intnum(x = 0, [oo,1],  g(x)) - Euler
%2 = 0.E-115
@eprog\noindent It is up to the user to determine constants such as the
$10^{-18}$ and $10$ used above.

\misctitle{True singularities} With true singularities the result is worse.
For instance

\bprog
? intnum(x = 0, 1,  x^(-1/2)) - 2
%1 = -3.5... E-68 \\@com only $68$ correct decimals

? intnum(x = [0,-1/2], 1,  x^(-1/2)) - 2
%2 = 0.E-114 \\@com better
@eprog

\misctitle{Oscillating functions}

\bprog
? intnum(x = 0, oo, sin(x) / x) - Pi/2
%1 = 16.19.. \\@com nonsense
? intnum(x = 0, [oo,1], sin(x)/x) - Pi/2
%2 = -0.006.. \\@com bad
? intnum(x = 0, [oo,-I], sin(x)/x) - Pi/2
%3 = 0.E-115 \\@com perfect
? intnum(x = 0, [oo,-I], sin(2*x)/x) - Pi/2  \\@com oops, wrong $k$
%4 = 0.06...
? intnum(x = 0, [oo,-2*I], sin(2*x)/x) - Pi/2
%5 = 0.E-115 \\@com perfect

? intnum(x = 0, [oo,-I], sin(x)^3/x) - Pi/4
%6 = -0.0008... \\@com bad
? sin(x)^3 - (3*sin(x)-sin(3*x))/4
%7 = O(x^17)
@eprog\noindent
We may use the above linearization and compute two oscillating integrals with
endpoints \kbd{[oo, -I]} and \kbd{[oo, -3*I]} respectively, or
notice the obvious change of variable, and reduce to the single integral
${1\over 2}\int_0^\infty \sin(x)/x\,dx$. We finish with some more complicated
examples:

\bprog
? intnum(x = 0, [oo,-I], (1-cos(x))/x^2) - Pi/2
%1 = -0.0003... \\@com bad
? intnum(x = 0, 1, (1-cos(x))/x^2) \
+ intnum(x = 1, oo, 1/x^2) - intnum(x = 1, [oo,I], cos(x)/x^2) - Pi/2
%2 = 0.E-115 \\@com perfect

? intnum(x = 0, [oo, 1], sin(x)^3*exp(-x)) - 0.3
%3 = -7.34... E-55 \\@com bad
? intnum(x = 0, [oo,-I], sin(x)^3*exp(-x)) - 0.3
%4 = 8.9... E-103 \\@com better. Try higher $m$
? tab = intnuminit(0,[oo,-I], 1); \\@com double number of sampling points
? intnum(x = 0, oo, sin(x)^3*exp(-x), tab) - 0.3
%6 = 0.E-115 \\@com perfect
@eprog

\misctitle{Warning} Like \tet{sumalt}, \kbd{intnum} often assigns a
reasonable value to diverging integrals. Use these values at your own risk!
For example:

\bprog
? intnum(x = 0, [oo, -I], x^2*sin(x))
%1 = -2.0000000000...
@eprog\noindent
Note the formula
$$ \int_0^\infty \sin(x)/x^s\,dx = \cos(\pi s/2) \Gamma(1-s)\;, $$
a priori valid only for $0 < \Re(s) < 2$, but the right hand side provides an
analytic continuation which may be evaluated at $s = -2$\dots

\misctitle{Multivariate integration}
Using successive univariate integration with respect to different formal
parameters, it is immediate to do naive multivariate integration. But it is
important to use a suitable \kbd{intnuminit} to precompute data for the
\emph{internal} integrations at least!

For example, to compute the double integral on the unit disc $x^2+y^2\le1$
of the function $x^2+y^2$, we can write
\bprog
? tab = intnuminit(-1,1);
? intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2, tab),tab) - Pi/2
%2 = -7.1... E-115 \\@com OK

@eprog\noindent
The first \var{tab} is essential, the second optional. Compare:

\bprog
? tab = intnuminit(-1,1);
time = 4 ms.
? intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2));
time = 3,092 ms. \\@com slow
? intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2, tab), tab);
time = 252 ms.  \\@com faster
? intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2, tab));
time = 261 ms.  \\@com the \emph{internal} integral matters most
@eprog

\synt{intnum}{void *E, GEN (*eval)(void*,GEN), GEN a,GEN b,GEN tab, long prec},
where an omitted \var{tab} is coded as \kbd{NULL}.

\subsec{intnumgauss$(X=a,b,\var{expr},\{\var{tab}\})$}\kbdsidx{intnumgauss}\label{se:intnumgauss}
Numerical integration of \var{expr} on the compact interval $[a,b]$ with
respect to $X$ using Gauss-Legendre quadrature; \kbd{tab} is either omitted
or precomputed with \kbd{intnumgaussinit}. As a convenience, it can be an
integer $n$ in which case we call
\kbd{intnumgaussinit}$(n)$ and use $n$-point quadrature.
\bprog
? test(n, b = 1) = T=intnumgaussinit(n);\
    intnumgauss(x=-b,b, 1/(1+x^2),T) - 2*atan(b);
? test(0) \\ default
%1 = -9.490148553624725335 E-22
? test(40)
%2 = -6.186629001816965717 E-31
? test(50)
%3 = -1.1754943508222875080 E-38
? test(50, 2) \\ double interval length
%4 = -4.891779568527713636 E-21
? test(90, 2) \\ n must almost be doubled as well!
%5 = -9.403954806578300064 E-38
@eprog\noindent On the other hand, we recommend to split the integral
and change variables rather than increasing $n$ too much:
\bprog
? f(x) = 1/(1+x^2);
? b = 100;
? intnumgauss(x=0,1, f(x)) + intnumgauss(x=1,1/b, f(1/x)*(-1/x^2)) - atan(b)
%3 = -1.0579449157400587572 E-37
@eprog

The library syntax is \fun{GEN}{intnumgauss0}{GEN X, GEN b, GEN expr, GEN tab = NULL, long prec}.

\subsec{intnumgaussinit$(\{n\})$}\kbdsidx{intnumgaussinit}\label{se:intnumgaussinit}
Initialize tables for $n$-point Gauss-Legendre integration of
a smooth function $f$ on a compact interval $[a,b]$. If $n$ is omitted, make a
default choice $n \approx B / 4$, where $B$ is
\kbd{realbitprecision}, suitable for analytic functions on $[-1,1]$.
The error is bounded by
$$
   \dfrac{(b-a)^{2n+1} (n!)^4}{(2n+1)!(2n)!} \dfrac{f^{(2n)}}{(2n)!} (\xi) ,
   \qquad a < \xi < b.
$$
If $r$ denotes the distance of the nearest pole to the interval $[a,b]$,
then this is of the order of $((b-a) / (4r))^{2n}$. In particular, the
integral must be subdivided if the interval length $b - a$ becomes close to
$4r$. The default choice $n \approx B / 4$ makes this quantity of order
$2^{-B}$ when $b - a = r$, as is the case when integrating $1/(1+t)$ on
$[0,1]$ for instance. If the interval length increases, $n$ should be
increased as well.

Specifically, the function returns a pair of vectors $[x,w]$, where $x$
contains the nonnegative roots of the $n$-th Legendre polynomial $P_n$ and
$w$ the corresponding Gaussian integration weights
$Q_n(x_j)/P'_n(x_j) = 2 / ((1-x_j^2)P'_n(x_j))^2$  such that
$$ \int_{-1}^{1} f(t)\, dt \approx w_j f(x_j)\;. $$

\bprog
? T = intnumgaussinit();
? intnumgauss(t=-1,1,exp(t), T) - exp(1)+exp(-1)
%1 = -5.877471754111437540 E-39
? intnumgauss(t=-10,10,exp(t), T) - exp(10)+exp(-10)
%2 = -8.358367809712546836 E-35
? intnumgauss(t=-1,1,1/(1+t^2), T) - Pi/2 \\ b - a = 2r
%3 = -9.490148553624725335 E-22 \\ ... loses half the accuracy

? T = intnumgaussinit(50);
? intnumgauss(t=-1,1,1/(1+t^2), T) - Pi/2
%5 = -1.1754943508222875080 E-38
? intnumgauss(t=-5,5,1/(1+t^2), T) - 2*atan(5)
%6 = -1.2[...]E-8
@eprog
On the other hand, we recommend to split the integral and change variables
rather than increasing $n$ too much, see \tet{intnumgauss}.

The library syntax is \fun{GEN}{intnumgaussinit}{long n, long prec}.

\subsec{intnuminit$(a,b,\{m=0\})$}\kbdsidx{intnuminit}\label{se:intnuminit}
Initialize tables for integration from
$a$ to $b$, where $a$ and $b$ are coded as in \kbd{intnum}. Only the
compactness, the possible existence of singularities, the speed of decrease
or the oscillations at infinity are taken into account, and not the values.
For instance {\tt intnuminit(-1,1)} is equivalent to {\tt intnuminit(0,Pi)},
and {\tt intnuminit([0,-1/2],oo)} is equivalent to
{\tt intnuminit([-1,-1/2], -oo)}; on the other hand, the order matters
and
{\tt intnuminit([0,-1/2], [1,-1/3])} is \emph{not} equivalent to
{\tt intnuminit([0,-1/3], [1,-1/2])} !

If $m$ is present, it must be nonnegative and we multiply the default
number of sampling points by $2^m$ (increasing the running time by a
similar factor).

The result is technical and liable to change in the future, but we document
it here for completeness. Let $x=\phi(t)$, $t\in ]-\infty,\infty[$ be an
internally chosen change of variable, achieving double exponential decrease of
the integrand at infinity. The integrator \kbd{intnum} will compute
$$ h \sum_{|n| < N} \phi'(nh) F(\phi(nh)) $$
for some integration step $h$ and truncation parameter $N$.
In basic use, let
\bprog
[h, x0, w0, xp, wp, xm, wm] = intnuminit(a,b);
@eprog

\item $h$ is the integration step

\item $x_0 = \phi(0)$  and $w_0 = \phi'(0)$,

\item \var{xp} contains the $\phi(nh)$, $0 < n < N$,

\item \var{xm} contains the $\phi(nh)$, $0 < -n < N$, or is empty.

\item \var{wp} contains the $\phi'(nh)$, $0 < n < N$,

\item \var{wm} contains the $\phi'(nh)$, $0 < -n < N$, or is empty.

The arrays \var{xm} and \var{wm} are left empty when $\phi$ is an odd
function. In complicated situations,
\kbd{intnuminit} may return up to $3$ such arrays, corresponding
to a splitting of up to $3$ integrals of basic type.

If the functions to be integrated later are of the form $F = f(t) k(t,z)$
for some kernel $k$ (e.g. Fourier, Laplace, Mellin, \dots), it is
useful to also precompute the values of $f(\phi(nh))$, which is accomplished
by \tet{intfuncinit}. The hard part is to determine the behavior
of $F$ at endpoints, depending on $z$.

The library syntax is \fun{GEN}{intnuminit}{GEN a, GEN b, long m, long prec}.

\subsec{intnumosc$(x=a,\var{expr},H,\{\fl=0\},\{\var{tab}\})$}\kbdsidx{intnumosc}\label{se:intnumosc}
Numerical integration from $a$ to $\infty$ of oscillating
quasi-periodic function \var{expr} of half-period $H$, meaning that we
at least expect the distance between the function's consecutive zeros to be
close to $H$: the sine or cosine functions ($H = \pi$) are paradigmatic
examples, but the Bessel $J_\nu$ or $Y_\nu$ functions ($H = \pi/2$) can
also be handled. The integral from $a$ to $\infty$ is computed
by summing the integral between two consecutive multiples of $H$;
\fl determines the summation algorithm used: either $0$ (Sidi extrapolation,
safe mode), 1 (Sidi extrapolation, unsafe mode), 2 (\kbd{sumalt}),
3 (\kbd{sumnumlagrange}) or 4 (\kbd{sumpos}). For the last two modes
(Lagrange and Sumpos), one should input the period $2H$ instead of the
half-period $H$.

The default is $\fl = 0$; Sidi summation should be the most
robust algorithm; you can try it in unsafe mode when the integrals between
two consecutive multiples of $H$ form an alternating series, this should be
about twice faster than the default and not lose accuracy. Sumpos should be
by far the slowest method, but also very robust and may be able to handle
integrals where Sidi fails. Sumalt should be fast but often wrong,
especially when the integrals between two consecutive multiples of $H$
do not form an alternating series), and Lagrange should be as fast as Sumalt
but more often wrong.

When one of the Sidi modes runs into difficulties, it will return the result
to the accuracy believed to be correct (the other modes do not perform
extrapolation and do not have this property) :
\bprog
? f(x)=besselj(0,x)^4*log(x+1);
? \pb384
? intnumosc(x = 0, f(x), Pi)
%1 = 0.4549032054850867417 \\ fewer digits than expected !
? bitprecision(%)
%2 = 64
? \g1 \\ increase debug level to see diagnostics
? intnumosc(x = 0, f(x), Pi)
sumsidi: reached accuracy of 23 bits.
%2 = 0.4549032054850867417
@eprog\noindent The algorithm could extrapolate the series to 23 bits of
accuracy, then diverged. So only the absolute error is likely to be
around $2^{-23}$ instead of the possible $2^{-64}$ (or the requested
$2^{-384}$). We'll come back to this example at the end.

In case of difficulties, you may try to replace the half-(quasi)-period $H$
by a multiple, such as the quasi-period $2H$: since we do not expect
alternating behaviour, \kbd{sumalt} mode will almost surely be broken, but
others may improve, in particular Lagrange or Sumpos.

\kbd{tab} is either omitted or precomputed with \kbd{intnumgaussinit};
if using Sidi summation in safe mode ($\fl = 0$) \emph{and} precompute
\kbd{tab}, you should use a precision roughly 50\% larger than the target
(this is not necessary for any of the other summations).

First an alternating example:
\bprog
? \pb384
\\ Sidi, safe mode
? exponent(intnumosc(x=0,sinc(x),Pi) - Pi/2)
time = 183 ms.
%1 = -383
? exponent(intnumosc(x=0,sinc(x),2*Pi) - Pi/2)
time = 224 ms.
%2 = -383 \\ also works with 2H, a little slower

\\ Sidi, unsafe mode
? exponent(intnumosc(x=0,sinc(x),Pi,1) - Pi/2)
time = 79 ms.
%3 = -383  \\ alternating: unsafe mode is fine and almost twice faster
? exponent(intnumosc(x=0,sinc(x),2*Pi,1) - Pi/2)
time = 86 ms.
%4 = -285 \\ but this time 2H loses accuracy

\\ Sumalt
? exponent(intnumosc(x=0,sinc(x),Pi,2) - Pi/2)
time = 115 ms. \\ sumalt is just as accurate and fast
%5 = -383
? exponent(intnumosc(x=0,sinc(x),2*Pi,2) - Pi/2)
time = 115 ms.
%6 = -10 \\ ...but breaks completely with 2H

\\ Lagrange
? exponent(intnumosc(x=0,sinc(x),Pi,2) - Pi/2)
time = 100 ms. \\ junk
%7 = 224
? exponent(intnumosc(x=0,sinc(x),2*Pi,2) - Pi/2)
time = 100 ms.
%8 = -238 \\ ...a little better with 2H

\\ Sumpos
? exponent(intnumosc(x=0,sinc(x),Pi,4) - Pi/2)
time = 17,961 ms.
%9 = 7 \\ junk; slow
? exponent(intnumosc(x=0,sinc(x),2*Pi,4) - Pi/2)
time = 19,105 ms.
%10 = -4 \\ still junk
@eprog

Now a non-alternating one:
\bprog
? exponent(intnumosc(x=0,sinc(x)^2,Pi) - Pi/2)
time = 277 ms.
%1 = -383 \\ safe mode is still perfect
? exponent(intnumosc(x=0,sinc(x)^2,Pi,1) - Pi/2)
time = 97 ms.
%2 = -284 \\ non-alternating; this time, Sidi's unsafe mode loses accuracy
? exponent(intnumosc(x=0,sinc(x)^2,Pi,2) - Pi/2)
time = 113 ms.
%3 = -10 \\ this time sumalt fails completely
? exponent(intnumosc(x=0,sinc(x)^2,Pi,3) - Pi/2)
time = 103 ms.
%4 = -237 \\ Lagrange loses accuracy (same with 2H = 2*Pi)
? exponent(intnumosc(x=0,sinc(x)^2,Pi,4) - Pi/2)
time = 17,681 ms.
%4 = -381 \\ and Sumpos is good but slow (perfect with 2H)
@eprog

Exemples of a different flavour:
\bprog
? exponent(intnumosc(x = 0, besselj(0,x)*sin(3*x), Pi) - 1/sqrt(8))
time = 4,615 ms.
%1 = -385 \\ more expensive but correct
? exponent(intnumosc(x = 0, besselj(0,x)*sin(3*x), Pi, 1) - 1/sqrt(8))
time = 1,424 ms.
%2 = -279 \\ unsafe mode loses some accuracy (other modes return junk)

? S = log(2*Pi)- Euler - 1;
? exponent(intnumosc(t=1, (frac(t)/t)^2, 1/2) - S)
time = 21 ms.
%4 = -6 \\ junk
? exponent(intnumosc(t=1, (frac(t)/t)^2, 1) - S)
time = 66ms.
%5 = -384 \\ perfect with 2H
? exponent(intnumosc(t=1, (frac(t)/t)^2, 1, 1) - S)
time = 20 ms.
%6 = -286 \\ unsafe mode loses accuracy
? exponent(intnumosc(t=1, (frac(t)/t)^2, 1, 3) - S)
time = 30 ms.
%7 = -236  \\ and so does Lagrange (Sumalt fails)
? exponent(intnumosc(t=1, (frac(t)/t)^2, 1, 4) - S)
time = 2,315 ms.
%8 = -382 \\ Sumpos is perfect but slow
@eprog\noindent Again, Sidi extrapolation behaves well, especially in safe
mode, but $2H$ is required here.

If the integrand has singularities close to the interval of integration,
it is advisable to split the integral in two: use the more robust \kbd{intnum}
to handle the singularities, then \kbd{intnumosc} for the remainder:
\bprog
? \p38
? f(x) = besselj(0,x)^3 * log(x); \\ mild singularity at 0
? g() = intnumosc(x = 0, f(x), Pi); \\ direct
? h() = intnum(x = 0, Pi, f(x)) + intnumosc(x = Pi, f(x), Pi); \\ split at Pi
? G = g();
time = 293 ms.
? H = h();
time = 320 ms. \\ about as fast
? exponent(G-H)
%6 = -12 \\ at least one of them is junk
? \p77 \\ increase accuracy
? G2=g(); H2=h();
? exponent(G - G2)
%8 = -13  \\ g() is not consistent
? exponent(H - H2)
%9 = -128  \\ not a proof, but h() looks good
@eprog\noindent Finally, here is an exemple where all methods fail, even
when splitting the integral, except Sumpos:
\bprog
? \p38
? f(x)=besselj(0,x)^4*log(x+1);
? F = intnumosc(x=0,f(x), Pi, 4)
time = 2,437 ms.
%2 = 0.45489838778971732178155161172638343214
? \p76 \\ double accuracy to check
? exponent(F - intnumosc(x = 0,f(x), Pi, 4))
time = 18,817 ms.
%3 = -122 \\ F was almost perfect
@eprog

The library syntax is \fun{GEN}{intnumosc0}{GEN x, GEN expr, GEN H, long flag, GEN tab = NULL, long prec}.

\subsec{intnumromb$(X=a,b,\var{expr},\{\fl=0\})$}\kbdsidx{intnumromb}\label{se:intnumromb}
Numerical integration of \var{expr} (smooth in $]a,b[$), with respect to
$X$. Suitable for low accuracy; if \var{expr} is very regular (e.g. analytic
in a large region) and high accuracy is desired, try \tet{intnum} first.

Set $\fl=0$ (or omit it altogether) when $a$ and $b$ are not too large, the
function is smooth, and can be evaluated exactly everywhere on the interval
$[a,b]$.

If $\fl=1$, uses a general driver routine for doing numerical integration,
making no particular assumption (slow).

$\fl=2$ is tailored for being used when $a$ or $b$ are infinite using the
change of variable $t = 1/X$. One \emph{must} have $ab>0$, and in fact if
for example $b=+\infty$, then it is preferable to have $a$ as large as
possible, at least $a\ge1$.

If $\fl=3$, the function is allowed to be undefined
at $a$ (but right continuous) or $b$ (left continuous),
for example the function $\sin(x)/x$ between $x=0$ and $1$.

The user should not require too much accuracy: \tet{realprecision} about
30 decimal digits (\tet{realbitprecision} about 100 bits) is OK,
but not much more. In addition, analytical cleanup of the integral must have
been done: there must be no singularities in the interval or at the
boundaries. In practice this can be accomplished with a change of
variable. Furthermore, for improper integrals, where one or both of the
limits of integration are plus or minus infinity, the function must decrease
sufficiently rapidly at infinity, which can often be accomplished through
integration by parts. Finally, the function to be integrated should not be
very small (compared to the current precision) on the entire interval. This
can of course be accomplished by just multiplying by an appropriate constant.

Note that \idx{infinity} can be represented with essentially no loss of
accuracy by an appropriate huge number. However beware of real underflow
when dealing with rapidly decreasing functions. For example, in order to
compute the $\int_0^\infty e^{-x^2}\,dx$ to 28 decimal digits, then one can
set infinity equal to 10 for example, and certainly not to \kbd{1e1000}.
%\syn{NO}

The library syntax is \fun{GEN}{intnumromb_bitprec}{void *E, GEN (*eval)(void*,GEN), GEN a, GEN b, long flag, long bitprec}, where \kbd{eval}$(x, E)$ returns the value of the
function at $x$. You may store any additional information required by
\kbd{eval} in $E$, or set it to \kbd{NULL}. The historical variant
\tet{intnumromb}, where \kbd{prec} is expressed in words, not bits, is
obsolete and should no longer be used.

\subsec{laurentseries$(f, \{M = \var{seriesprecision}\}, \{x='x\})$}\kbdsidx{laurentseries}\label{se:laurentseries}
Expand $f$ as a Laurent series around $x = 0$ to order $M$. This
function computes $f(x + O(x^n))$ until $n$ is large enough: it
must be possible to evaluate $f$ on a power series with $0$ constant term.
\bprog
? laurentseries(t->sin(t)/(1-cos(t)), 5)
%1 = 2*x^-1 - 1/6*x - 1/360*x^3 - 1/15120*x^5 + O(x^6)
? laurentseries(log)
  ***   at top-level: laurentseries(log)
  ***                 ^------------------
  ***   in function laurentseries: log
  ***                              ^---
  *** log: domain error in log: series valuation != 0
@eprog

Note that individual Laurent coefficients of order $\leq M$
can be retrieved from $s = \kbd{laurentseries}(f,M)$ via \kbd{polcoef(s,i)}
for any $i \leq M$. The series $s$ may occasionally be more precise that
the required $O(x^{M+1})$.

With respect to successive calls to \tet{derivnum},
\kbd{laurentseries} is both faster and more precise:
\bprog
? laurentseries(t->log(3+t),1)
%1 = 1.0986122886681096913952452369225257047 + 1/3*x - 1/18*x^2 + O(x^3)
? derivnum(t=0,log(3+t),1)
%2 = 0.33333333333333333333333333333333333333
? derivnum(t=0,log(3+t),2)
%3 = -0.11111111111111111111111111111111111111

? f = x->sin(exp(x));
? polcoef(laurentseries(x->f(x+2), 1), 1)
%5 = 3.3129294231043339804683687620360224365
? exp(2) * cos(exp(2));
%6 = 3.3129294231043339804683687620360224365
? derivnum(x = 2, f(x))
%7 = 3.3129294231043339804683687620360224364 \\ 1 ulp off

? default(realprecision,115);
? for(i=1,10^4, laurentseries(x->f(x+2),1))
time = 279 ms.
? for(i=1,10^4, derivnum(x=2,f(x)))  \\ ... and slower
time = 1,134 ms.
@eprog

\synt{laurentseries}{void *E, GEN (*f)(void*,GEN,long), long M, long v, long prec}.

\subsec{limitnum$(\var{expr},\{\var{alpha}=1\})$}\kbdsidx{limitnum}\label{se:limitnum}
Lagrange-Zagier numerical extrapolation of \var{expr}, corresponding to
a sequence $u_n$, either given by a closure \kbd{n->u(n)}. I.e., assuming
that $u_n$ tends to a finite limit $\ell$, try to determine $\ell$.

The routine assume that $u_n$ has an asymptotic expansion in $n^{-\alpha}$ :
$$u_n = \ell + \sum_{i\geq 1} a_i n^{-i\alpha}$$
for some $a_i$. It is purely numerical and heuristic, thus may or may not
work on your examples. The expression will be evaluated for $n = 1, 2,
\dots, N$ for an $N = O(B)$ at a bit accuracy bounded by $1.612 B$.

\bprog
? limitnum(n -> n*sin(1/n))
%1 = 1.0000000000000000000000000000000000000

? limitnum(n -> (1+1/n)^n) - exp(1)
%2 = 0.E-37

? limitnum(n -> 2^(4*n+1)*(n!)^4 / (2*n)! /(2*n+1)! ) - Pi
%3 = 0.E -37
@eprog\noindent
It is not mandatory to specify $\alpha$ when the $u_n$ have an asymptotic
expansion in $n^{-1}$. However, if the series in $n^{-1}$ is lacunary,
specifying $\alpha$ allows faster computation:
\bprog
? \p1000
? limitnum(n->(1+1/n^2)^(n^2)) - exp(1)
time = 1min, 44,681 ms.
%4 = 0.E-1001
? limitnum(n->(1+1/n^2)^(n^2), 2) - exp(1)
time = 27,271 ms.
%5 = 0.E-1001 \\ still perfect, 4 times faster
@eprog\noindent
When $u_n$ has an asymptotic expansion in $n^{-\alpha}$ with $\alpha$ not an
integer, leaving $\alpha$ unspecified will bring an inexact limit. Giving a
satisfying optional argument improves precision; the program runs faster when
the optional argument gives non lacunary series.
\bprog
? \p50
? limitnum(n->(1+1/n^(7/2))^(n^(7/2))) - exp(1)
time = 982 ms.
%6 = 4.13[...] E-12
? limitnum(n->(1+1/n^(7/2))^(n^(7/2)), 1/2) - exp(1)
time = 16,745 ms.
%7 = 0.E-57
? limitnum(n->(1+1/n^(7/2))^(n^(7/2)), 7/2) - exp(1)
time = 105 ms.
%8 = 0.E-57
@eprog\noindent
Alternatively, $u_n$ may be given by a closure $N\mapsto [u_1,\dots, u_N]$
which can often be programmed in a more efficient way, for instance
when $u_{n+1}$ is a simple function of the preceding terms:
\bprog
? \p2000
? limitnum(n -> 2^(4*n+1)*(n!)^4 / (2*n)! /(2*n+1)! ) - Pi
time = 1,755 ms.
%9 = 0.E-2003
? vu(N) = \\ exploit hypergeometric property
  { my(v = vector(N)); v[1] = 8./3;\
    for (n=2, N, my(q = 4*n^2); v[n] = v[n-1]*q/(q-1));\
    return(v);
  }
? limitnum(vu) - Pi \\ much faster
time = 106 ms.
%11 = 0.E-2003
@eprog\noindent All sums and recursions can be handled in the same way.
In the above it is essential that $u_n$ be defined as a closure because
it must be evaluated at a higher precision than the one expected for the
limit. Make sure that the closure does not depend on a global variable which
would be computed at a priori fixed accuracy. For instance, precomputing
\kbd{v1 = 8.0/3} first and using \kbd{v1} in \kbd{vu} above would be wrong
because the resulting vector of values will use the accuracy of \kbd{v1}
instead of the ambient accuracy at which \kbd{limitnum} will call it.

Alternatively, and more clumsily, $u_n$ may be given by a vector of values:
it must be long and precise enough for the extrapolation
to make sense. Let $B$ be the current \kbd{realbitprecision}, the vector
length must be at least $1.102 B$ and the values computed with bit accuracy
$1.612 B$.
\bprog
? limitnum(vector(10,n,(1+1/n)^n))
 ***                 ^--------------------
 *** limitnum: nonexistent component in limitnum: index < 43
\\ at this accuracy, we must have at least 43 values
? limitnum(vector(43,n,(1+1/n)^n)) - exp(1)
%12 = 0.E-37

? v = vector(43);
? s = 0; for(i=1,#v, s += 1/i; v[i]= s - log(i));
? limitnum(v) - Euler
%15 = -1.57[...] E-16

? v = vector(43);
\\ ~ 128 bit * 1.612
? localbitprec(207);\
  s = 0; for(i=1,#v, s += 1/i; v[i]= s - log(i));
? limitnum(v) - Euler
%18 = 0.E-38
@eprog

Because of the above problems, the preferred format is thus a closure,
given either a single value or the vector of values $[u_1,\dots,u_N]$. The
function distinguishes between the two formats by evaluating the closure
at $N\neq 1$ and $1$ and checking whether it yields vectors of respective
length $N$ and $1$ or not.

\misctitle{Warning} The expression is evaluated for $n = 1, 2, \dots, N$
for an $N = O(B)$ if the current bit accuracy is $B$. If it is not defined
for one of these values, translate or rescale accordingly:
\bprog
? limitnum(n->log(1-1/n))  \\ can't evaluate at n = 1 !
 ***   at top-level: limitnum(n->log(1-1/n))
 ***                 ^-----------------------
 ***   in function limitnum: log(1-1/n)
 ***                         ^----------
 *** log: domain error in log: argument = 0
? limitnum(n->-log(1-1/(2*n)))
%19 = -6.11[...] E-58
@eprog

We conclude with a complicated example. Since the function is heuristic,
it is advisable to check whether it produces the same limit for
$u_n, u_{2n}, \dots u_{km}$ for a suitable small multiplier $k$.
The following function implements the recursion for the Motzkin numbers
$M_n$ which count the number of ways to draw non intersecting chords between
$n$ points on a circle:
$$ M_n = M_{n-1} + \sum_{i < n-1} M_i M_{n-2-i}
       = ((n+1)M_{n-1}+(3n-3)M_{n-2}) / (n+2).$$
It is known that $M_n \sim \dfrac{3^{n+1}}{\sqrt{12\pi n^3}}$.
\bprog
\\ [M_k, M_{k*2}, ..., M_{k*N}] / (3^n / n^(3/2))
vM(N, k = 1) =
{ my(q = k*N, V);
   if (q == 1, return ([1/3]));
   V = vector(q); V[1] = V[2] = 1;
   for(n = 2, q - 1,
     V[n+1] = ((2*n + 1)*V[n] + 3*(n - 1)*V[n-1]) / (n + 2));
   f = (n -> 3^n / n^(3/2));
   return (vector(N, n, V[n*k] / f(n*k)));
}
? limitnum(vM) - 3/sqrt(12*Pi) \\ complete junk
%1 = 35540390.753542730306762369615276452646
? limitnum(N->vM(N,5)) - 3/sqrt(12*Pi) \\ M_{5n}: better
%2 = 4.130710262178469860 E-25
? limitnum(N->vM(N,10)) - 3/sqrt(12*Pi) \\ M_{10n}: perfect
%3 = 0.E-38
? \p2000
? limitnum(N->vM(N,10)) - 3/sqrt(12*Pi) \\ also at high accuracy
time = 409 ms.
%4 = 1.1048895470044788191 E-2004
@eprog\noindent In difficult cases such as the above a multiplier of 5 to 10
is usually sufficient. The above example is typical: a good multiplier usually
remains sufficient when the requested precision increases!

\synt{limitnum}{void *E, GEN (*u)(void *,GEN,long), GEN alpha, long prec}, where \kbd{u(E, n, prec)} must return $u(n)$ in precision \kbd{prec}.
Also available is
\fun{GEN}{limitnum0}{GEN u, GEN alpha, long prec}, where $u$
must be a vector of sufficient length as above.

\subsec{prod$(X=a,b,\var{expr},\{x=1\})$}\kbdsidx{prod}\label{se:prod}
Product of expression
\var{expr}, initialized at $x$, the formal parameter $X$ going from $a$ to
$b$. As for \kbd{sum}, the main purpose of the initialization parameter $x$
is to force the type of the operations being performed. For example if it is
set equal to the integer 1, operations will start being done exactly. If it
is set equal to the real $1.$, they will be done using real numbers having
the default precision. If it is set equal to the power series $1+O(X^k)$ for
a certain $k$, they will be done using power series of precision at most $k$.
These are the three most common initializations.

\noindent As an extreme example, compare

\bprog
? prod(i=1, 100, 1 - X^i);  \\@com this has degree $5050$ !!
time = 128 ms.
? prod(i=1, 100, 1 - X^i, 1 + O(X^101))
time = 8 ms.
%2 = 1 - X - X^2 + X^5 + X^7 - X^12 - X^15 + X^22 + X^26 - X^35 - X^40 + \
X^51 + X^57 - X^70 - X^77 + X^92 + X^100 + O(X^101)
@eprog\noindent
Of course, in  this specific case, it is faster to use \tet{eta},
which is computed using Euler's formula.
\bprog
? prod(i=1, 1000, 1 - X^i, 1 + O(X^1001));
time = 589 ms.
? \ps1000
seriesprecision = 1000 significant terms
? eta(X) - %
time = 8ms.
%4 = O(X^1001)
@eprog

\synt{produit}{GEN a, GEN b, char *expr, GEN x}.

\subsec{prodeuler$(p=a,b,\var{expr})$}\kbdsidx{prodeuler}\label{se:prodeuler}
Product of expression \var{expr}, initialized at \kbd{1.0}
(i.e.~to a floating point number equal to 1 to the
current \kbd{realprecision}), the formal parameter $p$ ranging over the prime
numbers between $a$ and $b$.\sidx{Euler product}
\bprog
? prodeuler(p = 2, 10^4, 1 - p^-2)
%1 = 0.60793306911405513018380499671124428015
? P = 1; forprime(p = 2, 10^4, P *= (1 - p^-2))
? exponent(numerator(P))
%3 = 22953
@eprog\noindent The function returns a floating point number because,
as the second expression shows, such products are usually intractably
large rational numbers when computed symbolically.
If the expression is a rational funtction, \kbd{prodeulerrat} computes the
product over all primes:
\bprog
? prodeulerrat(1 - p^-2)
%4 = 0.60792710185402662866327677925836583343
? 6/Pi^2
%3 = 0.60792710185402662866327677925836583343
@eprog

\synt{prodeuler}{void *E, GEN (*eval)(void*,GEN), GEN a,GEN b, long prec}.

\subsec{prodeulerrat$(F,\{s=1\},\{a=2\})$}\kbdsidx{prodeulerrat}\label{se:prodeulerrat}
$\prod_{p\ge a}F(p^s)$, where the product is taken over prime numbers
and $F$ is a rational function.
\bprog
? prodeulerrat(1+1/q^3,1)
%1 = 1.1815649490102569125693997341604542605
? zeta(3)/zeta(6)
%2 = 1.1815649490102569125693997341604542606
@eprog

The library syntax is \fun{GEN}{prodeulerrat}{GEN F, GEN s = NULL, long a, long prec}.

\subsec{prodinf$(X=a,\var{expr},\{\fl=0\})$}\kbdsidx{prodinf}\label{se:prodinf}
\idx{infinite product} of
expression \var{expr}, the formal parameter $X$ starting at $a$. The evaluation
stops when the relative error of the expression minus 1 is less than the
default precision. In particular, divergent products result in infinite
loops. The expressions must always evaluate to an element of $\C$.

If $\fl=1$, do the product of the ($1+\var{expr}$) instead.

\synt{prodinf}{void *E, GEN (*eval)(void*,GEN), GEN a, long prec}
($\fl=0$), or \tet{prodinf1} with the same arguments ($\fl=1$).

\subsec{prodnumrat$(F,a)$}\kbdsidx{prodnumrat}\label{se:prodnumrat}
$\prod_{n\ge a}F(n)$, where $F-1$ is a rational function of degree less
than or equal to $-2$.
\bprog
? prodnumrat(1+1/x^2,1)
%1 = 3.6760779103749777206956974920282606665
@eprog

The library syntax is \fun{GEN}{prodnumrat}{GEN F, long a, long prec}.

\subsec{solve$(X=a,b,\var{expr})$}\kbdsidx{solve}\label{se:solve}
Find a real root of expression
\var{expr} between $a$ and $b$.
If both $a$ and $b$ are finite, the condition is that
$\var{expr}(X=a) * \var{expr}(X=b) \le 0$. (You will get an error message
\kbd{roots must be bracketed in solve} if this does not hold.)

If only one between $a$ and $b$ is finite, say $a$, then $b=\pm\infty$. The
routine will test all $b=a\pm 2^r$, with $r\geq \log_2(|a|)$ until it finds
a bracket for the root which satisfies the abovementioned condition.

If both $a$ and $b$ are infinite, the routine will test $0$ and all $\pm 2^r$,
$r\geq 0$, until it finds a bracket for the root which satisfies the
condition.

This routine uses Brent's method and can fail miserably if \var{expr} is
not defined in the whole of $[a,b]$ (try \kbd{solve(x=1, 2, tan(x))}).

\synt{zbrent}{void *E,GEN (*eval)(void*,GEN),GEN a,GEN b,long prec}.

\subsec{solvestep$(X=a,b,\var{step},\var{expr},\{\fl=0\})$}\kbdsidx{solvestep}\label{se:solvestep}
Find zeros of a continuous function in the real interval $[a,b]$ by naive
interval splitting. This function is heuristic and may or may not find the
intended zeros. Binary digits of \fl\ mean

\item 1: return as soon as one zero is found, otherwise return all
zeros found;

\item 2: refine the splitting until at least one zero is found
(may loop indefinitely if there are no zeros);

\item 4: do a multiplicative search (we must have $a > 0$ and $\var{step} >
1$), otherwise an additive search; \var{step} is the multiplicative or
additive step.

\item 8: refine the splitting until at least one zero is very close to an
integer.

\bprog
? solvestep(X=0,10,1,sin(X^2),1)
%1 = 1.7724538509055160272981674833411451828
? solvestep(X=1,12,2,besselj(4,X),4)
%2 = [7.588342434..., 11.064709488...]
@eprog\noindent

\synt{solvestep}{void *E, GEN (*eval)(void*,GEN), GEN a,GEN b, GEN step,long flag,long prec}.

\subsec{sum$(X=a,b,\var{expr},\{x=0\})$}\kbdsidx{sum}\label{se:sum}
Sum of expression \var{expr},
initialized at $x$, the formal parameter going from $a$ to $b$. As for
\kbd{prod}, the initialization parameter $x$ may be given to force the type
of the operations being performed.

\noindent As an extreme example, compare

\bprog
? sum(i=1, 10^4, 1/i); \\@com rational number: denominator has $4345$ digits.
time = 236 ms.
? sum(i=1, 5000, 1/i, 0.)
time = 8 ms.
%2 = 9.787606036044382264178477904
@eprog

% \syn{NO}

\subsec{sumalt$(X=a,\var{expr},\{\fl=0\})$}\kbdsidx{sumalt}\label{se:sumalt}
Numerical summation of the series \var{expr}, which should be an
\idx{alternating series} $(-1)^k a_k$, the formal variable $X$ starting at
$a$. Use an algorithm of Cohen, Villegas and Zagier (\emph{Experiment. Math.}
{\bf 9} (2000), no.~1, 3--12).

If $\fl=0$, assuming that the $a_k$ are the moments of a positive
measure on $[0,1]$, the relative error is $O(3+\sqrt8)^{-n}$ after using
$a_k$ for $k\leq n$. If \kbd{realprecision} is $p$, we thus set
$n = \log(10)p/\log(3+\sqrt8)\approx 1.3 p$; besides the time needed to
compute the $a_k$, $k\leq n$, the algorithm overhead is negligible: time
$O(p^2)$ and space $O(p)$.

If $\fl=1$, use a variant with more complicated polynomials, see
\tet{polzagier}. If the $a_k$ are the moments of $w(x)dx$ where $w$
(or only $xw(x^2)$) is a smooth function extending analytically to the whole
complex plane, convergence is in $O(14.4^{-n})$. If $xw(x^2)$ extends
analytically to a smaller region, we still have exponential convergence,
with worse constants. Usually faster when the computation of $a_k$ is
expensive. If \kbd{realprecision} is $p$, we thus set
$n = \log(10)p/\log(14.4)\approx 0.86 p$; besides the time needed to
compute the $a_k$, $k\leq n$, the algorithm overhead is \emph{not}
negligible: time $O(p^3)$ and space $O(p^2)$. Thus, even if the analytic
conditions for rigorous use are met, this variant is only worthwile if the
$a_k$ are hard to compute, at least $O(p^2)$ individually on average:
otherwise we gain a small constant factor (1.5, say) in the number of
needed $a_k$ at the expense of a large overhead.

The conditions for rigorous use are hard to check but the routine is best used
heuristically: even divergent alternating series can sometimes be summed by
this method, as well as series which are not exactly alternating (see for
example \secref{se:user_defined}). It should be used to try and guess the
value of an infinite sum. (However, see the example at the end of
\secref{se:userfundef}.)

If the series already converges geometrically,
\tet{suminf} is often a better choice:
\bprog
? \p38
? sumalt(i = 1, -(-1)^i / i)  - log(2)
time = 0 ms.
%1 = 0.E-38
? suminf(i = 1, -(-1)^i / i)   \\@com Had to hit \kbd{Ctrl-C}
  ***   at top-level: suminf(i=1,-(-1)^i/i)
  ***                                ^------
  *** suminf: user interrupt after 10min, 20,100 ms.
? \p1000
? sumalt(i = 1, -(-1)^i / i)  - log(2)
time = 90 ms.
%2 = 4.459597722 E-1002

? sumalt(i = 0, (-1)^i / i!) - exp(-1)
time = 670 ms.
%3 = -4.03698781490633483156497361352190615794353338591897830587 E-944
? suminf(i = 0, (-1)^i / i!) - exp(-1)
time = 110 ms.
%4 = -8.39147638 E-1000   \\ @com faster and more accurate
@eprog

\synt{sumalt}{void *E, GEN (*eval)(void*,GEN),GEN a,long prec}. Also
available is \tet{sumalt2} with the same arguments ($\fl = 1$).

\subsec{sumdiv$(n,X,\var{expr})$}\kbdsidx{sumdiv}\label{se:sumdiv}
Sum of expression \var{expr} over the positive divisors of $n$.
This function is a trivial wrapper essentially equivalent to
\bprog
  D = divisors(n);
  sum (i = 1, #D, my(X = D[i]); eval(expr))
@eprog\noindent
If \var{expr} is a multiplicative function, use \tet{sumdivmult}.
%\syn{NO}

\subsec{sumdivmult$(n,d,\var{expr})$}\kbdsidx{sumdivmult}\label{se:sumdivmult}
Sum of \emph{multiplicative} expression \var{expr} over the positive
divisors $d$ of $n$. Assume that \var{expr} evaluates to $f(d)$
where $f$ is multiplicative: $f(1) = 1$ and $f(ab) = f(a)f(b)$ for coprime
$a$ and $b$.
\synt{sumdivmultexpr}{void *E, GEN (*eval)(void*,GEN), GEN d}

\subsec{sumeulerrat$(F,\{s=1\},\{a=2\})$}\kbdsidx{sumeulerrat}\label{se:sumeulerrat}
$\sum_{p\ge a}F(p^s)$, where the sum is taken over prime numbers
and $F$ is a rational function.
\bprog
? sumeulerrat(1/p^2)
%1 = 0.45224742004106549850654336483224793417
? sumeulerrat(1/p, 2)
%2 = 0.45224742004106549850654336483224793417
@eprog

The library syntax is \fun{GEN}{sumeulerrat}{GEN F, GEN s = NULL, long a, long prec}.

\subsec{suminf$(X=a,\var{expr})$}\kbdsidx{suminf}\label{se:suminf}
Naive summation of expression \var{expr}, the formal parameter $X$
going from $a$ to infinity. The evaluation stops when the relative error of
the expression is less than the default bit precision for 3 consecutive
evaluations. The expressions must evaluate to a complex number.

If the expression tends slowly to $0$, like $n^{-a}$ for some $a > 1$,
make sure $b = \kbd{realbitprecision}$ is low: indeed, the algorithm will
require $O(2^{b/a})$ function evaluations and we expect only about $b(1-1/a)$
correct bits in the answer. If the series is alternating, we can expect $b$
correct bits but the \tet{sumalt} function should be used instead since its
complexity is polynomial in $b$, instead of exponential. More generally,
\kbd{sumpos} should be used if the terms have a constant sign and
\kbd{sumnum} if the function is $C^\infty$.

\bprog
? \pb25
  realbitprecision = 25 significant bits (7 decimal digits displayed)
? exponent(suminf(i = 1, (-1)^i / i) + log(2))
time = 2min, 2,602 ms.
%1 = -29
? \pb45
  realbitprecision = 45 significant bits (13 decimal digits displayed)
? exponent(suminf(i = 1, 1 / i^2) - zeta(2))
time = 2,186 ms.
%2 = -23

\\ alternatives are much faster
? \pb 10000
  realbitprecision = 10000 significant bits (3010 decimal digits displayed)
? exponent(sumalt(i = 1, (-1)^i / i) + log(2))
time = 25 ms.
%3 = -10043

? \pb 4000
  realbitprecision = 4000 significant bits (1204 decimal digits displayed)))
? exponent(sumpos(i = 1, 1 / i^2) - zeta(2))
time = 22,593 ms.
%4 = -4030

? exponent(sumnum(i = 1, 1 / i^2) - zeta(2))
time = 7,032 ms.
%5 = -4031

\\ but suminf is perfect for geometrically converging series
? exponent(suminf(i = 1, 2^-i) - 1)
time = 25 ms.
%6 = -4003
@eprog

\synt{suminf_bitprec}{void *E, GEN (*eval)(void*,GEN), GEN a, long prec}.
The historical variant \fun{GEN}{suminf}{\dots, long prec}, where \kbd{prec} is
expressed in words, not bits, is obsolete and should no longer be used.

\subsec{sumnum$(n=a,f,\{\var{tab}\})$}\kbdsidx{sumnum}\label{se:sumnum}
Numerical summation of $f(n)$ at high accuracy using Euler-MacLaurin,
the variable $n$ taking values from $a$ to $+\infty$, where $f$ is assumed to
have positive values and is a $C^\infty$ function; \kbd{a} must be an integer
and \kbd{tab}, if given, is the output of \kbd{sumnuminit}. The latter
precomputes abscissas and weights, speeding up the computation; it also allows
to specify the behavior at infinity via \kbd{sumnuminit([+oo, asymp])}.
\bprog
? \p500
? z3 = zeta(3);
? sumpos(n = 1, n^-3) - z3
time = 2,332 ms.
%2 = 2.438468843 E-501
? sumnum(n = 1, n^-3) - z3 \\ here slower than sumpos
time = 2,752 ms.
%3 = 0.E-500
@eprog

\misctitle{Complexity}
The function $f$ will be evaluated at $O(D \log D)$ real arguments,
where $D \approx \kbd{realprecision} \cdot \log(10)$. The routine is geared
towards slowly decreasing functions: if $f$ decreases exponentially fast,
then one of \kbd{suminf} or \kbd{sumpos} should be preferred.
If $f$ satisfies the stronger hypotheses required for Monien summation,
i.e. if $f(1/z)$ is holomorphic in a complex neighbourhood of $[0,1]$,
then \tet{sumnummonien} will be faster since it only requires $O(D/\log D)$
evaluations:
\bprog
? sumnummonien(n = 1, 1/n^3) - z3
time = 1,985 ms.
%3 = 0.E-500
@eprog\noindent The \kbd{tab} argument precomputes technical data
not depending on the expression being summed and valid for a given accuracy,
speeding up immensely later calls:
\bprog
? tab = sumnuminit();
time = 2,709 ms.
? sumnum(n = 1, 1/n^3, tab) - z3 \\ now much faster than sumpos
time = 40 ms.
%5 = 0.E-500

? tabmon = sumnummonieninit(); \\ Monien summation allows precomputations too
time = 1,781 ms.
? sumnummonien(n = 1, 1/n^3, tabmon) - z3
time = 2 ms.
%7 = 0.E-500
@eprog\noindent The speedup due to precomputations becomes less impressive
when the function $f$ is expensive to evaluate, though:
\bprog
? sumnum(n = 1, lngamma(1+1/n)/n, tab);
time = 14,180 ms.

? sumnummonien(n = 1, lngamma(1+1/n)/n, tabmon); \\ fewer evaluations
time = 717 ms.
@eprog

\misctitle{Behaviour at infinity}
By default, \kbd{sumnum} assumes that \var{expr} decreases slowly at infinity,
but at least like $O(n^{-2})$. If the function decreases like $n^{\alpha}$
for some $-2 < \alpha < -1$, then it must be indicated via
\bprog
  tab = sumnuminit([+oo, alpha]); /* alpha < 0 slow decrease */
@eprog\noindent otherwise loss of accuracy is expected.
If the functions decreases quickly, like $\exp(-\alpha n)$ for some
$\alpha > 0$, then it must be indicated via
\bprog
  tab = sumnuminit([+oo, alpha]); /* alpha  > 0 exponential decrease */
@eprog\noindent otherwise exponent overflow will occur.
\bprog
? sumnum(n=1,2^-n)
 ***   at top-level: sumnum(n=1,2^-n)
 ***                             ^----
 *** _^_: overflow in expo().
? tab = sumnuminit([+oo,log(2)]); sumnum(n=1,2^-n, tab)
%1 = 1.000[...]
@eprog

As a shortcut, one can also input
\bprog
  sumnum(n = [a, asymp], f)
@eprog\noindent instead of
\bprog
  tab = sumnuminit(asymp);
  sumnum(n = a, f, tab)
@eprog

\misctitle{Further examples}
\bprog
? \p200
? sumnum(n = 1, n^(-2)) - zeta(2) \\ accurate, fast
time = 200 ms.
%1 = -2.376364457868949779 E-212
? sumpos(n = 1, n^(-2)) - zeta(2)  \\ even faster
time = 96 ms.
%2 = 0.E-211
? sumpos(n=1,n^(-4/3)) - zeta(4/3)   \\ now much slower
time = 13,045 ms.
%3 = -9.980730723049589073 E-210
? sumnum(n=1,n^(-4/3)) - zeta(4/3)  \\ fast but inaccurate
time = 365 ms.
%4 = -9.85[...]E-85
? sumnum(n=[1,-4/3],n^(-4/3)) - zeta(4/3) \\ with decrease rate, now accurate
time = 416 ms.
%5 = -4.134874156691972616 E-210

? tab = sumnuminit([+oo,-4/3]);
time = 196 ms.
? sumnum(n=1, n^(-4/3), tab) - zeta(4/3) \\ faster with precomputations
time = 216 ms.
%5 = -4.134874156691972616 E-210
? sumnum(n=1,-log(n)*n^(-4/3), tab) - zeta'(4/3)
time = 321 ms.
%7 = 7.224147951921607329 E-210
@eprog

Note that in the case of slow decrease ($\alpha < 0$), the exact
decrease rate must be indicated, while in the case of exponential decrease,
a rough value will do. In fact, for exponentially decreasing functions,
\kbd{sumnum} is given for completeness and comparison purposes only: one
of \kbd{suminf} or \kbd{sumpos} should always be preferred.
\bprog
? sumnum(n=[1, 1], 2^-n) \\ pretend we decrease as exp(-n)
time = 240 ms.
%8 = 1.000[...] \\ perfect
? sumpos(n=1, 2^-n)
%9 = 1.000[...] \\ perfect and instantaneous
@eprog

\misctitle{Beware cancellation} The function $f(n)$ is evaluated for huge
values of $n$, so beware of cancellation in the evaluation:
\bprog
? f(n) = 2 - 1/n - 2*n*log(1+1/n); \\ result is O(1/n^2)
? z = -2 + log(2*Pi) - Euler;
? sumnummonien(n=1, f(n)) - z
time = 149 ms.
%12 = 0.E-212  \\ perfect
? sumnum(n=1, f(n)) - z
time = 116 ms.
%13 = -948.216[...] \\ junk
@eprog\noindent As \kbd{sumnum(n=1, print(n))} shows, we evaluate $f(n)$ for
$n > 1e233$ and our implementation of $f$ suffers from massive cancellation
since we are summing two terms of the order of $O(1)$ for a result in
$O(1/n^2)$. You can either rewrite your sum so that individual terms are
evaluated without cancellation or locally replace $f(n)$ by an accurate
asymptotic expansion:
\bprog
? F = truncate( f(1/x + O(x^30)) );
? sumnum(n=1, if(n > 1e7, subst(F,x,1/n), f(n))) - z
%15 = 1.1 E-212 \\ now perfect
@eprog

\synt{sumnum}{(void *E, GEN (*eval)(void*, GEN), GEN a, GEN tab, long prec)}
where an omitted \var{tab} is coded as \kbd{NULL}.

\subsec{sumnumap$(n=a,f,\{\var{tab}\})$}\kbdsidx{sumnumap}\label{se:sumnumap}
Numerical summation of $f(n)$ at high accuracy using Abel-Plana,
the variable $n$ taking values from $a$ to $+\infty$, where $f$ is
holomorphic in the right half-place $\Re(z) > a$; \kbd{a} must be an integer
and \kbd{tab}, if given, is the output of \kbd{sumnumapinit}. The latter
precomputes abscissas and weights, speeding up the computation; it also allows
to specify the behavior at infinity via \kbd{sumnumapinit([+oo, asymp])}.
\bprog
? \p500
? z3 = zeta(3);
? sumpos(n = 1, n^-3) - z3
time = 2,332 ms.
%2 = 2.438468843 E-501
? sumnumap(n = 1, n^-3) - z3 \\ here slower than sumpos
time = 2,565 ms.
%3 = 0.E-500
@eprog

\misctitle{Complexity}
The function $f$ will be evaluated at $O(D \log D)$ real arguments
and $O(D)$ complex arguments,
where $D \approx \kbd{realprecision} \cdot \log(10)$. The routine is geared
towards slowly decreasing functions: if $f$ decreases exponentially fast,
then one of \kbd{suminf} or \kbd{sumpos} should be preferred.
The default algorithm \kbd{sumnum} is usually a little \emph{slower}
than \kbd{sumnumap} but its initialization function \kbd{sumnuminit}
becomes much faster as \kbd{realprecision} increases.

If $f$ satisfies the stronger hypotheses required for Monien summation,
i.e. if $f(1/z)$ is holomorphic in a complex neighbourhood of $[0,1]$,
then \tet{sumnummonien} will be faster since it only requires $O(D/\log D)$
evaluations:
\bprog
? sumnummonien(n = 1, 1/n^3) - z3
time = 1,128 ms.
%3 = 0.E-500
@eprog\noindent The \kbd{tab} argument precomputes technical data
not depending on the expression being summed and valid for a given accuracy,
speeding up immensely later calls:
\bprog
? tab = sumnumapinit();
time = 2,567 ms.
? sumnumap(n = 1, 1/n^3, tab) - z3 \\ now much faster than sumpos
time = 39 ms.
%5 = 0.E-500

? tabmon = sumnummonieninit(); \\ Monien summation allows precomputations too
time = 1,125 ms.
? sumnummonien(n = 1, 1/n^3, tabmon) - z3
time = 2 ms.
%7 = 0.E-500
@eprog\noindent The speedup due to precomputations becomes less impressive
when the function $f$ is expensive to evaluate, though:
\bprog
? sumnumap(n = 1, lngamma(1+1/n)/n, tab);
time = 10,762 ms.

? sumnummonien(n = 1, lngamma(1+1/n)/n, tabmon); \\ fewer evaluations
time = 205 ms.
@eprog

\misctitle{Behaviour at infinity}
By default, \kbd{sumnumap} assumes that \var{expr} decreases slowly at
infinity, but at least like $O(n^{-2})$. If the function decreases
like $n^{\alpha}$ for some $-2 < \alpha < -1$, then it must be indicated via
\bprog
  tab = sumnumapinit([+oo, alpha]); /* alpha < 0 slow decrease */
@eprog\noindent otherwise loss of accuracy is expected.
If the functions decreases quickly, like $\exp(-\alpha n)$ for some
$\alpha > 0$, then it must be indicated via
\bprog
  tab = sumnumapinit([+oo, alpha]); /* alpha  > 0 exponential decrease */
@eprog\noindent otherwise exponent overflow will occur.
\bprog
? sumnumap(n=1,2^-n)
 ***   at top-level: sumnumap(n=1,2^-n)
 ***                             ^----
 *** _^_: overflow in expo().
? tab = sumnumapinit([+oo,log(2)]); sumnumap(n=1,2^-n, tab)
%1 = 1.000[...]
@eprog

As a shortcut, one can also input
\bprog
  sumnumap(n = [a, asymp], f)
@eprog\noindent instead of
\bprog
  tab = sumnumapinit(asymp);
  sumnumap(n = a, f, tab)
@eprog

\misctitle{Further examples}
\bprog
? \p200
? sumnumap(n = 1, n^(-2)) - zeta(2) \\ accurate, fast
time = 169 ms.
%1 = -4.752728915737899559 E-212
? sumpos(n = 1, n^(-2)) - zeta(2)  \\ even faster
time = 79 ms.
%2 = 0.E-211
? sumpos(n=1,n^(-4/3)) - zeta(4/3)   \\ now much slower
time = 10,518 ms.
%3 = -9.980730723049589073 E-210
? sumnumap(n=1,n^(-4/3)) - zeta(4/3)  \\ fast but inaccurate
time = 309 ms.
%4 = -2.57[...]E-78
? sumnumap(n=[1,-4/3],n^(-4/3)) - zeta(4/3) \\ decrease rate: now accurate
time = 329 ms.
%6 = -5.418110963941205497 E-210

? tab = sumnumapinit([+oo,-4/3]);
time = 160 ms.
? sumnumap(n=1, n^(-4/3), tab) - zeta(4/3) \\ faster with precomputations
time = 175 ms.
%5 = -5.418110963941205497 E-210
? sumnumap(n=1,-log(n)*n^(-4/3), tab) - zeta'(4/3)
time = 258 ms.
%7 = 9.125239518216767153 E-210
@eprog

Note that in the case of slow decrease ($\alpha < 0$), the exact
decrease rate must be indicated, while in the case of exponential decrease,
a rough value will do. In fact, for exponentially decreasing functions,
\kbd{sumnumap} is given for completeness and comparison purposes only: one
of \kbd{suminf} or \kbd{sumpos} should always be preferred.
\bprog
? sumnumap(n=[1, 1], 2^-n) \\ pretend we decrease as exp(-n)
time = 240 ms.
%8 = 1.000[...] \\ perfect
? sumpos(n=1, 2^-n)
%9 = 1.000[...] \\ perfect and instantaneous
@eprog

\synt{sumnumap}{(void *E, GEN (*eval)(void*,GEN), GEN a, GEN tab, long prec)}
where an omitted \var{tab} is coded as \kbd{NULL}.

\subsec{sumnumapinit$(\{\var{asymp}\})$}\kbdsidx{sumnumapinit}\label{se:sumnumapinit}
Initialize tables for Abel--Plana summation of a series $\sum f(n)$,
where $f$ is holomorphic in a right half-plane.
If given, \kbd{asymp} is of the form $[\kbd{+oo}, \alpha]$,
as in \tet{intnum} and indicates the decrease rate at infinity of functions
to be summed. A positive
$\alpha > 0$ encodes an exponential decrease of type $\exp(-\alpha n)$ and
a negative $-2 < \alpha < -1$ encodes a slow polynomial decrease of type
$n^{\alpha}$.
\bprog
? \p200
? sumnumap(n=1, n^-2);
time = 163 ms.
? tab = sumnumapinit();
time = 160 ms.
? sumnumap(n=1, n^-2, tab); \\ faster
time = 7 ms.

? tab = sumnumapinit([+oo, log(2)]); \\ decrease like 2^-n
time = 164 ms.
? sumnumap(n=1, 2^-n, tab) - 1
time = 36 ms.
%5 = 3.0127431466707723218 E-282

? tab = sumnumapinit([+oo, -4/3]); \\ decrease like n^(-4/3)
time = 166 ms.
? sumnumap(n=1, n^(-4/3), tab);
time = 181 ms.
@eprog

The library syntax is \fun{GEN}{sumnumapinit}{GEN asymp = NULL, long prec}.

\subsec{sumnuminit$(\{\var{asymp}\})$}\kbdsidx{sumnuminit}\label{se:sumnuminit}
Initialize tables for Euler--MacLaurin delta summation of a series with
positive terms. If given, \kbd{asymp} is of the form $[\kbd{+oo}, \alpha]$,
as in \tet{intnum} and indicates the decrease rate at infinity of functions
to be summed. A positive
$\alpha > 0$ encodes an exponential decrease of type $\exp(-\alpha n)$ and
a negative $-2 < \alpha < -1$ encodes a slow polynomial decrease of type
$n^{\alpha}$.
\bprog
? \p200
? sumnum(n=1, n^-2);
time = 200 ms.
? tab = sumnuminit();
time = 188 ms.
? sumnum(n=1, n^-2, tab); \\ faster
time = 8 ms.

? tab = sumnuminit([+oo, log(2)]); \\ decrease like 2^-n
time = 200 ms.
? sumnum(n=1, 2^-n, tab)
time = 44 ms.

? tab = sumnuminit([+oo, -4/3]); \\ decrease like n^(-4/3)
time = 200 ms.
? sumnum(n=1, n^(-4/3), tab);
time = 221 ms.
@eprog

The library syntax is \fun{GEN}{sumnuminit}{GEN asymp = NULL, long prec}.

\subsec{sumnumlagrange$(n=a,f,\{\var{tab}\})$}\kbdsidx{sumnumlagrange}\label{se:sumnumlagrange}
Numerical summation of $f(n)$ from $n=a$ to $+\infty$ using Lagrange
summation; $a$ must be an integer, and the optional argument \kbd{tab} is
the output of \kbd{sumnumlagrangeinit}. By default, the program assumes that
the $N$th remainder has an asymptotic expansion in integral powers of $1/N$.
If not, initialize \kbd{tab} using \kbd{sumnumlagrangeinit(al)}, where
the asymptotic expansion of the remainder is integral powers of $1/N^{al}$;
$al$ can be equal to $1$ (default), $1/2$, $1/3$, or $1/4$, and also
equal to $2$, but in this latter case it is the $N$th remainder minus one
half of the last summand which has an asymptotic expansion in integral
powers of $1/N^2$.
\bprog
? \p1000
? z3 = zeta(3);
? sumpos(n = 1, n^-3) - z3
time = 4,440 ms.
%2 = -2.08[...] E-1001
? sumnumlagrange(n = 1, n^-3) - z3 \\ much faster than sumpos
time = 25 ms.
%3 = 0.E-1001
? tab = sumnumlagrangeinit();
time = 21 ms.
? sumnumlagrange(n = 1, n^-3, tab) - z3
time = 2 ms. /* even faster */
%5 = 0.E-1001

? \p115
? tab = sumnumlagrangeinit([1/3,1/3]);
time = 316 ms.
? sumnumlagrange(n = 1, n^-(7/3), tab) - zeta(7/3)
time = 24 ms.
%7 = 0.E-115
? sumnumlagrange(n = 1, n^(-2/3) - 3*(n^(1/3)-(n-1)^(1/3)), tab) - zeta(2/3)
time = 32 ms.
%8 = 1.0151767349262596893 E-115
@eprog

\misctitle{Complexity}
The function $f$ is evaluated at $O(D)$ integer arguments,
where $D \approx \kbd{realprecision} \cdot \log(10)$.

\synt{sumnumlagrange}{(void *E, GEN (*eval)(void*, GEN), GEN a, GEN tab, long prec)}
where an omitted \var{tab} is coded as \kbd{NULL}.

\subsec{sumnumlagrangeinit$(\{\var{asymp}\}, \{\var{c1}\})$}\kbdsidx{sumnumlagrangeinit}\label{se:sumnumlagrangeinit}
Initialize tables for Lagrange summation of a series. By
default, assume that the remainder $R(n) = \sum_{m \geq n} f(m)$
has an asymptotic expansion
$$R(n) = \sum_{m \geq n} f(n) \approx \sum_{i\geq 1} a_i / n^i$$
at infinity. The argument \kbd{asymp} allows to specify different
expansions:

\item a real number $\beta$ means
$$ R(n) = n^{-\beta} \sum_{i\geq 1} a_i / n^i $$

\item a \typ{CLOSURE} $g$ means
$$R(n) = g(n) \sum_{i\geq 1} a_i / n^i$$
(The preceding case corresponds to $g(n) = n^{-\beta}$.)

\item a pair $[\alpha,\beta]$ where $\beta$ is as above and
$\alpha\in \{2, 1, 1/2, 1/3, 1/4\}$. We let $R_2(n) = R(n) - f(n)/2$
and $R_\alpha(n) = R(n)$ for $\alpha\neq 2$. Then
$$R_\alpha(n) = g(n) \sum_{i\geq 1} a_i / n^{i\alpha}$$
Note that the initialization times increase considerable for the $\alpha$
is this list ($1/4$ being the slowest).

The constant $c1$ is technical and computed by the program, but can be set
by the user: the number of interpolation steps will be chosen close to
$c1\cdot B$, where $B$ is the bit accuracy.

\bprog
? \p2000
? sumnumlagrange(n=1, n^-2);
time = 173 ms.
? tab = sumnumlagrangeinit();
time = 172 ms.
? sumnumlagrange(n=1, n^-2, tab);
time = 4 ms.

? \p115
? sumnumlagrange(n=1, n^(-4/3)) - zeta(4/3);
%1 = -0.1093[...] \\ junk: expansion in n^(1/3)
time = 84 ms.
? tab = sumnumlagrangeinit([1/3,0]); \\ alpha = 1/3
time = 336 ms.
? sumnumlagrange(n=1, n^(-4/3), tab) - zeta(4/3)
time = 84 ms.
%3 = 1.0151767349262596893 E-115 \\ now OK

? tab = sumnumlagrangeinit(1/3); \\ alpha = 1, beta = 1/3: much faster
time = 3ms
? sumnumlagrange(n=1, n^(-4/3), tab) - zeta(4/3) \\ ... but wrong
%5 = -0.273825[...]   \\ junk !
? tab = sumnumlagrangeinit(-2/3); \\ alpha = 1, beta = -2/3
time = 3ms
? sumnumlagrange(n=1, n^(-4/3), tab) - zeta(4/3)
%6 = 2.030353469852519379 E-115 \\ now OK
@eprog\noindent in The final example with $\zeta(4/3)$, the remainder
$R_1(n)$ is of the form $n^{-1/3} \sum_{i\geq 0} a_i / n^i$, i.e.
$n^{2/3} \sum_{i\geq 1} a_i / n^i$. The explains the wrong result
for $\beta = 1/3$ and the correction with $\beta = -2/3$.

The library syntax is \fun{GEN}{sumnumlagrangeinit}{GEN asymp = NULL, GEN c1 = NULL, long prec}.

\subsec{sumnummonien$(n=a,f,\{\var{tab}\})$}\kbdsidx{sumnummonien}\label{se:sumnummonien}
Numerical summation $\sum_{n\geq a} f(n)$ at high accuracy, the variable
$n$ taking values from the integer $a$ to $+\infty$ using Monien summation,
which assumes that $f(1/z)$ has a complex analytic continuation in a (complex)
neighbourhood of the segment $[0,1]$.

The function $f$ is evaluated at $O(D / \log D)$ real arguments,
where $D \approx \kbd{realprecision} \cdot \log(10)$.
By default, assume that $f(n) = O(n^{-2})$ and has a nonzero asymptotic
expansion
$$f(n) = \sum_{i\geq 2} a_i n^{-i}$$
at infinity. To handle more complicated behaviors and allow time-saving
precomputations (for a given \kbd{realprecision}), see \kbd{sumnummonieninit}.

The library syntax is \fun{GEN}{sumnummonien0}{GEN n, GEN f, GEN tab = NULL, long prec}.

\subsec{sumnummonieninit$(\{\var{asymp}\},\{w\},\{\var{n0} = 1\})$}\kbdsidx{sumnummonieninit}\label{se:sumnummonieninit}
Initialize tables for Monien summation of a series $\sum_{n\geq n_0}
f(n)$ where $f(1/z)$ has a complex analytic continuation in a (complex)
neighbourhood of the segment $[0,1]$.

By default, assume that $f(n) = O(n^{-2})$ and has a nonzero asymptotic
expansion
$$f(n) = \sum_{i\geq 2} a_i / n^i$$
at infinity. Note that the sum starts at $i = 2$! The argument \kbd{asymp}
allows to specify different expansions:

\item a real number $\beta > 0$ means
 $$f(n) = \sum_{i\geq 1} a_i / n^{i + \beta}$$
(Now the summation starts at $1$.)

\item a vector $[\alpha,\beta]$ of reals, where we must have $\alpha > 0$
and $\alpha + \beta > 1$ to ensure convergence, means that
 $$f(n) = \sum_{i\geq 1} a_i / n^{\alpha i + \beta}$$
Note that $\kbd{asymp} = [1, \beta]$ is equivalent to
$\kbd{asymp}=\beta$.

\bprog
? \p57
? s = sumnum(n = 1, sin(1/sqrt(n)) / n); \\ reference point

? \p38
? sumnummonien(n = 1, sin(1/sqrt(n)) / n) - s
%2 = -0.001[...] \\ completely wrong

? t = sumnummonieninit(1/2);  \\ f(n) = sum_i 1 / n^(i+1/2)
? sumnummonien(n = 1, sin(1/sqrt(n)) / n, t) - s
%3 = 0.E-37 \\ now correct
@eprog\noindent (As a matter of fact, in the above summation, the
result given by \kbd{sumnum} at \kbd{\bs p38} is slighly incorrect,
so we had to increase the accuracy to \kbd{\bs p57}.)

The argument $w$ is used to sum expressions of the form
$$ \sum_{n\geq n_0} f(n) w(n),$$
for varying $f$ \emph{as above}, and fixed weight function $w$, where we
further assume that the auxiliary sums
$$g_w(m) = \sum_{n\geq n_0} w(n) / n^{\alpha m + \beta} $$
converge for all $m\geq 1$. Note that for nonnegative integers $k$,
and weight $w(n) = (\log n)^k$, the function $g_w(m) = \zeta^{(k)}(\alpha m +
\beta)$ has a simple expression; for general weights, $g_w$ is
computed using \kbd{sumnum}. The following variants are available

\item an integer $k \geq 0$, to code $w(n) = (\log n)^k$;

\item a \typ{CLOSURE} computing the values $w(n)$, where we
assume that $w(n) = O(n^\epsilon)$ for all $\epsilon > 0$;

\item a vector $[w, \kbd{fast}]$, where $w$ is a closure as above
and \kbd{fast} is a scalar;
we assume that $w(n) = O(n^{\kbd{fast}+\epsilon})$; note that
$\kbd{w} = [w, 0]$ is equivalent to $\kbd{w} = w$. Note that if
$w$ decreases exponentially, \kbd{suminf} should be used instead.

The subsequent calls to \kbd{sumnummonien} \emph{must} use the same value
of $n_0$ as was used here.
\bprog
? \p300
? sumnummonien(n = 1, n^-2*log(n)) + zeta'(2)
time = 328 ms.
%1 = -1.323[...]E-6 \\ completely wrong, f does not satisfy hypotheses !
? tab = sumnummonieninit(, 1); \\ codes w(n) = log(n)
time = 3,993 ms.
? sumnummonien(n = 1, n^-2, tab) + zeta'(2)
time = 41 ms.
%3 = -5.562684646268003458 E-309  \\ now perfect

? tab = sumnummonieninit(, n->log(n)); \\ generic, slower
time = 9,808 ms.
? sumnummonien(n = 1, n^-2, tab) + zeta'(2)
time = 40 ms.
%5 = -5.562684646268003458 E-309  \\ identical result
@eprog

The library syntax is \fun{GEN}{sumnummonieninit}{GEN asymp = NULL, GEN w = NULL, GEN n0 = NULL, long prec}.

\subsec{sumnumrat$(F,a)$}\kbdsidx{sumnumrat}\label{se:sumnumrat}
$\sum_{n\geq a}F(n)$, where $F$ is a rational function of degree less
than or equal to $-2$ and where poles of $F$ at integers $\geq a$ are
omitted from the summation. The argument $a$ must be a \typ{INT}
or \kbd{-oo}.
\bprog
? sumnumrat(1/(x^2+1)^2,0)
%1 = 1.3068369754229086939178621382829073480
? sumnumrat(1/x^2, -oo) \\ value at x=0 is discarded
%2 = 3.2898681336964528729448303332920503784
? 2*zeta(2)
%3 = 3.2898681336964528729448303332920503784
@eprog\noindent When $\deg F = -1$, we define
$$\sum_{-\infty}^{\infty} F(n) := \sum_{n\geq 0} (F(n) + F(-1-n)):$$
\bprog
? sumnumrat(1/x, -oo)
%4 = 0.E-38
@eprog

The library syntax is \fun{GEN}{sumnumrat}{GEN F, GEN a, long prec}.

\subsec{sumnumsidi$(n=a,f,\{\var{safe}=1\})$}\kbdsidx{sumnumsidi}\label{se:sumnumsidi}
Numerical summation of $f(n)$ from $n=a$ to $+\infty$ using Sidi
summation; $a$ must be an integer. The optional argument \kbd{safe}
(set by default to $1$) can be set to $0$ for a faster but much less
robust program; this is likely to lose accuracy when the sum is
non-alternating.
\bprog
? \pb3328
? z = zeta(2);
? exponent(sumnumsidi(n = 1, 1/n^2) - z)
time = 1,507 ms.
%2 = -3261 \\ already loses some decimals
? exponent(sumnumsidi(n = 1, 1/n^2, 0) - z)
time = 442 ms. \\ unsafe is much faster
%3 = -2108     \\ ... but very wrong

? l2 = log(2);
? exponent(sumnumsidi(n = 1,(-1)^(n-1)/n) - z)
time = 718 ms.
%5 = -3328 \\ not so slow and perfect
? exponent(sumnumsidi(n = 1,(-1)^(n-1)/n, 0) - z)
time = 504 ms.
%5 = -3328 \\ still perfect in unsafe mode, not so much faster
@eprog
\misctitle{Complexity} If the bitprecision is $b$, we try to achieve an
absolute error less than $2^{-b}$. The function $f$ is evaluated at $O(b)$
consecutive integer arguments at bit accuracy $1.56 b$ (resp.~$b$) in safe
(resp.~unsafe) mode.

The library syntax is \fun{GEN}{sumnumsidi0}{GEN n, GEN f, long safe, long prec}.

\subsec{sumpos$(X=a,\var{expr},\{\fl=0\})$}\kbdsidx{sumpos}\label{se:sumpos}
Numerical summation of the series \var{expr}, which must be a series of
terms having the same sign, the formal variable $X$ starting at $a$. The
algorithm uses Van Wijngaarden's trick for converting such a series into
an alternating one, then \tet{sumalt}. For regular functions, the
function \kbd{sumnum} is in general much faster once the initializations
have been made using \kbd{sumnuminit}. Contrary to \kbd{sumnum},
\kbd{sumpos} allows functions defined only at integers:
\bprog
? sumnum(n = 0, 1/n!)
 ***   at top-level: sumnum(n=1,1/n!)
 ***                              ^---
 ***   incorrect type in gtos [integer expected] (t_FRAC).
? sumpos(n = 0, 1/n!) - exp(1)
%2 = -1.0862155548773347717 E-33
@eprog\noindent On the other hand, when the function accepts general real
numbers, it is usually advantageous to replace $n$ by \kbd{$n$ * 1.0} in the
sumpos call in particular when rational functions are involved:
\bprog
? \p500
? sumpos(n = 0, n^7 / (n^9+n+1));
time = 6,108 ms.
? sumpos(n = 0, n *= 1.; n^7 / (n^9+n+1));
time = 2,788 ms.
? sumnumrat(n^7 / (n^9+n+1), 0);
time = 4 ms.
@eprog\noindent In the last example, \kbd{sumnumrat} is of course much
faster but it only applies to rational functions.

The routine is heuristic and assumes that \var{expr} is more or less a
decreasing function of $X$. In particular, the result will be completely
wrong if \var{expr} is 0 too often. We do not check either that all terms
have the same sign: as \tet{sumalt}, this function should be used to
try and guess the value of an infinite sum.

If $\fl=1$, use \kbd{sumalt}$(,1)$ instead of \kbd{sumalt}$(,0)$, see
\secref{se:sumalt}. Requiring more stringent analytic properties for
rigorous use, but allowing to compute fewer series terms.

To reach accuracy $10^{-p}$, both algorithms require $O(p^2)$ space;
furthermore, assuming the terms decrease polynomially (in $O(n^{-C})$), both
need to compute $O(p^2)$ terms. The \kbd{sumpos}$(,1)$ variant has a smaller
implied constant (roughly 1.5 times smaller). Since the \kbd{sumalt}$(,1)$
overhead is now small compared to the time needed to compute series terms,
this last variant should be about 1.5 faster. On the other hand, the
achieved accuracy may be much worse: as for \tet{sumalt}, since
conditions for rigorous use are hard to check, the routine is best used
heuristically.

\synt{sumpos}{void *E, GEN (*eval)(void*,GEN),GEN a,long prec}. Also
available is \tet{sumpos2} with the same arguments ($\fl = 1$).

\section{General number fields}

In this section, we describe functions related to general number fields.
Functions related to quadratic number fields are found in
\secref{se:arithmetic} (Arithmetic functions).

\subsec{Number field structures} %GPHELPskip

Let $K = \Q[X] / (T)$ a number field, $\Z_K$ its ring of integers, $T\in\Z[X]$
is monic. Three basic number field structures can be attached to $K$ in
GP:

\item $\tev{nf}$ denotes a number field, i.e.~a data structure output by
\tet{nfinit}. This contains the basic arithmetic data attached to the
number field: signature, maximal order (given by a basis \kbd{nf.zk}),
discriminant, defining polynomial $T$, etc.

\item $\tev{bnf}$ denotes a ``Buchmann's number field'', i.e.~a
data structure output by \tet{bnfinit}. This contains
$\var{nf}$ and the deeper invariants of the field: units $U(K)$, class group
$\Cl(K)$, as well as technical data required to solve the two attached
discrete logarithm problems.

\item $\tev{bnr}$ denotes a ``ray number field'', i.e.~a data structure
output by \kbd{bnrinit}, corresponding to the ray class group structure of
the field, for some modulus $f$. It contains a \var{bnf}, the modulus
$f$, the ray class group $\Cl_f(K)$ and data attached to
the discrete logarithm problem therein.

\subsec{Algebraic numbers and ideals} %GPHELPskip

\noindent An \tev{algebraic number} belonging to $K = \Q[X]/(T)$ is given as

\item a \typ{INT}, \typ{FRAC} or \typ{POL} (implicitly modulo $T$), or

\item a \typ{POLMOD} (modulo $T$), or

\item a \typ{COL}~\kbd{v} of dimension $N = [K:\Q]$, representing
the element in terms of the computed integral basis, as
\kbd{sum(i = 1, N,~v[i] * nf.zk[i])}. Note that a \typ{VEC}
will not be recognized.
\medskip

\noindent An \tev{ideal} is given in any of the following ways:

\item an algebraic number in one of the above forms, defining a principal ideal.

\item a prime ideal, i.e.~a 5-component vector in the format output by
\kbd{idealprimedec} or \kbd{idealfactor}.

\item a \typ{MAT}, square and in Hermite Normal Form (or at least
upper triangular with nonnegative coefficients), whose columns represent a
$\Z$-basis of the ideal.

One may use \kbd{idealhnf} to convert any ideal to the last (preferred) format.

\item an \emph{extended ideal} \sidx{ideal (extended)} is a 2-component
vector $[I, t]$, where $I$ is an ideal as above and $t$ is an algebraic
number, representing the ideal $(t)I$. This is useful whenever \tet{idealred}
is involved, implicitly working in the ideal class group, while keeping track
of principal ideals. The following multiplicative ideal operations
update the principal part: \kbd{idealmul}, \kbd{idealinv},
\kbd{idealsqr}, \kbd{idealpow} and \kbd{idealred}; e.g.~using \kbd{idealmul}
on $[I,t]$, $[J,u]$, we obtain $[IJ, tu]$. In all other
functions, the extended part is silently discarded, e.g.~using
\kbd{idealadd} with the above input produces $I+J$.

The ``principal part'' $t$ in an extended ideal may be
represented in any of the above forms, and \emph{also} as a factorization
matrix (in terms of number field elements, not ideals!), possibly the empty
factorization matrix \kbd{factor(1)} representing $1$; the empty matrix
\kbd{[;]} is also accepted as a synonym for $1$. When $t$ is such a
factorization matrix, elements stay in
factored form, or \tev{famat} for \emph{fa}ctorization \emph{mat}rix, which
is a convenient way to avoid coefficient explosion. To recover the
conventional expanded form, try \tet{nffactorback}; but many functions
already accept \var{famat}s as input, for instance \tet{ideallog}, so
expanding huge elements should never be necessary.

\subsec{Finite abelian groups} %GPHELPskip

A finite abelian group $G$ in user-readable format is given by its Smith
Normal Form as a pair $[h,d]$ or triple $[h,d,g]$.
Here $h$ is the cardinality of $G$, $(d_i)$ is the vector of elementary
divisors, and $(g_i)$ is a vector of generators. In short,
$G = \oplus_{i\leq n} (\Z/d_i\Z) g_i$, with $d_n \mid \dots \mid d_2 \mid d_1$
and $\prod d_i = h$. This information can also be retrieved as
$G.\kbd{no}$, $G.\kbd{cyc}$ and $G.\kbd{gen}$.

\item a \tev{character} on the abelian group
$\oplus (\Z/d_j\Z) g_j$
is given by a row vector $\chi = [a_1,\ldots,a_n]$ such that
$\chi(\prod g_j^{n_j}) = \exp(2\pi i\sum a_j n_j / d_j)$.

\item given such a structure, a \tev{subgroup} $H$ is input as a square
matrix in HNF, whose columns express generators of $H$ on the given generators
$g_i$. Note that the determinant of that matrix is equal to the index $(G:H)$.

\subsec{Relative extensions} %GPHELPskip

We now have a look at data structures attached to relative extensions
of number fields $L/K$, and to projective $\Z_K$-modules. When defining a
relative extension $L/K$, the $\var{nf}$ attached to the base field $K$
must be defined by a variable having a lower priority (see
\secref{se:priority}) than the variable defining the extension. For example,
you may use the variable name $y$ to define the base field $K$, and $x$ to
define the relative extension $L/K$.

\misctitle{Basic definitions}\label{se:ZKmodules} %GPHELPskip

\item $\tev{rnf}$ denotes a relative number field, i.e.~a data structure
output by \kbd{rnfinit}, attached to the extension $L/K$. The \var{nf}
attached to be base field $K$ is \kbd{rnf.nf}.

\item A \emph{relative matrix} is an $m\times n$ matrix whose entries are
elements of $K$, in any form. Its $m$ columns $A_j$ represent elements
in $K^n$.

\item An \tev{ideal list} is a row vector of fractional ideals of the number
field $\var{nf}$.

\item A \tev{pseudo-matrix} is a 2-component row vector $(A,I)$ where $A$
is a relative $m\times n$ matrix and $I$ an ideal list of length $n$. If $I =
\{\goth{a}_1,\dots, \goth{a}_n\}$ and the columns of $A$ are $(A_1,\dots,
A_n)$, this data defines the torsion-free (projective) $\Z_K$-module
$\goth{a}_1 A_1\oplus \goth{a}_n A_n$.

\item An \tev{integral pseudo-matrix} is a 3-component row vector $(A,I,J)$
where $A = (a_{i,j})$ is an $m\times n$ relative matrix and $I =
(\goth{b}_1,\dots, \goth{b}_m)$, $J = (\goth{a}_1,\dots, \goth{a}_n)$ are ideal
lists, such that $a_{i,j} \in \goth{b}_i \goth{a}_j^{-1}$ for all $i,j$. This
data defines two abstract projective $\Z_K$-modules
$N = \goth{a}_1\omega_1\oplus \cdots\oplus \goth{a}_n\omega_n $ in $K^n$,
$P = \goth{b}_1\eta_1\oplus \cdots\oplus \goth{b}_m\eta_m$ in $K^m$, and a
$\Z_K$-linear map $f:N\to P$ given by
$$ f(\sum \alpha_j\omega_j) = \sum_i \Big(a_{i,j}\alpha_j\Big) \eta_i.$$
This data defines the $\Z_K$-module $M = P/f(N)$.

\item Any \emph{projective} $\Z_K$-module\varsidx{projective module} $M$
of finite type in $K^m$ can be given by a pseudo matrix $(A,I)$.

\item An arbitrary $\Z_K$ module of finite type in $K^m$, with nontrivial
torsion, is given by an integral pseudo-matrix $(A,I,J)$

\misctitle{Algebraic numbers in relative extension}

We are given a number field $K = \kbd{nfinit}(T)$, attached to $K = \Q[Y]/(T)$,
$T \in \Q[Y]$, and a relative extension $L = \kbd{rnfinit}(K, P)$, attached
to $L = K[X]/(P)$, $P \in K[X]$.
In all contexts (except \kbd{rnfeltabstorel}, see below), an
\tev{algebraic number} is given as

\item a \typ{INT}, \typ{FRAC} or \typ{POL} in $\Q[Y]$ (implicitly modulo $T$)
or a \typ{POL} in $K[X]$ (implicitly modulo $P$),

\item a \typ{POLMOD} (modulo $T$ or $P$), or

\item a \typ{COL}~\kbd{v} of dimension $m = [K:\Q]$, representing
the element in terms of the integral basis \kbd{K.zk};

\item if an absolute \kbd{nf} structure \kbd{Labs} was attached to $L$, via
\kbd{Labs = nfinit}$(L)$, then we can also use a \typ{COL}~\kbd{v} of
dimension $[L:\Q]$, representing the element in terms of the computed integral
basis \kbd{Labs.zk}. Be careful that in the degenerate case
$L = K$, then the previous interpretation (with respect to \kbd{$K$.zk})
takes precedence. This is no concern when $K = \Q$ or if $P = X - Y$
(because in that case the primitive
polynomial \kbd{Labs.pol} defining $L$ of $\Q$ is \kbd{nf.pol} and the
computation of \kbd{nf.zk} is deterministic); but in other cases, the
integer bases attached to $K$ and \kbd{Labs} may differ.

\misctitle{Special case: \kbd{rnfabstorel}} This function assumes
that elements are given in absolute representation (with respect to
\kbd{Labs.zk} or modulo \kbd{Labs.pol} and converts them to relative
representation modulo \kbd{$L$.pol}. In that function (only), a \typ{POL} in
$X$ is implicitly understood modulo \kbd{Labs.pol} and a \typ{COL}
of length $[L:\Q]$ refers to the integral basis \kbd{Labs.zk} in all cases,
including $L = K$.

\misctitle{Pseudo-bases, determinant} %GPHELPskip

\item The pair $(A,I)$ is a \tev{pseudo-basis} of the module it
generates if the $\goth{a}_j$ are nonzero, and the $A_j$ are $K$-linearly
independent. We call $n$ the \emph{size} of the pseudo-basis. If $A$ is a
relative matrix, the latter condition means it is square with nonzero
determinant; we say that it is in Hermite Normal
Form\sidx{Hermite normal form} (HNF) if it is upper triangular and all the
elements of the diagonal are equal to 1.

\item For instance, the relative integer basis \kbd{rnf.zk} is a pseudo-basis
$(A,I)$ of $\Z_L$, where $A = \kbd{rnf.zk[1]}$ is a vector of elements of $L$,
which are $K$-linearly independent. Most \var{rnf} routines return and handle
$\Z_K$-modules contained in $L$ (e.g.~$\Z_L$-ideals) via a pseudo-basis
$(A',I')$, where $A'$ is a relative matrix representing a vector of elements of
$L$ in terms of the fixed basis \kbd{rnf.zk[1]}

\item The \emph{determinant} of a pseudo-basis $(A,I)$ is the ideal
equal to the product of the determinant of $A$ by all the ideals of $I$. The
determinant of a pseudo-matrix is the determinant of any pseudo-basis of the
module it generates.

\subsec{Class field theory}\label{se:CFT}

A $\tev{modulus}$, in the sense of class field theory, is a divisor supported
on the real and finite places of $K$. In PARI terms, this means either an
ordinary ideal $I$ as above (no Archimedean component), or a pair $[I,a]$,
where $a$ is a vector with $r_1$ $\{0,1\}$-components, corresponding to the
infinite part of the divisor. More precisely, the $i$-th component of $a$
corresponds to the real embedding attached to the $i$-th real root of
\kbd{K.roots}. (That ordering is not canonical, but well defined once a
defining polynomial for $K$ is chosen.) For instance, \kbd{[1, [1,1]]} is a
modulus for a real quadratic field, allowing ramification at any of the two
places at infinity, and nowhere else.

A \tev{bid} or ``big ideal'' is a structure output by \kbd{idealstar}
needed to compute in $(\Z_K/I)^*$, where $I$ is a modulus in the above sense.
It is a finite abelian group as described above, supplemented by
technical data needed to solve discrete log problems.

Finally we explain how to input ray number fields (or \var{bnr}), using class
field theory. These are defined by a triple $A$, $B$, $C$, where the
defining set $[A,B,C]$ can have any of the following forms:
$[\var{bnr}]$,
$[\var{bnr},\var{subgroup}]$,
$[\var{bnr},\var{character}]$,
$[\var{bnf},\var{mod}]$,
$[\var{bnf},\var{mod},\var{subgroup}]$. The last two forms are kept for
backward compatibility, but no longer serve any real purpose (see example
below); no newly written function will accept them.

\item $\var{bnf}$ is as output by \kbd{bnfinit}, where units are mandatory
unless the modulus is trivial; \var{bnr} is as output by \kbd{bnrinit}. This
is the ground field $K$.

\item \emph{mod} is a modulus $\goth{f}$, as described above.

\item \emph{subgroup} a subgroup of the ray class group modulo $\goth{f}$ of
$K$. As described above, this is input as a square matrix expressing
generators of a subgroup of the ray class group \kbd{\var{bnr}.clgp} on the
given generators. We also allow a \typ{INT} $n$ for $n \cdot \text{Cl}_f$.

\item \emph{character} is a character $\chi$ of the ray class group modulo
$\goth{f}$, representing the subgroup $\text{Ker} \chi$.

The corresponding \var{bnr} is the subfield of the ray class field of $K$
modulo $\goth{f}$, fixed by the given subgroup.

\bprog
  ? K = bnfinit(y^2+1);
  ? bnr = bnrinit(K, 13)
  ? %.clgp
  %3 = [36, [12, 3]]
  ? bnrdisc(bnr); \\ discriminant of the full ray class field
  ? bnrdisc(bnr, [3,1;0,1]); \\ discriminant of cyclic cubic extension of K
  ? bnrconductor(bnr, [3,1]); \\ conductor of chi: g1->zeta_12^3, g2->zeta_3
@eprog\noindent
We could have written directly
\bprog
  ? bnrdisc(K, 13);
  ? bnrdisc(K, 13, [3,1;0,1]);
@eprog\noindent
avoiding one \tet{bnrinit}, but this would actually be slower since the
\kbd{bnrinit} is called internally anyway. And now twice!

\subsec{General use}

All the functions which are specific to relative extensions, number fields,
Buchmann's number fields, Buchmann's number rays, share the prefix \kbd{rnf},
\kbd{nf}, \kbd{bnf}, \kbd{bnr} respectively. They take as first argument a
number field of that precise type, respectively output by \kbd{rnfinit},
\kbd{nfinit}, \kbd{bnfinit}, and \kbd{bnrinit}.

However, and even though it may not be specified in the descriptions of the
functions below, it is permissible, if the function expects a $\var{nf}$, to
use a $\var{bnf}$ instead, which contains much more information. On the other
hand, if the function requires a \kbd{bnf}, it will \emph{not} launch
\kbd{bnfinit} for you, which is a costly operation. Instead, it will give you
a specific error message. In short, the types
$$ \kbd{nf} \leq \kbd{bnf} \leq \kbd{bnr}$$
are ordered, each function requires a minimal type to work properly, but you
may always substitute a larger type.

The data types corresponding to the structures described above are rather
complicated. Thus, as we already have seen it with elliptic curves, GP
provides ``member functions'' to retrieve data from these structures (once
they have been initialized of course). The relevant types of number fields
are indicated between parentheses: \smallskip

\sidx{member functions}
\settabs\+xxxxxxx&(\var{bnr},x&\var{bnf},x&nf\hskip2pt&)x&: &\cr
\+\tet{bid}    &(\var{bnr}&&&)&: & bid ideal structure.\cr

\+\tet{bnf}    &(\var{bnr},& \var{bnf}&&)&: & Buchmann's number field.\cr

\+\tet{clgp}  &(\var{bnr},& \var{bnf}&&)&: & classgroup. This one admits the
following three subclasses:\cr

\+      \quad \tet{cyc} &&&&&: & \quad cyclic decomposition
 (SNF)\sidx{Smith normal form}.\cr

\+      \quad \kbd{gen}\sidx{gen (member function)} &&&&&: &
 \quad generators.\cr

\+      \quad \tet{no}  &&&&&: & \quad number of elements.\cr

\+\tet{diff}  &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the different ideal.\cr

\+\tet{codiff}&(\var{bnr},& \var{bnf},& \var{nf}&)&: & the codifferent
(inverse of the different in the ideal group).\cr

\+\tet{disc} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & discriminant.\cr

\+\tet{fu}   &(          & \var{bnf}&&)&: & \idx{fundamental units}.\cr

\+\tet{index}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: &
 \idx{index} of the power order in the ring of integers.\cr

\+\tet{mod}   &(\var{bnr}&&&)&: & modulus.\cr

\+\tet{nf}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & number field.\cr

\+\tet{pol}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & defining polynomial.\cr

\+\tet{r1} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the number
of real embeddings.\cr

\+\tet{r2} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the number
of pairs of complex embeddings.\cr

\+\tet{reg}  &(          & \var{bnf}&&)&: & regulator.\cr

\+\tet{roots}&(\var{bnr},& \var{bnf},& \var{nf}&)&: & roots of the
polynomial generating the field.\cr

\+\tet{sign} &(\var{bnr},& \var{bnf},& \var{nf}&)&: & signature $[r1,r2]$.\cr

\+\tet{t2}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & the $T_2$ matrix (see
\kbd{nfinit}).\cr

\+\tet{tu}   &(          & \var{bnf}&&)&: & a generator for the torsion
units.\cr

\+\tet{zk}   &(\var{bnr},& \var{bnf},& \var{nf}&)&: & integral basis, i.e.~a
$\Z$-basis of the maximal order.\cr

\+\tet{zkst}   &(\var{bnr}&&&)&: & structure of $(\Z_K/m)^*$.\cr

The member functions \kbd{.codiff}, \kbd{.t2} and \kbd{.zk} perform a
computation and are relatively expensive in large degree: move them out of
tight loops and store them in variables.

  For instance, assume that $\var{bnf} = \kbd{bnfinit}(\var{pol})$, for some
polynomial. Then \kbd{\var{bnf}.clgp} retrieves the class group, and
\kbd{\var{bnf}.clgp.no} the class number. If we had set $\var{bnf} =
\kbd{nfinit}(\var{pol})$, both would have output an error message. All these
functions are completely recursive, thus for instance
\kbd{\var{bnr}.bnf.nf.zk} will yield the maximal order of \var{bnr}, which
you could get directly with a simple \kbd{\var{bnr}.zk}.

\subsec{Class group, units, and the GRH}\label{se:GRHbnf}

Some of the functions starting with \kbd{bnf} are implementations of the
sub-exponential algorithms for finding class and unit groups under \idx{GRH},
due to Hafner-McCurley, \idx{Buchmann} and Cohen-Diaz-Olivier. The general
call to the functions concerning class groups of general number fields
(i.e.~excluding \kbd{quadclassunit}) involves a polynomial $P$ and a
technical vector
$$\var{tech} = [c_1, c_2, \var{nrpid} ],$$
where the parameters are to be understood as follows:

$P$ is the defining polynomial for the number field, which must be in
$\Z[X]$, irreducible and monic. In fact, if you supply a nonmonic polynomial
at this point, \kbd{gp} issues a warning, then \emph{transforms your
polynomial} so that it becomes monic. The \kbd{nfinit} routine
will return a different result in this case: instead of \kbd{res}, you get a
vector \kbd{[res,Mod(a,Q)]}, where \kbd{Mod(a,Q) = Mod(X,P)} gives the change
of variables. In all other routines, the variable change is simply lost.

The \var{tech} interface is obsolete and you should not tamper with
these parameters. Indeed, from version 2.4.0 on,

\item the results are always rigorous under \idx{GRH} (before that version,
they relied on a heuristic strengthening, hence the need for overrides).

\item the influence of these parameters on execution time and stack size is
marginal. They \emph{can} be useful to fine-tune and experiment with the
\kbd{bnfinit} code, but you will be better off modifying all tuning
parameters in the C code (there are many more than just those three).
We nevertheless describe it for completeness.

The numbers $c_1 \leq c_2$ are nonnegative real numbers. By default they are
chosen so that the result is correct under GRH. For $i = 1,2$, let
$B_i = c_i(\log |d_K|)^2$, and denote by $S(B)$ the set of maximal ideals of
$K$ whose norm is less than $B$. We want $S(B_1)$ to generate $\Cl(K)$ and hope
that $S(B_2)$ can be \emph{proven} to generate $\Cl(K)$.

More precisely, $S(B_1)$ is a factorbase used to compute a tentative
$\Cl(K)$ by generators and relations. We then check explicitly, using
essentially \kbd{bnfisprincipal}, that the elements of $S(B_2)$ belong to the
span of $S(B_1)$. Under the assumption that $S(B_2)$ generates $\Cl(K)$, we
are done. User-supplied $c_i$ are only used to compute initial guesses for
the bounds $B_i$, and the algorithm increases them until one can \emph{prove}
under GRH that $S(B_2)$ generates $\Cl(K)$. A uniform result of Bach says
that $c_2 = 12$ is always suitable, but this bound is very pessimistic and a
direct algorithm due to Belabas-Diaz-Friedman is used to check the condition,
assuming GRH. The default values are $c_1 = c_2 = 0$. When $c_1$ is equal to
$0$ the algorithm takes it equal to $c_2$.

$\var{nrpid}$ is the maximal number of small norm relations attached to each
ideal in the factor base. Set it to $0$ to disable the search for small norm
relations. Otherwise, reasonable values are between 4 and 20. The default is
4.

\misctitle{Warning} Make sure you understand the above! By default, most of
the \kbd{bnf} routines depend on the correctness of the GRH. In particular,
any of the class number, class group structure, class group generators,
regulator and fundamental units may be wrong, independently of each other.
Any result computed from such a \kbd{bnf} may be wrong. The only guarantee is
that the units given generate a subgroup of finite index in the full unit
group. You must use \kbd{bnfcertify} to certify the computations
unconditionally.

\misctitle{Remarks}

You do not need to supply the technical parameters (under the library you
still need to send at least an empty vector, coded as \kbd{NULL}). However,
should you choose to set some of them, they \emph{must} be given in the
requested order. For example, if you want to specify a given value of
\var{nrpid}, you must give some values as well for $c_1$ and $c_2$, and provide
a vector $[c_1,c_2,\var{nrpid}]$.

Note also that you can use an $\var{nf}$ instead of $P$, which avoids
recomputing the integral basis and analogous quantities.

\subsec{Hecke Grossencharacters}\label{se:GCHAR}

Hecke Grossencharacters are continuous characters of the id\`ele class group;
they generalize classical Hecke characters on ray class groups obtained through
the $\var{bnr}$ structure.

Let $K$ be a number field, $\A^\times$ its group of id\`eles.
Every Grossencharacter
$$
   \chi \colon \A^\times/K^\times \to \C^\times
$$
can be uniquely written~$\chi = \chi_0 \|\cdot \|^s$ for some~$s\in\C$
and some character~$\chi_0$ of the compact
group~$\A^\times/(K^\times\cdot\R_{>0})$,
where~$\|a\| = \prod_v |a_v|_v$ is the id\`ele norm.

Let~$\goth{m}$ be a modulus
(an integral ideal and a finite set of real places). Let $U(\goth{m})$ be the
subgroup of id\`eles congruent to $1$ modulo $\goth{m}$
(units outside $\goth{m}$, positive at real places in $\goth{m}$).
The Hecke Grossencharacters defined modulo $\goth{m}$ are the characters of
the id\`ele class group
$$
 C_K(\goth{m}) = \A^\times/(K^\times\cdot U(\goth{m})),
$$
that is, combinations of an archimedean
character $\chi_\infty$ on the connected component $K_\infty^{\times \circ}$
and a ray class group character $\chi_f$ satisfying a compatibility condition
$\chi_\infty(a)\chi_f(a)=1$ for all units $a$ congruent to 1 modulo $\goth{m}$.

\varsidx{gchar} %
\item \var{gc} denotes a structure allowing to compute with Hecke
Grossencharacters.

\item \kbd{gcharinit(\var{bnf},\var{mod})} initializes the structure \var{gc}.
The underlying number field and modulus can be accessed using
\var{gc}\kbd{.bnf} and \var{gc}\kbd{.mod}.

\item \var{gc}\kbd{.cyc} describes the finite abelian group structure of
\var{gc}, the torsion part corresponding to finite order ray class
characters, the exact zeros corresponding to a lattice of infinite order
Grossencharacters, and the approximate zero being a placeholder for the
complex powers of the id\`ele norm.

\item A Hecke character of modulus~$\goth{m}$ is described as a \typ{COL} of
coordinates corresponding to~\var{gc}\kbd{.cyc}: all the coordinates are
integers except the last one, which can be an arbitrary complex number, or
omitted instead of~$0$.

\item Hecke Grossencharacters have $L$-functions and can be given to all \kbd{lfun} objects as a 2 components
vector \kbd{[\var{gc},\var{chi}]}.

\subsec{bnfcertify$(\var{bnf},\{\fl = 0\})$}\kbdsidx{bnfcertify}\label{se:bnfcertify}
$\var{bnf}$ being as output by
\kbd{bnfinit}, checks whether the result is correct, i.e.~whether it is
possible to remove the assumption of the Generalized Riemann
Hypothesis\sidx{GRH}. It is correct if and only if the answer is 1. If it is
incorrect, the program may output some error message, or loop indefinitely.
You can check its progress by increasing the debug level. The \var{bnf}
structure must contain the fundamental units:
\bprog
? K = bnfinit(x^3+2^2^3+1); bnfcertify(K)
  ***   at top-level: K=bnfinit(x^3+2^2^3+1);bnfcertify(K)
  ***                                        ^-------------
  *** bnfcertify: precision too low in makeunits [use bnfinit(,1)].
? K = bnfinit(x^3+2^2^3+1, 1); \\ include units
? bnfcertify(K)
%3 = 1
@eprog

If flag is present, only certify that the class group is a quotient of the
one computed in bnf (much simpler in general); likewise, the computed units
may form a subgroup of the full unit group. In this variant, the units are
no longer needed:
\bprog
? K = bnfinit(x^3+2^2^3+1); bnfcertify(K, 1)
%4 = 1
@eprog

The library syntax is \fun{long}{bnfcertify0}{GEN bnf, long flag}.
Also available is  \fun{GEN}{bnfcertify}{GEN bnf} ($\fl=0$).

\subsec{bnfdecodemodule$(\var{nf},m)$}\kbdsidx{bnfdecodemodule}\label{se:bnfdecodemodule}
If $m$ is a module as output in the
first component of an extension given by \kbd{bnrdisclist}, outputs the
true module.
\bprog
? K = bnfinit(x^2+23); L = bnrdisclist(K, 10); s = L[2]
%1 = [[[Vecsmall([8]), Vecsmall([1])], [[0, 0, 0]]],
      [[Vecsmall([9]), Vecsmall([1])], [[0, 0, 0]]]]
? bnfdecodemodule(K, s[1][1])
%2 =
[2 0]

[0 1]
? bnfdecodemodule(K,s[2][1])
%3 =
[2 1]

[0 1]
@eprog

The library syntax is \fun{GEN}{decodemodule}{GEN nf, GEN m}.

\subsec{bnfinit$(P,\{\fl=0\},\{\var{tech}=[\,]\})$}\kbdsidx{bnfinit}\label{se:bnfinit}
Initializes a
\kbd{bnf} structure. Used in programs such as \kbd{bnfisprincipal},
\kbd{bnfisunit} or \kbd{bnfnarrow}. By default, the results are conditional
on the GRH, see \ref{se:GRHbnf}. The result is a
10-component vector \var{bnf}.

This implements \idx{Buchmann}'s sub-exponential algorithm for computing the
class group, the regulator and a system of \idx{fundamental units} of the
general algebraic number field $K$ defined by the irreducible polynomial $P$
with integer coefficients. The meaning of \fl is as follows:

\item $\fl = 0$ (default). This is the historical behavior, kept for
compatibility reasons and speed. It has severe drawbacks but is likely to be
a little faster than the alternative, twice faster say, so only use it if
speed is paramount, you obtain a useful speed gain for the fields
under consideration, and you are only interested in the field invariants
such as the classgroup structure or its regulator. The computations involve
exact algebraic numbers which are replaced by floating point embeddings for
the sake of speed. If the precision is insufficient, \kbd{gp} may not be able
to compute fundamental units, nor to solve some discrete logarithm problems.
It \emph{may} be possible to increase the precision of the \kbd{bnf}
structure using \kbd{nfnewprec} but this may fail, in particular when
fundamental units are large. In short, the resulting \kbd{bnf}
structure is correct and contains useful information but later
function calls to \kbd{bnfisprincpal} or \kbd{bnrclassfield} may fail.

When $\fl=1$, we keep an exact algebraic version of all floating point data
and this allows to guarantee that functions using the structure will always
succeed, as well as to compute the fundamental units exactly. The units are
computed in compact form, as a product of small $S$-units, possibly with
huge exponents. This flag also allows \kbd{bnfisprincipal} to compute
generators of principal ideals in factored form as well. Be warned that
expanding such products explicitly can take a very long time, but they can
easily be mapped to floating point or $\ell$-adic embeddings of bounded
accuracy, or to $K^*/(K^*)^\ell$, and this is enough for applications. In
short, this flag should be used by default, unless you have a very good
reason for it, for instance building massive tables of class numbers, and
you do not care about units or the effect large units would have on your
computation.

$\var{tech}$ is a technical vector (empty by default, see \ref{se:GRHbnf}).
Careful use of this parameter may speed up your computations,
but it is mostly obsolete and you should leave it alone.

\smallskip

The components of a \var{bnf} are technical.
In fact: \emph{never access a component directly, always use
a proper member function.} However, for the sake of completeness and internal
documentation, their description is as follows. We use the notations
explained in the book by H. Cohen, \emph{A Course in Computational Algebraic
Number Theory}, Graduate Texts in Maths \key{138}, Springer-Verlag, 1993,
Section 6.5, and subsection 6.5.5 in particular.

$\var{bnf}[1]$ contains the matrix $W$, i.e.~the matrix in Hermite normal
form giving relations for the class group on prime ideal generators
$(\goth{p}_i)_{1\le i\le r}$.

$\var{bnf}[2]$ contains the matrix $B$, i.e.~the matrix containing the
expressions of the prime ideal factorbase in terms of the $\goth{p}_i$.
It is an $r\times c$ matrix.

$\var{bnf}[3]$ contains the complex logarithmic embeddings of the system of
fundamental units which has been found. It is an $(r_1+r_2)\times(r_1+r_2-1)$
matrix.

$\var{bnf}[4]$ contains the matrix $M''_C$ of Archimedean components of the
relations of the matrix $(W|B)$.

$\var{bnf}[5]$ contains the prime factor base, i.e.~the list of prime
ideals used in finding the relations.

$\var{bnf}[6]$ contains a dummy $0$.

$\var{bnf}[7]$ or \kbd{\var{bnf}.nf} is equal to the number field data
$\var{nf}$ as would be given by \kbd{nfinit}.

$\var{bnf}[8]$ is a vector containing the classgroup \kbd{\var{bnf}.clgp}
as a finite abelian group, the regulator \kbd{\var{bnf}.reg},
the number of roots of unity and a generator \kbd{\var{bnf}.tu}, the
fundamental units \emph{in expanded form} \kbd{\var{bnf}.fu}. If the
fundamental units were omitted in the \var{bnf}, \kbd{\var{bnf}.fu} returns
the sentinel value $0$. If $\fl = 1$, this vector contain also algebraic
data corresponding to the fundamental units and to the discrete logarithm
problem (see \kbd{bnfisprincipal}). In particular, if $\fl = 1$ we may
\emph{only} know the units in factored form: the first call to
\kbd{\var{bnf}.fu} expands them, which may be very costly, then caches the
result.

$\var{bnf}[9]$ is a vector used in \tet{bnfisprincipal} only
and obtained as follows. Let $D = U W V$ obtained by applying the
\idx{Smith normal form} algorithm to the matrix $W$ (= $\var{bnf}[1]$) and
let $U_r$ be the reduction of $U$ modulo $D$. The first elements of the
factorbase are given (in terms of \kbd{bnf.gen}) by the columns of $U_r$,
with Archimedean component $g_a$; let also $GD_a$ be the Archimedean
components of the generators of the (principal) ideals defined by the
\kbd{bnf.gen[i]\pow bnf.cyc[i]}. Then $\var{bnf}[9]=[U_r, g_a, GD_a]$,
followed by technical exact components which allow to recompute $g_a$ and
$GD_a$ to higher accuracy.

$\var{bnf}[10]$ is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available, which
is rarely needed, hence would be too expensive to compute during the initial
\kbd{bnfinit} call. For instance, the generators of the principal ideals
\kbd{bnf.gen[i]\pow bnf.cyc[i]} (during a call to \tet{bnrisprincipal}), or
those corresponding to the relations in $W$ and $B$ (when the \kbd{bnf}
internal precision needs to be increased).

The library syntax is \fun{GEN}{bnfinit0}{GEN P, long flag, GEN tech = NULL, long prec}.

Also available is \fun{GEN}{Buchall}{GEN P, long flag, long prec},
corresponding to \kbd{tech = NULL}, where
\kbd{flag} is either $0$ (default) or \tet{nf_FORCE} (include all data in
algebraic form). The function
\fun{GEN}{Buchall_param}{GEN P, double c1, double c2, long nrpid, long flag, long prec} gives direct access to the technical parameters.

\subsec{bnfisintnorm$(\var{bnf},x)$}\kbdsidx{bnfisintnorm}\label{se:bnfisintnorm}
Computes a complete system of
solutions (modulo units of positive norm) of the absolute norm equation
$\Norm(a)=x$,
where $a$ is an integer in $\var{bnf}$. If $\var{bnf}$ has not been certified,
the correctness of the result depends on the validity of \idx{GRH}.

See also \tet{bnfisnorm}.

The library syntax is \fun{GEN}{bnfisintnorm}{GEN bnf, GEN x}.
The function \fun{GEN}{bnfisintnormabs}{GEN bnf, GEN a},
where \kbd{bnf} is a true \var{bnf} structure,
returns a complete system of solutions modulo units of the absolute norm
equation $|\Norm(x)| = |a|$. As fast as \kbd{bnfisintnorm}, but solves
the two equations $\Norm(x) = \pm a$ simultaneously.

\subsec{bnfisnorm$(\var{bnf},x,\{\fl=1\})$}\kbdsidx{bnfisnorm}\label{se:bnfisnorm}
Tries to tell whether the
rational number $x$ is the norm of some element y in $\var{bnf}$. Returns a
vector $[a,b]$ where $x=Norm(a)*b$. Looks for a solution which is an $S$-unit,
with $S$ a certain set of prime ideals containing (among others) all primes
dividing $x$. If $\var{bnf}$ is known to be \idx{Galois}, you may set $\fl=0$
(in this case, $x$ is a norm iff $b=1$). If $\fl$ is nonzero the program adds
to $S$ the following prime ideals, depending on the sign of $\fl$. If $\fl>0$,
the ideals of norm less than $\fl$. And if $\fl<0$ the ideals dividing $\fl$.

Assuming \idx{GRH}, the answer is guaranteed (i.e.~$x$ is a norm iff $b=1$),
if $S$ contains all primes less than $12\log(\disc(\var{Bnf}))^2$, where
$\var{Bnf}$ is the Galois closure of $\var{bnf}$.

See also \tet{bnfisintnorm}.

The library syntax is \fun{GEN}{bnfisnorm}{GEN bnf, GEN x, long flag}.

\subsec{bnfisprincipal$(\var{bnf},x,\{\fl=1\})$}\kbdsidx{bnfisprincipal}\label{se:bnfisprincipal}
$\var{bnf}$ being the \sidx{principal ideal}
number field data output by \kbd{bnfinit}, and $x$ being an ideal, this
function tests whether the ideal is principal or not. The result is more
complete than a simple true/false answer and solves a general discrete
logarithm problem. Assume the class group is $\oplus (\Z/d_i\Z)g_i$
(where the generators $g_i$ and their orders $d_i$ are respectively given by
\kbd{bnf.gen} and \kbd{bnf.cyc}). The routine returns a row vector $[e,t]$,
where $e$ is a vector of exponents $0 \leq e_i < d_i$, and $t$ is a number
field element such that
$$ x = (t) \prod_i  g_i^{e_i}.$$
For \emph{given} $g_i$ (i.e. for a given \kbd{bnf}), the $e_i$ are unique,
and $t$ is unique modulo units.

In particular, $x$ is principal if and only if $e$ is the zero vector. Note
that the empty vector, which is returned when the class number is $1$, is
considered to be a zero vector (of dimension $0$).
\bprog
? K = bnfinit(y^2+23);
? K.cyc
%2 = [3]
? K.gen
%3 = [[2, 0; 0, 1]]          \\ a prime ideal above 2
? P = idealprimedec(K,3)[1]; \\ a prime ideal above 3
? v = bnfisprincipal(K, P)
%5 = [[2]~, [3/4, 1/4]~]
? idealmul(K, v[2], idealfactorback(K, K.gen, v[1]))
%6 =
[3 0]

[0 1]
? % == idealhnf(K, P)
%7 = 1
@eprog

\noindent The binary digits of \fl mean:

\item $1$: If set, outputs $[e,t]$ as explained above, otherwise returns
only $e$, which is easier to compute. The following idiom only tests
whether an ideal is principal:
\bprog
  is_principal(bnf, x) = !bnfisprincipal(bnf,x,0);
@eprog

\item $2$: It may not be possible to recover $t$, given the initial accuracy
to which the \kbd{bnf} structure was computed. In that case, a warning is
printed and $t$ is set equal to the empty vector \kbd{[]\til}. If this bit is
set, increase the precision and recompute needed quantities until $t$ can be
computed. Warning: setting this may induce \emph{lengthy} computations, and
the result may be too large to be physically representable in any case.
You should consider using flag $4$ instead.

\item $4$: Return $t$ in factored form (compact representation),
as a small product of $S$-units for a small set of finite places $S$,
possibly with huge exponents. This kind of result can be cheaply mapped to
$K^*/(K^*)^\ell$ or to $\C$ or $\Q_p$ to bounded accuracy and this is usually
enough for applications. Explicitly expanding such a compact representation
is possible using \kbd{nffactorback} but may be \emph{very} costly.
The algorithm is guaranteed to succeed if the \kbd{bnf} was computed using
\kbd{bnfinit(,1)}. If not, the algorithm may fail to compute a huge
generator in this case (and replace it by \kbd{[]\til}). This is orders of
magnitude faster than flag $2$ when the generators are indeed large.

The library syntax is \fun{GEN}{bnfisprincipal0}{GEN bnf, GEN x, long flag}.
Instead of the above hardcoded numerical flags, one should
rather use an or-ed combination of the symbolic flags \tet{nf_GEN} (include
generators, possibly a place holder if too difficult), \tet{nf_GENMAT}
(include generators in compact form) and
\tet{nf_FORCE} (insist on finding the generators, a no-op if \tet{nf_GENMAT}
is included).

\subsec{bnfissunit$(\var{bnf},\var{sfu},x)$}\kbdsidx{bnfissunit}\label{se:bnfissunit}
This function is obsolete, use \kbd{bnfisunit}.

The library syntax is \fun{GEN}{bnfissunit}{GEN bnf, GEN sfu, GEN x}.

\subsec{bnfisunit$(\var{bnf},x, \{U\})$}\kbdsidx{bnfisunit}\label{se:bnfisunit}
\var{bnf} being the number field data
output by \kbd{bnfinit} and $x$ being an algebraic number (type integer,
rational or polmod), this outputs the decomposition of $x$ on the fundamental
units and the roots of unity if $x$ is a unit, the empty vector otherwise.
More precisely, if $u_1$,\dots,$u_r$ are the fundamental units, and $\zeta$
is the generator of the group of roots of unity (\kbd{bnf.tu}), the output is
a vector $[x_1,\dots,x_r,x_{r+1}]$ such that $x=u_1^{x_1}\cdots
u_r^{x_r}\cdot\zeta^{x_{r+1}}$. The $x_i$ are integers but the last one
($i = r+1$) is only defined modulo the order $w$ of $\zeta$ and is guaranteed
to be in $[0,w[$.

Note that \var{bnf} need not contain the fundamental units explicitly: it may
contain the placeholder $0$ instead:
\bprog
? setrand(1); bnf = bnfinit(x^2-x-100000);
? bnf.fu
%2 = 0
? u = [119836165644250789990462835950022871665178127611316131167, \
       379554884019013781006303254896369154068336082609238336]~;
? bnfisunit(bnf, u)
%3 = [-1, 0]~
@eprog\noindent The given $u$ is $1/u_1$, where $u_1$ is the fundamental
unit implicitly stored in \var{bnf}. In this case, $u_1$ was not computed
and stored in algebraic form since the default accuracy was too low. Re-run
the \kbd{bnfinit} command at \kbd{\bs g1} or higher to see such diagnostics.

This function allows $x$ to be given in factored form, but it then assumes
that $x$ is an actual unit. (Because it is general too costly to check
whether this is the case.)
\bprog
? { v = [2, 85; 5, -71; 13, -162; 17, -76; 23, -37; 29, -104; [224, 1]~, -66;
[-86, 1]~, 86; [-241, 1]~, -20; [44, 1]~, 30; [124, 1]~, 11; [125, -1]~, -11;
[-214, 1]~, 33; [-213, -1]~, -33; [189, 1]~, 74; [190, -1]~, 104;
[-168, 1]~, 2; [-167, -1]~, -8]; }
? bnfisunit(bnf,v)
%5 = [1, 0]~
@eprog\noindent Note that $v$ is the fundamental unit of \kbd{bnf} given in
compact (factored) form.

If the argument \kbd{U} is present, as output by \kbd{bnfunits(bnf, S)},
then the function decomposes $x$ on the $S$-units generators given in
\kbd{U[1]}.
\bprog
 ? bnf = bnfinit(x^4 - x^3 + 4*x^2 + 3*x + 9, 1);
 ? bnf.sign
 %2 = [0, 2]
 ? S = idealprimedec(bnf,5); #S
 %3 = 2
 ? US = bnfunits(bnf,S);
 ? g = US[1]; #g  \\ #S = #g, four S-units generators, in factored form
 %5 = 4
 ? g[1]
 %6 = [[6, -3, -2, -2]~ 1]
 ? g[2]
 %7 =
 [[-1, 1/2, -1/2, -1/2]~ 1]

 [      [4, -2, -1, -1]~ 1]
 ? [nffactorback(bnf, x) | x <- g]
 %8 = [[6, -3, -2, -2]~, [-5, 5, 0, 0]~, [-1, 1, -1, 0]~,
       [1, -1, 0, 0]~]

 ? u = [10,-40,24,11]~;
 ? a = bnfisunit(bnf, u, US)
 %9 = [2, 0, 1, 4]~
 ? nffactorback(bnf, g, a) \\ prod_i g[i]^a[i] still in factored form
 %10 =
 [[6, -3, -2, -2]~  2]

 [ [0, 0, -1, -1]~  1]

 [ [2, -1, -1, 0]~ -2]

 [   [1, 1, 0, 0]~  2]

 [  [-1, 1, 1, 1]~ -1]

 [  [1, -1, 0, 0]~  4]

 ? nffactorback(bnf,%)  \\ u = prod_i g[i]^a[i]
 %11 = [10, -40, 24, 11]~
@eprog

The library syntax is \fun{GEN}{bnfisunit0}{GEN bnf, GEN x, GEN U = NULL}.
Also available is \fun{GEN}{bnfisunit}{GEN bnf, GEN x} for $U =
\kbd{NULL}$.

\subsec{bnflog$(\var{bnf}, l)$}\kbdsidx{bnflog}\label{se:bnflog}
Let \var{bnf} be a \var{bnf} structure attached to the number field $F$ and let $l$ be
a prime number (hereafter denoted $\ell$ for typographical reasons). Return
the logarithmic $\ell$-class group $\widetilde{Cl}_F$
of $F$. This is an abelian group, conjecturally finite (known to be finite
if $F/\Q$ is abelian). The function returns if and only if
the group is indeed finite (otherwise it would run into an infinite loop).
Let $S = \{ \goth{p}_1,\dots, \goth{p}_k\}$ be the set of $\ell$-adic places
(maximal ideals containing $\ell$).
The function returns $[D, G(\ell), G']$, where

\item $D$ is the vector of elementary divisors for $\widetilde{Cl}_F$.

\item $G(\ell)$ is the vector of elementary divisors for
the (conjecturally finite) abelian group
$$\widetilde{\Cl}(\ell) =
\{ \goth{a} = \sum_{i \leq k} a_i \goth{p}_i :~\deg_F \goth{a} = 0\},$$
where the $\goth{p}_i$ are the $\ell$-adic places of $F$; this is a
subgroup of $\widetilde{\Cl}$.

\item $G'$ is the vector of elementary divisors for the $\ell$-Sylow $Cl'$
of the $S$-class group of $F$; the group $\widetilde{\Cl}$ maps to $Cl'$
with a simple co-kernel.

The library syntax is \fun{GEN}{bnflog}{GEN bnf, GEN l}.

\subsec{bnflogdegree$(\var{nf}, A, l)$}\kbdsidx{bnflogdegree}\label{se:bnflogdegree}
Let \var{nf} be a \var{nf} structure attached to a number field $F$,
and let $l$ be a prime number (hereafter
denoted $\ell$). The
$\ell$-adified group of id\`{e}les of $F$ quotiented by
the group of logarithmic units is identified to the $\ell$-group
of logarithmic divisors $\oplus \Z_\ell [\goth{p}]$, generated by the
maximal ideals of $F$.

The \emph{degree} map $\deg_F$ is additive with values in $\Z_\ell$,
defined by $\deg_F \goth{p} = \tilde{f}_{\goth{p}} \deg_\ell p$,
where the integer $\tilde{f}_{\goth{p}}$ is as in \tet{bnflogef} and $\deg_\ell p$
is $\log_\ell p$ for $p\neq \ell$, $\log_\ell (1 + \ell)$ for
$p = \ell\neq 2$ and $\log_\ell (1 + 2^2)$ for $p = \ell = 2$.

Let $A = \prod \goth{p}^{n_{\goth{p}}}$ be an ideal and let $\tilde{A} =
\sum n_\goth{p} [\goth{p}]$ be the attached logarithmic divisor. Return the
exponential of the $\ell$-adic logarithmic degree $\deg_F A$, which is a
natural number.

The library syntax is \fun{GEN}{bnflogdegree}{GEN nf, GEN A, GEN l}.

\subsec{bnflogef$(\var{nf},\var{pr})$}\kbdsidx{bnflogef}\label{se:bnflogef}
Let \var{nf} be a \var{nf} structure attached to a number field $F$
and let \var{pr} be a \var{prid} structure attached to a
maximal ideal $\goth{p} / p$. Return
$[\tilde{e}(F_\goth{p} / \Q_p), \tilde{f}(F_\goth{p} / \Q_p)]$
the logarithmic ramification and residue degrees. Let $\Q_p^c/\Q_p$ be the
cyclotomic $\Z_p$-extension, then
$\tilde{e} = [F_\goth{p} \colon F_\goth{p} \cap \Q_p^c]$ and
$\tilde{f} = [F_\goth{p} \cap \Q_p^c \colon \Q_p]$. Note that
$\tilde{e}\tilde{f} = e(\goth{p}/p) f(\goth{p}/p)$, where $e(\goth{p}/p)$ and $f(\goth{p}/p)$ denote the
usual ramification and residue degrees.
\bprog
? F = nfinit(y^6 - 3*y^5 + 5*y^3 - 3*y + 1);
? bnflogef(F, idealprimedec(F,2)[1])
%2 = [6, 1]
? bnflogef(F, idealprimedec(F,5)[1])
%3 = [1, 2]
@eprog

The library syntax is \fun{GEN}{bnflogef}{GEN nf, GEN pr}.

\subsec{bnfnarrow$(\var{bnf})$}\kbdsidx{bnfnarrow}\label{se:bnfnarrow}
\var{bnf} being as output by
\kbd{bnfinit}, computes the narrow class group of \var{bnf}. The output is
a 3-component row vector $v$ analogous to the corresponding class group
component \kbd{\var{bnf}.clgp}: the first component
is the narrow class number \kbd{$v$.no}, the second component is a vector
containing the SNF\sidx{Smith normal form} cyclic components \kbd{$v$.cyc} of
the narrow class group, and the third is a vector giving the generators of
the corresponding \kbd{$v$.gen} cyclic groups. Note that this function is a
special case of \kbd{bnrinit}; the \var{bnf} need not contain fundamental
units.

The library syntax is \fun{GEN}{bnfnarrow}{GEN bnf}.

\subsec{bnfsignunit$(\var{bnf})$}\kbdsidx{bnfsignunit}\label{se:bnfsignunit}
$\var{bnf}$ being as output by
\kbd{bnfinit}, this computes an $r_1\times(r_1+r_2-1)$ matrix having $\pm1$
components, giving the signs of the real embeddings of the fundamental units.
The following functions compute generators for the totally positive units:
\bprog
/* exponents of totally positive units generators on K.tu, K.fu */
tpuexpo(K)=
{ my(M, S = bnfsignunit(K), [m,n] = matsize(S));
  \\ m = K.r1, n = r1+r2-1
  S = matrix(m,n, i,j, if (S[i,j] < 0, 1,0));
  S = concat(vectorv(m,i,1), S);   \\ add sign(-1)
  M = matkermod(S, 2);
  if (M, mathnfmodid(M, 2), 2*matid(n+1))
}

/* totally positive fundamental units of bnf K */
tpu(K)=
{ my(ex = tpuexpo(K)[,^1]); \\ remove ex[,1], corresponds to 1 or -1
  my(v = concat(K.tu[2], K.fu));
  [ nffactorback(K, v, c) | c <- ex];
}
@eprog

The library syntax is \fun{GEN}{signunits}{GEN bnf}.

\subsec{bnfsunit$(\var{bnf},S)$}\kbdsidx{bnfsunit}\label{se:bnfsunit}
Computes the fundamental $S$-units of the
number field $\var{bnf}$ (output by \kbd{bnfinit}), where $S$ is a list of
prime ideals (output by \kbd{idealprimedec}). The output is a vector $v$ with
6 components.

$v[1]$ gives a minimal system of (integral) generators of the $S$-unit group
modulo the unit group.

$v[2]$ contains technical data needed by \kbd{bnfissunit}.

$v[3]$ is an obsoleted component, now the empty vector.

$v[4]$ is the $S$-regulator (this is the product of the regulator, the
$S$-class number and the natural logarithms of the norms of the ideals
in $S$).

$v[5]$ gives the $S$-class group structure, in the usual abelian group
format: a vector whose three components give in order the $S$-class number,
the cyclic components and the generators.

$v[6]$ is a copy of $S$.

The library syntax is \fun{GEN}{bnfsunit}{GEN bnf, GEN S, long prec}.
Also available is
\fun{GEN}{sunits_mod_units}{GEN bnf, GEN S} which returns only $v[1]$.

\subsec{bnfunits$(\var{bnf},\{S\})$}\kbdsidx{bnfunits}\label{se:bnfunits}
Return the fundamental units of the number field
bnf output by bnfinit; if $S$ is present and is a list of prime ideals,
compute fundamental $S$-units instead. The first component of the result
contains independent integral $S$-units generators: first nonunits, then
$r_1+r_2-1$ fundamental units, then the torsion unit. The result may be used
as an optional argument to bnfisunit. The units are given in compact form:
no expensive computation is attempted if the \var{bnf} does not already
contain units.

\bprog
 ? bnf = bnfinit(x^4 - x^3 + 4*x^2 + 3*x + 9, 1);
 ? bnf.sign   \\ r1 + r2 - 1 = 1
 %2 = [0, 2]
 ? U = bnfunits(bnf); u = U[1];
 ? #u \\ r1 + r2 = 2 units
 %5 = 2;
 ? u[1] \\ fundamental unit as factorization matrix
 %6 =
 [[0, 0, -1, -1]~  1]

 [[2, -1, -1, 0]~ -2]

 [  [1, 1, 0, 0]~  2]

 [ [-1, 1, 1, 1]~ -1]
 ? u[2] \\ torsion unit as factorization matrix
 %7 =
 [[1, -1, 0, 0]~ 1]
 ? [nffactorback(bnf, z) | z <- u]  \\ same units in expanded form
 %8 = [[-1, 1, -1, 0]~, [1, -1, 0, 0]~]
 @eprog

 Now an example involving $S$-units for a nontrivial $S$:
 \bprog
 ? S = idealprimedec(bnf,5); #S
 %9 = 2
 ? US = bnfunits(bnf, S); uS = US[1];
 ? g = [nffactorback(bnf, z) | z <- uS] \\ now 4 units
 %11 = [[6, -3, -2, -2]~, [-5, 5, 0, 0]~, [-1, 1, -1, 0]~, [1, -1, 0, 0]~]
 ? bnfisunit(bnf,[10,-40,24,11]~)
 %12 = []~  \\ not a unit
 ? e = bnfisunit(bnf, [10,-40,24,11]~, US)
 %13 = [2, 0, 1, 4]~  \\ ...but an S-unit
 ? nffactorback(bnf, g, e)
 %14 = [10, -40, 24, 11]~
 ? nffactorback(bnf, uS, e) \\ in factored form
 %15 =
 [[6, -3, -2, -2]~  2]

 [ [0, 0, -1, -1]~  1]

 [ [2, -1, -1, 0]~ -2]

 [   [1, 1, 0, 0]~  2]

 [  [-1, 1, 1, 1]~ -1]

 [  [1, -1, 0, 0]~  4]
 @eprog\noindent Note that in more complicated cases, any \kbd{nffactorback}
 fully expanding an element in factored form could be \emph{very} expensive.
 On the other hand, the final example expands a factorization whose components
 are themselves in factored form, hence the result is a factored form:
 this is a cheap operation.

The library syntax is \fun{GEN}{bnfunits}{GEN bnf, GEN S = NULL}.

\subsec{bnrL1$(\var{bnr}, \{H\}, \{\fl=0\})$}\kbdsidx{bnrL1}\label{se:bnrL1}
Let \var{bnr} be the number field data output by \kbd{bnrinit} and
\var{H} be a square matrix defining a congruence subgroup of the
ray class group corresponding to \var{bnr} (the trivial congruence subgroup
if omitted). This function returns, for each \idx{character} $\chi$ of the ray
class group which is trivial on $H$, the value at $s = 1$ (or $s = 0$) of the
abelian $L$-function attached to $\chi$. For the value at $s = 0$, the
function returns in fact for each $\chi$ a vector $[r_\chi, c_\chi]$ where
$$L(s, \chi) = c \cdot s^r + O(s^{r + 1})$$
\noindent near $0$.

The argument \fl\ is optional, its binary digits
mean 1: compute at $s = 0$ if unset or $s = 1$ if set, 2: compute the
primitive $L$-function attached to $\chi$ if unset or the $L$-function
with Euler factors at prime ideals dividing the modulus of \var{bnr} removed
if set (that is $L_S(s, \chi)$, where $S$ is the
set of infinite places of the number field together with the finite prime
ideals dividing the modulus of \var{bnr}), 3: return also the character if
set.
\bprog
K = bnfinit(x^2-229);
bnr = bnrinit(K,1);
bnrL1(bnr)
@eprog\noindent
returns the order and the first nonzero term of $L(s, \chi)$ at $s = 0$
where $\chi$ runs through the characters of the class group of
$K = \Q(\sqrt{229})$. Then
\bprog
bnr2 = bnrinit(K,2);
bnrL1(bnr2,,2)
@eprog\noindent
returns the order and the first nonzero terms of $L_S(s, \chi)$ at $s = 0$
where $\chi$ runs through the characters of the class group of $K$ and $S$ is
the set of infinite places of $K$ together with the finite prime $2$. Note
that the ray class group modulo $2$ is in fact the class group, so
\kbd{bnrL1(bnr2,0)} returns the same answer as \kbd{bnrL1(bnr,0)}.

This function will fail with the message
\bprog
 *** bnrL1: overflow in zeta_get_N0 [need too many primes].
@eprog\noindent if the approximate functional equation requires us to sum
too many terms (if the discriminant of $K$ is too large).

The library syntax is \fun{GEN}{bnrL1}{GEN bnr, GEN H = NULL, long flag, long prec}.

\subsec{bnrchar$(G,g,\{v\})$}\kbdsidx{bnrchar}\label{se:bnrchar}
Returns all characters $\chi$ on $G$ such that
$\chi(g_i) = e(v_i)$, where $e(x) = \exp(2i\pi x)$. $G$ is allowed to be a
\var{bnr} struct (representing a ray class group) or a \var{znstar}
(representing $(\Z/N\Z)^*$). If $v$ is omitted,
returns all characters that are trivial on the $g_i$. Else the vectors $g$
and $v$ must have the same length, the $g_i$ must be elements of $G$, and
each $v_i$ is a rational number whose denominator must divide the order of
$g_i$ in $G$.

For convenience, the vector of the $g_i$
can be replaced by a matrix whose columns give their discrete logarithm
in $G$, for instance as given by \kbd{bnrisprincipal} if $G$ is a \var{bnr};
in this particular case, $G$ can be any finite abelian group
given by a vector of elementary divisors.

\bprog
? G = bnrinit(bnfinit(x), [160,[1]], 1); /* (Z/160Z)^* */
? G.cyc
%2 = [8, 4, 2]
? g = G.gen;
? bnrchar(G, g, [1/2,0,0])
%4 = [[4, 0, 0]]  \\ a unique character
? bnrchar(G, [g[1],g[3]]) \\ all characters trivial on g[1] and g[3]
%5 = [[0, 1, 0], [0, 2, 0], [0, 3, 0], [0, 0, 0]]
? bnrchar(G, [1,0,0;0,1,0;0,0,2])
%6 = [[0, 0, 1], [0, 0, 0]]  \\ characters trivial on given subgroup

? G = znstar(75, 1);
? bnrchar(G, [2, 7], [11/20, 1/4])
%8 = [[1, 1]] \\ Dirichlet char: chi(2) = e(11/20), chi(7) = e(1/4)
@eprog

The library syntax is \fun{GEN}{bnrchar}{GEN G, GEN g, GEN v = NULL}.

\subsec{bnrclassfield$(\var{bnr},\{\var{subgp}\},\{\fl=0\})$}\kbdsidx{bnrclassfield}\label{se:bnrclassfield}
\var{bnr} being as output by \kbd{bnrinit}, returns a relative equation
for the class field corresponding to the congruence group defined by
$(\var{bnr},\var{subgp})$ (the full ray class field if \var{subgp} is
omitted). The subgroup can also be a \typ{INT}~$n$,
meaning~$n \cdot \text{Cl}_f$. The function also handles a vector of
subgroup, e.g, from \tet{subgrouplist} and returns the vector of individual
results in this case.

If $\fl=0$, returns a vector of polynomials such that the compositum of the
corresponding fields is the class field; if $\fl=1$ returns a single
polynomial; if $\fl=2$ returns a single absolute polynomial.

\bprog
? bnf = bnfinit(y^3+14*y-1); bnf.cyc
%1 = [4, 2]
? pol = bnrclassfield(bnf,,1) \\ Hilbert class field
%2 = x^8 - 2*x^7 + ... + Mod(11*y^2 - 82*y + 116, y^3 + 14*y - 1)
? rnfdisc(bnf,pol)[1]
%3 = 1
? bnr = bnrinit(bnf,3*5*7); bnr.cyc
%4 = [24, 12, 12, 2]
? bnrclassfield(bnr,2) \\ maximal 2-elementary subextension
%5 = [x^2 + (-21*y - 105), x^2 + (-5*y - 25), x^2 + (-y - 5), x^2 + (-y - 1)]
\\ quadratic extensions of maximal conductor
? bnrclassfield(bnr, subgrouplist(bnr,[2]))
%6 = [[x^2 - 105], [x^2 + (-105*y^2 - 1260)], [x^2 + (-105*y - 525)],
      [x^2 + (-105*y - 105)]]
? #bnrclassfield(bnr,subgrouplist(bnr,[2],1)) \\ all quadratic extensions
%7 = 15
@eprog\noindent When the subgroup contains $n \text{Cl}_f$, where $n$ is fixed,
it is advised to directly compute the \kbd{bnr} modulo $n$ to avoid expensive
discrete logarithms:
\bprog
? bnf = bnfinit(y^2-5); p = 1594287814679644276013;
? bnr = bnrinit(bnf,p); \\ very slow
time = 24,146 ms.
? bnrclassfield(bnr, 2) \\ ... even though the result is trivial
%3 = [x^2 - 1594287814679644276013]
? bnr2 = bnrinit(bnf,p,,2); \\ now fast
time = 1 ms.
? bnrclassfield(bnr2, 2)
%5 = [x^2 - 1594287814679644276013]
@eprog\noindent This will save a lot of time when the modulus contains a
maximal ideal whose residue field is large.

The library syntax is \fun{GEN}{bnrclassfield}{GEN bnr, GEN subgp = NULL, long flag, long prec}.

\subsec{bnrclassno$(A,\{B\},\{C\})$}\kbdsidx{bnrclassno}\label{se:bnrclassno}
Let $A$, $B$, $C$ define a class field $L$ over a ground field $K$
(of type \kbd{[\var{bnr}]},
\kbd{[\var{bnr}, \var{subgroup}]},
or \kbd{[\var{bnf}, \var{modulus}]},
or \kbd{[\var{bnf}, \var{modulus},\var{subgroup}]},
\secref{se:CFT}); this function returns the relative degree $[L:K]$.

In particular if $A$ is a \var{bnf} (with units), and $B$ a modulus,
this function returns the corresponding ray class number modulo $B$.
One can input the attached \var{bid} (with generators if the subgroup
$C$ is non trivial) for $B$ instead of the module itself, saving some time.

This function is faster than \kbd{bnrinit} and should be used if only the
ray class number is desired. See \tet{bnrclassnolist} if you need ray class
numbers for all moduli less than some bound.

The library syntax is \fun{GEN}{bnrclassno0}{GEN A, GEN B = NULL, GEN C = NULL}.
Also available is
\fun{GEN}{bnrclassno}{GEN bnf,GEN f} to compute the ray class number
modulo~$f$.

\subsec{bnrclassnolist$(\var{bnf},\var{list})$}\kbdsidx{bnrclassnolist}\label{se:bnrclassnolist}
$\var{bnf}$ being as
output by \kbd{bnfinit}, and \var{list} being a list of moduli (with units) as
output by \kbd{ideallist} or \kbd{ideallistarch}, outputs the list of the
class numbers of the corresponding ray class groups. To compute a single
class number, \tet{bnrclassno} is more efficient.

\bprog
? bnf = bnfinit(x^2 - 2);
? L = ideallist(bnf, 100, 2);
? H = bnrclassnolist(bnf, L);
? H[98]
%4 = [1, 3, 1]
? l = L[1][98]; ids = vector(#l, i, l[i].mod[1])
%5 = [[98, 88; 0, 1], [14, 0; 0, 7], [98, 10; 0, 1]]
@eprog
The weird \kbd{l[i].mod[1]}, is the first component of \kbd{l[i].mod}, i.e.
the finite part of the conductor. (This is cosmetic: since by construction
the Archimedean part is trivial, I do not want to see it). This tells us that
the ray class groups modulo the ideals of norm 98 (printed as \kbd{\%5}) have
respectively order $1$, $3$ and $1$. Indeed, we may check directly:
\bprog
? bnrclassno(bnf, ids[2])
%6 = 3
@eprog

The library syntax is \fun{GEN}{bnrclassnolist}{GEN bnf, GEN list}.

\subsec{bnrcompositum$(A,B)$}\kbdsidx{bnrcompositum}\label{se:bnrcompositum}
Given two abelian extensions $A = \kbd{[bnr1, H1]}$ and
$B = \kbd{[bnr2, H2]}$, where \kbd{bnr1} and \kbd{bnr2} are two \kbd{bnr}
structures attached to the same base field, return their compositum
as \kbd{[bnr, H]}. The modulus attached to \kbd{bnr} need not be the
conductor of the compositum.
\bprog
? Q = bnfinit(y);
? bnr1 = bnrinit(Q, [7, [1]]); bnr1.cyc
%2 = [6]
? bnr2 = bnrinit(Q, [13, [1]]); bnr2.cyc
%3 = [12]
? H1 = Mat(2); bnrclassfield(bnr1, H1)
%4 = [x^2 + 7]
? H2 = Mat(2); bnrclassfield(bnr2, H2)
%5 = [x^2 - 13]
? [bnr,H] = bnrcompositum([bnr1, H1], [bnr2,H2]);
? bnrclassfield(bnr,H)
%7 = [x^2 - 13, x^2 + 7]
@eprog

The library syntax is \fun{GEN}{bnrcompositum}{GEN A, GEN B}.

\subsec{bnrconductor$(A,\{B\},\{C\},\{\fl=0\})$}\kbdsidx{bnrconductor}\label{se:bnrconductor}
Conductor $f$ of the subfield of a ray class field as defined by $[A,B,C]$
(of type \kbd{[\var{bnr}]},
\kbd{[\var{bnr}, \var{subgroup}]},
\kbd{[\var{bnf}, \var{modulus}]} or
\kbd{[\var{bnf}, \var{modulus}, \var{subgroup}]},
\secref{se:CFT})

If $\fl = 0$, returns $f$.

If $\fl = 1$, returns $[f, Cl_f, H]$, where $Cl_f$ is the ray class group
modulo $f$, as a finite abelian group; finally $H$ is the subgroup of $Cl_f$
defining the extension.

If $\fl = 2$, returns $[f, \var{bnr}(f), H]$, as above except $Cl_f$ is
replaced by a \kbd{bnr} structure, as output by $\tet{bnrinit}(,f)$, without
generators unless the input contained a \var{bnr} with generators.

In place of a subgroup $H$, this function also accepts a character
\kbd{chi}  $=(a_j)$, expressed as usual in terms of the generators
\kbd{bnr.gen}: $\chi(g_j) = \exp(2i\pi a_j / d_j)$, where $g_j$ has
order $d_j = \kbd{bnr.cyc[j]}$. In which case, the function returns
respectively

If $\fl = 0$, the conductor $f$ of $\text{Ker} \chi$.

If $\fl = 1$, $[f, Cl_f, \chi_f]$, where $\chi_f$ is $\chi$ expressed
on the minimal ray class group, whose modulus is the conductor.

If $\fl = 2$, $[f, \var{bnr}(f), \chi_f]$.

\misctitle{Note} Using this function with $\fl \neq 0$ is usually a
bad idea and kept for compatibility and convenience only: $\fl = 1$ has
always been useless, since it is no faster than $\fl = 2$ and returns less
information; $\fl = 2$ is mostly OK with two subtle drawbacks:

$\bullet$ it returns the full \var{bnr} attached to the full ray class
group, whereas in applications we only need $Cl_f$ modulo $N$-th powers,
where $N$ is any multiple of the exponent of $Cl_f/H$. Computing directly the
conductor, then calling \kbd{bnrinit} with optional argument $N$ avoids this
problem.

$\bullet$ computing the \var{bnr} needs only be done once for each
conductor, which is not possible using this function.

For maximal efficiency, the recommended procedure is as follows. Starting
from data (character or congruence subgroups) attached to a modulus $m$,
we can first compute the conductors using this function with default $\fl =
0$. Then for all data with a common conductor $f \mid m$, compute (once!) the
\var{bnr} attached to $f$ using \kbd{bnrinit} (modulo $N$-th powers for
a suitable $N$!) and finally map original data to the new \var{bnr} using
\kbd{bnrmap}.

The library syntax is \fun{GEN}{bnrconductor0}{GEN A, GEN B = NULL, GEN C = NULL, long flag}.

Also available are \fun{GEN}{bnrconductor}{GEN bnr, GEN H, long flag}
and \fun{GEN}{bnrconductormod}{GEN bnr, GEN H, long flag, GEN cycmod}
which returns ray class groups modulo \kbd{cycmod}-th powers.

\subsec{bnrconductorofchar$(\var{bnr},\var{chi})$}\kbdsidx{bnrconductorofchar}\label{se:bnrconductorofchar}
This function is obsolete, use \tev{bnrconductor}.

The library syntax is \fun{GEN}{bnrconductorofchar}{GEN bnr, GEN chi}.

\subsec{bnrdisc$(A,\{B\},\{C\},\{\fl=0\})$}\kbdsidx{bnrdisc}\label{se:bnrdisc}
$A$, $B$, $C$ defining a class field $L$ over a ground field $K$
(of type \kbd{[\var{bnr}]},
\kbd{[\var{bnr}, \var{subgroup}]},
\kbd{[\var{bnr}, \var{character}]},
\kbd{[\var{bnf}, \var{modulus}]} or
\kbd{[\var{bnf}, \var{modulus}, \var{subgroup}]},
\secref{se:CFT}), outputs data $[N,r_1,D]$ giving the discriminant and
signature of $L$, depending on the binary digits of \fl:

\item 1: if this bit is unset, output absolute data related to $L/\Q$:
$N$ is the absolute degree $[L:\Q]$, $r_1$ the number of real places of $L$,
and $D$ the discriminant of $L/\Q$. Otherwise, output relative data for $L/K$:
$N$ is the relative degree $[L:K]$, $r_1$ is the number of real places of $K$
unramified in $L$ (so that the number of real places of $L$ is equal to $r_1$
times $N$), and $D$ is the relative discriminant ideal of $L/K$.

\item 2: if this bit is set and if the modulus is not the conductor of $L$,
only return 0.

The library syntax is \fun{GEN}{bnrdisc0}{GEN A, GEN B = NULL, GEN C = NULL, long flag}.

\subsec{bnrdisclist$(\var{bnf},\var{bound},\{\var{arch}\})$}\kbdsidx{bnrdisclist}\label{se:bnrdisclist}
$\var{bnf}$ being as output by \kbd{bnfinit} (with units), computes a
list of discriminants of Abelian extensions of the number field by increasing
modulus norm up to bound \var{bound}. The ramified Archimedean places are
given by \var{arch}; all possible values are taken if \var{arch} is omitted.

The alternative syntax $\kbd{bnrdisclist}(\var{bnf},\var{list})$ is
supported, where \var{list} is as output by \kbd{ideallist} or
\kbd{ideallistarch} (with units), in which case \var{arch} is disregarded.

The output $v$ is a vector, where $v[k]$ is itself a vector $w$, whose length
is the number of ideals of norm $k$.

\item We consider first the case where \var{arch} was specified. Each
component of $w$ corresponds to an ideal $m$ of norm $k$, and
gives invariants attached to the ray class field $L$ of $\var{bnf}$ of
conductor $[m, \var{arch}]$. Namely, each contains a vector $[m,d,r,D]$ with
the following meaning: $m$ is the prime ideal factorization of the modulus,
$d = [L:\Q]$ is the absolute degree of $L$, $r$ is the number of real places
of $L$, and $D$ is the factorization of its absolute discriminant. We set $d
= r = D = 0$ if $m$ is not the finite part of a conductor.

\item If \var{arch} was omitted, all $t = 2^{r_1}$ possible values are taken
and a component of $w$ has the form
$[m, [[d_1,r_1,D_1], \dots, [d_t,r_t,D_t]]]$,
where $m$ is the finite part of the conductor as above, and
$[d_i,r_i,D_i]$ are the invariants of the ray class field of conductor
$[m,v_i]$, where $v_i$ is the $i$-th Archimedean component, ordered by
inverse lexicographic order; so $v_1 = [0,\dots,0]$, $v_2 = [1,0\dots,0]$,
etc. Again, we set $d_i = r_i = D_i = 0$ if $[m,v_i]$ is not a conductor.

Finally, each prime ideal $pr = [p,\alpha,e,f,\beta]$ in the prime
factorization $m$ is coded as the integer $p\cdot n^2+(f-1)\cdot n+(j-1)$,
where $n$ is the degree of the base field and $j$ is such that

\kbd{pr = idealprimedec(\var{nf},p)[j]}.

\noindent $m$ can be decoded using \tet{bnfdecodemodule}.

Note that to compute such data for a single field, either \tet{bnrclassno}
or \tet{bnrdisc} are (much) more efficient.

The library syntax is \fun{GEN}{bnrdisclist0}{GEN bnf, GEN bound, GEN arch = NULL}.

\subsec{bnrgaloisapply$(\var{bnr}, \var{mat}, H)$}\kbdsidx{bnrgaloisapply}\label{se:bnrgaloisapply}
Apply the automorphism given by its matrix \var{mat} to the congruence
subgroup $H$ given as a HNF matrix.
The matrix \var{mat} can be computed with \tet{bnrgaloismatrix}.

The library syntax is \fun{GEN}{bnrgaloisapply}{GEN bnr, GEN mat, GEN H}.

\subsec{bnrgaloismatrix$(\var{bnr},\var{aut})$}\kbdsidx{bnrgaloismatrix}\label{se:bnrgaloismatrix}
Return the matrix of the action of the automorphism \var{aut} of the base
field \kbd{bnf.nf} on the generators of the ray class field \kbd{bnr.gen}.
The automorphism
\var{aut} can be given as a polynomial, an algebraic number, or a vector of
automorphisms and must stabilize the modulus \kbd{bnr.mod}. We also
allow a Galois group as output by \kbd{galoisinit}, in which case a
vector of matrices is returned corresponding to the generators
\kbd{aut.gen}.
Note: This function only makes sense when the ray class field attached to
\var{bnr} is Galois, which is not checked.

The generators \kbd{bnr.gen} need not be explicitly computed in the input
\var{bnr}, which saves time: the result is well defined in this case also.

\bprog
? K = bnfinit(a^4-3*a^2+253009); B = bnrinit(K,9); B.cyc
%1 = [8400, 12, 6, 3]
? G = nfgaloisconj(K)
%2 = [-a, a, -1/503*a^3 + 3/503*a, 1/503*a^3 - 3/503*a]~
? bnrgaloismatrix(B, G[2])  \\ G[2] = Id ...
%3 =
[1 0 0 0]

[0 1 0 0]

[0 0 1 0]

[0 0 0 1]
? bnrgaloismatrix(B, G[3]) \\ automorphism of order 2
%4 =
[799 0 0 2800]

[  0 7 0    4]

[  4 0 5    2]

[  0 0 0    2]
? M = %^2; for (i=1, #B.cyc, M[i,] %= B.cyc[i]); M
%5 =  \\ acts on ray class group as automorphism of order 2
[1 0 0 0]

[0 1 0 0]

[0 0 1 0]

[0 0 0 1]
@eprog

See \kbd{bnrisgalois} for further examples.

The library syntax is \fun{GEN}{bnrgaloismatrix}{GEN bnr, GEN aut}.
When $aut$ is a polynomial or an algebraic number,
\fun{GEN}{bnrautmatrix}{GEN bnr, GEN aut} is available.

\subsec{bnrinit$(\var{bnf},f,\{\fl=0\},\{\var{cycmod}\})$}\kbdsidx{bnrinit}\label{se:bnrinit}
$\var{bnf}$ is as
output by \kbd{bnfinit} (including fundamental units), $f$ is a modulus,
initializes data linked to the ray class group structure corresponding to
this module, a so-called \kbd{bnr} structure. One can input the attached
\var{bid} with generators for $f$ instead of the module itself, saving some
time. (As in \tet{idealstar}, the finite part of the conductor may be given
by a factorization into prime ideals, as produced by \tet{idealfactor}.)

If the positive integer \kbd{cycmod} is present, only compute the ray class
group modulo \kbd{cycmod}, which may save a lot of time when some maximal
ideals in $f$ have a huge residue field. In applications, we are given
a congruence subgroup $H$ and study the class field attached to
$\text{Cl}_f/H$. If that finite Abelian group has an exponent which divides
\kbd{cycmod}, then we have changed nothing theoretically, while trivializing
expensive discrete logs in residue fields (since computations can be
made modulo \kbd{cycmod}-th powers). This is useful in \kbd{bnrclassfield},
for instance when computing $p$-elementary extensions.

The following member functions are available
on the result: \kbd{.bnf} is the underlying \var{bnf},
\kbd{.mod} the modulus, \kbd{.bid} the \kbd{bid} structure attached to the
modulus; finally, \kbd{.clgp}, \kbd{.no}, \kbd{.cyc}, \kbd{.gen} refer to the
ray class group (as a finite abelian group), its cardinality, its elementary
divisors, its generators (only computed if $\fl = 1$).

The last group of functions are different from the members of the underlying
\var{bnf}, which refer to the class group; use \kbd{\var{bnr}.bnf.\var{xxx}}
to access these, e.g.~\kbd{\var{bnr}.bnf.cyc} to get the cyclic decomposition
of the class group.

They are also different from the members of the underlying \var{bid}, which
refer to $(\Z_K/f)^*$; use \kbd{\var{bnr}.bid.\var{xxx}} to access these,
e.g.~\kbd{\var{bnr}.bid.no} to get $\phi(f)$.

If $\fl=0$ (default), the generators of the ray class group are not
explicitly computed, which saves time. Hence \kbd{\var{bnr}.gen} would
produce an error. Note that implicit generators are still fixed and stored
in the \var{bnr} (and guaranteed to be the same for fixed \var{bnf} and
\var{bid} inputs), in terms of \kbd{bnr.bnf.gen} and \kbd{bnr.bid.gen}.
The computation which is not performed is the expansion of such products
in the ray class group so as to fix eplicit ideal representatives.

If $\fl=1$, as the default, except that generators are computed.

The library syntax is \fun{GEN}{bnrinitmod}{GEN bnf, GEN f, long flag, GEN cycmod = NULL}.
Instead of the above hardcoded  numerical flags,  one should rather use
\fun{GEN}{Buchraymod}{GEN bnf, GEN module, long flag, GEN cycmod}
where an omitted \kbd{cycmod} is coded as \kbd{NULL} and flag is an or-ed
combination of \kbd{nf\_GEN} (include generators) and \kbd{nf\_INIT} (if
omitted, return just the cardinality of the ray class group and its structure),
possibly 0. Or simply
  \fun{GEN}{Buchray}{GEN bnf, GEN module, long flag}
when \kbd{cycmod} is \kbd{NULL}.

\subsec{bnrisconductor$(A,\{B\},\{C\})$}\kbdsidx{bnrisconductor}\label{se:bnrisconductor}
Fast variant of \kbd{bnrconductor}$(A,B,C)$; $A$, $B$, $C$ represent
an extension of the base field, given by class field theory
(see~\secref{se:CFT}). Outputs 1 if this modulus is the conductor, and 0
otherwise. This is slightly faster than \kbd{bnrconductor} when the
character or subgroup is not primitive.

The library syntax is \fun{long}{bnrisconductor0}{GEN A, GEN B = NULL, GEN C = NULL}.

\subsec{bnrisgalois$(\var{bnr}, \var{gal}, H)$}\kbdsidx{bnrisgalois}\label{se:bnrisgalois}
Check whether the class field attached to the subgroup $H$ is Galois
over the subfield of \kbd{bnr.nf} fixed by the group \var{gal}, which can be
given as output by \tet{galoisinit}, or as a matrix or a vector of matrices as
output by \kbd{bnrgaloismatrix}, the second option being preferable, since it
saves the recomputation of the matrices.  Note: The function assumes that the
ray class field attached to \var{bnr} is Galois, which is not checked.

In the following example, we lists the congruence subgroups of subextension of
degree at most $3$ of the ray class field of conductor $9$ which are Galois
over the rationals.

\bprog
? K = bnfinit(a^4-3*a^2+253009); B = bnrinit(K,9); G = galoisinit(K);
? [H | H<-subgrouplist(B,3), bnrisgalois(B,G,H)];
time = 160 ms.
? M = bnrgaloismatrix(B,G);
? [H | H<-subgrouplist(B,3), bnrisgalois(B,M,H)]
time = 1 ms.
@eprog
The second computation is much faster since \kbd{bnrgaloismatrix(B,G)} is
computed only once.

The library syntax is \fun{long}{bnrisgalois}{GEN bnr, GEN gal, GEN H}.

\subsec{bnrisprincipal$(\var{bnr},x,\{\fl=1\})$}\kbdsidx{bnrisprincipal}\label{se:bnrisprincipal}
Let \var{bnr} be the ray class group data output by
\kbd{bnrinit}$(,,1)$ and let $x$ be an ideal in any form, coprime
to the modulus $f = \kbd{bnr.mod}$. Solves the discrete logarithm problem
in the ray class group, with respect to the generators \kbd{bnr.gen},
in a way similar to \tet{bnfisprincipal}. If $x$ is not coprime to the
modulus of \var{bnr} the result is undefined. Note that \var{bnr} need not
contain the ray class group generators, i.e.~it may be created with
\kbd{bnrinit}$(,,0)$; in that case, although \kbd{bnr.gen} is undefined, we
can still fix natural generators for the ray class group (in terms of the
generators in \kbd{bnr.bnf.gen} and \kbd{bnr.bid.gen}) and compute with
respect to them.

The binary digits of $\fl$ (default $\fl = 1$) mean:

\item $1$: If set returns a 2-component vector $[e,\alpha]$ where $e$
is the vector of components of $x$ on the ray class group generators,
$\alpha$ is an element congruent to $1~\text{mod}^* f$ such that
$x = \alpha \prod_i g_i^{e_i}$. If unset, returns only $e$.

\item $4$: If set, returns $[e,\alpha]$ where $\alpha$ is given in factored
form (compact representation). This is orders of magnitude faster.

\bprog
? K = bnfinit(x^2 - 30); bnr = bnrinit(K, [4, [1,1]]);
? bnr.clgp \\ ray class group is isomorphic to Z/4 x Z/2 x Z/2
%2 = [16, [4, 2, 2]]
? P = idealprimedec(K, 3)[1]; \\ the ramified prime ideal above 3
? bnrisprincipal(bnr,P) \\ bnr.gen undefined !
%5 = [[3, 0, 0]~, 9]
? bnrisprincipal(bnr,P, 0) \\ omit principal part
%5 = [3, 0, 0]~
? bnr = bnrinit(bnr, bnr.bid, 1); \\ include explicit generators
? bnrisprincipal(bnr,P) \\ ... alpha is different !
%7 = [[3, 0, 0]~, 1/128625]
@eprog It may be surprising that the generator $\alpha$ is different
although the underlying \var{bnf} and \var{bid} are the same. This defines
unique generators for the ray class group as ideal \emph{classes}, whether
we use \kbd{bnrinit(,0)} or \kbd{bnrinit(,1)}. But the actual ideal
representatives (implicit if the flag is $0$, computed and stored in the
\var{bnr} if the flag is $1$) are in general different and this is what
happens here. Indeed, the implicit generators are naturally expressed
in terms of \kbd{bnr.bnf.gen} and \kbd{bnr.bid.gen} and \emph{then}
expanded and simplified (in the same ideal class) so that we obtain ideal
representatives for \kbd{bnr.gen} which are as simple as possible.
And indeed the quotient of the two $\alpha$ found is $1$ modulo the
conductor (and positive at the infinite places it contains), and this is the
only guaranteed property.

Beware that, when \kbd{bnr} is generated using \kbd{bnrinit(, cycmod)}, the
results are given in $\text{Cl}_f$ modulo \kbd{cycmod}-th powers:
\bprog
? bnr2 = bnrinit(K, bnr.mod,, 2);  \\ modulo squares
? bnr2.clgp
%9 = [8, [2, 2, 2]]  \\ bnr.clgp tensored by Z/2Z
? bnrisprincipal(bnr2,P, 0)
%10 = [1, 0, 0]~
@eprog

The library syntax is \fun{GEN}{bnrisprincipal}{GEN bnr, GEN x, long flag}.
Instead of hardcoded  numerical flags,  one should rather use
\fun{GEN}{isprincipalray}{GEN bnr, GEN x} for $\kbd{flag} = 0$, and if you
want generators:
\bprog
  bnrisprincipal(bnr, x, nf_GEN)
@eprog
Also available is
\fun{GEN}{bnrisprincipalmod}{GEN bnr, GEN x, GEN mod, long flag}
that returns the discrete logarithm of~$x$ modulo the~\typ{INT}
\kbd{mod}; the value~$\kbd{mod = NULL}$ is treated as~$0$ (full discrete
logarithm), and~$\kbd{flag}=1$ is not allowed if~\kbd{mod} is set.

\subsec{bnrmap$(A, B)$}\kbdsidx{bnrmap}\label{se:bnrmap}
This function has two different uses:

\item if $A$ and $B$ are \var{bnr} structures for the same \var{bnf} attached
to moduli $m_A$ and $m_B$ with $m_B \mid m_A$, return the canonical surjection
from $A$ to $B$, i.e. from the ray class group moodulo $m_A$ to the ray
class group modulo $m_B$. The map is coded by a triple
$[M,\var{cyc}_A,\var{cyc}_B]$:
$M$ gives the image of the fixed ray class group generators of $A$ in
terms of the ones in $B$, $\var{cyc}_A$ and $\var{cyc}_B$ are the cyclic
structures \kbd{A.cyc} and \kbd{B.cyc} respectively. Note that this function
does \emph{not} need $A$ or $B$ to contain explicit generators for the ray
class groups: they may be created using \kbd{bnrinit(,0)}.

If $B$ is only known modulo $N$-th powers (from \kbd{bnrinit(,N)}), the result
is correct provided $N$ is a multiple of the exponent of $A$.

\item if $A$ is a projection map as above and $B$ is either a congruence
subgroup $H$, or a ray class character $\chi$, or a discrete logarithm
(from \kbd{bnrisprincipal})  modulo $m_A$ whose conductor
divides $m_B$, return the image of the subgroup (resp. the character, the
discrete logarighm) as defined modulo $m_B$. The main use of this variant is
to compute the primitive subgroup or character attached to a \var{bnr} modulo
their conductor. This is more efficient than \tet{bnrconductor} in two
respects: the \var{bnr} attached to the conductor need only be computed once
and, most importantly, the ray class group can be computed modulo $N$-th
powers, where $N$ is a multiple of the exponent of $\text{Cl}_{m_A} / H$ (resp.
of the order of $\chi$). Whereas \kbd{bnrconductor} is specified to return a
\var{bnr} attached to the full ray class group, which may lead to untractable
discrete logarithms in the full ray class group instead of a tiny quotient.

The library syntax is \fun{GEN}{bnrmap}{GEN A, GEN B}.

\subsec{bnrrootnumber$(\var{bnr},\var{chi},\{\fl=0\})$}\kbdsidx{bnrrootnumber}\label{se:bnrrootnumber}
If $\chi=\var{chi}$ is a
\idx{character} over \var{bnr}, not necessarily primitive, let
$L(s,\chi) = \sum_{id} \chi(id) N(id)^{-s}$ be the attached
\idx{Artin L-function}. Returns the so-called \idx{Artin root number}, i.e.~the
complex number $W(\chi)$ of modulus 1 such that
%
$$\Lambda(1-s,\chi) = W(\chi) \Lambda(s,\overline{\chi})$$
%
\noindent where $\Lambda(s,\chi) = A(\chi)^{s/2}\gamma_\chi(s) L(s,\chi)$ is
the enlarged L-function attached to $L$.

You can set $\fl=1$ if the character is known to be primitive. Example:
\bprog
bnf = bnfinit(x^2 - x - 57);
bnr = bnrinit(bnf, [7,[1,1]]);
bnrrootnumber(bnr, [2,1])
@eprog\noindent
returns the root number of the character $\chi$ of
$\Cl_{7\infty_1\infty_2}(\Q(\sqrt{229}))$ defined by $\chi(g_1^ag_2^b)
= \zeta_1^{2a}\zeta_2^b$. Here $g_1, g_2$ are the generators of the
ray-class group given by \kbd{bnr.gen} and $\zeta_1 = e^{2i\pi/N_1},
\zeta_2 = e^{2i\pi/N_2}$ where $N_1, N_2$ are the orders of $g_1$ and
$g_2$ respectively ($N_1=6$ and $N_2=3$ as \kbd{bnr.cyc} readily tells us).

The library syntax is \fun{GEN}{bnrrootnumber}{GEN bnr, GEN chi, long flag, long prec}.

\subsec{bnrstark$(\var{bnr},\{\var{subgroup}\})$}\kbdsidx{bnrstark}\label{se:bnrstark}
\var{bnr} being as output by \kbd{bnrinit}, finds a relative equation
for the class field corresponding to the modulus in \var{bnr} and the given
congruence subgroup (as usual, omit $\var{subgroup}$ if you want the whole ray
class group).

The main variable of \var{bnr} must not be $x$, and the ground field and the
class field must be totally real. When the base field is $\Q$, the vastly
simpler \tet{galoissubcyclo} is used instead. Here is an example:
\bprog
bnf = bnfinit(y^2 - 3);
bnr = bnrinit(bnf, 5);
bnrstark(bnr)
@eprog\noindent
returns the ray class field of $\Q(\sqrt{3})$ modulo $5$. Usually, one wants
to apply to the result one of
\bprog
rnfpolredbest(bnf, pol)    \\@com compute a reduced relative polynomial
rnfpolredbest(bnf, pol, 2) \\@com compute a reduced absolute polynomial
@eprog

The routine uses \idx{Stark units} and needs to find a suitable auxiliary
conductor, which may not exist when the class field is not cyclic over the
base. In this case \kbd{bnrstark} is allowed to return a vector of
polynomials defining \emph{independent} relative extensions, whose compositum
is the requested class field. We decided that it was useful to keep the
extra information thus made available, hence the user has to take the
compositum herself, see \kbd{nfcompositum}.

Even if it exists, the auxiliary conductor may be so large that later
computations become unfeasible. (And of course, Stark's conjecture may simply
be wrong.) In case of difficulties, try \tet{bnrclassfield}:
\bprog
? bnr = bnrinit(bnfinit(y^8-12*y^6+36*y^4-36*y^2+9,1), 2);
? bnrstark(bnr)
  ***   at top-level: bnrstark(bnr)
  ***                 ^-------------
  *** bnrstark: need 3919350809720744 coefficients in initzeta.
  *** Computation impossible.
? bnrclassfield(bnr)
time = 20 ms.
%2 = [x^2 + (-2/3*y^6 + 7*y^4 - 14*y^2 + 3)]
@eprog

The library syntax is \fun{GEN}{bnrstark}{GEN bnr, GEN subgroup = NULL, long prec}.

\subsec{dirzetak$(\var{nf},b)$}\kbdsidx{dirzetak}\label{se:dirzetak}
Gives as a vector the first $b$
coefficients of the \idx{Dedekind} zeta function of the number field $\var{nf}$
considered as a \idx{Dirichlet series}.

The library syntax is \fun{GEN}{dirzetak}{GEN nf, GEN b}.

\subsec{factornf$(x,t)$}\kbdsidx{factornf}\label{se:factornf}
This function is obsolete, use \kbd{nffactor}.

factorization of the univariate polynomial $x$
over the number field defined by the (univariate) polynomial $t$. $x$ may
have coefficients in $\Q$ or in the number field. The algorithm reduces to
factorization over $\Q$ (\idx{Trager}'s trick). The direct approach of
\tet{nffactor}, which uses \idx{van Hoeij}'s method in a relative setting, is
in general faster.

The main variable of $t$ must be of \emph{lower} priority than that of $x$
(see \secref{se:priority}). However if nonrational number field elements
occur (as polmods or polynomials) as coefficients of $x$, the variable of
these polmods \emph{must} be the same as the main variable of $t$. For
example

\bprog
? factornf(x^2 + Mod(y, y^2+1), y^2+1);
? factornf(x^2 + y, y^2+1); \\@com these two are OK
? factornf(x^2 + Mod(z,z^2+1), y^2+1)
  ***   at top-level: factornf(x^2+Mod(z,z
  ***                 ^--------------------
  *** factornf: inconsistent data in rnf function.
? factornf(x^2 + z, y^2+1)
  ***   at top-level: factornf(x^2+z,y^2+1
  ***                 ^--------------------
  *** factornf: incorrect variable in rnf function.
@eprog

The library syntax is \fun{GEN}{polfnf}{GEN x, GEN t}.

\subsec{galoischardet$(\var{gal}, \var{chi}, \{o=1\})$}\kbdsidx{galoischardet}\label{se:galoischardet}
Let $G$ be the group attached to the \kbd{galoisinit}
structure~\var{gal}, and
let $\chi$ be the character of some representation $\rho$ of the group $G$,
where a polynomial variable is to be interpreted as an $o$-th root of 1.
For instance, if \kbd{[T,o] = galoischartable(gal)} the characters
$\chi$ are input as the columns of \kbd{T}.

Return the degree-$1$ character $\det\rho$ as the list of $\det \rho(g)$,
where $g$ runs through representatives of the conjugacy classes
in \kbd{galoisconjclasses(gal)}, with the same ordering.
\bprog
? P = x^5 - x^4 - 5*x^3 + 4*x^2 + 3*x - 1;
? polgalois(P)
%2 = [10, 1, 1, "D(5) = 5:2"]
? K = nfsplitting(P);
? gal = galoisinit(K);  \\ dihedral of order 10
? [T,o] = galoischartable(gal);
? chi = T[,1]; \\ trivial character
? galoischardet(gal, chi, o)
%7 = [1, 1, 1, 1]~
? [galoischardet(gal, T[,i], o) | i <- [1..#T]] \\ all characters
%8 = [[1, 1, 1, 1]~, [1, 1, -1, 1]~, [1, 1, -1, 1]~, [1, 1, -1, 1]~]
@eprog

The library syntax is \fun{GEN}{galoischardet}{GEN gal, GEN chi, long o}.

\subsec{galoischarpoly$(\var{gal}, \var{chi}, \{o=1\})$}\kbdsidx{galoischarpoly}\label{se:galoischarpoly}
Let $G$ be the group attached to the \kbd{galoisinit}
structure~\var{gal}, and
let $\chi$ be the character of some representation $\rho$ of the group
$G$, where a polynomial variable is to be interpreted as an $o$-th root of
1, e.g., if \kbd{[T,o] = galoischartable(gal)} and $\chi$ is a column of
\kbd{T}.
Return the list of characteristic polynomials $\det(1 - \rho(g)T)$,
where $g$ runs through representatives of the conjugacy classes
in \kbd{galoisconjclasses(gal)}, with the same ordering.
\bprog
? T = x^5 - x^4 - 5*x^3 + 4*x^2 + 3*x - 1;
? polgalois(T)
%2 = [10, 1, 1, "D(5) = 5:2"]
? K = nfsplitting(T);
? gal = galoisinit(K);  \\ dihedral of order 10
? [T,o] = galoischartable(gal);
? o
%5 = 5
? galoischarpoly(gal, T[,1], o)  \\ T[,1] is the trivial character
%6 = [-x + 1, -x + 1, -x + 1, -x + 1]~
? galoischarpoly(gal, T[,3], o)
%7 = [x^2 - 2*x + 1,
      x^2 + (y^3 + y^2 + 1)*x + 1,
      -x^2 + 1,
      x^2 + (-y^3 - y^2)*x + 1]~
@eprog

The library syntax is \fun{GEN}{galoischarpoly}{GEN gal, GEN chi, long o}.

\subsec{galoischartable$(\var{gal})$}\kbdsidx{galoischartable}\label{se:galoischartable}
Compute the character table of~$G$, where~$G$ is the underlying group of
the \kbd{galoisinit} structure~\var{gal}. The input~\var{gal} is also allowed
to be a \typ{VEC} of permutations that is closed under products.
Let~$N$ be the number of conjugacy classes of~$G$.
Return a \typ{VEC}~$[M,\var{e}]$ where $e \geq 1$ is an integer
and $M$ is a square \typ{MAT} of size~$N$ giving the character table
of~$G$.

\item Each column corresponds to an irreducible character; the characters
are ordered by increasing dimension and the first column is the trivial
character (hence contains only $1$'s).

\item Each row corresponds to a conjugacy class; the conjugacy classes are
ordered as specified by \kbd{galoisconjclasses(gal)}, in particular the
first row corresponds to the identity and gives the dimension $\chi(1)$
of the irreducible representation attached to the successive characters
$\chi$.

The value $M[i,j]$ of the character $j$ at the conjugacy class $i$
is represented by a polynomial in \kbd{y} whose variable should be
interpreted as an $e$-th root of unity, i.e. as the lift of
\bprog
  Mod(y, polcyclo(e,'y))
@eprog\noindent (Note that $M$ is the transpose of the usual orientation for
character tables.)

The integer $e$ divides the exponent of the group $G$ and is chosen as small
as posible; for instance $e = 1$ when the characters are all defined over
$\Q$, as is the case for $S_n$. Examples:
\bprog
? K = nfsplitting(x^4+x+1);
? gal = galoisinit(K);
? [M,e] = galoischartable(gal);
? M~  \\ take the transpose to get the usual orientation
%4 =
[1  1  1  1  1]

[1 -1 -1  1  1]

[2  0  0 -1  2]

[3 -1  1  0 -1]

[3  1 -1  0 -1]
? e
%5 = 1
? {G = [Vecsmall([1, 2, 3, 4, 5]), Vecsmall([1, 5, 4, 3, 2]),
        Vecsmall([2, 1, 5, 4, 3]), Vecsmall([2, 3, 4, 5, 1]),
        Vecsmall([3, 2, 1, 5, 4]), Vecsmall([3, 4, 5, 1, 2]),
        Vecsmall([4, 3, 2, 1, 5]), Vecsmall([4, 5, 1, 2, 3]),
        Vecsmall([5, 1, 2, 3, 4]), Vecsmall([5, 4, 3, 2, 1])];}
  \\G = D10
? [M,e] = galoischartable(G);
? M~
%8 =
[1  1              1              1]

[1 -1              1              1]

[2  0 -y^3 - y^2 - 1      y^3 + y^2]

[2  0      y^3 + y^2 -y^3 - y^2 - 1]
? e
%9 = 5
@eprog

The library syntax is \fun{GEN}{galoischartable}{GEN gal}.

\subsec{galoisconjclasses$(\var{gal})$}\kbdsidx{galoisconjclasses}\label{se:galoisconjclasses}
\var{gal} being output by \kbd{galoisinit},
return the list of conjugacy classes of the underlying group.
The ordering of the classes is consistent with \kbd{galoischartable}
and the trivial class comes first.

\bprog
? G = galoisinit(x^6+108);
? galoisidentify(G)
%2 = [6, 1]  \\ S_3
? S = galoisconjclasses(G)
%3 = [[Vecsmall([1,2,3,4,5,6])],
      [Vecsmall([3,1,2,6,4,5]),Vecsmall([2,3,1,5,6,4])],
      [Vecsmall([6,5,4,3,2,1]),Vecsmall([5,4,6,2,1,3]),
                               Vecsmall([4,6,5,1,3,2])]]
? [[permorder(c[1]),#c] | c <- S ]
%4 = [[1,1], [3,2], [2,3]]
@eprog\noindent
This command also accepts subgroups returned by \kbd{galoissubgroups}:
\bprog
? subs = galoissubgroups(G); H = subs[5];
? galoisidentify(H)
%2 = [2, 1]  \\ Z/2
? S = galoisconjclasses(subgroups_of_G[5]);
? [[permorder(c[1]),#c] | c <- S ]
%4 = [[1,1], [2,1]]
@eprog\noindent

The library syntax is \fun{GEN}{galoisconjclasses}{GEN gal}.

\subsec{galoisexport$(\var{gal},\{\fl\})$}\kbdsidx{galoisexport}\label{se:galoisexport}
\var{gal} being be a Galois group as output by \tet{galoisinit},
export the underlying permutation group as a string suitable
for (no flags or $\fl=0$) GAP or ($\fl=1$) Magma. The following example
compute the index of the underlying abstract group in the GAP library:
\bprog
? G = galoisinit(x^6+108);
? s = galoisexport(G)
%2 = "Group((1, 2, 3)(4, 5, 6), (1, 4)(2, 6)(3, 5))"
? extern("echo \"IdGroup("s");\" | gap -q")
%3 = [6, 1]
? galoisidentify(G)
%4 = [6, 1]
@eprog\noindent
This command also accepts subgroups returned by \kbd{galoissubgroups}.

To \emph{import} a GAP permutation into gp (for \tet{galoissubfields} for
instance), the following GAP function may be useful:
\bprog
PermToGP := function(p, n)
  return Permuted([1..n],p);
end;

gap> p:= (1,26)(2,5)(3,17)(4,32)(6,9)(7,11)(8,24)(10,13)(12,15)(14,27)
  (16,22)(18,28)(19,20)(21,29)(23,31)(25,30)
gap> PermToGP(p,32);
[ 26, 5, 17, 32, 2, 9, 11, 24, 6, 13, 7, 15, 10, 27, 12, 22, 3, 28, 20, 19,
  29, 16, 31, 8, 30, 1, 14, 18, 21, 25, 23, 4 ]
@eprog

The library syntax is \fun{GEN}{galoisexport}{GEN gal, long flag}.

\subsec{galoisfixedfield$(\var{gal},\var{perm},\{\fl\},\{v=y\})$}\kbdsidx{galoisfixedfield}\label{se:galoisfixedfield}
\var{gal} being be a Galois group as output by \tet{galoisinit} and
\var{perm} an element of $\var{gal}.group$, a vector of such elements
or a subgroup of \var{gal} as returned by galoissubgroups,
computes the fixed field of \var{gal} by the automorphism defined by the
permutations \var{perm} of the roots $\var{gal}.roots$. $P$ is guaranteed to
be squarefree modulo $\var{gal}.p$.

If no flags or $\fl=0$, output format is the same as for \tet{nfsubfield},
returning $[P,x]$ such that $P$ is a polynomial defining the fixed field, and
$x$ is a root of $P$ expressed as a polmod in $\var{gal}.pol$.

If $\fl=1$ return only the polynomial $P$.

If $\fl=2$ return $[P,x,F]$ where $P$ and $x$ are as above and $F$ is the
factorization of $\var{gal}.pol$ over the field defined by $P$, where
variable $v$ ($y$ by default) stands for a root of $P$. The priority of $v$
must be less than the priority of the variable of $\var{gal}.pol$ (see
\secref{se:priority}).
In this case, $P$ is also expressed in the variable $v$ for compatibility
with $F$. Example:

\bprog
? G = galoisinit(x^4+1);
? galoisfixedfield(G,G.group[2],2)
%2 = [y^2 - 2, Mod(- x^3 + x, x^4 + 1), [x^2 - y*x + 1, x^2 + y*x + 1]]
@eprog\noindent
computes the factorization  $x^4+1=(x^2-\sqrt{2}x+1)(x^2+\sqrt{2}x+1)$

The library syntax is \fun{GEN}{galoisfixedfield}{GEN gal, GEN perm, long flag, long v = -1} where \kbd{v} is a variable number.

\subsec{galoisgetgroup$(a,\{b\})$}\kbdsidx{galoisgetgroup}\label{se:galoisgetgroup}
Query the \kbd{galpol} package for a group of order $a$ with index $b$
in the GAP4 Small Group library, by Hans Ulrich Besche, Bettina Eick and
Eamonn O'Brien.

The current version of \kbd{galpol} supports groups of order $a\leq 143$.
If $b$ is omitted, return the number of isomorphism classes of
groups of order $a$.

The library syntax is \fun{GEN}{galoisgetgroup}{long a, long b}.
Also available is \fun{GEN}{galoisnbpol}{long a} when $b$
is omitted.

\subsec{galoisgetname$(a,b)$}\kbdsidx{galoisgetname}\label{se:galoisgetname}
Query the \kbd{galpol} package for a string describing the group of order
$a$ with index $b$ in the GAP4 Small Group library, by Hans Ulrich Besche,
Bettina Eick and Eamonn O'Brien.
The strings were generated using the GAP4 function \kbd{StructureDescription}.
The command below outputs the names of all abstract groups of order 12:
\bprog
? o = 12; N = galoisgetgroup(o); \\ # of abstract groups of order 12
? for(i=1, N, print(i, ". ", galoisgetname(o,i)))
1. C3 : C4
2. C12
3. A4
4. D12
5. C6 x C2
@eprog\noindent
The current version of \kbd{galpol} supports groups of order $a\leq 143$.
For $a \geq 16$, it is possible for different groups to have the same name:
\bprog
? o = 20; N = galoisgetgroup(o);
? for(i=1, N, print(i, ". ", galoisgetname(o,i)))
1. C5 : C4
2. C20
3. C5 : C4
4. D20
5. C10 x C2
@eprog

The library syntax is \fun{GEN}{galoisgetname}{long a, long b}.

\subsec{galoisgetpol$(a,\{b\},\{s\})$}\kbdsidx{galoisgetpol}\label{se:galoisgetpol}
Query the \kbd{galpol} package for a polynomial with Galois group
isomorphic to
GAP4(a,b), totally real if $s=1$ (default) and totally complex if $s=2$.
The current version of \kbd{galpol} supports groups of order $a\leq 143$.
The output is a vector [\kbd{pol}, \kbd{den}] where

\item  \kbd{pol} is the polynomial of degree $a$

\item \kbd{den} is the denominator of \kbd{nfgaloisconj(pol)}.
Pass it as an optional argument to \tet{galoisinit} or \tet{nfgaloisconj} to
speed them up:
\bprog
? [pol,den] = galoisgetpol(64,4,1);
? G = galoisinit(pol);
time = 352ms
? galoisinit(pol, den);  \\ passing 'den' speeds up the computation
time = 264ms
? % == %`
%4 = 1  \\ same answer
@eprog
If $b$ and $s$ are omitted, return the number of isomorphism classes of
groups of order $a$.

The library syntax is \fun{GEN}{galoisgetpol}{long a, long b, long s}.
Also available is \fun{GEN}{galoisnbpol}{long a} when $b$ and $s$
are omitted.

\subsec{galoisidentify$(\var{gal})$}\kbdsidx{galoisidentify}\label{se:galoisidentify}
\var{gal} being be a Galois group as output by \tet{galoisinit},
output the isomorphism class of the underlying abstract group as a
two-components vector $[o,i]$, where $o$ is the group order, and $i$ is the
group index in the GAP4 Small Group library, by Hans Ulrich Besche, Bettina
Eick and Eamonn O'Brien.

This command also accepts subgroups returned by \kbd{galoissubgroups}.

The current implementation is limited to degree less or equal to $127$.
Some larger ``easy'' orders are also supported.

The output is similar to the output of the function \kbd{IdGroup} in GAP4.
Note that GAP4 \kbd{IdGroup} handles all groups of order less than $2000$
except $1024$, so you can use \tet{galoisexport} and GAP4 to identify large
Galois groups.

The library syntax is \fun{GEN}{galoisidentify}{GEN gal}.

\subsec{galoisinit$(\var{pol},\{\var{den}\})$}\kbdsidx{galoisinit}\label{se:galoisinit}
Computes the Galois group
and all necessary information for computing the fixed fields of the
Galois extension $K/\Q$ where $K$ is the number field defined by
$\var{pol}$ (monic irreducible polynomial in $\Z[X]$ or
a number field as output by \tet{nfinit}). The extension $K/\Q$ must be
Galois with Galois group ``weakly'' super-solvable, see below;
returns 0 otherwise. Hence this permits to quickly check whether a polynomial
of order strictly less than $48$ is Galois or not.

The algorithm used is an improved version of the paper
``An efficient algorithm for the computation of Galois automorphisms'',
Bill Allombert, Math.~Comp, vol.~73, 245, 2001, pp.~359--375.

A group $G$ is said to be ``weakly'' super-solvable if there exists a
normal series

$\{1\} = H_0 \triangleleft H_1 \triangleleft \cdots \triangleleft H_{n-1}
\triangleleft H_n$

such that each $H_i$ is normal in $G$ and for $i<n$, each quotient group
$H_{i+1}/H_i$ is cyclic, and either $H_n=G$ (then $G$ is super-solvable) or
$G/H_n$ is isomorphic to either $A_4$, $S_4$ or the group
 $(3\times 3):4$ (\kbd{GAP4(36,9)}) then
$[o_1,\ldots,o_g]$ ends by $[3,3,4]$.

In practice, almost all small groups are WKSS, the exceptions having order
48(2), 56(1), 60(1), 72(3), 75(1), 80(1), 96(10), 112(1), 120(3) and $\geq 144$.

This function is a prerequisite for most of the \kbd{galois}$xxx$ routines.
For instance:

\bprog
P = x^6 + 108;
G = galoisinit(P);
L = galoissubgroups(G);
vector(#L, i, galoisisabelian(L[i],1))
vector(#L, i, galoisidentify(L[i]))
@eprog

The output is an 8-component vector \var{gal}.

$\var{gal}[1]$ contains the polynomial \var{pol}
(\kbd{\var{gal}.pol}).

$\var{gal}[2]$ is a three-components vector $[p,e,q]$ where $p$ is a
prime number (\kbd{\var{gal}.p}) such that \var{pol} totally split
modulo $p$ , $e$ is an integer and $q=p^e$ (\kbd{\var{gal}.mod}) is the
modulus of the roots in \kbd{\var{gal}.roots}.

$\var{gal}[3]$ is a vector $L$ containing the $p$-adic roots of
\var{pol} as integers implicitly modulo \kbd{\var{gal}.mod}.
(\kbd{\var{gal}.roots}).

$\var{gal}[4]$ is the inverse of the Vandermonde matrix of the
$p$-adic roots of \var{pol}, multiplied by $\var{gal}[5]$.

$\var{gal}[5]$ is a multiple of the least common denominator of the
automorphisms expressed as polynomial in a root of \var{pol}.

$\var{gal}[6]$ is the Galois group $G$ expressed as a vector of
permutations of $L$ (\kbd{\var{gal}.group}).

$\var{gal}[7]$ is a generating subset $S=[s_1,\ldots,s_g]$ of $G$
expressed as a vector of permutations of $L$ (\kbd{\var{gal}.gen}).

$\var{gal}[8]$ contains the relative orders $[o_1,\ldots,o_g]$ of
the generators of $S$ (\kbd{\var{gal}.orders}).

Let $H_n$ be as above, we have the following properties:

\quad\item if $G/H_n\simeq A_4$ then $[o_1,\ldots,o_g]$ ends by
$[2,2,3]$.

\quad\item if $G/H_n\simeq S_4$ then $[o_1,\ldots,o_g]$ ends by
$[2,2,3,2]$.

\quad\item if $G/H_n\simeq (3\times 3):4$ (\kbd{GAP4(36,9)}) then
$[o_1,\ldots,o_g]$ ends by $[3,3,4]$.

\quad\item for $1\leq i \leq g$ the subgroup of $G$ generated by
$[s_1,\ldots,s_i]$ is normal, with the exception of $i=g-2$ in the
$A_4$ case and of $i=g-3$ in the $S_4$ case.

\quad\item the relative order $o_i$ of $s_i$ is its order in the
quotient group $G/\langle s_1,\ldots,s_{i-1}\rangle$, with the same
exceptions.

\quad\item for any $x\in G$ there exists a unique family
$[e_1,\ldots,e_g]$ such that (no exceptions):

-- for $1\leq i \leq g$ we have $0\leq e_i<o_i$

-- $x=g_1^{e_1}g_2^{e_2}\ldots g_n^{e_n}$

If present $den$ must be a suitable value for $\var{gal}[5]$.

The library syntax is \fun{GEN}{galoisinit}{GEN pol, GEN den = NULL}.

\subsec{galoisisabelian$(\var{gal},\{\fl=0\})$}\kbdsidx{galoisisabelian}\label{se:galoisisabelian}
\var{gal} being as output by \kbd{galoisinit}, return $0$ if
\var{gal} is not an abelian group, and the HNF matrix of \var{gal} over
\kbd{gal.gen} if $\fl=0$, $1$ if $\fl=1$, and the SNF matrix of \var{gal}
if $\fl=2$.

This command also accepts subgroups returned by \kbd{galoissubgroups}.

The library syntax is \fun{GEN}{galoisisabelian}{GEN gal, long flag}.

\subsec{galoisisnormal$(\var{gal},\var{subgrp})$}\kbdsidx{galoisisnormal}\label{se:galoisisnormal}
\var{gal} being as output by \kbd{galoisinit}, and \var{subgrp} a subgroup
of \var{gal} as output by \kbd{galoissubgroups},return $1$ if \var{subgrp} is a
normal subgroup of \var{gal}, else return 0.

This command also accepts subgroups returned by \kbd{galoissubgroups}.

The library syntax is \fun{long}{galoisisnormal}{GEN gal, GEN subgrp}.

\subsec{galoispermtopol$(\var{gal},\var{perm})$}\kbdsidx{galoispermtopol}\label{se:galoispermtopol}
\var{gal} being a
Galois group as output by \kbd{galoisinit} and \var{perm} a element of
$\var{gal}.group$, return the polynomial defining the Galois
automorphism, as output by \kbd{nfgaloisconj}, attached to the
permutation \var{perm} of the roots $\var{gal}.roots$. \var{perm} can
also be a vector or matrix, in this case, \kbd{galoispermtopol} is
applied to all components recursively.

\noindent Note that
\bprog
G = galoisinit(pol);
galoispermtopol(G, G[6])~
@eprog\noindent
is equivalent to \kbd{nfgaloisconj(pol)}, if degree of \var{pol} is greater
or equal to $2$.

The library syntax is \fun{GEN}{galoispermtopol}{GEN gal, GEN perm}.

\subsec{galoissplittinginit$(P,\{d\})$}\kbdsidx{galoissplittinginit}\label{se:galoissplittinginit}
Computes the Galois group over $Q$ of the splitting field of
$P$, that is the smallest field over which $P$ is totally split. $P$ is
assumed to be integral, monic and irreducible; it can
also be given by a nf structure. If $d$ is given, it must be a multiple of
the splitting field degree. The output is compatible with functions expecting
a \kbd{galoisinit} structure.

The library syntax is \fun{GEN}{galoissplittinginit}{GEN P, GEN d = NULL}.

\subsec{galoissubcyclo$(N,H,\{\var{fl}=0\},\{v\})$}\kbdsidx{galoissubcyclo}\label{se:galoissubcyclo}
Computes the subextension $L$ of $\Q(\zeta_n)$ fixed by the subgroup
$H \subset (\Z/n\Z)^*$. By the Kronecker-Weber theorem, all abelian number
fields can be generated in this way (uniquely if $n$ is taken to be minimal).
This function output is somewhat canonical, as it returns the minimal
polynomial of a Gaussian period $\text{Tr}_{\Q(\zeta_n)/L}(\zeta_n)$.

\noindent The pair $(n, H)$ is deduced from the parameters $(N, H)$ as follows

\item $N$ an integer: then $n = N$; $H$ is a generator, i.e. an
integer or an integer modulo $n$; or a vector of generators.

\item $N$ the output of \kbd{znstar}$(n)$ or \kbd{znstar}$(n,1)$.
$H$ as in the first case above, or a matrix, taken to be a HNF left divisor
of the SNF for $(\Z/n\Z)^*$
(\kbd{$N$.cyc}), giving the generators of $H$ in terms of \kbd{$N$.gen}.

\item $N$ the output of \kbd{bnrinit(bnfinit(y), $m$)} where $m$ is a
module. $H$ as in the first case, or a matrix taken to be a HNF left
divisor of the SNF for the ray class group modulo $m$
(of type \kbd{$N$.cyc}), giving the generators of $H$ in terms of
\kbd{$N$.bid.gen} (= \kbd{$N$}.gen if $N$ includes generators).

In this last case, beware that $H$ is understood relatively to $N$; in
particular, if the infinite place does not divide the module, e.g if $m$ is
an integer, then it is not a subgroup of $(\Z/n\Z)^*$, but of its quotient by
$\{\pm 1\}$.

If $fl=0$, compute a polynomial (in the variable \var{v}) defining
the subfield of $\Q(\zeta_n)$ fixed by the subgroup \var{H} of $(\Z/n\Z)^*$.

If $fl=1$, compute only the conductor of the abelian extension, as a module.

If $fl=2$, output $[pol, N]$, where $pol$ is the polynomial as output when
$fl=0$ and $N$ the conductor as output when $fl=1$.

If $fl=3$; output \kbd{galoisinit(pol)}.

The following function can be used to compute all subfields of
$\Q(\zeta_n)$ (of exact degree \kbd{d}, if \kbd{d} is set):
\bprog
subcyclo(n, d = -1)=
{ my(bnr,L,IndexBound);
  IndexBound = if (d < 0, n, [d]);
  bnr = bnrinit(bnfinit(y), [n,[1]]);
  L = subgrouplist(bnr, IndexBound, 1);
  vector(#L,i, galoissubcyclo(bnr,L[i]));
}
@eprog\noindent
Setting \kbd{L = subgrouplist(bnr, IndexBound)} would produce subfields of
exact conductor $n\infty$.

The library syntax is \fun{GEN}{galoissubcyclo}{GEN N, GEN H = NULL, long fl, long v = -1} where \kbd{v} is a variable number.

\subsec{galoissubfields$(G,\{\fl=0\},\{v\})$}\kbdsidx{galoissubfields}\label{se:galoissubfields}
Outputs all the subfields of the Galois group \var{G}, as a vector.
This works by applying \kbd{galoisfixedfield} to all subgroups. The meaning of
\var{flag} is the same as for \kbd{galoisfixedfield}.

The library syntax is \fun{GEN}{galoissubfields}{GEN G, long flag, long v = -1} where \kbd{v} is a variable number.

\subsec{galoissubgroups$(G)$}\kbdsidx{galoissubgroups}\label{se:galoissubgroups}
Outputs all the subgroups of the Galois group \kbd{gal}. A subgroup is a
vector [\var{gen}, \var{orders}], with the same meaning
as for $\var{gal}.gen$ and $\var{gal}.orders$. Hence \var{gen} is a vector of
permutations generating the subgroup, and \var{orders} is the relatives
orders of the generators. The cardinality of a subgroup is the product of the
relative orders. Such subgroup can be used instead of a Galois group in the
following command: \kbd{galoisisabelian}, \kbd{galoissubgroups},
\kbd{galoisexport} and \kbd{galoisidentify}.

To get the subfield fixed by a subgroup \var{sub} of \var{gal}, use
\bprog
galoisfixedfield(gal,sub[1])
@eprog

The library syntax is \fun{GEN}{galoissubgroups}{GEN G}.

\subsec{gcharalgebraic$(\var{gc},\{\var{type}\})$}\kbdsidx{gcharalgebraic}\label{se:gcharalgebraic}
\var{gc} being the structure returned by \kbd{gcharinit}, return a \typ{MAT}
whose columns form a basis of the subgroup of algebraic Grossencharacters in
\var{gc} (Weil type A0). The last component is interpreted as a power of the
norm.

If \var{type} is a \typ{VEC} of length $\var{gc}\kbd{.r1}+\var{gc}\kbd{.r2}$,
containing a pair of integers $[p_\tau,q_\tau]$ for each complex
embedding~$\tau$, return a \typ{VEC} containing a character whose infinity type
at~$\tau$ is
$$
 z \mapsto z^{-p_\tau}\bar{z}^{-q_\tau}
$$
if such a character exists, or empty otherwise.
The full set of characters of that infinity type is obtained by multiplying by
the group of finite order characters.

\bprog
? bnf = bnfinit(x^4-2*x^3+23*x^2-22*x+6,1);
? gc = gcharinit(bnf,1);
? gc.cyc
% = [6, 0, 0, 0, 0.E-57]
? gcharalgebraic(gc)
% =
[1    0    0  0]
[0    1    0  0]
[0    0    1  0]
[0    0    0  0]
[0 -1/2 -1/2 -1]
? gcharalgebraic(gc,[[1,1],[0,1]])
% = [] \\ @com $p_\tau+q_\tau$ must be constant for an algebraic character to exist
? gcharalgebraic(gc,[[1,1],[0,2]])
% = [[0, 1, 1, 0, -1]~]
@eprog

The library syntax is \fun{GEN}{gcharalgebraic}{GEN gc, GEN type = NULL}.

\subsec{gcharconductor$(\var{gc},\var{chi})$}\kbdsidx{gcharconductor}\label{se:gcharconductor}
Returns the conductor of \kbd{chi}, as a modulus over \kbd{gc.bnf}. This is
the minimum modulus $\goth{m}$ such that
$U(\goth{m})\subset\text{ker}(\var{chi})$
indicating the exact ramification of \var{chi}.

\item for a real place $v$, $v\mid \goth{m}$ iff $\chi_v(-1)=-1$.

\item for a finite place~$\goth{p}$, the prime power~$\goth{p}^e$ divides
exactly $\goth{m}$ if $e\ge 0$ is the smallest integer such that $\chi_{\goth{p}}
(U_e)=1$ where~$U_0 = \Z_{\goth{p}}^\times$ and~$U_i =
1+\goth{p}^i\Z_{\goth{p}}$ for~$i>0$.

\bprog
? bnf = bnfinit(x^2-5,1);
? gc = gcharinit(bnf,[(13*19)^2,[1,1]]);
? gc.cyc
% = [8892, 6, 2, 0, 0.E-57]
? chi = [0,0,1,1]~;
? gcharconductor(gc,chi)
% = [[61009, 7267; 0, 169], [1, 0]]
? gcharconductor(gc,13*chi)
% = [[4693, 559; 0, 13], [1, 0]]
? gcharconductor(gc,13*19*chi)
% = [[247, 65; 0, 13], [1, 0]]
? gcharconductor(gc,13*19*168*chi)
% = [[19, 5; 0, 1], [0, 0]]
@eprog

The library syntax is \fun{GEN}{gchar_conductor}{GEN gc, GEN chi}.

\subsec{gcharduallog$(\var{gc},\var{chi})$}\kbdsidx{gcharduallog}\label{se:gcharduallog}
Return internal logarithm vector of character \kbd{chi}
as a \typ{VEC} in $\R^n$, so that for all \var{x},
\kbd{gchareval}(\var{gc},\var{chi},\var{x},$0$) is equal to
\kbd{gcharduallog}(\var{gc},\var{chi}) * \kbd{gcharlog}(\var{gc},\var{x}).

The components are organized as follows:

\item the first \kbd{ns} components are in~$\R$ and describe the character on
the class group generators: $\theta$ encodes~$\goth{p}\mapsto
\exp(2i\pi\theta)$,

\item the next \kbd{nc} components are in~$\R$ and describe the \kbd{idealstar}
group character via its image on generators: $\theta$ encodes the
image~$\exp(2i\pi\theta)$,

\item the next $r_1+r_2$ components are in $\R$ and correspond to characters
of $\R$ for each infinite place: $\varphi$ encodes~$x\mapsto |x|^{i\varphi}$ in
the real case and~$z\mapsto |z|^{2i\varphi}$ in the complex case,

\item the last $r_2$ components are in $\Z$ and correspond to characters of
$\R/\Z$ for each complex place: $k$ encodes~$z\mapsto (z/|z|)^k$.

\item the last component~$s$ is in~$\C$ and corresponds to a
power~$\|\cdot\|^s$ of the ad\'elic norm.

See also \kbd{gcharlog}.

\bprog
? bnf = bnfinit(x^3+4*x-1,1);
? gc = gcharinit(bnf,[1,[1]]);
? gc.cyc
% = [2, 0, 0, 0.E-57]
? chi = [0,1,0]~;
? f = gcharduallog(gc,chi)
% = [0.153497221319231, 1/2, 0.776369647248353, -0.388184823624176, 1, 0]
? pr = idealprimedec(bnf,2)[1];
? v = gcharlog(gc,pr);
? exp(2*I*Pi*f*v)
% = -0.569867696226731232993110144 - 0.821736459454756074068598760*I
? gchareval(gc,chi,pr)
% = -0.569867696226731232993110144 - 0.821736459454756074068598760*I
@eprog

The library syntax is \fun{GEN}{gcharduallog}{GEN gc, GEN chi}.

\subsec{gchareval$(\var{gc},\var{chi},x,\{\fl=1\})$}\kbdsidx{gchareval}\label{se:gchareval}
\var{gc} being the structure returned by \kbd{gcharinit}, \var{chi} a
character in \var{gc}, and \var{x} an ideal of the base field, return the
value~$\chi(x)$. If~$\fl=1$ (default), return a value in~$\C^\times$;
if~$\fl=0$, return a value in~$\C/\Z$, normalized so that the real part is
between~$-1/2$ and~$1/2$.

\bprog
? bnf = bnfinit(x^2-5);
? gc = gcharinit(bnf,1);
? chi = [1]~;
? pr = idealprimedec(bnf,11)[1];
? a = gchareval(gc,chi,pr)
% = -0.3804107379142448929315340886 - 0.9248176417432464199580504588*I
? b = gchareval(gc,chi,pr,0)
% = -0.3121086861831031476247589216
? a == exp(2*Pi*I*b)
%7 = 1
@eprog

The library syntax is \fun{GEN}{gchareval}{GEN gc, GEN chi, GEN x, long flag}.

\subsec{gcharidentify$(\var{gc},\var{Lv},\var{Lchiv})$}\kbdsidx{gcharidentify}\label{se:gcharidentify}
\var{gc} being a Grossencharacter group as output by \kbd{gcharinit}, $Lv$
being \typ{VEC} of places~$v$ encoded by a \typ{INT} (infinite place) or a prime
ideal structure representing a prime not dividing the modulus of~$gc$ (finite
place), and $Lchiv$ being a \typ{VEC} of local characters~$\chi_v$ encoded
by~$[k,\varphi]$ with~$k$ a \typ{INT} and $\varphi$ a \typ{REAL} or
\typ{COMPLEX} representing~$x\mapsto \text{sign}(x)^k|x|^{i\varphi}$ (real
place) or~$z\mapsto (z/|z|)^k|z|^{2i\varphi}$(complex place) or by a \typ{REAL}
or \typ{COMPLEX}~$\theta$ representing~$\goth{p} \mapsto \exp(2i\pi \theta)$
(finite place), returns a Grossencharacter~$\psi$ belonging to~$g$ such
that~$\psi_v \approx \chi_v$ for all~$v$.
At finite places, in place of a scalar one can provide a \typ{VEC} whose
last component is $\theta$, as output by \kbd{gcharlocal}.
To ensure proper identification, it is recommended to provide all infinite
places together with a set of primes that generate the ray class group of
modulus \var{gc}\kbd{.mod}.

\bprog
? bnf = bnfinit(x^2-5,1);
? gc = gcharinit(bnf,1);
? chi = gcharidentify(gc,[2],[[0,13.]]);
? gcharlocal(gc,chi,2)
% = [0, 13.057005210545987626926134713745179631]
? pr = idealprimedec(bnf,11)[1];
? chi = gcharidentify(gc,[pr],[0.3]);
? gchareval(gc,chi,pr,0)
% = 0.30000006229129706787363344444425752636
@eprog

If you know only few digits, it may be a good idea to reduce the current
precision to obtain a meaningful result.

\bprog
? bnf = bnfinit(x^2-5,1);
? gc = gcharinit(bnf,1);
? pr = idealprimedec(bnf,11)[1];
? chi = gcharidentify(gc,[pr],[0.184760])
% = [-420226]~ \\ @com unlikely to be meaningful
? gchareval(gc,chi,pr,0)
% = 0.18475998070331376194260927294721168954
? \p 10
  realprecision = 19 significant digits (10 digits displayed)
? chi = gcharidentify(gc,[pr],[0.184760])
% = [-7]~ \\ @com probably what we were looking for
? gchareval(gc,chi,pr,0)
% = 0.1847608033
? \p 38
  realprecision = 38 significant digits
? gchareval(gc,chi,pr,0)
% = 0.18476080328172203337331245154966763237
@eprog

The output may be a quasi-character.

\bprog
? bnf = bnfinit(x^2-2,1);
? gc = gcharinit(bnf,1); gc.cyc
% = [0]
? gcharidentify(gc,[1,2],[[0,3.5+1/3*I],[0,-3.5+1/3*I]])
% = [-1, 1/3]~
@eprog

The library syntax is \fun{GEN}{gchar_identify}{GEN gc, GEN Lv, GEN Lchiv, long prec}.

\subsec{gcharinit$(\var{bnf},f)$}\kbdsidx{gcharinit}\label{se:gcharinit}
$\var{bnf}$ being a number field output by \kbd{bnfinit} (including
fundamental units), $f$ a modulus, initializes a structure (\kbd{gc})
describing the group of Hecke Grossencharacters of modulus $f$.
(As in \tet{idealstar}, the finite part of the conductor may be given
by a factorization into prime ideals, as produced by \tet{idealfactor}.)

The following member functions are available
on the result: \kbd{.bnf} is the underlying \var{bnf},
\kbd{.mod} the modulus, \kbd{.cyc} its elementary divisors.

The internal representation uses a logarithm map on ideals
${\cal L}: I \to \R^n$,
so that a Hecke Grossencharacter $\chi$ can be described by a $n$
components vector $v$ via
$\chi: a\in I \mapsto \exp(2i\pi v\cdot{{\cal L}(a)})$.

See \kbd{gcharlog} for more details on the map ${\cal L}$.

\bprog
? bnf = bnfinit(polcyclo(5),1); \\ @com initialize number field $\Q(\zeta_5)$
? pr = idealprimedec(bnf,5)[1]; \\ @com prime $\goth{p}=(1-\zeta_5)$ above 5
? gc = gcharinit(bnf,idealpow(bnf,pr,2)); \\ @com characters of modulus dividing $\goth{p}^2$
? gc.cyc \\ @com structure as an abelian group
% = [0,0,0,0.E-57]
? chi = [1,1,-1,0]~; \\ @com a character
? gcharconductor(gc,chi)[1]
% =
[5 4 4 4]
[0 1 0 0]
[0 0 1 0]
[0 0 0 1]
@eprog

Currently, \kbd{gc} is a row vector with 11 components:

$\var{gc}[1]$ is a matrix whose rows describe a system of generators
of the characters as vectors of $\R^n$, under the above description.

$\var{gc}[2]$ contains the underlying number field \var{bnf}
(\kbd{\var{gc}.bnf}).

$\var{gc}[3]$ contains the underlying number field \var{nf}
(\kbd{\var{gc}.nf}), possibly stored at higher precision than \var{bnf}.

$\var{gc}[4]$ contains data for computing in $(\Z_K/f)^\times$.

$\var{gc}[5]$ is a vector $S$ of prime ideals which generate the class group.

$\var{gc}[6]$ contains data to compute discrete logarithms with respect to $S$
in the class group.

$\var{gc}[7]$ is a vector \kbd{[Sunits,m]}, where \kbd{Sunits} describes
the $S$-units of $\var{bnf}$ and $m$ is a relation matrix for internal usage.

$\var{gc}[8]$ is
\kbd{[Vecsmall([evalprec,prec,nfprec]), Vecsmall([ntors,nfree,nalg])]}
caching precisions and various dimensions.

$\var{gc}[9]$ is a vector describing $\var{gc}$ as a $\Z$-module
via its SNF invariants (\kbd{\var{gc}.cyc}), the last component
representing the norm character.

$\var{gc}[10]$ is a vector \kbd{[R,U,Ui]} allowing to convert characters
from SNF basis to internal combination of generators.

Specifically, a character \kbd{chi} in SNF basis has coordinates
\kbd{chi*Ui} in internal basis (the rows of $\var{gc}[1]$).

$\var{gc}[11]=m$ is the matrix of ${\cal L}(v)$ for all $S$-units $v$.

$\var{gc}[12]=u$ is an integral base change matrix such that $\var{gc}[1]$
corresponds to $(mu)^{-1}$.

The library syntax is \fun{GEN}{gcharinit}{GEN bnf, GEN f, long prec}.

\subsec{gcharisalgebraic$(\var{gc},\var{chi},\{\&\var{type}\})$}\kbdsidx{gcharisalgebraic}\label{se:gcharisalgebraic}
\var{gc} being the structure returned by \kbd{gcharinit} and \var{chi}
a character on \var{gc}, return 1 if and only if \var{chi} is an algebraic
(Weil type A0) character, so that its infinity type at every complex
embedding~$\tau$ can be written
$$
 z \mapsto z^{-p_\tau}\bar{z}^{-q_\tau}
$$
for some pair of integers $(p_\tau,q_\tau)$.

If \var{type} is given, set it to the \typ{VEC} of exponents $[p_\tau,q_\tau]$.

\bprog
? bnf = bnfinit(x^4+1,1);
? gc = gcharinit(bnf,1);
? gc.cyc
% = [0, 0, 0, 0.E-57]
? chi1 = [0,0,1]~;
? gcharisalgebraic(gc,chi1)
% = 0
? gcharlocal(gc,chi1,1)
% = [-3, -0.89110698909568455588720672648627467040]
? chi2 = [1,0,0,-3]~;
? gcharisalgebraic(gc,chi2,&typ)
% = 1
? typ
% = [[6, 0], [2, 4]]
? gcharlocal(gc,chi2,1)
% = [-6, 3*I]
@eprog

The library syntax is \fun{GEN}{gcharisalgebraic}{GEN gc, GEN chi, GEN *type = NULL}.

\subsec{gcharlocal$(\var{gc},\var{chi},v,\{\&\var{BID}\})$}\kbdsidx{gcharlocal}\label{se:gcharlocal}
\kbd{gc} being a gchar structure initialised by \kbd{gcharinit}, returns
the local component $\chi_v$, where $v$ is either an integer between~$1$
and~$r_1+r_2$ encoding an infinite place, or a prime ideal structure encoding a
finite place.

\item if~$v$ is a real place, $\chi_v(x) = {\rm sign}(x)^k
|x|^{i\varphi}$ is encoded as~$[k,\varphi]$;

\item if~$v$ is a complex place, $\chi_v(z) = (z/|z|)^k |z|^{2i\varphi}$ is
encoded as~$[k,\varphi]$;

\item if~$v = \goth{p}$ is a finite place not dividing~\var{gc}\kbd{.mod},
$\chi_v(\pi_v) = \exp(2i\pi \theta)$ is encoded as~$[\theta]$;

\item if~$v = \goth{p}$ is a finite place dividing~\var{gc}\kbd{.mod},
we can define a \var{bid} structure attached to the multiplicative group
$G = (\Z_K/\goth{p}^k)^*$, where $\goth{p}^k$ divides exactly
\var{gc}\kbd{.mod} (see \kbd{idealstar}).
Then~$\chi_v$ is encoded as~$[c_1,\dots,c_n,\theta]$ where~$[c_1,\dots,c_n]$
defines a character on $G$
(see \kbd{gchareval}) and~$\chi_v(\pi_v) = \exp(2i\pi\theta)$. This \var{bid}
structure only depends on \kbd{gc} and $v$ (and not on the character $\chi$);
it can be recovered through the optional argument \var{BID}.
\bprog
? bnf = bnfinit(x^3-x-1);
? gc = gcharinit(bnf,1);
? gc.cyc
% = [0, 0, 0.E-57]
? chi = [0,1,1/3]~;
? pr = idealprimedec(bnf,5)[1];
? gcharlocal(gc,chi,1)
% = [0, -4.8839310048284836274074581373242545693 - 1/3*I]
? gcharlocal(gc,chi,2)
% = [6, 2.4419655024142418137037290686621272847 - 1/3*I]
? gcharlocal(gc,chi,pr)
% = [0.115465135184293124024408915 + 0.0853833331211293579127218326*I]
? bnf = bnfinit(x^2+1,1);
? pr3 = idealprimedec(bnf,3)[1];
? pr5 = idealprimedec(bnf,5)[1];
? gc = gcharinit(bnf,[pr3,2;pr5,3]);
? gc.cyc
% = [600, 3, 0, 0.E-57]
? chi = [1,1,1]~;
? gcharlocal(gc,chi,pr3,&bid)
% = [1, 1, -21/50]
? bid.cyc
% = [24, 3]
? gcharlocal(gc,chi,pr5,&bid)
% = [98, -0.30120819117478336291229946188762973702]
? bid.cyc
% = [100]
@eprog

The library syntax is \fun{GEN}{gcharlocal}{GEN gc, GEN chi, GEN v, long prec, GEN *BID = NULL}.

\subsec{gcharlog$(\var{gc},x)$}\kbdsidx{gcharlog}\label{se:gcharlog}
Return the internal (logarithmic) representation of the ideal $x$ suitable
for computations in $gc$, as a \typ{COL} in $\R^n$.

Its $n = \kbd{ns+nc}+(r_1+r_2)+r_2+1$ components correspond to a
logarithm map on the group of fractional ideals~${\cal L}: I \to \R^n$, see
\kbd{gcharinit}.

More precisely, let $x = (\alpha) \prod \goth{p}_i^{a_i}$ a
principalization of $x$ on a set $S$ of primes generating
the class group (see \kbd{bnfisprincipal}),
then the logarithm of $x$ is the \typ{COL}
$$
 {\cal L}(x) = \left[ (a_i), \log_f(\alpha), \dfrac{\log|x/\alpha|_\tau}{2\pi},
\dfrac{\arg(x/\alpha)_\tau}{2\pi}, \dfrac{\log N(x)}{2\pi}\cdot i \right]
$$
where

\item the exponent vector $(a_i)$ has \kbd{ns} components, where
$\kbd{ns}=\#S$ is the number of prime ideals used to generate the class group,

\item $\log_f(\alpha)$ is a discrete logarithm of
$\alpha$ in the \kbd{idealstar} group $(\Z_K/f)^\times$, with \kbd{nc} components,

\item $\log|x/\alpha|_\tau$ has $r_1+r_2$ components, one for each
real embedding and pair of complex embeddings $\tau\colon K\to\C$
(and $|z|_\tau=|z|^2$ for complex $\tau$).

\item $\arg{(x/\alpha)_\tau}$ has $r_2$ components, one for each
pair of complex embeddings $\tau\colon K\to\C$.

\item $N(x)$ is the norm of the ideal~$x$.

\bprog
? bnf = bnfinit(x^3-x^2+5*x+1,1);
? gc = gcharinit(bnf,3);
? gc.cyc
% = [3, 0, 0, 0.E-57]
? chi = [1,1,0,-1]~;
? f = gcharduallog(gc,chi);
? pr = idealprimedec(bnf,5)[1];
? v = gcharlog(gc,pr)
% = [2, -5, -1, 0.0188115475004995312411, -0.0188115475004995312411,
     -0.840176314833856764413, 0.256149999363388073738*I]~
? exp(2*I*Pi*f*v)
% = -4.5285995080704456583673312 + 2.1193835177957097598574507*I
? gchareval(gc,chi,pr)
% = -4.5285995080704456583673312 + 2.1193835177957097598574507*I
@eprog

The library syntax is \fun{GEN}{gcharlog}{GEN gc, GEN x, long prec}.

\subsec{gcharnewprec$(\var{gc})$}\kbdsidx{gcharnewprec}\label{se:gcharnewprec}
$\var{gc}$ being a Grossencharacter group output by \kbd{gcharinit},
recompute its archimedean components ensuring accurate computations to
current precision.

It is advisable to increase the precision before computing several
values at large ideals.

The library syntax is \fun{GEN}{gcharnewprec}{GEN gc, long prec}.

\subsec{idealadd$(\var{nf},x,y)$}\kbdsidx{idealadd}\label{se:idealadd}
Sum of the two ideals $x$ and $y$ in the number field $\var{nf}$. The
result is given in HNF.
\bprog
 ? K = nfinit(x^2 + 1);
 ? a = idealadd(K, 2, x + 1)  \\ ideal generated by 2 and 1+I
 %2 =
 [2 1]

 [0 1]
 ? pr = idealprimedec(K, 5)[1];  \\ a prime ideal above 5
 ? idealadd(K, a, pr)     \\ coprime, as expected
 %4 =
 [1 0]

 [0 1]
@eprog\noindent
This function cannot be used to add arbitrary $\Z$-modules, since it assumes
that its arguments are ideals:
\bprog
  ? b = Mat([1,0]~);
  ? idealadd(K, b, b)     \\ only square t_MATs represent ideals
  *** idealadd: nonsquare t_MAT in idealtyp.
  ? c = [2, 0; 2, 0]; idealadd(K, c, c)   \\ nonsense
  %6 =
  [2 0]

  [0 2]
  ? d = [1, 0; 0, 2]; idealadd(K, d, d)   \\ nonsense
  %7 =
  [1 0]

  [0 1]

@eprog\noindent In the last two examples, we get wrong results since the
matrices $c$ and $d$ do not correspond to an ideal: the $\Z$-span of their
columns (as usual interpreted as coordinates with respect to the integer basis
\kbd{K.zk}) is not an $O_K$-module. To add arbitrary $\Z$-modules generated
by the columns of matrices $A$ and $B$, use \kbd{mathnf(concat(A,B))}.

The library syntax is \fun{GEN}{idealadd}{GEN nf, GEN x, GEN y}.

\subsec{idealaddtoone$(\var{nf},x,\{y\})$}\kbdsidx{idealaddtoone}\label{se:idealaddtoone}
$x$ and $y$ being two co-prime
integral ideals (given in any form), this gives a two-component row vector
$[a,b]$ such that $a\in x$, $b\in y$ and $a+b=1$.

The alternative syntax $\kbd{idealaddtoone}(\var{nf},v)$, is supported, where
$v$ is a $k$-component vector of ideals (given in any form) which sum to
$\Z_K$. This outputs a $k$-component vector $e$ such that $e[i]\in x[i]$ for
$1\le i\le k$ and $\sum_{1\le i\le k}e[i]=1$.

The library syntax is \fun{GEN}{idealaddtoone0}{GEN nf, GEN x, GEN y = NULL}.

\subsec{idealappr$(\var{nf},x,\{\fl\})$}\kbdsidx{idealappr}\label{se:idealappr}
If $x$ is a fractional ideal
(given in any form), gives an element $\alpha$ in $\var{nf}$ such that for
all prime ideals $\goth{p}$ such that the valuation of $x$ at $\goth{p}$ is
nonzero, we have $v_{\goth{p}}(\alpha)=v_{\goth{p}}(x)$, and
$v_{\goth{p}}(\alpha)\ge0$ for all other $\goth{p}$.

The argument $x$ may also be given as a prime ideal factorization, as
output by \kbd{idealfactor}, but allowing zero exponents.
This yields an element $\alpha$ such that for all prime ideals $\goth{p}$
occurring in $x$, $v_{\goth{p}}(\alpha) = v_{\goth{p}}(x)$;
for all other prime ideals, $v_{\goth{p}}(\alpha)\ge0$.

flag is deprecated (ignored), kept for backward compatibility.

The library syntax is \fun{GEN}{idealappr0}{GEN nf, GEN x, long flag}.
Use directly \fun{GEN}{idealappr}{GEN nf, GEN x} since \fl is ignored.

\subsec{idealchinese$(\var{nf},x,\{y\})$}\kbdsidx{idealchinese}\label{se:idealchinese}
$x$ being a prime ideal factorization (i.e.~a 2-columns matrix whose first
column contains prime ideals and the second column contains integral
exponents), $y$ a vector of elements in $\var{nf}$ indexed by the ideals in
$x$, computes an element $b$ such that

$v_{\goth{p}}(b - y_{\goth{p}}) \geq v_{\goth{p}}(x)$ for all prime ideals
in $x$ and $v_{\goth{p}}(b)\geq 0$ for all other $\goth{p}$.

\bprog
? K = nfinit(t^2-2);
? x = idealfactor(K, 2^2*3)
%2 =
[[2, [0, 1]~, 2, 1, [0, 2; 1, 0]] 4]

[           [3, [3, 0]~, 1, 2, 1] 1]
? y = [t,1];
? idealchinese(K, x, y)
%4 = [4, -3]~
@eprog

The argument $x$ may also be of the form $[x, s]$ where the first component
is as above and $s$ is a vector of signs, with $r_1$ components
$s_i$ in $\{-1,0,1\}$:
if $\sigma_i$ denotes the $i$-th real embedding of the number field,
the element $b$ returned satisfies further
$\kbd{sign}(\sigma_i(b)) = s_i$ for all $i$ such that $s_i = \pm1$.
In other words, the sign is fixed to $s_i$ at the $i$-th embedding whenever
$s_i$ is nonzero.
\bprog
? idealchinese(K, [x, [1,1]], y)
%5 = [16, -3]~
? idealchinese(K, [x, [-1,-1]], y)
%6 = [-20, -3]~
? idealchinese(K, [x, [1,-1]], y)
%7 = [4, -3]~
@eprog

If $y$ is omitted, return a data structure which can be used in
place of $x$ in later calls and allows to solve many chinese remainder
problems for a given $x$ more efficiently. In this case, the right hand side
$y$ is not allowed to have denominators, unless they are coprime to $x$.
\bprog
? C = idealchinese(K, [x, [1,1]]);
? idealchinese(K, C, y) \\ as above
%9 = [16, -3]~
? for(i=1,10^4, idealchinese(K,C,y))  \\ ... but faster !
time = 80 ms.
? for(i=1,10^4, idealchinese(K,[x,[1,1]],y))
time = 224 ms.
@eprog
Finally, this structure is itself allowed in place of $x$, the
new $s$ overriding the one already present in the structure. This allows to
initialize for different sign conditions more efficiently when the underlying
ideal factorization remains the same.
\bprog
? D = idealchinese(K, [C, [1,-1]]);   \\ replaces [1,1]
? idealchinese(K, D, y)
%13 = [4, -3]~
? for(i=1,10^4,idealchinese(K,[C,[1,-1]]))
time = 40 ms.   \\ faster than starting from scratch
? for(i=1,10^4,idealchinese(K,[x,[1,-1]]))
time = 128 ms.
@eprog

The library syntax is \fun{GEN}{idealchinese}{GEN nf, GEN x, GEN y = NULL}.
Also available is
\fun{GEN}{idealchineseinit}{GEN nf, GEN x} when $y = \kbd{NULL}$.

\subsec{idealcoprime$(\var{nf},x,y)$}\kbdsidx{idealcoprime}\label{se:idealcoprime}
Given two integral ideals $x$ and $y$
in the number field $\var{nf}$, returns a $\beta$ in the field,
such that $\beta\cdot x$ is an integral ideal coprime to $y$. In fact,
$\beta$ is also guaranteed to be integral outside primes dividing $y$.

The library syntax is \fun{GEN}{idealcoprime}{GEN nf, GEN x, GEN y}.

\subsec{idealdiv$(\var{nf},x,y,\{\fl=0\})$}\kbdsidx{idealdiv}\label{se:idealdiv}
Quotient $x\cdot y^{-1}$ of the two ideals $x$ and $y$ in the number
field $\var{nf}$. The result is given in HNF.

If $\fl$ is nonzero, the quotient $x \cdot y^{-1}$ is assumed to be an
integral ideal. This can be much faster when the norm of the quotient is
small even though the norms of $x$ and $y$ are large. More precisely,
the algorithm cheaply removes all maximal ideals above rational
primes such that $v_p(Nx) = v_p(Ny)$.

The library syntax is \fun{GEN}{idealdiv0}{GEN nf, GEN x, GEN y, long flag}.
Also available are \fun{GEN}{idealdiv}{GEN nf, GEN x, GEN y}
($\fl=0$) and \fun{GEN}{idealdivexact}{GEN nf, GEN x, GEN y} ($\fl=1$).

\subsec{idealdown$(\var{nf},x)$}\kbdsidx{idealdown}\label{se:idealdown}
Let $\var{nf}$ be a number field as output by \kbd{nfinit}, and $x$ a
fractional ideal. This function returns the nonnegative rational generator
of $x \cap \Q$. If $x$ is an extended ideal, the extended part is ignored.
\bprog
? nf = nfinit(y^2+1);
? idealdown(nf, -1/2)
%2 = 1/2
? idealdown(nf, (y+1)/3)
%3 = 2/3
? idealdown(nf, [2, 11]~)
%4 = 125
? x = idealprimedec(nf, 2)[1]; idealdown(nf, x)
%5 = 2
? idealdown(nf, [130, 94; 0, 2])
%6 = 130
@eprog

The library syntax is \fun{GEN}{idealdown}{GEN nf, GEN x}.

\subsec{idealfactor$(\var{nf},x,\{\var{lim}\})$}\kbdsidx{idealfactor}\label{se:idealfactor}
Factors into prime ideal powers the ideal $x$ in the number field
$\var{nf}$. The output format is similar to the \kbd{factor} function, and
the prime ideals are represented in the form output by the
\kbd{idealprimedec} function. If \var{lim} is set, return partial
factorization, including only prime ideals above rational primes
$< \var{lim}$.
\bprog
? nf = nfinit(x^3-2);
? idealfactor(nf, x) \\ a prime ideal above 2
%2 =
[[2, [0, 1, 0]~, 3, 1, ...] 1]

? A = idealhnf(nf, 6*x, 4+2*x+x^2)
%3 =
[6 0 4]

[0 6 2]

[0 0 1]

? idealfactor(nf, A)
%4 =
 [[2, [0, 1, 0]~, 3, 1, ...] 2]

 [[3, [1, 1, 0]~, 3, 1, ...] 2]

? idealfactor(nf, A, 3) \\ restrict to primes above p < 3
%5 =
[[2, [0, 1, 0]~, 3, 1, ...] 2]
@eprog

The library syntax is \fun{GEN}{gpidealfactor}{GEN nf, GEN x, GEN lim = NULL}.
This function should only be used by the \kbd{gp} interface. Use
directly \fun{GEN}{idealfactor}{GEN nf, GEN x} or
\fun{GEN}{idealfactor_limit}{GEN nf, GEN x, ulong lim}.

\subsec{idealfactorback$(\var{nf},f,\{e\},\{\fl = 0\})$}\kbdsidx{idealfactorback}\label{se:idealfactorback}
Gives back the ideal corresponding to a factorization. The integer $1$
corresponds to the empty factorization.
If $e$ is present, $e$ and $f$ must be vectors of the same length ($e$ being
integral), and the corresponding factorization is the product of the
$f[i]^{e[i]}$.

If not, and $f$ is vector, it is understood as in the preceding case with $e$
a vector of 1s: we return the product of the $f[i]$. Finally, $f$ can be a
regular factorization, as produced by \kbd{idealfactor}.
\bprog
? nf = nfinit(y^2+1); idealfactor(nf, 4 + 2*y)
%1 =
[[2, [1, 1]~, 2, 1, [1, 1]~] 2]

[[5, [2, 1]~, 1, 1, [-2, 1]~] 1]

? idealfactorback(nf, %)
%2 =
[10 4]

[0  2]

? f = %1[,1]; e = %1[,2]; idealfactorback(nf, f, e)
%3 =
[10 4]

[0  2]

? % == idealhnf(nf, 4 + 2*y)
%4 = 1
@eprog
If \kbd{flag} is nonzero, perform ideal reductions (\tet{idealred}) along the
way. This is most useful if the ideals involved are all \emph{extended}
ideals (for instance with trivial principal part), so that the principal parts
extracted by \kbd{idealred} are not lost. Here is an example:
\bprog
? f = vector(#f, i, [f[i], [;]]);  \\ transform to extended ideals
? idealfactorback(nf, f, e, 1)
%6 = [[1, 0; 0, 1], [2, 1; [2, 1]~, 1]]
? nffactorback(nf, %[2])
%7 = [4, 2]~
@eprog
The extended ideal returned in \kbd{\%6} is the trivial ideal $1$, extended
with a principal generator given in factored form. We use \tet{nffactorback}
to recover it in standard form.

The library syntax is \fun{GEN}{idealfactorback}{GEN nf, GEN f, GEN e = NULL, long flag}.

\subsec{idealfrobenius$(\var{nf},\var{gal},\var{pr})$}\kbdsidx{idealfrobenius}\label{se:idealfrobenius}
Let $K$ be the number field defined by $nf$ and assume $K/\Q$ be a
Galois extension with Galois group given \kbd{gal=galoisinit(nf)},
and that \var{pr} is an unramified prime ideal $\goth{p}$ in \kbd{prid}
format.
This function returns a permutation of \kbd{gal.group} which defines
the Frobenius element $\Frob_{\goth{p}}$ attached to $\goth{p}$.
If $p$ is the unique prime number in $\goth{p}$, then
$\Frob(x)\equiv x^p\mod\goth{p}$ for all $x\in\Z_K$.
\bprog
? nf = nfinit(polcyclo(31));
? gal = galoisinit(nf);
? pr = idealprimedec(nf,101)[1];
? g = idealfrobenius(nf,gal,pr);
? galoispermtopol(gal,g)
%5 = x^8
@eprog\noindent This is correct since $101\equiv 8\mod{31}$.

The library syntax is \fun{GEN}{idealfrobenius}{GEN nf, GEN gal, GEN pr}.

\subsec{idealhnf$(\var{nf},u,\{v\})$}\kbdsidx{idealhnf}\label{se:idealhnf}
Gives the \idx{Hermite normal form} of the ideal $u\Z_K+v\Z_K$, where $u$
and $v$ are elements of the number field $K$ defined by \var{nf}.
\bprog
? nf = nfinit(y^3 - 2);
? idealhnf(nf, 2, y+1)
%2 =
[1 0 0]

[0 1 0]

[0 0 1]
? idealhnf(nf, y/2, [0,0,1/3]~)
%3 =
[1/3 0 0]

[0 1/6 0]

[0 0 1/6]
@eprog

If $b$ is omitted, returns the HNF of the ideal defined by $u$: $u$ may be an
algebraic number (defining a principal ideal), a maximal ideal (as given by
\kbd{idealprimedec} or \kbd{idealfactor}), or a matrix whose columns give
generators for the ideal. This last format is a little complicated, but
useful to reduce general modules to the canonical form once in a while:

\item if strictly less than $N = [K:\Q]$ generators are given, $u$
is the $\Z_K$-module they generate,

\item if $N$ or more are given, it is \emph{assumed} that they form a
$\Z$-basis of the ideal, in particular that the matrix has maximal rank $N$.
This acts as \kbd{mathnf} since the $\Z_K$-module structure is (taken for
granted hence) not taken into account in this case.
\bprog
? idealhnf(nf, idealprimedec(nf,2)[1])
%4 =
[2 0 0]

[0 1 0]

[0 0 1]
? idealhnf(nf, [1,2;2,3;3,4])
%5 =
[1 0 0]

[0 1 0]

[0 0 1]
@eprog\noindent Finally, when $K$ is quadratic with discriminant $D_K$, we
allow $u =$ \kbd{Qfb(a,b,c)}, provided $b^2 - 4ac = D_K$. As usual,
this represents the ideal $a \Z + (1/2)(-b + \sqrt{D_K}) \Z$.
\bprog
? K = nfinit(x^2 - 60); K.disc
%1 = 60
? idealhnf(K, qfbprimeform(60,2))
%2 =
[2 1]

[0 1]
? idealhnf(K, Qfb(1,2,3))
  ***   at top-level: idealhnf(K,Qfb(1,2,3
  ***                 ^--------------------
  *** idealhnf: Qfb(1, 2, 3) has discriminant != 60 in idealhnf.
@eprog

The library syntax is \fun{GEN}{idealhnf0}{GEN nf, GEN u, GEN v = NULL}.
Also available is \fun{GEN}{idealhnf}{GEN nf, GEN a}, where \kbd{nf}
is a true \var{nf} structure.

\subsec{idealintersect$(\var{nf},A,B)$}\kbdsidx{idealintersect}\label{se:idealintersect}
Intersection of the two ideals
$A$ and $B$ in the number field $\var{nf}$. The result is given in HNF.
\bprog
? nf = nfinit(x^2+1);
? idealintersect(nf, 2, x+1)
%2 =
[2 0]

[0 2]
@eprog

This function does not apply to general $\Z$-modules, e.g.~orders, since its
arguments are replaced by the ideals they generate. The following script
intersects $\Z$-modules $A$ and $B$ given by matrices of compatible
dimensions with integer coefficients:
\bprog
ZM_intersect(A,B) =
{ my(Ker = matkerint(concat(A,B)));
  mathnf( A * Ker[1..#A,] )
}
@eprog

The library syntax is \fun{GEN}{idealintersect}{GEN nf, GEN A, GEN B}.

\subsec{idealinv$(\var{nf},x)$}\kbdsidx{idealinv}\label{se:idealinv}
Inverse of the ideal $x$ in the
number field $\var{nf}$, given in HNF. If $x$ is an extended
ideal\sidx{ideal (extended)}, its principal part is suitably
updated: i.e. inverting $[I,t]$, yields $[I^{-1}, 1/t]$.

The library syntax is \fun{GEN}{idealinv}{GEN nf, GEN x}.

\subsec{idealismaximal$(\var{nf},x)$}\kbdsidx{idealismaximal}\label{se:idealismaximal}
Given \var{nf} a number field as output by \kbd{nfinit} and an ideal
$x$, return $0$ if $x$ is not a maximal ideal. Otherwise return a \kbd{prid}
structure \var{nf} attached to the ideal. This function uses
\kbd{ispseudoprime} and may return a wrong result in case the underlying
rational pseudoprime is not an actual prime number: apply \kbd{isprime(pr.p)}
to guarantee correctness. If $x$ is an extended ideal, the extended part is
ignored.
\bprog
? K = nfinit(y^2 + 1);
? idealismaximal(K, 3) \\ 3 is inert
%2 = [3, [3, 0]~, 1, 2, 1]
? idealismaximal(K, 5) \\ 5 is not
%3 = 0
? pr = idealprimedec(K,5)[1] \\ already a prid
%4 = [5, [-2, 1]~, 1, 1, [2, -1; 1, 2]]
? idealismaximal(K, pr) \\ trivial check
%5 = [5, [-2, 1]~, 1, 1, [2, -1; 1, 2]]
? x = idealhnf(K, pr)
%6 =
[5 3]

[0 1]
? idealismaximal(K, x) \\ converts from matrix form to prid
%7 = [5, [-2, 1]~, 1, 1, [2, -1; 1, 2]]
@eprog\noindent This function is noticeably faster than \kbd{idealfactor}
since it never involves an actually factorization, in particular when $x
\cap \Z$ is not a prime number.

The library syntax is \fun{GEN}{idealismaximal}{GEN nf, GEN x}.

\subsec{idealispower$(\var{nf},A,n,\{\&B\})$}\kbdsidx{idealispower}\label{se:idealispower}
Let \var{nf} be a number field and $n > 0$ be a positive integer.
Return $1$ if the fractional ideal $A = B^n$ is an $n$-th power and $0$
otherwise. If the argument $B$ is present, set it to the $n$-th root of $A$,
in HNF.
\bprog
? K = nfinit(x^3 - 2);
? A = [46875, 30966, 9573; 0, 3, 0; 0, 0, 3];
? idealispower(K, A, 3, &B)
%3 = 1
? B
%4 =
[75 22 41]

[ 0  1  0]

[ 0  0  1]

? A = [9375, 2841, 198; 0, 3, 0; 0, 0, 3];
? idealispower(K, A, 3)
%5 = 0
@eprog\noindent

The library syntax is \fun{long}{idealispower}{GEN nf, GEN A, long n, GEN *B = NULL}.

\subsec{ideallist$(\var{nf},\var{bound},\{\fl=4\})$}\kbdsidx{ideallist}\label{se:ideallist}
Computes the list of all ideals of norm less or equal to \var{bound} in
the number field
\var{nf}. The result is a row vector with exactly \var{bound} components.
Each component is itself a row vector containing the information about
ideals of a given norm, in no specific order. The information is inferred
from local data and Chinese remainders and less expensive than computing
than a direct global computation.

The binary digits of $\fl$ mean:

\item 1: if the ideals are given by a \var{bid}, include generators;
otherwise don't.

\item 2: if this bit is set, \var{nf} must be a \var{bnf} with units. Each
component is of the form $[\var{bid},U]$, where \var{bid} is attached to
an ideal $f$ and $U$ is a vector of discrete logarithms of the units in
$(\Z_K/f)^*$. More precisely, $U$ gives the \kbd{ideallog}s with respect
to \var{bid} of $(\zeta,u_1,\dots,u_r)$
where $\zeta$ is the torsion unit generator \kbd{bnf.tu[2]} and $(u_i)$
are the fundamental units in \kbd{bnf.fu}.
This structure is technical, meant to be used in conjunction with
\tet{bnrclassnolist} or \tet{bnrdisclist}.

\item 4: give only the ideal (in HNF), else a \var{bid}.

\item 8: omit ideals which cannot be conductors, i.e. divisible exactly my
a prime ideal of norm $2$.

\bprog
? nf = nfinit(x^2+1);
? L = ideallist(nf, 100);
? L[1]
%3 = [[1, 0; 0, 1]]  \\@com A single ideal of norm 1
? #L[65]
%4 = 4               \\@com There are 4 ideals of norm 65 in $\Z[i]$
@eprog
If one wants more information:
\bprog
? L = ideallist(nf, 100, 0);
? l = L[25]; vector(#l, i, l[i].clgp)
%6 = [[20, [20]], [16, [4, 4]], [20, [20]]]
? l[1].mod
%7 = [[25, 18; 0, 1], []]
? l[2].mod
%8 = [[5, 0; 0, 5], []]
? l[3].mod
%9 = [[25, 7; 0, 1], []]
@eprog\noindent where we ask for the structures of the $(\Z[i]/f)^*$ for all
three ideals of norm $25$. In fact, for all moduli with finite part of norm
$25$ and trivial Archimedean part, as the last 3 commands show. See
\tet{ideallistarch} to treat general moduli.

Finally, one can input a negative \kbd{bound}. The function
then returns the ideals of norm $|\kbd{bound}|$, given by their
factorization matrix. The only valid value of \fl\ is then the default.
If needed, one can obtain their HNF using
\kbd{idealfactorback}, and the corresponding \var{bid} structures using
\kbd{idealstar} (which accepts ideals in factored form).

The library syntax is \fun{GEN}{gideallist}{GEN nf, GEN bound, long flag}.
Also available is
\fun{GEN}{ideallist0}{GEN nf,long bound, long flag} for a non-negative
bound.

\subsec{ideallistarch$(\var{nf},\var{list},\var{arch})$}\kbdsidx{ideallistarch}\label{se:ideallistarch}
\var{list} is a vector of vectors of bid's, as output by \tet{ideallist} with
flag $0$ to $3$. Return a vector of vectors with the same number of
components as the original \var{list}. The leaves give information about
moduli whose finite part is as in original list, in the same order, and
Archimedean part is now \var{arch} (it was originally trivial). The
information contained is of the same kind as was present in the input; see
\tet{ideallist}, in particular the meaning of \fl.

\bprog
? bnf = bnfinit(x^2-2);
? bnf.sign
%2 = [2, 0]                         \\@com two places at infinity
? L = ideallist(bnf, 100, 0);
? l = L[98]; vector(#l, i, l[i].clgp)
%4 = [[42, [42]], [36, [6, 6]], [42, [42]]]
? La = ideallistarch(bnf, L, [1,1]); \\@com add them to the modulus
? l = La[98]; vector(#l, i, l[i].clgp)
%6 = [[168, [42, 2, 2]], [144, [6, 6, 2, 2]], [168, [42, 2, 2]]]
@eprog
Of course, the results above are obvious: adding $t$ places at infinity will
add $t$ copies of $\Z/2\Z$ to $(\Z_K/f)^*$. The following application
is more typical:
\bprog
? L = ideallist(bnf, 100, 2);        \\@com units are required now
? La = ideallistarch(bnf, L, [1,1]);
? H = bnrclassnolist(bnf, La);
? H[98];
%4 = [2, 12, 2]
@eprog

The library syntax is \fun{GEN}{ideallistarch}{GEN nf, GEN list, GEN arch}.

\subsec{ideallog$(\{\var{nf}\},x,\var{bid})$}\kbdsidx{ideallog}\label{se:ideallog}
$\var{nf}$ is a number field,
\var{bid} is as output by \kbd{idealstar(nf, D, \dots)} and $x$ an
element of \var{nf} which must have valuation
equal to 0 at all prime ideals in the support of $\kbd{D}$ and need not be
integral. This function
computes the discrete logarithm of $x$ on the generators given in
\kbd{\var{bid}.gen}. In other words, if $g_i$ are these generators, of orders
$d_i$ respectively, the result is a column vector of integers $(x_i)$ such
that $0\le x_i<d_i$ and
$$x \equiv \prod_i g_i^{x_i} \pmod{\ ^*D}\enspace.$$
Note that when the support of \kbd{D} contains places at infinity, this
congruence implies also sign conditions on the attached real embeddings.
See \tet{znlog} for the limitations of the underlying discrete log algorithms.

When \var{nf} is omitted, take it to be the rational number field. In that
case, $x$ must be a \typ{INT} and \var{bid} must have been initialized by
\kbd{znstar(N,1)}.

The library syntax is \fun{GEN}{ideallog}{GEN nf = NULL, GEN x, GEN bid}.
Also available are
\fun{GEN}{Zideallog}{GEN bid, GEN x} when \kbd{nf} is \kbd{NULL},
and \fun{GEN}{ideallogmod}{GEN nf, GEN x, GEN bid, GEN mod}
that returns the discrete logarithm of~$x$ modulo the~\typ{INT}
\kbd{mod}; the value~$\kbd{mod = NULL}$ is treated as~$0$ (full discrete
logarithm), but~$\kbd{nf=NULL}$ is not implemented with nonzero~\kbd{mod}.

\subsec{idealmin$(\var{nf},\var{ix},\{\var{vdir}\})$}\kbdsidx{idealmin}\label{se:idealmin}
\emph{This function is useless and kept for backward compatibility only,
use \kbd{idealred}}. Computes a pseudo-minimum of the ideal $x$ in the
direction \var{vdir} in the number field \var{nf}.

The library syntax is \fun{GEN}{idealmin}{GEN nf, GEN ix, GEN vdir = NULL}.

\subsec{idealmul$(\var{nf},x,y,\{\fl=0\})$}\kbdsidx{idealmul}\label{se:idealmul}
Ideal multiplication of the ideals $x$ and $y$ in the number field
\var{nf}; the result is the ideal product in HNF. If either $x$ or $y$
are extended ideals\sidx{ideal (extended)}, their principal part is suitably
updated: i.e. multiplying $[I,t]$, $[J,u]$ yields $[IJ, tu]$; multiplying
$I$ and $[J, u]$ yields $[IJ, u]$.
\bprog
? nf = nfinit(x^2 + 1);
? idealmul(nf, 2, x+1)
%2 =
[4 2]

[0 2]
? idealmul(nf, [2, x], x+1)        \\ extended ideal * ideal
%3 = [[4, 2; 0, 2], x]
? idealmul(nf, [2, x], [x+1, x])   \\ two extended ideals
%4 = [[4, 2; 0, 2], [-1, 0]~]
@eprog\noindent
If $\fl$ is nonzero, reduce the result using \kbd{idealred}.

The library syntax is \fun{GEN}{idealmul0}{GEN nf, GEN x, GEN y, long flag}.

\noindent See also
\fun{GEN}{idealmul}{GEN nf, GEN x, GEN y} ($\fl=0$) and
\fun{GEN}{idealmulred}{GEN nf, GEN x, GEN y} ($\fl\neq0$).

\subsec{idealnorm$(\var{nf},x)$}\kbdsidx{idealnorm}\label{se:idealnorm}
Computes the norm of the ideal~$x$ in the number field~$\var{nf}$.

The library syntax is \fun{GEN}{idealnorm}{GEN nf, GEN x}.

\subsec{idealnumden$(\var{nf},x)$}\kbdsidx{idealnumden}\label{se:idealnumden}
Returns $[A,B]$, where $A,B$ are coprime integer ideals
such that $x = A/B$, in the number field $\var{nf}$.
\bprog
? nf = nfinit(x^2+1);
? idealnumden(nf, (x+1)/2)
%2 = [[1, 0; 0, 1], [2, 1; 0, 1]]
@eprog

The library syntax is \fun{GEN}{idealnumden}{GEN nf, GEN x}.

\subsec{idealpow$(\var{nf},x,k,\{\fl=0\})$}\kbdsidx{idealpow}\label{se:idealpow}
Computes the $k$-th power of
the ideal $x$ in the number field $\var{nf}$; $k\in\Z$.
If $x$ is an extended
ideal\sidx{ideal (extended)}, its principal part is suitably
updated: i.e. raising $[I,t]$ to the $k$-th power, yields $[I^k, t^k]$.

If $\fl$ is nonzero, reduce the result using \kbd{idealred}, \emph{throughout
the (binary) powering process}; in particular, this is \emph{not} the same
as $\kbd{idealpow}(\var{nf},x,k)$ followed by reduction.

The library syntax is \fun{GEN}{idealpow0}{GEN nf, GEN x, GEN k, long flag}.

\noindent See also
\fun{GEN}{idealpow}{GEN nf, GEN x, GEN k} and
\fun{GEN}{idealpows}{GEN nf, GEN x, long k} ($\fl = 0$).
Corresponding to $\fl=1$ is \fun{GEN}{idealpowred}{GEN nf, GEN vp, GEN k}.

\subsec{idealprimedec$(\var{nf},p,\{f=0\})$}\kbdsidx{idealprimedec}\label{se:idealprimedec}
Computes the prime ideal
decomposition of the (positive) prime number $p$ in the number field $K$
represented by \var{nf}. If a nonprime $p$ is given the result is undefined.
If $f$ is present and nonzero, restrict the result to primes of residue
degree $\leq f$.

The result is a vector of \tev{prid} structures, each representing one of the
prime ideals above $p$ in the number field $\var{nf}$. The representation
$\kbd{pr}=[p,a,e,f,\var{mb}]$ of a prime ideal means the following: $a$
is an algebraic integer in the maximal order $\Z_K$ and the prime ideal is
equal to $\goth{p} = p\Z_K + a\Z_K$;
$e$ is the ramification index; $f$ is the residual index;
finally, \var{mb} is the multiplication table attached to an algebraic
integer $b$ such that $\goth{p}^{-1}=\Z_K+ b/ p\Z_K$, which is used
internally to compute valuations. In other words if $p$ is inert,
then \var{mb} is the integer $1$, and otherwise it is a square \typ{MAT}
whose $j$-th column is $b \cdot \kbd{nf.zk[j]}$.

The algebraic number $a$ is guaranteed to have a
valuation equal to 1 at the prime ideal (this is automatic if $e>1$).

The components of \kbd{pr} should be accessed by member functions: \kbd{pr.p},
\kbd{pr.e}, \kbd{pr.f}, and \kbd{pr.gen} (returns the vector $[p,a]$):
\bprog
? K = nfinit(x^3-2);
? P = idealprimedec(K, 5);
? #P       \\ 2 primes above 5 in Q(2^(1/3))
%3 = 2
? [p1,p2] = P;
? [p1.e, p1.f]    \\ the first is unramified of degree 1
%5 = [1, 1]
? [p2.e, p2.f]    \\ the second is unramified of degree 2
%6 = [1, 2]
? p1.gen
%7 = [5, [2, 1, 0]~]
? nfbasistoalg(K, %[2])  \\ a uniformizer for p1
%8 = Mod(x + 2, x^3 - 2)
? #idealprimedec(K, 5, 1) \\ restrict to f = 1
%9 = 1            \\ now only p1
@eprog

The library syntax is \fun{GEN}{idealprimedec_limit_f}{GEN nf, GEN p, long f}.

\subsec{idealprincipalunits$(\var{nf},\var{pr},k)$}\kbdsidx{idealprincipalunits}\label{se:idealprincipalunits}
Given a prime ideal in \tet{idealprimedec} format,
returns the multiplicative group $(1 + \var{pr}) / (1 + \var{pr}^k)$ as an
abelian group. This function is much faster than \tet{idealstar} when the
norm of \var{pr} is large, since it avoids (useless) work in the
multiplicative group of the residue field.
\bprog
? K = nfinit(y^2+1);
? P = idealprimedec(K,2)[1];
? G = idealprincipalunits(K, P, 20);
? G.cyc
%4 = [512, 256, 4]   \\ Z/512 x Z/256 x Z/4
? G.gen
%5 = [[-1, -2]~, 1021, [0, -1]~] \\ minimal generators of given order
@eprog

The library syntax is \fun{GEN}{idealprincipalunits}{GEN nf, GEN pr, long k}.

\subsec{idealramgroups$(\var{nf},\var{gal},\var{pr})$}\kbdsidx{idealramgroups}\label{se:idealramgroups}
Let $K$ be the number field defined by \var{nf} and assume that $K/\Q$ is
Galois with Galois group $G$ given by \kbd{gal=galoisinit(nf)}.
Let \var{pr} be the prime ideal $\goth{P}$ in prid format.
This function returns a vector $g$ of subgroups of \kbd{gal}
as follows:

\item \kbd{g[1]} is the decomposition group of $\goth{P}$,

\item \kbd{g[2]} is $G_0(\goth{P})$, the inertia group of $\goth{P}$,

and for $i\geq 2$,

\item \kbd{g[i]} is $G_{i-2}(\goth{P})$, the $i-2$-th
\idx{ramification group} of $\goth{P}$.

\noindent The length of $g$ is the number of nontrivial groups in the
sequence, thus is $0$ if $e=1$ and $f=1$, and $1$ if $f>1$ and $e=1$.
The following function computes the cardinality of a subgroup of $G$,
as given by the components of $g$:
\bprog
card(H) =my(o=H[2]); prod(i=1,#o,o[i]);
@eprog
\bprog
? nf=nfinit(x^6+3); gal=galoisinit(nf); pr=idealprimedec(nf,3)[1];
? g = idealramgroups(nf, gal, pr);
? apply(card,g)
%3 = [6, 6, 3, 3, 3] \\ cardinalities of the G_i
@eprog

\bprog
? nf=nfinit(x^6+108); gal=galoisinit(nf); pr=idealprimedec(nf,2)[1];
? iso=idealramgroups(nf,gal,pr)[2]
%5 = [[Vecsmall([2, 3, 1, 5, 6, 4])], Vecsmall([3])]
? nfdisc(galoisfixedfield(gal,iso,1))
%6 = -3
@eprog\noindent The field fixed by the inertia group of $2$ is not ramified at
$2$.

The library syntax is \fun{GEN}{idealramgroups}{GEN nf, GEN gal, GEN pr}.

\subsec{idealred$(\var{nf},I,\{v=0\})$}\kbdsidx{idealred}\label{se:idealred}
\idx{LLL} reduction of
the ideal $I$ in the number field $K$ attached to \var{nf}, along the
direction $v$. The $v$ parameter is best left omitted, but if it is present,
it must be an $\kbd{nf.r1} + \kbd{nf.r2}$-component vector of
\emph{nonnegative} integers. (What counts is the relative magnitude of the
entries: if all entries are equal, the effect is the same as if the vector
had been omitted.)

This function finds an $a\in K^*$ such that $J = (a)I$ is
``small'' and integral (see the end for technical details).
The result is the Hermite normal form of
the ``reduced'' ideal $J$.
\bprog
? K = nfinit(y^2+1);
? P = idealprimedec(K,5)[1];
? idealred(K, P)
%3 =
[1 0]

[0 1]
@eprog\noindent More often than not, a \idx{principal ideal} yields the unit
ideal as above. This is a quick and dirty way to check if ideals are principal,
but it is not a necessary condition: a nontrivial result does not prove that
the ideal is nonprincipal. For guaranteed results, see \kbd{bnfisprincipal},
which requires the computation of a full \kbd{bnf} structure.

If the input is an extended ideal $[I,s]$, the output is $[J, sa]$; in
this way, one keeps track of the principal ideal part:
\bprog
? idealred(K, [P, 1])
%5 = [[1, 0; 0, 1], [2, -1]~]
@eprog\noindent
meaning that $P$ is generated by $[2, -1]~$. The number field element in the
extended part is an algebraic number in any form \emph{or} a factorization
matrix (in terms of number field elements, not ideals!). In the latter case,
elements stay in factored form, which is a convenient way to avoid
coefficient explosion; see also \tet{idealpow}.

\misctitle{Technical note} The routine computes an LLL-reduced
basis for the lattice $I^{-1}$ equipped with the quadratic
form
$$|| x ||_v^2 = \sum_{i=1}^{r_1+r_2} 2^{v_i}\varepsilon_i|\sigma_i(x)|^2,$$
where as usual the $\sigma_i$ are the (real and) complex embeddings and
$\varepsilon_i = 1$, resp.~$2$, for a real, resp.~complex place. The element
$a$ is simply the first vector in the LLL basis. The only reason you may want
to try to change some directions and set some $v_i\neq 0$ is to randomize
the elements found for a fixed ideal, which is heuristically useful in index
calculus algorithms like \tet{bnfinit} and \tet{bnfisprincipal}.

\misctitle{Even more technical note} In fact, the above is a white lie.
We do not use $||\cdot||_v$ exactly but a rescaled rounded variant which
gets us faster and simpler LLLs. There's no harm since we are not using any
theoretical property of $a$ after all, except that it belongs to $I^{-1}$
and that $a I$ is ``expected to be small''.

The library syntax is \fun{GEN}{idealred0}{GEN nf, GEN I, GEN v = NULL}.

\subsec{idealredmodpower$(\var{nf},x,n,\{B=\var{primelimit}\})$}\kbdsidx{idealredmodpower}\label{se:idealredmodpower}
Let \var{nf} be a number field, $x$ an ideal in \var{nf} and $n > 0$ be a
positive integer. Return a number field element $b$ such that $x b^n = v$
is small. If $x$ is integral, then $v$ is also integral.

More precisely, \kbd{idealnumden} reduces the problem to $x$ integral. Then,
factoring out the prime ideals dividing a rational prime $p \leq B$,
we rewrite $x = I J^n$ where the ideals $I$ and $J$ are both integral and
$I$ is $B$-smooth. Then we return a small element $b$ in $J^{-1}$.

The bound $B$ avoids a costly complete factorization of $x$; as soon as the
$n$-core of $x$ is $B$-smooth (i.e., as soon as $I$ is $n$-power free),
then $J$ is as large as possible and so is the expected reduction.
\bprog
? T = x^6+108; nf = nfinit(T); a = Mod(x,T);
? setrand(1); u = (2*a^2+a+3)*random(2^1000*x^6)^6;
? sizebyte(u)
%3 = 4864
? b = idealredmodpower(nf,u,2);
? v2 = nfeltmul(nf,u, nfeltpow(nf,b,2))
%5 = [34, 47, 15, 35, 9, 3]~
? b = idealredmodpower(nf,u,6);
? v6 = nfeltmul(nf,u, nfeltpow(nf,b,6))
%7 = [3, 0, 2, 6, -7, 1]~
@eprog\noindent The last element \kbd{v6}, obtained by reducing
modulo $6$-th powers instead of squares, looks smaller than \kbd{v2}
but its norm is actually a little larger:
\bprog
? idealnorm(nf,v2)
%8 = 81309
? idealnorm(nf,v6)
%9 = 731781
@eprog

The library syntax is \fun{GEN}{idealredmodpower}{GEN nf, GEN x, ulong n, ulong B}.

\subsec{idealstar$(\{\var{nf}\},N,\{\fl=1\},\{\var{cycmod}\})$}\kbdsidx{idealstar}\label{se:idealstar}
Outputs a \kbd{bid} structure,
necessary for computing in the finite abelian group $G = (\Z_K/N)^*$. Here,
\var{nf} is a number field and $N$ is a \var{modulus}: either an ideal in any
form, or a row vector whose first component is an ideal and whose second
component is a row vector of $r_1$ 0 or 1. Ideals can also be given
by a factorization into prime ideals, as produced by \tet{idealfactor}.

If the positive integer \kbd{cycmod} is present,  only compute the group
modulo \kbd{cycmod}-th powers,  which may save a lot of time when some
maximal ideals in the modulus have a huge residue field. Whereas you might
only be interested in quadratic or cubic residuosity; see also \kbd{bnrinit}
for applications in class field theory.

This \var{bid} is used in \tet{ideallog} to compute discrete logarithms. It
also contains useful information which can be conveniently retrieved as
\kbd{\var{bid}.mod} (the modulus),
\kbd{\var{bid}.clgp} ($G$ as a finite abelian group),
\kbd{\var{bid}.no} (the cardinality of $G$),
\kbd{\var{bid}.cyc} (elementary divisors) and
\kbd{\var{bid}.gen} (generators).

If $\fl=1$ (default), the result is a \kbd{bid} structure without
generators: they are well defined but not explicitly computed, which saves
time.

If $\fl=2$, as $\fl=1$, but including generators.

If $\fl=0$, only outputs $(\Z_K/N)^*$ as an abelian group,
i.e as a 3-component vector $[h,d,g]$: $h$ is the order, $d$ is the vector of
SNF\sidx{Smith normal form} cyclic components and $g$ the corresponding
generators.

If \var{nf} is omitted, we take it to be the rational number fields, $N$ must
be an integer and we return the structure of $(\Z/N\Z)^*$. In other words
\kbd{idealstar(, N, flag)} is short for
\bprog
  idealstar(nfinit(x), N, flag)
@eprog\noindent but faster. The alternative syntax \kbd{znstar(N, flag)}
is also available for an analogous effect but, due to an unfortunate
historical oversight, the default value of \kbd{flag} is different in
the two functions (\kbd{znstar} does not initialize by default, you probably
want \kbd{znstar(N,1)}).

The library syntax is \fun{GEN}{idealstarmod}{GEN nf = NULL, GEN N, long flag, GEN cycmod = NULL}.
Instead the above hardcoded numerical flags, one should rather use
\fun{GEN}{Idealstarmod}{GEN nf, GEN ideal, long flag, GEN cycmod} or
\fun{GEN}{Idealstar}{GEN nf, GEN ideal, long flag} (\kbd{cycmod} is
\kbd{NULL}), where \kbd{flag} is
an or-ed combination of \tet{nf_GEN} (include generators) and \tet{nf_INIT}
(return a full \kbd{bid}, not a group), possibly $0$. This offers
one more combination: gen, but no init. The \kbd{nf} argument must be a true
\var{nf} structure.

\subsec{idealtwoelt$(\var{nf},x,\{a\})$}\kbdsidx{idealtwoelt}\label{se:idealtwoelt}
Computes a two-element representation of the ideal $x$ in the number
field $\var{nf}$, combining a random search and an approximation theorem; $x$
is an ideal in any form (possibly an extended ideal, whose principal part is
ignored)

\item When called as \kbd{idealtwoelt(nf,x)}, the result is a row vector
$[a,\alpha]$ with two components such that $x=a\Z_K+\alpha\Z_K$ and $a$ is
chosen to be the positive generator of $x\cap\Z$, unless $x$ was given as a
principal ideal in which case we may choose $a = 0$. The algorithm
uses a fast lazy factorization of $x\cap \Z$ and runs in randomized
polynomial time.

\bprog
? K = nfinit(t^5-23);
? x = idealhnf(K, t^2*(t+1), t^3*(t+1))
%2 =  \\ some random ideal of norm 552*23
[552 23 23 529 23]

[  0 23  0   0  0]

[  0  0  1   0  0]

[  0  0  0   1  0]

[  0  0  0   0  1]

? [a,alpha] = idealtwoelt(K, x)
%3 = [552, [23, 0, 1, 0, 0]~]
? nfbasistoalg(K, alpha)
%4 = Mod(t^2 + 23, t^5 - 23)
@eprog

\item When called as \kbd{idealtwoelt(nf,x,a)} with an explicit nonzero $a$
supplied as third argument, the function assumes that $a \in x$ and returns
$\alpha\in x$ such that $x = a\Z_K + \alpha\Z_K$. Note that we must factor
$a$ in this case, and the algorithm is generally slower than the
default variant and gives larger generators:
\bprog
? alpha2 = idealtwoelt(K, x, 552)
%5 = [-161, -161, -183, -207, 0]~
? idealhnf(K, 552, alpha2) == x
%6 = 1
@eprog\noindent Note that, in both cases, the return value is \emph{not}
recognized as an ideal by GP functions; one must use \kbd{idealhnf} as
above to recover a valid ideal structure from the two-element representation.

The library syntax is \fun{GEN}{idealtwoelt0}{GEN nf, GEN x, GEN a = NULL}.
Also available are
\fun{GEN}{idealtwoelt}{GEN nf, GEN x} and
\fun{GEN}{idealtwoelt2}{GEN nf, GEN x, GEN a}.

\subsec{idealval$(\var{nf},x,\var{pr})$}\kbdsidx{idealval}\label{se:idealval}
Gives the valuation of the ideal $x$ at the prime ideal \var{pr} in the
number field $\var{nf}$, where \var{pr} is in \kbd{idealprimedec} format.
The valuation of the $0$ ideal is \kbd{+oo}.

The library syntax is \fun{GEN}{gpidealval}{GEN nf, GEN x, GEN pr}.
Also available is
\fun{long}{idealval}{GEN nf, GEN x, GEN pr}, which returns
\tet{LONG_MAX} if $x = 0$ and the valuation as a \kbd{long} integer.

\subsec{matalgtobasis$(\var{nf},x)$}\kbdsidx{matalgtobasis}\label{se:matalgtobasis}
This function is deprecated, use \kbd{apply}.

$\var{nf}$ being a number field in \kbd{nfinit} format, and $x$ a
(row or column) vector or matrix, apply \tet{nfalgtobasis} to each entry
of $x$.

The library syntax is \fun{GEN}{matalgtobasis}{GEN nf, GEN x}.

\subsec{matbasistoalg$(\var{nf},x)$}\kbdsidx{matbasistoalg}\label{se:matbasistoalg}
This function is deprecated, use \kbd{apply}.

$\var{nf}$ being a number field in \kbd{nfinit} format, and $x$ a
(row or column) vector or matrix, apply \tet{nfbasistoalg} to each entry
of $x$.

The library syntax is \fun{GEN}{matbasistoalg}{GEN nf, GEN x}.

\subsec{modreverse$(z)$}\kbdsidx{modreverse}\label{se:modreverse}
Let $z = \kbd{Mod(A, T)}$ be a polmod, and $Q$ be its minimal
polynomial, which must satisfy $\text{deg}(Q) = \text{deg}(T)$.
Returns a ``reverse polmod'' \kbd{Mod(B, Q)}, which is a root of $T$.

This is quite useful when one changes the generating element in algebraic
extensions:
\bprog
? u = Mod(x, x^3 - x -1); v = u^5;
? w = modreverse(v)
%2 = Mod(x^2 - 4*x + 1, x^3 - 5*x^2 + 4*x - 1)
@eprog\noindent
which means that $x^3 - 5x^2 + 4x -1$ is another defining polynomial for the
cubic field
$$\Q(u) = \Q[x]/(x^3 - x - 1) = \Q[x]/(x^3 - 5x^2 + 4x - 1) = \Q(v),$$
and that $u \to v^2 - 4v + 1$ gives an explicit isomorphism. From this, it is
easy to convert elements between the $A(u)\in \Q(u)$ and $B(v)\in \Q(v)$
representations:
\bprog
? A = u^2 + 2*u + 3; subst(lift(A), 'x, w)
%3 = Mod(x^2 - 3*x + 3, x^3 - 5*x^2 + 4*x - 1)
? B = v^2 + v + 1;   subst(lift(B), 'x, v)
%4 = Mod(26*x^2 + 31*x + 26, x^3 - x - 1)
@eprog
If the minimal polynomial of $z$ has lower degree than expected, the routine
fails
\bprog
? u = Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)
? modreverse(u)
 *** modreverse: domain error in modreverse: deg(minpoly(z)) < 4
 ***   Break loop: type 'break' to go back to GP prompt
break> Vec( dbg_err() ) \\ ask for more info
["e_DOMAIN", "modreverse", "deg(minpoly(z))", "<", 4,
  Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)]
break> minpoly(u)
x^2 - 8
@eprog

The library syntax is \fun{GEN}{modreverse}{GEN z}.

\subsec{newtonpoly$(x,p)$}\kbdsidx{newtonpoly}\label{se:newtonpoly}
Gives the vector of the slopes of the Newton
polygon of the polynomial $x$ with respect to the prime number $p$. The $n$
components of the vector are in decreasing order, where $n$ is equal to the
degree of $x$. Vertical slopes occur iff the constant coefficient of $x$ is
zero and are denoted by \kbd{+oo}.

The library syntax is \fun{GEN}{newtonpoly}{GEN x, GEN p}.

\subsec{nfalgtobasis$(\var{nf},x)$}\kbdsidx{nfalgtobasis}\label{se:nfalgtobasis}
Given an algebraic number $x$ in the number field $\var{nf}$,
transforms it to a column vector on the integral basis \kbd{\var{nf}.zk}.
\bprog
? nf = nfinit(y^2 + 4);
? nf.zk
%2 = [1, 1/2*y]
? nfalgtobasis(nf, [1,1]~)
%3 = [1, 1]~
? nfalgtobasis(nf, y)
%4 = [0, 2]~
? nfalgtobasis(nf, Mod(y, y^2+4))
%5 = [0, 2]~
@eprog
This is the inverse function of \kbd{nfbasistoalg}.

The library syntax is \fun{GEN}{algtobasis}{GEN nf, GEN x}.

\subsec{nfbasis$(T, \{\&\var{dK}\})$}\kbdsidx{nfbasis}\label{se:nfbasis}
Let $T(X)$ be an irreducible polynomial with integral coefficients. This
function returns an \idx{integral basis} of the number field defined by $T$,
that is a $\Z$-basis of its maximal order. If present, \kbd{dK} is set
to the discriminant of the returned order. The basis elements are given as
elements in $K = \Q[X]/(T)$, in Hermite normal form with respect to the
$\Q$-basis $(1,X,\dots,X^{\deg T-1})$ of $K$, lifted to $\Q[X]$.
In particular its first element is always $1$ and its $i$-th element is a
polynomial of degree $i-1$ whose leading coefficient is the inverse of an
integer: the product of those integers is the index of $\Z[X]/(T)$ in the
maximal order $\Z_K$:
\bprog
? nfbasis(x^2 + 4) \\ Z[X]/(T) has index 2 in Z_K
%1 = [1, x/2]
? nfbasis(x^2 + 4, &D)
%2 = [1, x/2]
? D
%3 = -4
@eprog
This function uses a modified version of the \idx{round 4} algorithm,
due to David \idx{Ford}, Sebastian \idx{Pauli} and Xavier \idx{Roblot}.

\misctitle{Local basis, orders maximal at certain primes}

Obtaining the maximal order is hard: it requires factoring the discriminant
$D$ of $T$. Obtaining an order which is maximal at a finite explicit set of
primes is easy, but it may then be a strict suborder of the maximal order. To
specify that we are interested in a given set of places only, we can replace
the argument $T$ by an argument $[T,\var{listP}]$, where \var{listP} encodes
the primes we are interested in: it must be a factorization matrix, a vector
of integers or a single integer.

\item Vector: we assume that it contains distinct \emph{prime} numbers.

\item Matrix: we assume that it is a two-column matrix of a
(partial) factorization of $D$; namely the first column contains
distinct \emph{primes} and the second one the valuation of $D$ at each of
these primes.

\item Integer $B$: this is replaced by the vector of primes up to $B$. Note
that the function will use at least $O(B)$ time: a small value, about
$10^5$, should be enough for most applications. Values larger than $2^{32}$
are not supported.

In all these cases, the primes may or may not divide the discriminant $D$
of $T$. The function then returns a $\Z$-basis of an order whose index is
not divisible by any of these prime numbers. The result may actually be
a global integral basis, in particular if all the prime divisors of the
\emph{field} discriminant are included, but this is not guaranteed!
Note that \kbd{nfinit} has built-in support for such a check:
\bprog
? K = nfinit([T, listP]);
? nfcertify(K)   \\ we computed an actual maximal order
%2 = [];
@eprog\noindent The first line initializes a number field structure
incorporating \kbd{nfbasis([T, listP]} in place of a proven integral basis.
The second line certifies that the resulting structure is correct. This
allows to create an \kbd{nf} structure attached to the number field $K =
\Q[X]/(T)$, when the discriminant of $T$ cannot be factored completely,
whereas the prime divisors of $\disc K$ are known. If present, the argument
\kbd{dK} is set to the discriminant of the returned order, and is
equal to the field discriminant if and only if the order is maximal.

Of course, if \var{listP} contains a single prime number $p$,
the function returns a local integral basis for $\Z_p[X]/(T)$:
\bprog
? nfbasis(x^2+x-1001)
%1 = [1, 1/3*x - 1/3]
? nfbasis( [x^2+x-1001, [2]] )
%2 = [1, x]
@eprog\noindent The following function computes the index $i_T$ of $\Z[X]/(T)$
in the order generated by the $\Z$-basis $B$:
\bprog
nfbasisindex(T, B) = vecprod([denominator(pollead(Q)) | Q <- B]);
@eprog\noindent In particular, $B$ is a basis of the maximal order
if and only if $\kbd{poldisc}(T) / i_T^2$ is equal to the field
discriminant. More generally, this formula gives the square of index of the
order given by $B$ in $\Z_K$. For instance, assume that $P$ is a vector
of prime numbers containing (at least) all prime divisors of the field
discriminant, then the following construct allows to provably compute the
field discriminant and to check whether the returned basis is actually
a basis of the maximal order
\bprog
? B = nfbasis([T, P], &D);
? dK = sign(D) * vecprod([p^valuation(D,p) | p<-P]);
? dK * nfbasisindex(T, B)^2 == poldisc(T)
@eprog\noindent The variable \kbd{dK} contains the field discriminant and
the last command returns $1$ if and only if $B$ is a $\Z$-basis of the
maximal order. Of course, the \kbd{nfinit} / \kbd{nfcertify} approach is
simpler, but it is also more costly.

\misctitle{The Buchmann-Lenstra algorithm}

We now complicate the picture: it is in fact allowed to include
\emph{composite} numbers instead of primes
in \kbd{listP} (Vector or Matrix case), provided they are pairwise coprime.
The result may still be a correct integral basis if
the field discriminant factors completely over the actual primes in the
list; again, this is not guaranteed. Adding a composite $C$ such that $C^2$
\emph{divides} $D$ may help because when we consider $C$ as a prime and run
the algorithm, two good things can happen: either we succeed in proving that
no prime dividing $C$ can divide the index (without actually needing to find
those primes), or the computation exhibits a nontrivial zero divisor,
thereby factoring $C$ and we go on with the refined factorization. (Note that
including a $C$ such that $C^2$ does not divide $D$ is useless.) If neither
happen, then the computed basis need not generate the maximal order. Here is
an example:
\bprog
? B = 10^5;
? listP = factor(poldisc(T), B); \\ primes <= B dividing D + cofactor
? basis = nfbasis([T, listP], &D)
@eprog\noindent If the computed discriminant $D$ factors completely
over the primes less than $B$ (together with the primes contained in the
\tet{addprimes} table), then everything is certified: $D$ is the field
discriminant and \kbd{basis} generates the maximal order.
This can be tested as follows:
\bprog
  F = factor(D, B); P = F[,1]; E = F[,2];
  for (i = 1, #P,
    if (P[i] > B && !isprime(P[i]), warning("nf may be incorrect")));
@eprog\noindent
This is a sufficient but not a necessary condition, hence the warning,
instead of an error.

The function \tet{nfcertify} speeds up and automates the above process:
\bprog
? B = 10^5;
? nf = nfinit([T, B]);
? nfcertify(nf)
%3 = []      \\ nf is unconditionally correct
? [basis, disc] = [nf.zk, nf.disc];
@eprog

The library syntax is \fun{GEN}{nfbasis}{GEN T, GEN *dK = NULL}.

\subsec{nfbasistoalg$(\var{nf},x)$}\kbdsidx{nfbasistoalg}\label{se:nfbasistoalg}
Given an algebraic number $x$ in the number field \var{nf}, transforms it
into \typ{POLMOD} form.
\bprog
? nf = nfinit(y^2 + 4);
? nf.zk
%2 = [1, 1/2*y]
? nfbasistoalg(nf, [1,1]~)
%3 = Mod(1/2*y + 1, y^2 + 4)
? nfbasistoalg(nf, y)
%4 = Mod(y, y^2 + 4)
? nfbasistoalg(nf, Mod(y, y^2+4))
%5 = Mod(y, y^2 + 4)
@eprog
This is the inverse function of \kbd{nfalgtobasis}.

The library syntax is \fun{GEN}{basistoalg}{GEN nf, GEN x}.

\subsec{nfcertify$(\var{nf})$}\kbdsidx{nfcertify}\label{se:nfcertify}
$\var{nf}$ being as output by
\kbd{nfinit}, checks whether the integer basis is known unconditionally.
This is in particular useful when the argument to \kbd{nfinit} was of the
form $[T, \kbd{listP}]$, specifying a finite list of primes when
$p$-maximality had to be proven, or a list of coprime integers to which
Buchmann-Lenstra algorithm was to be applied.

The function returns a vector of coprime composite integers. If this vector
is empty, then \kbd{nf.zk} and \kbd{nf.disc} are correct. Otherwise, the
result is dubious. In order to obtain a certified result, one must completely
factor each of the given integers, then \kbd{addprime} each of their prime
factors, then check whether \kbd{nfdisc(nf.pol)} is equal to \kbd{nf.disc}.

The library syntax is \fun{GEN}{nfcertify}{GEN nf}.

\subsec{nfcompositum$(\var{nf},P,Q,\{\fl=0\})$}\kbdsidx{nfcompositum}\label{se:nfcompositum}
Let \var{nf} be a number field structure attached to the field $K$
and let \sidx{compositum} $P$ and $Q$
be squarefree polynomials in $K[X]$ in the same variable. Outputs
the simple factors of the \'etale $K$-algebra $A = K[X, Y] / (P(X), Q(Y))$.
The factors are given by a list of polynomials $R$ in $K[X]$, attached to
the number field $K[X]/ (R)$, and sorted by increasing degree (with respect
to lexicographic ordering for factors of equal degrees). Returns an error if
one of the polynomials is not squarefree.

Note that it is more efficient to reduce to the case where $P$ and $Q$ are
irreducible first. The routine will not perform this for you, since it may be
expensive, and the inputs are irreducible in most applications anyway. In
this case, there will be a single factor $R$ if and only if the number
fields defined by $P$ and $Q$ are linearly disjoint (their intersection is
$K$).

The binary digits of $\fl$ mean

1: outputs a vector of 4-component vectors $[R,a,b,k]$, where $R$
ranges through the list of all possible compositums as above, and $a$
(resp. $b$) expresses the root of $P$ (resp. $Q$) as an element of
$K[X]/(R)$. Finally, $k$ is a small integer such that $b + ka = X$ modulo
$R$.

2: assume that $P$ and $Q$ define number fields that are linearly disjoint:
both polynomials are irreducible and the corresponding number fields
have no common subfield besides $K$. This allows to save a costly
factorization over $K$. In this case return the single simple factor
instead of a vector with one element.

A compositum is often defined by a complicated polynomial, which it is
advisable to reduce before further work. Here is an example involving
the field $K(\zeta_5, 5^{1/10})$, $K=\Q(\sqrt{5})$:
\bprog
? K = nfinit(y^2-5);
? L = nfcompositum(K, x^5 - y, polcyclo(5), 1); \\@com list of $[R,a,b,k]$
? [R, a] = L[1];  \\@com pick the single factor, extract $R,a$ (ignore $b,k$)
? lift(R)         \\@com defines the compositum
%4 = x^10 + (-5/2*y + 5/2)*x^9 + (-5*y + 20)*x^8 + (-20*y + 30)*x^7 + \
(-45/2*y + 145/2)*x^6 + (-71/2*y + 121/2)*x^5 + (-20*y + 60)*x^4 +    \
(-25*y + 5)*x^3 + 45*x^2 + (-5*y + 15)*x + (-2*y + 6)
? a^5 - y         \\@com a fifth root of $y$
%5 = 0
? [T, X] = rnfpolredbest(K, R, 1);
? lift(T)     \\@com simpler defining polynomial for $K[x]/(R)$
%7 = x^10 + (-11/2*y + 25/2)
? liftall(X)  \\ @com root of $R$ in $K[x]/(T(x))$
%8 = (3/4*y + 7/4)*x^7 + (-1/2*y - 1)*x^5 + 1/2*x^2 + (1/4*y - 1/4)
? a = subst(a.pol, 'x, X);  \\@com \kbd{a} in the new coordinates
? liftall(a)
%10 = (-3/4*y - 7/4)*x^7 - 1/2*x^2
? a^5 - y
%11 = 0
@eprog

The main variables of $P$ and $Q$ must be the same and have higher priority
than that of \var{nf} (see~\kbd{varhigher} and~\kbd{varlower}).

The library syntax is \fun{GEN}{nfcompositum}{GEN nf, GEN P, GEN Q, long flag}.

\subsec{nfdetint$(\var{nf},x)$}\kbdsidx{nfdetint}\label{se:nfdetint}
Given a pseudo-matrix $x$, computes a
nonzero ideal contained in (i.e.~multiple of) the determinant of $x$. This
is particularly useful in conjunction with \kbd{nfhnfmod}.

The library syntax is \fun{GEN}{nfdetint}{GEN nf, GEN x}.

\subsec{nfdisc$(T)$}\kbdsidx{nfdisc}\label{se:nfdisc}
\idx{field discriminant} of the number field defined by the integral,
preferably monic, irreducible polynomial $T(X)$. Returns the discriminant of
the number field $\Q[X]/(T)$, using the Round $4$ algorithm.

\misctitle{Local discriminants, valuations at certain primes}

As in \kbd{nfbasis}, the argument $T$ can be replaced by $[T,\var{listP}]$,
where \kbd{listP} is as in \kbd{nfbasis}: a vector of pairwise coprime
integers (usually distinct primes), a factorization matrix, or a single
integer. In that case, the function returns the discriminant of an order
whose basis is given by \kbd{nfbasis(T,listP)}, which need not be the maximal
order, and whose valuation at a prime entry in \kbd{listP} is the same as the
valuation of the field discriminant.

In particular, if \kbd{listP} is $[p]$ for a prime $p$, we can
return the $p$-adic discriminant of the maximal order of $\Z_p[X]/(T)$,
as a power of $p$, as follows:
\bprog
? padicdisc(T,p) = p^valuation(nfdisc([T,[p]]), p);
? nfdisc(x^2 + 6)
%2 = -24
? padicdisc(x^2 + 6, 2)
%3 = 8
? padicdisc(x^2 + 6, 3)
%4 = 3
@eprog\noindent The following function computes the discriminant of the
maximal order under the assumption that $P$ is a vector of prime numbers
containing (at least) all prime divisors of the field discriminant:
\bprog
globaldisc(T, P) =
{ my (D = nfdisc([T, P]));
  sign(D) * vecprod([p^valuation(D,p) | p <-P]);
}
? globaldisc(x^2 + 6, [2, 3, 5])
%1 = -24
@eprog

\synt{nfdisc}{GEN T}. Also available is \fun{GEN}{nfbasis}{GEN T, GEN *d},
which returns the order basis, and where \kbd{*d} receives the order
discriminant.

\subsec{nfdiscfactors$(T)$}\kbdsidx{nfdiscfactors}\label{se:nfdiscfactors}
Given a polynomial $T$ with integer coefficients, return
$[D, \var{faD}]$ where $D$ is \kbd{nfdisc}$(T)$ and
\var{faD} is the factorization of $|D|$. All the variants \kbd{[T,listP]}
are allowed (see \kbd{??nfdisc}), in which case \var{faD} is the
factorization of the discriminant underlying order (which need not be maximal
at the primes not specified by \kbd{listP}) and the factorization may
contain large composites.
\bprog
? T = x^3 - 6021021*x^2 + 12072210077769*x - 8092423140177664432;
? [D,faD] = nfdiscfactors(T); print(faD); D
[3, 3; 500009, 2]
%2 = -6750243002187]

? T = x^3 + 9*x^2 + 27*x - 125014250689643346789780229390526092263790263725;
? [D,faD] = nfdiscfactors(T); print(faD); D
[3, 3; 1000003, 2]
%4 = -27000162000243

? [D,faD] = nfdiscfactors([T, 10^3]); print(faD)
[3, 3; 125007125141751093502187, 2]
@eprog\noindent In the final example, we only get a partial factorization,
which is only guaranteed correct at primes $\leq 10^3$.

The function also accept number field structures, for instance as output by
\kbd{nfinit}, and returns the field discriminant and its factorization:
\bprog
? T = x^3 + 9*x^2 + 27*x - 125014250689643346789780229390526092263790263725;
? nf = nfinit(T); [D,faD] = nfdiscfactors(T); print(faD); D
%2 = -27000162000243
? nf.disc
%3 = -27000162000243
@eprog

The library syntax is \fun{GEN}{nfdiscfactors}{GEN T}.

\subsec{nfeltadd$(\var{nf},x,y)$}\kbdsidx{nfeltadd}\label{se:nfeltadd}
Given two elements $x$ and $y$ in
\var{nf}, computes their sum $x+y$ in the number field $\var{nf}$.

\bprog
? nf = nfinit(1+x^2);
? nfeltadd(nf, 1, x) \\ 1 + I
%2 = [1, 1]~
@eprog

The library syntax is \fun{GEN}{nfadd}{GEN nf, GEN x, GEN y}.

\subsec{nfeltdiv$(\var{nf},x,y)$}\kbdsidx{nfeltdiv}\label{se:nfeltdiv}
Given two elements $x$ and $y$ in
\var{nf}, computes their quotient $x/y$ in the number field $\var{nf}$.

The library syntax is \fun{GEN}{nfdiv}{GEN nf, GEN x, GEN y}.

\subsec{nfeltdiveuc$(\var{nf},x,y)$}\kbdsidx{nfeltdiveuc}\label{se:nfeltdiveuc}
Given two elements $x$ and $y$ in
\var{nf}, computes an algebraic integer $q$ in the number field $\var{nf}$
such that the components of $x-qy$ are reasonably small. In fact, this is
functionally identical to \kbd{round(nfdiv(\var{nf},x,y))}.

The library syntax is \fun{GEN}{nfdiveuc}{GEN nf, GEN x, GEN y}.

\subsec{nfeltdivmodpr$(\var{nf},x,y,\var{pr})$}\kbdsidx{nfeltdivmodpr}\label{se:nfeltdivmodpr}
This function is obsolete, use \kbd{nfmodpr}.

Given two elements $x$
and $y$ in \var{nf} and \var{pr} a prime ideal in \kbd{modpr} format (see
\tet{nfmodprinit}), computes their quotient $x / y$ modulo the prime ideal
\var{pr}.

The library syntax is \fun{GEN}{nfdivmodpr}{GEN nf, GEN x, GEN y, GEN pr}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nf\_to\_Fq}, then work there.

\subsec{nfeltdivrem$(\var{nf},x,y)$}\kbdsidx{nfeltdivrem}\label{se:nfeltdivrem}
Given two elements $x$ and $y$ in
\var{nf}, gives a two-element row vector $[q,r]$ such that $x=qy+r$, $q$ is
an algebraic integer in $\var{nf}$, and the components of $r$ are
reasonably small.

The library syntax is \fun{GEN}{nfdivrem}{GEN nf, GEN x, GEN y}.

\subsec{nfeltembed$(\var{nf},x,\{\var{pl}\})$}\kbdsidx{nfeltembed}\label{se:nfeltembed}
Given an element $x$ in the number field \var{nf}, return
the (real or) complex embeddings of $x$ specified by optional argument
\var{pl}, at the current \kbd{realprecision}:

\item \var{pl} omitted: return the vector of embeddings at all $r_1+r_2$
places;

\item \var{pl} an integer between $1$ and $r_1+r_2$: return the
$i$-th embedding of $x$, attached to the $i$-th root of \kbd{nf.pol},
i.e. \kbd{nf.roots$[i]$};

\item \var{pl} a vector or \typ{VECSMALL}: return the vector of embeddings; the $i$-th
entry gives the embedding at the place attached to the $\var{pl}[i]$-th real
root of \kbd{nf.pol}.

\bprog
? nf = nfinit('y^3 - 2);
? nf.sign
%2 = [1, 1]
? nfeltembed(nf, 'y)
%3 = [1.25992[...], -0.62996[...] + 1.09112[...]*I]]
? nfeltembed(nf, 'y, 1)
%4 = 1.25992[...]
? nfeltembed(nf, 'y, 3) \\ there are only 2 arch. places
 ***   at top-level: nfeltembed(nf,'y,3)
 ***                 ^-----------------
 *** nfeltembed: domain error in nfeltembed: index > 2
@eprog

The library syntax is \fun{GEN}{nfeltembed}{GEN nf, GEN x, GEN pl = NULL, long prec}.

\subsec{nfeltispower$(\var{nf},x,n,\{\&y\})$}\kbdsidx{nfeltispower}\label{se:nfeltispower}
Return $1$ if $x$ is an $n$-th power (and set $y$ to an $n$-th root if the
argument is present), else return 0.

\bprog
? nf = nfinit(1+x^2);
? nfeltispower(nf, -4, 4, &y)
%2 = 1
? y
%3 = [-1, -1]~
@eprog

The library syntax is \fun{long}{nfispower}{GEN nf, GEN x, long n, GEN *y = NULL}.

\subsec{nfeltissquare$(\var{nf},x,\{\&y\})$}\kbdsidx{nfeltissquare}\label{se:nfeltissquare}
Return $1$ if $x$ is a square (and set $y$ to a square root if the
argument is present), else return 0.

\bprog
? nf = nfinit(1+x^2);
? nfeltissquare(nf, -1, &y)
%2 = 1
? y
%3 = [0, -1]~
@eprog

The library syntax is \fun{long}{nfissquare}{GEN nf, GEN x, GEN *y = NULL}.

\subsec{nfeltmod$(\var{nf},x,y)$}\kbdsidx{nfeltmod}\label{se:nfeltmod}
Given two elements $x$ and $y$ in
\var{nf}, computes an element $r$ of $\var{nf}$ of the form $r=x-qy$ with
$q$ and algebraic integer, and such that $r$ is small. This is functionally
identical to
$$\kbd{x - nfmul(\var{nf},round(nfdiv(\var{nf},x,y)),y)}.$$

The library syntax is \fun{GEN}{nfmod}{GEN nf, GEN x, GEN y}.

\subsec{nfeltmul$(\var{nf},x,y)$}\kbdsidx{nfeltmul}\label{se:nfeltmul}
Given two elements $x$ and $y$ in \var{nf}, computes their product $x*y$
in the number field $\var{nf}$.

The library syntax is \fun{GEN}{nfmul}{GEN nf, GEN x, GEN y}.

\subsec{nfeltmulmodpr$(\var{nf},x,y,\var{pr})$}\kbdsidx{nfeltmulmodpr}\label{se:nfeltmulmodpr}
This function is obsolete, use \kbd{nfmodpr}.

Given two elements $x$ and
$y$ in \var{nf} and \var{pr} a prime ideal in \kbd{modpr} format (see
\tet{nfmodprinit}), computes their product $x*y$ modulo the prime ideal
\var{pr}.

The library syntax is \fun{GEN}{nfmulmodpr}{GEN nf, GEN x, GEN y, GEN pr}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nf\_to\_Fq}, then work there.

\subsec{nfeltnorm$(\var{nf},x)$}\kbdsidx{nfeltnorm}\label{se:nfeltnorm}
Returns the absolute norm of $x$.

The library syntax is \fun{GEN}{nfnorm}{GEN nf, GEN x}.

\subsec{nfeltpow$(\var{nf},x,k)$}\kbdsidx{nfeltpow}\label{se:nfeltpow}
Given an element $x$ in \var{nf}, and a positive or negative integer $k$,
computes $x^k$ in the number field $\var{nf}$.

The library syntax is \fun{GEN}{nfpow}{GEN nf, GEN x, GEN k}.
\fun{GEN}{nfinv}{GEN nf, GEN x} correspond to $k = -1$, and
\fun{GEN}{nfsqr}{GEN nf,GEN x} to $k = 2$.

\subsec{nfeltpowmodpr$(\var{nf},x,k,\var{pr})$}\kbdsidx{nfeltpowmodpr}\label{se:nfeltpowmodpr}
This function is obsolete, use \kbd{nfmodpr}.

Given an element $x$ in \var{nf}, an integer $k$ and a prime ideal
\var{pr} in \kbd{modpr} format
(see \tet{nfmodprinit}), computes $x^k$ modulo the prime ideal \var{pr}.

The library syntax is \fun{GEN}{nfpowmodpr}{GEN nf, GEN x, GEN k, GEN pr}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nf\_to\_Fq}, then work there.

\subsec{nfeltreduce$(\var{nf},a,\var{id})$}\kbdsidx{nfeltreduce}\label{se:nfeltreduce}
Given an ideal \var{id} in
Hermite normal form and an element $a$ of the number field $\var{nf}$,
finds an element $r$ in $\var{nf}$ such that $a-r$ belongs to the ideal
and $r$ is small.

The library syntax is \fun{GEN}{nfreduce}{GEN nf, GEN a, GEN id}.

\subsec{nfeltreducemodpr$(\var{nf},x,\var{pr})$}\kbdsidx{nfeltreducemodpr}\label{se:nfeltreducemodpr}
This function is obsolete, use \kbd{nfmodpr}.

Given an element $x$ of the number field $\var{nf}$ and a prime ideal
\var{pr} in \kbd{modpr} format compute a canonical representative for the
class of $x$ modulo \var{pr}.

The library syntax is \fun{GEN}{nfreducemodpr}{GEN nf, GEN x, GEN pr}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nf\_to\_Fq}, then work there.

\subsec{nfeltsign$(\var{nf},x,\{\var{pl}\})$}\kbdsidx{nfeltsign}\label{se:nfeltsign}
Given an element $x$ in the number field \var{nf}, returns the signs of
the real embeddings of $x$ specified by optional argument \var{pl}:

\item \var{pl} omitted: return the vector of signs at all $r_1$ real places;

\item \var{pl} an integer between $1$ and $r_1$: return the sign of the
$i$-th embedding of $x$, attached to the $i$-th real root of \kbd{nf.pol},
i.e. \kbd{nf.roots$[i]$};

\item \var{pl} a vector or \typ{VECSMALL}: return the vector of signs; the $i$-th
entry gives the sign at the real place attached to the $\var{pl}[i]$-th real
root of \kbd{nf.pol}.

\bprog
? nf = nfinit(polsubcyclo(11,5,'y)); \\ Q(cos(2 pi/11))
? nf.sign
%2 = [5, 0]
? x = Mod('y, nf.pol);
? nfeltsign(nf, x)
%4 = [-1, -1, -1, 1, 1]
? nfeltsign(nf, x, 1)
%5 = -1
? nfeltsign(nf, x, [1..4])
%6 = [-1, -1, -1, 1]
? nfeltsign(nf, x, 6) \\ there are only 5 real embeddings
 ***   at top-level: nfeltsign(nf,x,6)
 ***                 ^-----------------
 *** nfeltsign: domain error in nfeltsign: index > 5
@eprog

The library syntax is \fun{GEN}{nfeltsign}{GEN nf, GEN x, GEN pl = NULL}.

\subsec{nfelttrace$(\var{nf},x)$}\kbdsidx{nfelttrace}\label{se:nfelttrace}
Returns the absolute trace of $x$.

The library syntax is \fun{GEN}{nftrace}{GEN nf, GEN x}.

\subsec{nfeltval$(\var{nf},x,\var{pr},\{\&y\})$}\kbdsidx{nfeltval}\label{se:nfeltval}
Given an element $x$ in
\var{nf} and a prime ideal \var{pr} in the format output by
\kbd{idealprimedec}, computes the valuation $v$ at \var{pr} of the
element $x$. The valuation of $0$ is \kbd{+oo}.
\bprog
? nf = nfinit(x^2 + 1);
? P = idealprimedec(nf, 2)[1];
? nfeltval(nf, x+1, P)
%3 = 1
@eprog\noindent
This particular valuation can also be obtained using
\kbd{idealval(\var{nf},x,\var{pr})}, since $x$ is then converted to a
principal ideal.

If the $y$ argument is present, sets $y = x \tau^v$, where $\tau$ is a
fixed ``anti-uniformizer'' for \var{pr}: its valuation at \var{pr} is $-1$;
its valuation is $0$ at other prime ideals dividing \kbd{\var{pr}.p} and
nonnegative at all other primes. In other words $y$ is the part of $x$
coprime to \var{pr}. If $x$ is an algebraic integer, so is $y$.
\bprog
? nfeltval(nf, x+1, P, &y); y
%4 = [0, 1]~
@eprog
For instance if $x = \prod_i x_i^{e_i}$ is known to be coprime to \var{pr},
where the $x_i$ are algebraic integers and $e_i\in\Z$ then,
if $v_i = \kbd{nfeltval}(\var{nf}, x_i, \var{pr}, \&y_i)$, we still
have $x = \prod_i y_i^{e_i}$, where the $y_i$ are still algebraic integers
but now all of them are coprime to \var{pr}. They can then be mapped to
the residue field of \var{pr} more efficiently than if the product had
been expanded beforehand: we can reduce mod \var{pr} after each ring
operation.

The library syntax is \fun{GEN}{gpnfvalrem}{GEN nf, GEN x, GEN pr, GEN *y = NULL}.
Also available are
\fun{long}{nfvalrem}{GEN nf, GEN x, GEN pr, GEN *y = NULL}, which returns
\tet{LONG_MAX} if $x = 0$ and the valuation as a \kbd{long} integer,
and \fun{long}{nfval}{GEN nf, GEN x, GEN pr}, which only returns the
valuation ($y = \kbd{NULL}$).

\subsec{nffactor$(\var{nf},T)$}\kbdsidx{nffactor}\label{se:nffactor}
Factorization of the univariate
polynomial (or rational function) $T$ over the number field $\var{nf}$ given
by \kbd{nfinit}; $T$ has coefficients in $\var{nf}$ (i.e.~either scalar,
polmod, polynomial or column vector). The factors are sorted by increasing
degree.

The main variable of $\var{nf}$ must be of \emph{lower}
priority than that of $T$, see \secref{se:priority}. However if
the polynomial defining the number field occurs explicitly  in the
coefficients of $T$ as modulus of a \typ{POLMOD} or as a \typ{POL}
coefficient, its main variable must be \emph{the same} as the main variable
of $T$. For example,
\bprog
? nf = nfinit(y^2 + 1);
? nffactor(nf, x^2 + y); \\@com OK
? nffactor(nf, x^2 + Mod(y, y^2+1)); \\ @com OK
? nffactor(nf, x^2 + Mod(z, z^2+1)); \\ @com WRONG
@eprog

It is possible to input a defining polynomial for \var{nf}
instead, but this is in general less efficient since parts of an \kbd{nf}
structure will then be computed internally. This is useful in two
situations: when you do not need the \kbd{nf} elsewhere, or when you cannot
initialize an \kbd{nf} due to integer factorization difficulties when
attempting to compute the field discriminant and maximal order. In all
cases, the function runs in polynomial time using Belabas's variant
of \idx{van Hoeij}'s algorithm, which copes with hundreds of modular factors.

\misctitle{Caveat} \kbd{nfinit([T, listP])} allows to compute in polynomial
time a conditional \var{nf} structure, which sets \kbd{nf.zk} to an order
which is not guaranteed to be maximal at all primes. Always either use
\kbd{nfcertify} first (which may not run in polynomial time) or make sure
to input \kbd{nf.pol} instead of the conditional \var{nf}: \kbd{nffactor} is
able to recover in polynomial time in this case, instead of potentially
missing a factor.

The library syntax is \fun{GEN}{nffactor}{GEN nf, GEN T}.

\subsec{nffactorback$(\var{nf},f,\{e\})$}\kbdsidx{nffactorback}\label{se:nffactorback}
Gives back the \var{nf} element corresponding to a factorization.
The integer $1$ corresponds to the empty factorization.

If $e$ is present, $e$ and $f$ must be vectors of the same length ($e$ being
integral), and the corresponding factorization is the product of the
$f[i]^{e[i]}$.

If not, and $f$ is vector, it is understood as in the preceding case with $e$
a vector of 1s: we return the product of the $f[i]$. Finally, $f$ can be a
regular factorization matrix.
\bprog
? nf = nfinit(y^2+1);
? nffactorback(nf, [3, y+1, [1,2]~], [1, 2, 3])
%2 = [12, -66]~
? 3 * (I+1)^2 * (1+2*I)^3
%3 = 12 - 66*I
@eprog

The library syntax is \fun{GEN}{nffactorback}{GEN nf, GEN f, GEN e = NULL}.

\subsec{nffactormod$(\var{nf},Q,\var{pr})$}\kbdsidx{nffactormod}\label{se:nffactormod}
This routine is obsolete, use \kbd{nfmodpr} and \kbd{factormod}.

Factors the univariate polynomial $Q$ modulo the prime ideal \var{pr} in
the number field $\var{nf}$. The coefficients of $Q$ belong to the number
field (scalar, polmod, polynomial, even column vector) and the main variable
of $\var{nf}$ must be of lower priority than that of $Q$ (see
\secref{se:priority}). The prime ideal \var{pr} is either in
\tet{idealprimedec} or (preferred) \tet{modprinit} format. The coefficients
of the polynomial factors are lifted to elements of \var{nf}:
\bprog
? K = nfinit(y^2+1);
? P = idealprimedec(K, 3)[1];
? nffactormod(K, x^2 + y*x + 18*y+1, P)
%3 =
[x + (2*y + 1) 1]

[x + (2*y + 2) 1]
? P = nfmodprinit(K, P);  \\ convert to nfmodprinit format
? nffactormod(K, x^2 + y*x + 18*y+1)
%5 =
[x + (2*y + 1) 1]

[x + (2*y + 2) 1]
@eprog\noindent Same result, of course, here about 10\% faster due to the
precomputation.

The library syntax is \fun{GEN}{nffactormod}{GEN nf, GEN Q, GEN pr}.

\subsec{nfgaloisapply$(\var{nf},\var{aut},x)$}\kbdsidx{nfgaloisapply}\label{se:nfgaloisapply}
Let $\var{nf}$ be a
number field as output by \kbd{nfinit}, and let \var{aut} be a \idx{Galois}
automorphism of $\var{nf}$ expressed by its image on the field generator
(such automorphisms can be found using \kbd{nfgaloisconj}). The function
computes the action of the automorphism \var{aut} on the object $x$ in the
number field; $x$ can be a number field element, or an ideal (possibly
extended). Because of possible confusion with elements and ideals, other
vector or matrix arguments are forbidden.
 \bprog
 ? nf = nfinit(x^2+1);
 ? L = nfgaloisconj(nf)
 %2 = [-x, x]~
 ? aut = L[1]; /* the nontrivial automorphism */
 ? nfgaloisapply(nf, aut, x)
 %4 = Mod(-x, x^2 + 1)
 ? P = idealprimedec(nf,5); /* prime ideals above 5 */
 ? nfgaloisapply(nf, aut, P[2]) == P[1]
 %6 = 0 \\ !!!!
 ? idealval(nf, nfgaloisapply(nf, aut, P[2]), P[1])
 %7 = 1
@eprog\noindent The surprising failure of the equality test (\kbd{\%7}) is
due to the fact that although the corresponding prime ideals are equal, their
representations are not. (A prime ideal is specified by a uniformizer, and
there is no guarantee that applying automorphisms yields the same elements
as a direct \kbd{idealprimedec} call.)

The automorphism can also be given as a column vector, representing the
image of \kbd{Mod(x, nf.pol)} as an algebraic number. This last
representation is more efficient and should be preferred if a given
automorphism must be used in many such calls.
\bprog
 ? nf = nfinit(x^3 - 37*x^2 + 74*x - 37);
 ? aut = nfgaloisconj(nf)[2]; \\ @com an automorphism in basistoalg form
 %2 = -31/11*x^2 + 1109/11*x - 925/11
 ? AUT = nfalgtobasis(nf, aut); \\ @com same in algtobasis form
 %3 = [16, -6, 5]~
 ? v = [1, 2, 3]~; nfgaloisapply(nf, aut, v) == nfgaloisapply(nf, AUT, v)
 %4 = 1 \\ @com same result...
 ? for (i=1,10^5, nfgaloisapply(nf, aut, v))
 time = 463 ms.
 ? for (i=1,10^5, nfgaloisapply(nf, AUT, v))
 time = 343 ms.  \\ @com but the latter is faster
@eprog

The library syntax is \fun{GEN}{galoisapply}{GEN nf, GEN aut, GEN x}.

\subsec{nfgaloisconj$(\var{nf},\{\fl=0\},\{d\})$}\kbdsidx{nfgaloisconj}\label{se:nfgaloisconj}
$\var{nf}$ being a number field as output by \kbd{nfinit}, computes the
conjugates of a root $r$ of the nonconstant polynomial $x=\var{nf}[1]$
expressed as polynomials in $r$. This also makes sense when the number field
is not \idx{Galois} since some conjugates may lie in the field.
$\var{nf}$ can simply be a polynomial.

If no flags or $\fl=0$, use a combination of flag $4$ and $1$ and the result
is always complete. There is no point whatsoever in using the other flags.

If $\fl=1$, use \kbd{nfroots}: a little slow, but guaranteed to work in
polynomial time.

If $\fl=4$, use \kbd{galoisinit}: very fast, but only applies to (most)
Galois fields. If the field is Galois with weakly super-solvable Galois
group (see \tet{galoisinit}), return the complete list of automorphisms, else
only the identity element. If present, $d$ is assumed to be a multiple of the
least common denominator of the conjugates expressed as polynomial in a root
of \var{pol}.

This routine can only compute $\Q$-automorphisms, but it may be used to get
$K$-automorphism for any base field $K$ as follows:
\bprog
rnfgaloisconj(nfK, R) = \\ K-automorphisms of L = K[X] / (R)
{
  my(polabs, N,al,S, ala,k, vR);
  R *= Mod(1, nfK.pol); \\ convert coeffs to polmod elts of K
  vR = variable(R);
  al = Mod(variable(nfK.pol),nfK.pol);
  [polabs,ala,k] = rnfequation(nfK, R, 1);
  Rt = if(k==0,R,subst(R,vR,vR-al*k));
  N = nfgaloisconj(polabs) % Rt; \\ Q-automorphisms of L
  S = select(s->subst(Rt, vR, Mod(s,Rt)) == 0, N);
  if (k==0, S, apply(s->subst(s,vR,vR+k*al)-k*al,S));
}
K  = nfinit(y^2 + 7);
rnfgaloisconj(K, x^4 - y*x^3 - 3*x^2 + y*x + 1)  \\ K-automorphisms of L
@eprog

The library syntax is \fun{GEN}{galoisconj0}{GEN nf, long flag, GEN d = NULL, long prec}.
Use directly
\fun{GEN}{galoisconj}{GEN nf, GEN d}, corresponding to $\fl = 0$, the others
only have historical interest.

\subsec{nfgrunwaldwang$(\var{nf},\var{Lpr},\var{Ld},\var{pl},\{v='x\})$}\kbdsidx{nfgrunwaldwang}\label{se:nfgrunwaldwang}
Given \var{nf} a number field in \var{nf} or \var{bnf} format,
a \typ{VEC} \var{Lpr} of primes of \var{nf} and a \typ{VEC} \var{Ld} of
positive integers of the same length, a \typ{VECSMALL} \var{pl} of length
$r_1$ the number of real places of \var{nf}, computes a polynomial with
coefficients in \var{nf} defining a cyclic extension of \var{nf} of
minimal degree satisfying certain local conditions:

\item at the prime~$Lpr[i]$, the extension has local degree a multiple
of~$Ld[i]$;

\item at the $i$-th real place of \var{nf}, it is complex if $pl[i]=-1$
(no condition if $pl[i]=0$).

The extension has degree the LCM of the local degrees. Currently, the degree
is restricted to be a prime power for the search, and to be prime for the
construction because of the \kbd{rnfkummer} restrictions.

When \var{nf} is $\Q$, prime integers are accepted instead of \kbd{prid}
structures. However, their primality is not checked and the behavior is
undefined if you provide a composite number.

\misctitle{Warning} If the number field \var{nf} does not contain the $n$-th
roots of unity where $n$ is the degree of the extension to be computed,
the function triggers the computation of the \var{bnf} of $nf(\zeta_n)$,
which may be costly.

\bprog
? nf = nfinit(y^2-5);
? pr = idealprimedec(nf,13)[1];
? pol = nfgrunwaldwang(nf, [pr], [2], [0,-1], 'x)
%3 = x^2 + Mod(3/2*y + 13/2, y^2 - 5)
@eprog

The library syntax is \fun{GEN}{nfgrunwaldwang}{GEN nf, GEN Lpr, GEN Ld, GEN pl, long v = -1} where \kbd{v} is a variable number.

\subsec{nfhilbert$(\var{nf},a,b,\{\var{pr}\})$}\kbdsidx{nfhilbert}\label{se:nfhilbert}
If \var{pr} is omitted,
compute the global quadratic \idx{Hilbert symbol} $(a,b)$ in $\var{nf}$, that
is $1$ if $x^2 - a y^2 - b z^2$ has a non trivial solution $(x,y,z)$ in
$\var{nf}$, and $-1$ otherwise. Otherwise compute the local symbol modulo
the prime ideal \var{pr}, as output by \kbd{idealprimedec}.

The library syntax is \fun{long}{nfhilbert0}{GEN nf, GEN a, GEN b, GEN pr = NULL}.

Also available is \fun{long}{nfhilbert}{GEN nf,GEN a,GEN b} (global
quadratic Hilbert symbol), where \kbd{nf} is a true \var{nf} structure.

\subsec{nfhnf$(\var{nf},x,\{\fl=0\})$}\kbdsidx{nfhnf}\label{se:nfhnf}
Given a pseudo-matrix $(A,I)$, finds a
pseudo-basis $(B,J)$ in \idx{Hermite normal form} of the module it generates.
If $\fl$ is nonzero, also return the transformation matrix $U$ such that
$AU = [0|B]$.

The library syntax is \fun{GEN}{nfhnf0}{GEN nf, GEN x, long flag}.
Also available:

\fun{GEN}{nfhnf}{GEN nf, GEN x} ($\fl = 0$).

\fun{GEN}{rnfsimplifybasis}{GEN bnf, GEN x} simplifies the pseudo-basis
$x = (A,I)$, returning a pseudo-basis $(B,J)$. The ideals in the list $J$
are integral, primitive and either trivial (equal to the full ring of
integer) or nonprincipal.

\subsec{nfhnfmod$(\var{nf},x,\var{detx})$}\kbdsidx{nfhnfmod}\label{se:nfhnfmod}
Given a pseudo-matrix $(A,I)$
and an ideal \var{detx} which is contained in (read integral multiple of) the
determinant of $(A,I)$, finds a pseudo-basis in \idx{Hermite normal form}
of the module generated by $(A,I)$. This avoids coefficient explosion.
\var{detx} can be computed using the function \kbd{nfdetint}.

The library syntax is \fun{GEN}{nfhnfmod}{GEN nf, GEN x, GEN detx}.

\subsec{nfinit$(\var{pol},\{\fl=0\})$}\kbdsidx{nfinit}\label{se:nfinit}
\var{pol} being a nonconstant irreducible polynomial in $\Q[X]$,
preferably monic and integral, initializes a
\emph{number field} (or \var{nf}) structure  attached to the field $K$ defined
by \var{pol}. As such, it's a technical object passed as the first argument
to most \kbd{nf}\var{xxx} functions, but it contains some information which
may be directly useful. Access to this information via \emph{member
functions} is preferred since the specific data organization given below
may change in the future. Currently, \kbd{nf} is a row vector with 9
components:

$\var{nf}[1]$ contains the polynomial \var{pol} (\kbd{\var{nf}.pol}).

$\var{nf}[2]$ contains $[r1,r2]$ (\kbd{\var{nf}.sign}, \kbd{\var{nf}.r1},
\kbd{\var{nf}.r2}), the number of real and complex places of $K$.

$\var{nf}[3]$ contains the discriminant $d(K)$ (\kbd{\var{nf}.disc}) of $K$.

$\var{nf}[4]$ contains the index of $\var{nf}[1]$ (\kbd{\var{nf}.index}),
i.e.~$[\Z_K : \Z[\theta]]$, where $\theta$ is any root of $\var{nf}[1]$.

$\var{nf}[5]$ is a vector containing 7 matrices $M$, $G$, \var{roundG}, $T$,
\var{MD}, \var{TI}, \var{MDI} and a vector \var{vP} defined as follows:

\quad\item $M$ is the $(r1+r2)\times n$ matrix whose columns represent
the numerical values of the conjugates of the elements of the integral
basis.

\quad\item $G$ is an $n\times n$ matrix such that $T2 = {}^t G G$,
where $T2$ is the quadratic form $T_2(x) = \sum |\sigma(x)|^2$, $\sigma$
running over the embeddings of $K$ into $\C$.

\quad\item \var{roundG} is a rescaled copy of $G$, rounded to nearest
integers.

\quad\item $T$ is the $n\times n$ matrix whose coefficients are
$\text{Tr}(\omega_i\omega_j)$ where the $\omega_i$ are the elements of the
integral basis. Note also that $\det(T)$ is equal to the discriminant of the
field $K$. Also, when understood as an ideal, the matrix $T^{-1}$
generates the codifferent ideal.

\quad\item The columns of $MD$ (\kbd{\var{nf}.diff}) express a $\Z$-basis
of the different of $K$ on the integral basis.

\quad\item \var{TI} is equal to the primitive part of $T^{-1}$, which has
integral coefficients.

\quad\item \var{MDI} is a two-element representation (for faster
ideal product) of $d(K)$ times the codifferent ideal
(\kbd{\var{nf}.disc$*$\var{nf}.codiff}, which is an integral ideal). This is
used in \tet{idealinv}.

\quad\item \var{vP} is the list of prime divisors of the field discriminant,
i.e, the ramified primes (\kbd{\var{nf}.p}); \kbd{nfdiscfactors(nf)} is the
preferred way to access that information.

$\var{nf}[6]$ is the vector containing the $r1+r2$ roots
(\kbd{\var{nf}.roots}) of $\var{nf}[1]$ corresponding to the $r1+r2$
embeddings of the number field into $\C$ (the first $r1$ components are real,
the next $r2$ have positive imaginary part).

$\var{nf}[7]$ is a $\Z$-basis for $d\Z_K$, where $d = [\Z_K:\Z(\theta)]$,
expressed on the powers of $\theta$. The multiplication by
$d$ ensures that all polynomials have integral coefficients
and $\var{nf}[7] / d$ (\kbd{\var{nf}.zk}) is an integral basis for $\Z_K$.
Its first element is guaranteed to be $1$. This basis is LLL-reduced with
respect to $T_2$ (strictly speaking, it is a permutation of such a basis, due
to the condition that the first element be $1$).

$\var{nf}[8]$ is the $n\times n$ integral matrix expressing the power
basis in terms of the integral basis, and finally

$\var{nf}[9]$ is the $n\times n^2$ matrix giving the multiplication table
of the integral basis.

If a non monic or non integral polynomial is input, \kbd{nfinit} will
transform it, and return a structure attached to the new (monic integral)
polynomial together with the attached change of variables, see $\fl=3$.
It is allowed, though not very useful given the existence of
\tet{nfnewprec}, to input a \var{nf} or a \var{bnf} instead of a polynomial.
It is also allowed to input a \var{rnf}, in which case an \kbd{nf} structure
attached to the absolute defining polynomial \kbd{polabs} is returned (\fl is
then ignored).

\bprog
? nf = nfinit(x^3 - 12); \\ initialize number field Q[X] / (X^3 - 12)
? nf.pol   \\ defining polynomial
%2 = x^3 - 12
? nf.disc  \\ field discriminant
%3 = -972
? nf.index \\ index of power basis order in maximal order
%4 = 2
? nf.zk    \\ integer basis, lifted to Q[X]
%5 = [1, x, 1/2*x^2]
? nf.sign  \\ signature
%6 = [1, 1]
? factor(abs(nf.disc ))  \\ determines ramified primes
%7 =
[2 2]

[3 5]
? idealfactor(nf, 2)
%8 =
[[2, [0, 0, -1]~, 3, 1, [0, 1, 0]~] 3]  \\ @com $\goth{p}_2^3$
@eprog

\misctitle{Huge discriminants, helping nfdisc}

In case \var{pol} has a huge discriminant which is difficult to factor,
it is hard to compute from scratch the maximal order. The following
special input formats are also accepted:

\item $[\var{pol}, B]$ where \var{pol} is a monic integral polynomial and
$B$ is the lift of an integer basis, as would be computed by \tet{nfbasis}:
a vector of polynomials with first element $1$ (implicitly modulo \var{pol}).
This is useful if the maximal order is known in advance.

\item $[\var{pol}, B, P]$ where \var{pol} and $B$ are as above
(a monic integral polynomial and the lift of an integer basis), and $P$ is
the list of ramified primes in the extension.

\item $[\var{pol}, \kbd{listP}]$ where \var{pol} is a rational polynomial and
\kbd{listP} specifies a list of primes as in \tet{nfbasis}. Instead of the
maximal order, \kbd{nfinit} then computes
an order which is maximal at these particular primes as well as the primes
contained in the private prime table, see \tet{addprimes}. The result has
a good chance of being correct when the discriminant \kbd{nf.disc} factors
completely over this set of primes but this is not guaranteed. The function
\tet{nfcertify} automates this:
\bprog
? pol = polcompositum(x^5 - 101, polcyclo(7))[1];
? nf = nfinit( [pol, 10^3] );
? nfcertify(nf)
%3 = []
@eprog\noindent A priori, \kbd{nf.zk} defines an order which is only known
to be maximal at all primes $\leq 10^3$ (no prime $\leq 10^3$ divides
\kbd{nf.index}). The certification step proves the correctness of the
computation. Had it failed, that particular \kbd{nf} structure could
not have been trusted and may have caused routines using it to fail randomly.
One particular function that remains trustworthy in all cases is
\kbd{idealprimedec} when applied to a prime included in the above list
of primes or, more generally, a prime not dividing any entry in
\kbd{nfcertify} output.
\medskip
In order to explain the meaning of $\fl$, let $P =
\kbd{polredbest}(\var{pol})$, a polynomial defining the same number field
obtained using the LLL algorithm on the lattice $(\Z_K, T_2)$, which may be
equal to \var{pol} but is usually different and simpler. Binary digits of
$\fl$ mean:

\item $1$: return $[\var{nf},\kbd{Mod}(a,P)]$, where $\var{nf}$ is
\kbd{nfinit}$(P)$ and $\kbd{Mod}(a,P)=\kbd{Mod}(x,\var{pol})$ gives the
change of variables. If only this bit is set, the behaviour is useless since
we have $P = \var{pol}$.

\item $2$: return \kbd{nfinit}$(P)$.

Both flags are set automatically when \var{pol} is not monic or not
integral: first a linear change of variables is performed, to get a monic
integral polynomial, then \kbd{polredbest}.

\item $4$: do not LLL-reduce \kbd{nf.zk}, which saves time in large degrees,
you may expect to gain a factor $2$ or so in degree $n\geq 100$ or more, at
the expense of \emph{possibly} slowing down later uses of the \var{nf}
structure. Use this flag if you only need basic arithmetic
(the \kbd{nfelt*}, \kbd{nfmodpr*} and \kbd{ideal*} functions); or if you
expect the natural basis of the maximal order to contain small elements, this
will be the case for cyclotomic fields for instance. On the other hand,
functions involving LLL reduction of rank
$n$ lattices should be avoided since each call will be about as costly as the
initial LLL reduction that the flag prevents and may become more costly
because of this missing initial reduction. In particular it is silly to use
this flag in addition to the first two, although GP will not protest.

\bprog
? T = polcyclo(307);
? K = nfinit(T);
time = 19,390 ms.
? a = idealhnf(K,1-x);
time = 477ms
? idealfactor(K, a)
time = 294ms

? Kno = nfinit(T, 4);
time = 11,256 ms.
? ano = idealhnf(Kno,1-x); \\ no slowdown, even sligthly faster
time = 460ms
? idealfactor(Kno, ano)
time = 264ms

? nfinit(T, 2); \\ polredbest is very slow in high degree
time = 4min, 34,870 ms.
? norml2(%.pol) == norml2(T) \\ and gains nothing here
%9 = 1
@eprog

The library syntax is \fun{GEN}{nfinit0}{GEN pol, long flag, long prec}.
Also available are
\fun{GEN}{nfinit}{GEN x, long prec} ($\fl = 0$),
\fun{GEN}{nfinitred}{GEN x, long prec} ($\fl = 2$),
\fun{GEN}{nfinitred2}{GEN x, long prec} ($\fl = 3$).
Instead of the above hardcoded numerical flags in \kbd{nfinit0}, one should
rather use an or-ed combination of

\item \tet{nf_RED}: find a simpler defining polynomial,

\item \tet{nf_ORIG}: also return the change of variable,

\item \tet{nf_NOLLL}: do not LLL-reduce the maximal order $\Z$-basis.

\subsec{nfisideal$(\var{nf},x)$}\kbdsidx{nfisideal}\label{se:nfisideal}
Returns 1 if $x$ is an ideal in the number field $\var{nf}$, 0 otherwise.

The library syntax is \fun{long}{isideal}{GEN nf, GEN x}.

\subsec{nfisincl$(f,g,\{\fl=0\})$}\kbdsidx{nfisincl}\label{se:nfisincl}
Let $f$ and $g$ define number fields, where $f$ and $g$ are irreducible
polynomials in $\Q[X]$ and \var{nf} structures as output by \kbd{nfinit}.
If either $f$ or $g$ is not irreducible, the result is undefined.
Tests whether the number field $f$ is conjugate to a subfield of the field
$g$. If not, the output is the integer 0; if it is, the output depends on
the value of $\fl$:

\item $\fl = 0$ (default): return a vector of polynomials $[a_1,\dots,a_n]$
with rational coefficients, representing all distinct embeddings: we have
$g\mid f\circ a_i$ for all $i$.

\item $\fl = 1$: return a single polynomial $a$ representing a single
embedding; this can be $n$ times faster than the default when the
embeddings have huge coefficients.

\item $\fl = 2$: return a vector of rational functions $[r_1,\dots,r_n]$
whose denominators are coprime to $g$ and such that $r_i \% g$ is the
polynomial $a_i$ from $\fl = 0$. This variant is always faster than $\fl = 0$
but produces results which are harder to use. If the denominators are hard to
invert in $\Q[X]/(g)$, this may be even faster than $\fl = 1$.
\bprog
? T = x^6 + 3*x^4 - 6*x^3 + 3*x^2 + 18*x + 10;
? U = x^3 + 3*x^2 + 3*x - 2
? nfisincl(U, T)
%3 = [24/179*x^5-27/179*x^4+80/179*x^3-234/179*x^2+380/179*x+94/179]
? a = nfisincl(U, T, 1)
%4 = 24/179*x^5-27/179*x^4+80/179*x^3-234/179*x^2+380/179*x+94/179
? subst(U, x, Mod(a,T))
%5 = Mod(0, x^6 + 3*x^4 - 6*x^3 + 3*x^2 + 18*x + 10)
? nfisincl(U, T, 2) \\ a as a t_RFRAC
%6 = [(2*x^3 - 3*x^2 + 2*x + 4)/(3*x^2 - 1)]
? (a - %[1]) % T
%7 = 0
? #nfisincl(x^2+1, T) \\ two embeddings
%8 = 2

\\ same result with nf structures
? L = nfinit(T); K = nfinit(U); v = [a];
? nfisincl(U, L) == v
%10 = 1
? nfisincl(K, T) == v
%11 = 1
? nfisincl(K, L) == v
%12 = 1

\\ comparative bench: an nf is a little faster, esp. for the subfield
? B = 2000;
? for (i=1, B, nfisincl(U,T))
time = 1,364 ms.
? for (i=1, B, nfisincl(K,T))
time = 988 ms.
? for (i=1, B, nfisincl(U,L))
time = 1,341 ms.
? for (i=1, B, nfisincl(K,L))
time = 880 ms.
@eprog\noindent Using an \var{nf} structure for the tentative subfield is
faster if the structure is already available. On the other hand, the gain in
\kbd{nfisincl} is usually not sufficient to make it worthwhile to initialize
only for that purpose.
\bprog
? for (i=1, B, nfinit(U))
time = 590 ms.
@eprog\noindent A final more complicated example
\bprog
? f = x^8 - 72*x^6 + 1944*x^4 - 30228*x^2 - 62100*x - 34749;
? g = nfsplitting(f); poldegree(g)
%2 = 96
? #nfisincl(f, g)
time = 559 ms.
%3 = 8
? nfisincl(f,g,1);
time = 172 ms.
? v = nfisincl(f,g,2);
time = 199 ms.
? apply(x->poldegree(denominator(x)), v)
%6 = [81, 81, 81, 81, 81, 81, 80, 81]
? v % g;
time = 407 ms.
@eprog\noindent This final example shows that mapping rational functions to
$\Q[X]/(g)$ can be more costly than that the rest of the algorithm. Note that
\kbd{nfsplitting} also admits a $\fl$ yielding an embedding.

The library syntax is \fun{GEN}{nfisincl0}{GEN f, GEN g, long flag}.
Also available is
\fun{GEN}{nfisisom}{GEN a, GEN b} ($\fl = 0$).

\subsec{nfisisom$(f,g)$}\kbdsidx{nfisisom}\label{se:nfisisom}
As \tet{nfisincl}, but tests for isomorphism. More efficient if
$f$ or $g$ is a number field structure.
\bprog
? f = x^6 + 30*x^5 + 495*x^4 + 1870*x^3 + 16317*x^2 - 22560*x + 59648;
? g = x^6 + 42*x^5 + 999*x^4 + 8966*x^3 + 36117*x^2 + 21768*x + 159332;
? h = x^6 + 30*x^5 + 351*x^4 + 2240*x^3 + 10311*x^2 + 35466*x + 58321;

? #nfisisom(f,g)  \\ two isomorphisms
%3 = 2
? nfisisom(f,h) \\ not isomorphic
%4 = 0
\\ comparative bench
? K = nfinit(f); L = nfinit(g); B = 10^3;
? for (i=1, B, nfisisom(f,g))
time = 6,124 ms.
? for (i=1, B, nfisisom(K,g))
time = 3,356 ms.
? for (i=1, B, nfisisom(f,L))
time = 3,204 ms.
? for (i=1, B, nfisisom(K,L))
time = 3,173 ms.
@eprog\noindent
The function is usually very fast when the fields are nonisomorphic,
whenever the fields can be distinguished via a simple invariant such as
degree, signature or discriminant. It may be slower when the fields
share all invariants, but still faster than computing actual isomorphisms:
\bprog
\\ usually very fast when the answer is 'no':
? for (i=1, B, nfisisom(f,h))
time = 32 ms.

\\ but not always
? u = x^6 + 12*x^5 + 6*x^4 - 377*x^3 - 714*x^2 + 5304*x + 15379
? v = x^6 + 12*x^5 + 60*x^4 + 166*x^3 + 708*x^2 + 6600*x + 23353
? nfisisom(u,v)
%13 = 0
? polsturm(u) == polsturm(v)
%14 = 1
? nfdisc(u) == nfdisc(v)
%15 = 1
? for(i=1,B, nfisisom(u,v))
time = 1,821 ms.
? K = nfinit(u); L = nfinit(v);
? for(i=1,B, nfisisom(K,v))
time = 232 ms.
@eprog

The library syntax is \fun{GEN}{nfisisom}{GEN f, GEN g}.

\subsec{nfislocalpower$(\var{nf},\var{pr},a,n)$}\kbdsidx{nfislocalpower}\label{se:nfislocalpower}
Let \var{nf} be a \var{nf} structure attached to a number field $K$,
let $a \in K$ and let \var{pr} be a \var{prid} structure attached to a
maximal ideal $v$. Return $1$ if $a$ is an $n$-th power in the completed
local field $K_v$, and $0$ otherwise.
\bprog
? K = nfinit(y^2+1);
? P = idealprimedec(K,2)[1]; \\ the ramified prime above 2
? nfislocalpower(K,P,-1, 2) \\ -1 is a square
%3 = 1
? nfislocalpower(K,P,-1, 4) \\ ... but not a 4-th power
%4 = 0
? nfislocalpower(K,P,2, 2)  \\ 2 is not a square
%5 = 0

? Q = idealprimedec(K,5)[1]; \\ a prime above 5
? nfislocalpower(K,Q, [0, 32]~, 30)  \\ 32*I is locally a 30-th power
%7 = 1
@eprog

The library syntax is \fun{long}{nfislocalpower}{GEN nf, GEN pr, GEN a, GEN n}.

\subsec{nfkermodpr$(\var{nf},x,\var{pr})$}\kbdsidx{nfkermodpr}\label{se:nfkermodpr}
This function is obsolete, use \kbd{nfmodpr}.

Kernel of the matrix $a$ in $\Z_K/\var{pr}$, where \var{pr} is in
\key{modpr} format (see \kbd{nfmodprinit}).

The library syntax is \fun{GEN}{nfkermodpr}{GEN nf, GEN x, GEN pr}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nfM\_to\_FqM}, then work there.

\subsec{nflist$(G, \{N\}, \{s = -1\}, \{F\})$}\kbdsidx{nflist}\label{se:nflist}
Find number fields (up to isomorphism) with Galois group of Galois
closure isomorphic to $G$ with $s$ complex places. This function supports
the following groups:

\item degree $2$: $C_2=2T1$;

\item degree $3$: $C_3=3T1$ and $S_3=3T2$;

\item degree $4$: $C_4=4T1$, $V_4=4T2$, $D_4=4T3$, $A_4=4T4$, and $S_4=4T5$;

\item degree $5$: $C_5=5T1$, $D_5=5T2$, $F_5 = M_{20}=5T3$, and $A_5=5T4$;

\item degree $6$: $C_6=6T1$, $S_3(6) = D_6(6)=6T2$, $D_6(12)=6T3$,
$A_4(6)=6T4$, $S_3\times C_3=6T5$, $A_4(6)\times C_2=6T6$, $S_4(6)^+=6T7$,
$S_4(6)^-=6T8$, $S_3^2=6T9$, $C_3^2:C_4=6T10$, $S_4(6)\times C_2=6T11$,
$A_5(6)=PSL_2(5)=6T12$, and $C_3^2:D_4=6T13$;

\item degree $7$: $C_7=7T1$, $D_7=7T2$, $M_{21}=7T3$, and $M_{42}=7T4$;

\item degree $9$: $C_9=9T1$, $C_3\times C_3=9T2$, and $D_9=9T3$;

\item degree $\ell$ with $\ell$ prime: $C_\ell=\ell T1$ and $D_\ell=\ell T2$.

The groups $A_5$ and $A5(6)$ require the optional package \kbd{nflistdata}.

In addition, if $N$ is a polynomial, all transitive subgroups of $S_n$
with $n\le 15$, as well as alternating groups $A_n$ and the full symmetric group
$S_n$ for all $n$ (see below for details and explanations).

The groups are coded as $[n,k]$ using the \kbd{nTk} format where $n$ is the
degree and $k$ is the $T$-number, the index in the classification of
transitive subgroups of $S_n$.

Alternatively, the groups $C_n$, $D_n$,
$A_n$, $S_n$, $V_4$, $F_5 = M_{20}$, $M_{21}$ and $M_{42}$ can be input as
character strings exactly as written, lifting subscripts; for instance
\kbd{"S4"} or \kbd{"M21"}. If the group is not recognized or is
unsupported the function raises an exception.

The number fields are computed on the fly (and not from a preexisting table)
using a variety of algorithms, with the exception of $A_5$ and $A_5(6)$ which
are obtained by table lookup.
The algorithms are recursive and use the following ingredients: build
distinguished subfields (or resolvent fields in Galois closures) of smaller
degrees, use class field theory to build abelian extensions over a known
base, select subfields using Galois theory. Because of our use of class
field theory, and ultimately \kbd{bnfinit}, all results depend on the GRH in
degree $n > 3$.

To avoid wasting time, the output polynomials defining the number fields are
usually not the simplest possible, use \kbd{polredbest} or \kbd{polredabs}
to reduce them.

The non-negative integer $s$ specifies the number of complex places, between
$0$ and $n/2$. Additional supported values are:

\item $s = -1$ (default) all signatures;

\item $s = -2$ all signatures, given by increasing number of complex
places; in degree $n$, this means a vector with $1 + \text{floor}(n/2)$
components: the $i$-th entry corresponds to $s = i - 1$.

If the irreducible monic polynomial $F\in \Z[X]$ is specified, give only
number fields having $\Q[X]/(F)$ as a subfield, or in the case of
$S_3$, $D_\ell$, $A_4$, $S_4$, $F_5$, $M_{21}$ and $M_{42}$, as a resolvent
field (see also the function \kbd{nfresolvent} for these cases).

The parameter $N$ can be the following:

\item a positive integer: find all fields with absolute discriminant $N$
(recall that the discriminant over $\Q$ is $(-1)^s N$).

\item a pair of non-negative real numbers $[a,b]$ specifying a real interval:
find all fields with absolute value of discriminant between $a$ and $b$.
For most Galois groups, this is faster than iterating on individual $N$.

\item omitted (default): a few fields of small discriminant (not always
those with smallest absolute discriminant) are output with given $G$
and $s$; usually about 10, less if too difficult to find. The parameter
$F$ is ignored.

\item a polynomial with main variable, say $t$, of priority lower than $x$.
The program outputs a \emph{regular} polynomial in $\Q(t)[x]$ (in fact in
$\Z[x,t]$) with the given Galois group. By Hilbert irreducibility, almost all
specializations of $t$ will give suitable polynomials. The parameters $s$ and
$F$ are ignored. This is implemented for all transitive subgroups of
$S_n$ with $n\le15$ as well as for the alternating and symmetric groups $A_n$ and
$S_n$ for all $n$. Polynomials for $A_n$ were inspired by J.-F.~Mestre,
a few polynomials in degree $\leq 8$ come from G.~W.~Smith,
``Some polynomials over $\Q(t)$ and their
Galois groups'', \emph{Math. Comp.}, {\bf 69} (230), 1999, pp.~775--796
most others in degree $\leq 11$ were provided by J.~Kl\"uners and G.~Malle
(see G.~Malle and B.~H.~Matzat, \emph{Inverse Galois Theory}, Springer,
1999) and T.~Dokchitser completed the list up to degree~$15$. But for
$A_n$ and $S_n$, subgroups of $S_n$ for $n > 7$ require the optional
\kbd{nflistdata} package.

\misctitle{Complexity} : For a positive integer $N$, the complexity is
subexponential in $\log N$ (and involves factoring $N$). For an interval
$[a,b]$, the complexity is roughly as follows, ignoring terms which are
subexponential in $\log b$. It is usually linear in the output size.

\item $C_n$: $O(b^{1/\phi(n)})$ for $n = 2, 4, 6, 9$ or any odd prime;

\item $D_n$: $O(b^{2/\phi(n)})$ for $n = 4$ or any odd prime;

\item $V_4$, $A_4$: $O(b^{1/2})$, $S_4$: $O(b)$;
N.B. The subexponential terms are expensive for $A_4$ and $S_4$.

\item $M_{20}$: $O(b)$.

\item $S_4(6)^-$, $S_4(6)^+$ $A_4(6)\times C_2$, $S_3\times S_3$,
$S_4(6)\times C_2$ : $O(b)$,
$D_6(12)$, $A_4(6)$, $S_3(6)$, $S_3\times C_3$, $C_3^2:C_4$: $O(b^{1/2})$.

\item $M_{21}$, $M_{42}$: $O(b)$.

\item $C_3\times C_3$: $O(b^{1/3})$, $D_9$: $O(b^{5/12})$.

\bprog
? #nflist("S3", [1, 10^5]) \\ S3 cubic fields
%1 = 21794
? #nflist("S3", [1, 10^5], 0) \\ real S3 cubic fields (0 complex place)
%2 = 4753
? #nflist("S3", [1, 10^5], 1) \\ complex cubic fields (1 complex place)
%3 = 17041
? v = nflist("S3", [1, 10^5], -2); apply(length,v)
%4 = [4753, 17041]
? nflist("S4") \\ a few S4 fields
%5 = [x^4 + 12*x^2 - 8*x + 16, x^4 - 2*x^2 - 8*x + 25, ...]
? nflist("S4",,0) \\ a few real S4 fields
%6 = [x^4 - 52*x^2 - 56*x + 48, x^4 - 26*x^2 - 8*x + 1, ...]
? nflist("S4",,-2) \\ a few real S4 fields, by signature
%7 = [[x^4 - 52*x^2 - 56*x + 48, ...],
      [x^4 - 8*x - 16, ... ],
      [x^4 + 138*x^2 - 8*x + 4541, ...]]
? nflist("S3",,,x^2+23) \\ a few cubic fields with resolvent Q(sqrt(-23))
%8 = [x^3 + x + 1, x^3 + 2*x + 1, ...]
? nflist("C3", 3969) \\ C3 fields of given discriminant
%9 = [x^3 - 21*x + 28, x^3 - 21*x - 35]
? nflist([3,1], 3969) \\ C3 fields, using nTt label
%10 = [x^3 - 21*x + 28, x^3 - 21*x - 35]
? P = nflist([8,12],t) \\ geometric 8T12 polynomial
%11 = x^8 - 22*t*x^6 + 135*t^2*x^4 - 150*t^3*x^2 + t^4
? polgalois(subst(P, t, 11))
%12 = [24, 1, 12, "2A_4(8)=[2]A(4)=SL(2,3)"]
? nflist("S11")
 ***   at top-level: nflist("S11")
 ***                 ^-------------
 *** nflist: unsupported group (S11). Use one of
 "C1"=[1,1];
 "C2"=[2,1];
 "C3"=[3,1], "S3"=[3,2];
 "C4"=[4,1], "V4"=[4,2], "D4"=[4,3], "A4"=[4,4], "S4"=[4,5];
 "C5"=[5,1], "D5"=[5,2], "F5"="M20"=[5,3], "A5"=[5,4];
 "C6"=[6,1], "D6"=[6,2], [6,3], ..., [6,13];
 "C7"=[7,1], "D7"=[7,2], "M21"=[7,3], "M42"=[7,4];
 "C9"=[9,1], [9,2], "D9"=[9,3]."
 Also supported are "Cp"=[p,1] and "Dp"=[p,2] for any odd prime p.

? nflist("S25", 't)
%13 = x^25 + x*t + 1
@eprog

The library syntax is \fun{GEN}{nflist}{GEN G, GEN N = NULL, long s, GEN F = NULL}.

\subsec{nfmodpr$(\var{nf},x,\var{pr})$}\kbdsidx{nfmodpr}\label{se:nfmodpr}
Map $x$ to a \typ{FFELT} in the residue field modulo \var{pr}.
The argument \var{pr} is either a maximal ideal in \kbd{idealprimedec}
format or, preferably, a \var{modpr} structure from \tet{nfmodprinit}. The
function \tet{nfmodprlift} allows to lift back to $\Z_K$.

Note that the function applies to number field elements and not to
vector / matrices / polynomials of such. Use \kbd{apply} to convert
recursive structures.
\bprog
? K = nfinit(y^3-250);
? P = idealprimedec(K, 5)[2];
? modP = nfmodprinit(K, P, 't);
? K.zk
%4 = [1, 1/5*y, 1/25*y^2]
? apply(t->nfmodpr(K,t,modP), K.zk)
%5 = [1, t, 2*t + 1]
? %[1].mod
%6 = t^2 + 3*t + 4
? K.index
%7 = 125
@eprog\noindent For clarity, we represent elements in the residue
field $\F_5[t]/(T)$ as polynomials in the variable $t$. Whenever the
underlying rational prime does not divide \kbd{K.index}, it is actually
the case that $t$ is the reduction of $y$ in $\Q[y]/(\kbd{K.pol})$
modulo an irreducible factor of \kbd{K.pol} over $\F_p$. In the above
example, $5$ divides the index and $t$ is actually the reduction of $y/5$.

The library syntax is \fun{GEN}{nfmodpr}{GEN nf, GEN x, GEN pr}.

\subsec{nfmodprinit$(\var{nf},\var{pr}, \{v = \var{variable}(\var{nf}.\var{pol})\})$}\kbdsidx{nfmodprinit}\label{se:nfmodprinit}
Transforms the prime ideal \var{pr} into \tet{modpr} format necessary
for all operations modulo \var{pr} in the number field \var{nf}.
The functions \tet{nfmodpr} and \tet{nfmodprlift} allow to project
to and lift from the residue field. The variable $v$ is used to display
finite field elements (see \kbd{ffgen}).
\bprog
? K = nfinit(y^3-250);
? P = idealprimedec(K, 5)[2];
? modP = nfmodprinit(K, P, 't);
? K.zk
%4 = [1, 1/5*y, 1/25*y^2]
? apply(t->nfmodpr(K,t,modP), K.zk)
%5 = [1, t, 2*t + 1]
? %[1].mod
%6 = t^2 + 3*t + 4
? K.index
%7 = 125
@eprog\noindent For clarity, we represent elements in the residue
field $\F_5[t]/(T)$ as polynomials in the variable $t$. Whenever the
underlying rational prime does not divide \kbd{K.index}, it is actually
the case that $t$ is the reduction of $y$ in $\Q[y]/(\kbd{K.pol})$
modulo an irreducible factor of \kbd{K.pol} over $\F_p$. In the above
example, $5$ divides the index and $t$ is actually the reduction of $y/5$.

The library syntax is \fun{GEN}{nfmodprinit0}{GEN nf, GEN pr, long v) = -1} where \kbd{v)} is a variable number.

\subsec{nfmodprlift$(\var{nf},x,\var{pr})$}\kbdsidx{nfmodprlift}\label{se:nfmodprlift}
Lift the \typ{FFELT} $x$ (from \tet{nfmodpr}) in the residue field
modulo \var{pr} to the ring of integers. Vectors and matrices are also
supported. For polynomials, use \kbd{apply} and the present function.

The argument \var{pr} is either a maximal ideal in \kbd{idealprimedec}
format or, preferably, a \var{modpr} structure from \tet{nfmodprinit}.
There are no compatibility checks to try and decide whether $x$ is attached
the same residue field as defined by \var{pr}: the result is undefined
if not.

The function \tet{nfmodpr} allows to reduce to the residue field.
\bprog
? K = nfinit(y^3-250);
? P = idealprimedec(K, 5)[2];
? modP = nfmodprinit(K,P);
? K.zk
%4 = [1, 1/5*y, 1/25*y^2]
? apply(t->nfmodpr(K,t,modP), K.zk)
%5 = [1, y, 2*y + 1]
? nfmodprlift(K, %, modP)
%6 = [1, 1/5*y, 2/5*y + 1]
? nfeltval(K, %[3] - K.zk[3], P)
%7 = 1
@eprog

The library syntax is \fun{GEN}{nfmodprlift}{GEN nf, GEN x, GEN pr}.

\subsec{nfnewprec$(\var{nf})$}\kbdsidx{nfnewprec}\label{se:nfnewprec}
Transforms the number field $\var{nf}$
into the corresponding data using current (usually larger) precision. This
function works as expected if \var{nf} is in fact a \var{bnf} or a \var{bnr}
(update structure to current precision). \emph{If} the original
\var{bnf} structure was \emph{not} computed by \kbd{bnfinit(,1)}, then
this may be quite slow and even fail: many
generators of principal ideals have to be computed and the algorithm may
fail because the accuracy is not sufficient to bootstrap the
required generators and fundamental units.

The library syntax is \fun{GEN}{nfnewprec}{GEN nf, long prec}.
See also \fun{GEN}{bnfnewprec}{GEN bnf, long prec} and
\fun{GEN}{bnrnewprec}{GEN bnr, long prec}.

\subsec{nfpolsturm$(\var{nf}, T, \{\var{pl}\})$}\kbdsidx{nfpolsturm}\label{se:nfpolsturm}
Given a polynomial $T$ with coefficients in the number field \var{nf},
returns the number of real roots of the $s(T)$ where $s$ runs through
the real embeddings of the field specified by optional argument \var{pl}:

\item \var{pl} omitted: all $r_1$ real places;

\item \var{pl} an integer between $1$ and $r_1$: the embedding attached to
the $i$-th real root of \kbd{nf.pol}, i.e. \kbd{nf.roots$[i]$};

\item \var{pl} a vector or \typ{VECSMALL}: the embeddings
attached to the $\var{pl}[i]$-th real roots of \kbd{nf.pol}.

\bprog
? nf = nfinit('y^2 - 2);
? nf.sign
%2 = [2, 0]
? nf.roots
%3 = [-1.414..., 1.414...]
? T = x^2 + 'y;
? nfpolsturm(nf, T, 1) \\ subst(T,y,sqrt(2)) has two real roots
%5 = 2
? nfpolsturm(nf, T, 2) \\ subst(T,y,-sqrt(2)) has no real root
%6 = 0
? nfpolsturm(nf, T) \\ all embeddings together
%7 = [2, 0]
? nfpolsturm(nf, T, [2,1]) \\ second then first embedding
%8 = [0, 2]
? nfpolsturm(nf, x^3)  \\ number of distinct roots !
%9 = [1, 1]
? nfpolsturm(nf, x, 6) \\ there are only 2 real embeddings !
 ***   at top-level: nfpolsturm(nf,x,6)
 ***                 ^-----------------
 *** nfpolsturm: domain error in nfpolsturm: index > 2
@eprog

The library syntax is \fun{GEN}{nfpolsturm}{GEN nf, GEN T, GEN pl = NULL}.

\subsec{nfresolvent$(\var{pol},\{\fl=0\})$}\kbdsidx{nfresolvent}\label{se:nfresolvent}
Let \kbd{pol} be an irreducible integral polynomial defining a number
field $K$ with Galois closure $\tilde{K}$. This function is limited to the
Galois groups supported by \kbd{nflist}; in the following $\ell$ denotes an
odd prime. If $\text{Gal}(\tilde{K}/\Q)$ is $D_\ell$, $A_4$, $S_4$, $F_5$
($M_{20}$), $A_5$, $M_{21}$ or $M_{42}$,
return a polynomial $R$ defining the corresponding resolvent field (quadratic
for $D_\ell$, cyclic cubic for $A_4$ and $M_{21}$, noncyclic cubic for $S_4$,
cyclic quartic for $F_5$, $A_5(6)$ sextic for $A_5$, and cyclic sextic for
$M_{42}$). In the $A_5(6)$ case, return the $A_5$ field of which it is the
resolvent. Otherwise, give a ``canonical'' subfield, or $0$ if the Galois
group is not supported.

The binary digits of \fl\ correspond to 0: return a pair $[R,f]$ where $f$
is a ``conductor'' whose definition is specific to each group and given
below; 1: return all ``canonical'' subfields.

Let $D$ be the discriminant of the resolvent field \kbd{nfdisc}$(R)$:

\item In cases $C_\ell$, $D_\ell$, $A_4$, or $S_4$, $\text{disc}(K)
=(Df^2)^m$ with $m=(\ell-1)/2$ in the first two cases, and $1$ in the last
two.

\item In cases where $K$ is abelian over the resolvent subfield, the conductor
of the relative extension.

\item In case $F_5$, $\text{disc}(K)=Df^4$ if $f>0$ or $5^2Df^4$ if $f<0$.

\item In cases $M_{21}$ or $M_{42}$, $\text{disc}(K)=D^mf^6$ if $f>0$ or
$7^3D^mf^6$ if $f<0$, where $m=2$ for $M_{21}$ and $m=1$ for $M_{42}$.

\item In cases $A_5$ and $A_5(6)$, $\fl$ is currently ignored.

The library syntax is \fun{GEN}{nfresolvent}{GEN pol, long flag}.

\subsec{nfroots$(\{\var{nf}\},x)$}\kbdsidx{nfroots}\label{se:nfroots}
Roots of the polynomial $x$ in the
number field $\var{nf}$ given by \kbd{nfinit} without multiplicity (in $\Q$
if $\var{nf}$ is omitted). $x$ has coefficients in the number field (scalar,
polmod, polynomial, column vector). The main variable of $\var{nf}$ must be
of lower priority than that of $x$ (see \secref{se:priority}). However if the
coefficients of the number field occur explicitly (as polmods) as
coefficients of $x$, the variable of these polmods \emph{must} be the same as
the main variable of $t$ (see \kbd{nffactor}).

It is possible to input a defining polynomial for \var{nf}
instead, but this is in general less efficient since parts of an \kbd{nf}
structure will then be computed internally. This is useful in two
situations: when you do not need the \kbd{nf} elsewhere, or when you cannot
initialize an \kbd{nf} due to integer factorization difficulties when
attempting to compute the field discriminant and maximal order.

\misctitle{Caveat} \kbd{nfinit([T, listP])} allows to compute in polynomial
time a conditional \var{nf} structure, which sets \kbd{nf.zk} to an order
which is not guaranteed to be maximal at all primes. Always either use
\kbd{nfcertify} first (which may not run in polynomial time) or make sure
to input \kbd{nf.pol} instead of the conditional \var{nf}: \kbd{nfroots} is
able to recover in polynomial time in this case, instead of potentially
missing a factor.

The library syntax is \fun{GEN}{nfroots}{GEN nf = NULL, GEN x}.
See also \fun{GEN}{nfrootsQ}{GEN x},
corresponding to $\kbd{nf} = \kbd{NULL}$.

\subsec{nfrootsof1$(\var{nf})$}\kbdsidx{nfrootsof1}\label{se:nfrootsof1}
Returns a two-component vector $[w,z]$ where $w$ is the number of roots of
unity in the number field \var{nf}, and $z$ is a primitive $w$-th root
of unity. It is possible to input a defining polynomial for \var{nf}
instead.
\bprog
? K = nfinit(polcyclo(11));
? nfrootsof1(K)
%2 = [22, [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]~]
? z = nfbasistoalg(K, %[2])   \\ in algebraic form
%3 = Mod(-x^5, x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1)
? [lift(z^11), lift(z^2)]     \\ proves that the order of z is 22
%4 = [-1, -x^9 - x^8 - x^7 - x^6 - x^5 - x^4 - x^3 - x^2 - x - 1]
@eprog
This function guesses the number $w$ as the gcd of the $\#k(v)^*$ for
unramified $v$ above odd primes, then computes the roots in \var{nf}
of the $w$-th cyclotomic polynomial. The algorithm is polynomial time with
respect to the field degree and the bitsize of the multiplication table in
\var{nf} (both of them polynomially bounded in terms of the size of the
discriminant). Fields of degree up to $100$ or so should require less than
one minute.

The library syntax is \fun{GEN}{nfrootsof1}{GEN nf}.

\subsec{nfsnf$(\var{nf},x,\{\fl=0\})$}\kbdsidx{nfsnf}\label{se:nfsnf}
Given a torsion $\Z_K$-module $x$ attached to the square integral
invertible pseudo-matrix $(A,I,J)$, returns an ideal list
$D=[d_1,\dots,d_n]$ which is the \idx{Smith normal form} of $x$. In other
words, $x$ is isomorphic to $\Z_K/d_1\oplus\cdots\oplus\Z_K/d_n$ and $d_i$
divides $d_{i-1}$ for $i\ge2$. If $\fl$ is nonzero return $[D,U,V]$, where
$UAV$ is the identity.

See \secref{se:ZKmodules} for the definition of integral pseudo-matrix;
briefly, it is input as a 3-component row vector $[A,I,J]$ where
$I = [b_1,\dots,b_n]$ and $J = [a_1,\dots,a_n]$ are two ideal lists,
and $A$ is a square $n\times n$ matrix with columns $(A_1,\dots,A_n)$,
seen as elements in $K^n$ (with canonical basis $(e_1,\dots,e_n)$).
This data defines the $\Z_K$ module $x$ given by
$$ (b_1e_1\oplus\cdots\oplus b_ne_n) / (a_1A_1\oplus\cdots\oplus a_nA_n)
\enspace, $$
The integrality condition is $a_{i,j} \in b_i a_j^{-1}$ for all $i,j$. If it
is not satisfied, then the $d_i$ will not be integral. Note that every
finitely generated torsion module is isomorphic to a module of this form and
even with $b_i=Z_K$ for all $i$.

The library syntax is \fun{GEN}{nfsnf0}{GEN nf, GEN x, long flag}.
Also available:

\fun{GEN}{nfsnf}{GEN nf, GEN x} ($\fl = 0$).

\subsec{nfsolvemodpr$(\var{nf},a,b,P)$}\kbdsidx{nfsolvemodpr}\label{se:nfsolvemodpr}
This function is obsolete, use \kbd{nfmodpr}.

Let $P$ be a prime ideal in \key{modpr} format (see \kbd{nfmodprinit}),
let $a$ be a matrix, invertible over the residue field, and let $b$ be
a column vector or matrix. This function returns a solution of $a\cdot x =
b$; the coefficients of $x$ are lifted to \var{nf} elements.
\bprog
? K = nfinit(y^2+1);
? P = idealprimedec(K, 3)[1];
? P = nfmodprinit(K, P);
? a = [y+1, y; y, 0]; b = [1, y]~
? nfsolvemodpr(K, a,b, P)
%5 = [1, 2]~
@eprog

The library syntax is \fun{GEN}{nfsolvemodpr}{GEN nf, GEN a, GEN b, GEN P}.
This function is normally useless in library mode. Project your
inputs to the residue field using \kbd{nfM\_to\_FqM}, then work there.

\subsec{nfsplitting$(P,\{d\},\{\var{fl}\})$}\kbdsidx{nfsplitting}\label{se:nfsplitting}
Defining polynomial $S$ over~$\Q$ for the splitting field of
$\var{P}\in\Q[x]$, that is the smallest field over which $P$ is totally split.
If irreducible, the polynomial $P$ can also be given by a~\kbd{nf} structure,
which is more efficient. If $d$ is given, it must be a multiple of the
splitting field degree. Note that if $P$ is reducible the splitting field
degree can be smaller than the degree of $P$.

If $\fl$ is non-zero, we assume $P$ to be monic, integral and irreducible and
the return value depends on $\fl$:

\item $\fl = 1$: return $[S,C]$ where $S$ is as before and $C$ is an
embedding of $\Q[x]/(P)$ in its splitting field given by a polynomial
(implicitly modulo $S$, as in \kbd{nfisincl}).

\item $\fl = 2$: return $[S,C]$ where $C$ is vector of rationals functions
 whose image in $\Q[x]/(S)$ yields the embedding; this avoids inverting the
 denominator, which is costly. when the degree of the splitting field is huge.

\item $\fl = 3$: return $[S, v, p]$ a data structure allowing to quickly
compute the Galois group of the splitting field, which is used by
\kbd{galoissplittinginit}; more precisely, $p$ is a prime splitting
completely in the splitting field and $v$ is a vector with $\deg S$
elements describing the automorphisms of $S$ acting on the roots
of $S$ modulo $p$.

\bprog
? K = nfinit(x^3 - 2);
? nfsplitting(K)
%2 = x^6 + 108
? nfsplitting(x^8 - 2)
%3 = x^16 + 272*x^8 + 64
? S = nfsplitting(x^6 - 8) \\ reducible
%4 = x^4 + 2*x^2 + 4
? lift(nfroots(subst(S,x,a),x^6-8))
%5 = [-a, a, -1/2*a^3 - a, -1/2*a^3, 1/2*a^3, 1/2*a^3 + a]

? P = x^8-2;
? [S,C] = nfsplitting(P,,1)
%7 = [x^16 + 272*x^8 + 64, -7/768*x^13 - 239/96*x^5 + 1/2*x]
? subst(P, x, Mod(C,S))
%8 = Mod(0, x^16 + 272*x^8 + 64)
@eprog\noindent
Specifying the degree $d$ of the splitting field can make the computation
faster; if $d$ is not a multiple of the true degree, it will be ignored with
a warning.
\bprog
? nfsplitting(x^17-123);
time = 3,607 ms.
? poldegree(%)
%2 = 272
? nfsplitting(x^17-123,272);
time = 150 ms.
? nfsplitting(x^17-123,273);
 *** nfsplitting: Warning: ignoring incorrect degree bound 273
time = 3,611 ms.
@eprog
\noindent
The complexity of the algorithm is polynomial in the degree $d$ of the
splitting field and the bitsize of $T$; if $d$ is large the result will
likely be unusable, e.g. \kbd{nfinit} will not be an option:
\bprog
? nfsplitting(x^6-x-1)
[... degree 720 polynomial deleted ...]
time = 11,020 ms.
@eprog
Variant: Also available is
\fun{GEN}{nfsplitting}{GEN T, GEN D} for $\fl = 0$.

The library syntax is \fun{GEN}{nfsplitting0}{GEN P, GEN d = NULL, long fl}.

\subsec{nfsubfields$(\var{pol},\{d=0\},\{\var{fl}=0\})$}\kbdsidx{nfsubfields}\label{se:nfsubfields}
Finds all subfields of degree
$d$ of the number field defined by the (monic, integral) polynomial
\var{pol} (all subfields if $d$ is null or omitted). The result is a vector
of subfields, each being given by $[g,h]$ (default) or simply $g$ (\fl=1),
where $g$ is an absolute equation
and $h$ expresses one of the roots of $g$ in terms of the root $x$ of the
polynomial defining $\var{nf}$. This routine uses

\item Allombert's \tet{galoissubfields} when \var{nf} is Galois (with weakly
supersolvable Galois group).\sidx{Galois}\sidx{subfield}

\item Kl\"uners's or van Hoeij--Kl\"uners--Novocin algorithm
in the general case. The latter runs in polynomial time and is generally
superior unless there exists a small unramified prime $p$ such that \var{pol}
has few irreducible factors modulo $p$.

An input of the form~\kbd{[nf, fa]} is also allowed, where~\kbd{fa} is the
factorisation of~\var{nf.pol} over~\var{nf}, expressed as a famat of
polynomials with coefficients in the variable of~\kbd{nf}, in which case the van
Hoeij--Kl\"uners--Novocin algorithm is used.

\bprog
? pol = x^4 - x^3 - x^2 + x + 1;
? nfsubfields(pol)
%2 = [[x, 0], [x^2 - x + 1, x^3 - x^2 + 1], [x^4 - x^3 - x^2 + x + 1, x]]
? nfsubfields(pol,,1)
%2 = [x, x^2 - x + 1, x^4 - x^3 - x^2 + x + 1]
? y=varhigher("y"); fa = nffactor(pol,subst(pol,x,y));
? #nfsubfields([pol,fa])
%5 = 3
@eprog

The library syntax is \fun{GEN}{nfsubfields0}{GEN pol, long d, long fl}.
Also available is \fun{GEN}{nfsubfields}{GEN nf, long d}, corresponding
to \fl = 0.

\subsec{nfsubfieldscm$(\var{nf},\{\var{fl}=0\})$}\kbdsidx{nfsubfieldscm}\label{se:nfsubfieldscm}
Compute the maximal CM subfield of \var{nf}. Return $0$ if \var{nf} does
not have a CM subfield, otherwise return~$[g,h]$ (default) or $g$ (flag=1)
where~$g$ is an absolute
equation and~$h$ expresses a root of $g$ in terms of the generator of~\var{nf}.
Moreover, the CM involution is given by $X\bmod g(X) \mapsto -X\bmod g(X)$,
i.e. $X\bmod g(X)$ is a totally imaginary element.

An input of the form~\kbd{[nf, fa]} is also allowed, where~\kbd{fa} is the
factorisation of~\var{nf.pol} over~\var{nf}, and~\var{nf} is also allowed to
be a monic defining polynomial for the number field.

\bprog
? nf = nfinit(x^8 + 20*x^6 + 10*x^4 - 4*x^2 + 9);
? nfsubfieldscm(nf)
%2 = [x^4 + 4480*x^2 + 3612672, 3*x^5 + 58*x^3 + 5*x]
? pol = y^16-8*y^14+29*y^12-60*y^10+74*y^8-48*y^6+8*y^4+4*y^2+1;
? fa = nffactor(pol, subst(pol,y,x));
? nfsubfieldscm([pol,fa])
%5 = [y^8 + ... , ...]
@eprog

The library syntax is \fun{GEN}{nfsubfieldscm}{GEN nf, long fl}.

\subsec{nfsubfieldsmax$(\var{nf},\{\var{fl}=0\})$}\kbdsidx{nfsubfieldsmax}\label{se:nfsubfieldsmax}
Compute the list of maximal subfields of \var{nf}. The result is a vector
as in \tet{nfsubfields}.

An input of the form~\kbd{[nf, fa]} is also allowed, where~\kbd{fa} is the
factorisation of~\var{nf.pol} over~\var{nf}, and~\var{nf} is also allowed to
be a monic defining polynomial for the number field.

The library syntax is \fun{GEN}{nfsubfieldsmax}{GEN nf, long fl}.

\subsec{polcompositum$(P,Q,\{\fl=0\})$}\kbdsidx{polcompositum}\label{se:polcompositum}
\sidx{compositum} $P$ and $Q$
being squarefree polynomials in $\Z[X]$ in the same variable, outputs
the simple factors of the \'etale $\Q$-algebra $A = \Q(X, Y) / (P(X), Q(Y))$.
The factors are given by a list of polynomials $R$ in $\Z[X]$, attached to
the number field $\Q(X)/ (R)$, and sorted by increasing degree (with respect
to lexicographic ordering for factors of equal degrees). Returns an error if
one of the polynomials is not squarefree.

Note that it is more efficient to reduce to the case where $P$ and $Q$ are
irreducible first. The routine will not perform this for you, since it may be
expensive, and the inputs are irreducible in most applications anyway. In
this case, there will be a single factor $R$ if and only if the number
fields defined by $P$ and $Q$ are linearly disjoint (their intersection is
$\Q$).

Assuming $P$ is irreducible (of smaller degree than $Q$ for efficiency), it
is in general much faster to proceed as follows
\bprog
nf = nfinit(P); L = nffactor(nf, Q)[,1];
vector(#L, i, rnfequation(nf, L[i]))
@eprog\noindent
to obtain the same result. If you are only interested in the degrees of the
simple factors, the \kbd{rnfequation} instruction can be replaced by a
trivial \kbd{poldegree(P) * poldegree(L[i])}.

The binary digits of $\fl$ mean

1: outputs a vector of 4-component vectors $[R,a,b,k]$, where $R$
ranges through the list of all possible compositums as above, and $a$
(resp. $b$) expresses the root of $P$ (resp. $Q$) as an element of
$\Q(X)/(R)$. Finally, $k$ is a small integer such that $b + ka = X$ modulo
$R$.

2: assume that $P$ and $Q$ define number fields which are linearly disjoint:
both polynomials are irreducible and the corresponding number fields
have no common subfield besides $\Q$. This allows to save a costly
factorization over $\Q$. In this case return the single simple factor
instead of a vector with one element.

A compositum is often defined by a complicated polynomial, which it is
advisable to reduce before further work. Here is an example involving
the field $\Q(\zeta_5, 5^{1/5})$:
\bprog
? L = polcompositum(x^5 - 5, polcyclo(5), 1); \\@com list of $[R,a,b,k]$
? [R, a] = L[1];  \\@com pick the single factor, extract $R,a$ (ignore $b,k$)
? R               \\@com defines the compositum
%3 = x^20 + 5*x^19 + 15*x^18 + 35*x^17 + 70*x^16 + 141*x^15 + 260*x^14\
+ 355*x^13 + 95*x^12 - 1460*x^11 - 3279*x^10 - 3660*x^9 - 2005*x^8    \
+ 705*x^7 + 9210*x^6 + 13506*x^5 + 7145*x^4 - 2740*x^3 + 1040*x^2     \
- 320*x + 256
? a^5 - 5         \\@com a fifth root of $5$
%4 = 0
? [T, X] = polredbest(R, 1);
? T     \\@com simpler defining polynomial for $\Q[x]/(R)$
%6 = x^20 + 25*x^10 + 5
? X     \\ @com root of $R$ in $\Q[y]/(T(y))$
%7 = Mod(-1/11*x^15 - 1/11*x^14 + 1/22*x^10 - 47/22*x^5 - 29/11*x^4 + 7/22,\
x^20 + 25*x^10 + 5)
? a = subst(a.pol, 'x, X)  \\@com \kbd{a} in the new coordinates
%8 = Mod(1/11*x^14 + 29/11*x^4, x^20 + 25*x^10 + 5)
? a^5 - 5
%9 = 0
@eprog\noindent In the above example, $x^5-5$ and the $5$-th cyclotomic
polynomial are irreducible over $\Q$; they have coprime degrees so
define linearly disjoint extensions and we could have started by
\bprog
? [R,a] = polcompositum(x^5 - 5, polcyclo(5), 3); \\@com $[R,a,b,k]$
@eprog

The library syntax is \fun{GEN}{polcompositum0}{GEN P, GEN Q, long flag}.
Also available are
\fun{GEN}{compositum}{GEN P, GEN Q} ($\fl = 0$) and
\fun{GEN}{compositum2}{GEN P, GEN Q} ($\fl = 1$).

\subsec{polgalois$(T)$}\kbdsidx{polgalois}\label{se:polgalois}
\idx{Galois} group of the nonconstant
polynomial $T\in\Q[X]$. In the present version \vers, $T$ must be irreducible
and the degree $d$ of $T$ must be less than or equal to 7. If the
\tet{galdata} package has been installed, degrees 8, 9, 10 and 11 are also
implemented. By definition, if $K = \Q[x]/(T)$, this computes the action of
the Galois group of the Galois closure of $K$ on the $d$ distinct roots of
$T$, up to conjugacy (corresponding to different root orderings).

The output is a 4-component vector $[n,s,k,name]$ with the
following meaning: $n$ is the cardinality of the group, $s$ is its signature
($s=1$ if the group is a subgroup of the alternating group $A_d$, $s=-1$
otherwise) and name is a character string containing name of the transitive
group according to the GAP 4 transitive groups library by Alexander Hulpke.

$k$ is more arbitrary and the choice made up to version~2.2.3 of PARI is rather
unfortunate: for $d > 7$, $k$ is the numbering of the group among all
transitive subgroups of $S_d$, as given in ``The transitive groups of degree up
to eleven'', G.~Butler and J.~McKay, \emph{Communications in Algebra}, vol.~11,
1983,
pp.~863--911 (group $k$ is denoted $T_k$ there). And for $d \leq 7$, it was ad
hoc, so as to ensure that a given triple would denote a unique group.
Specifically, for polynomials of degree $d\leq 7$, the groups are coded as
follows, using standard notations
\smallskip
In degree 1: $S_1=[1,1,1]$.
\smallskip
In degree 2: $S_2=[2,-1,1]$.
\smallskip
In degree 3: $A_3=C_3=[3,1,1]$, $S_3=[6,-1,1]$.
\smallskip
In degree 4: $C_4=[4,-1,1]$, $V_4=[4,1,1]$, $D_4=[8,-1,1]$, $A_4=[12,1,1]$,
$S_4=[24,-1,1]$.
\smallskip
In degree 5: $C_5=[5,1,1]$, $D_5=[10,1,1]$, $M_{20}=[20,-1,1]$,
$A_5=[60,1,1]$, $S_5=[120,-1,1]$.
\smallskip
In degree 6: $C_6=[6,-1,1]$, $S_3=[6,-1,2]$, $D_6=[12,-1,1]$, $A_4=[12,1,1]$,
$G_{18}=[18,-1,1]$, $S_4^-=[24,-1,1]$, $A_4\times C_2=[24,-1,2]$,
$S_4^+=[24,1,1]$, $G_{36}^-=[36,-1,1]$, $G_{36}^+=[36,1,1]$,
$S_4\times C_2=[48,-1,1]$, $A_5=PSL_2(5)=[60,1,1]$, $G_{72}=[72,-1,1]$,
$S_5=PGL_2(5)=[120,-1,1]$, $A_6=[360,1,1]$, $S_6=[720,-1,1]$.
\smallskip
In degree 7: $C_7=[7,1,1]$, $D_7=[14,-1,1]$, $M_{21}=[21,1,1]$,
$M_{42}=[42,-1,1]$, $PSL_2(7)=PSL_3(2)=[168,1,1]$, $A_7=[2520,1,1]$,
$S_7=[5040,-1,1]$.
\smallskip
This is deprecated and obsolete, but for reasons of backward compatibility,
we cannot change this behavior yet. So you can use the default
\tet{new_galois_format} to switch to a consistent naming scheme, namely $k$ is
always the standard numbering of the group among all transitive subgroups of
$S_n$. If this default is in effect, the above groups will be coded as:
\smallskip
In degree 1: $S_1=[1,1,1]$.
\smallskip
In degree 2: $S_2=[2,-1,1]$.
\smallskip
In degree 3: $A_3=C_3=[3,1,1]$, $S_3=[6,-1,2]$.
\smallskip
In degree 4: $C_4=[4,-1,1]$, $V_4=[4,1,2]$, $D_4=[8,-1,3]$, $A_4=[12,1,4]$,
$S_4=[24,-1,5]$.
\smallskip
In degree 5: $C_5=[5,1,1]$, $D_5=[10,1,2]$, $M_{20}=[20,-1,3]$,
$A_5=[60,1,4]$, $S_5=[120,-1,5]$.
\smallskip
In degree 6: $C_6=[6,-1,1]$, $S_3=[6,-1,2]$, $D_6=[12,-1,3]$, $A_4=[12,1,4]$,
$G_{18}=[18,-1,5]$, $A_4\times C_2=[24,-1,6]$, $S_4^+=[24,1,7]$,
$S_4^-=[24,-1,8]$, $G_{36}^-=[36,-1,9]$, $G_{36}^+=[36,1,10]$,
$S_4\times C_2=[48,-1,11]$, $A_5=PSL_2(5)=[60,1,12]$, $G_{72}=[72,-1,13]$,
$S_5=PGL_2(5)=[120,-1,14]$, $A_6=[360,1,15]$, $S_6=[720,-1,16]$.
\smallskip
In degree 7: $C_7=[7,1,1]$, $D_7=[14,-1,2]$, $M_{21}=[21,1,3]$,
$M_{42}=[42,-1,4]$, $PSL_2(7)=PSL_3(2)=[168,1,5]$, $A_7=[2520,1,6]$,
$S_7=[5040,-1,7]$.
\smallskip

\misctitle{Warning} The method used is that of resolvent polynomials and is
sensitive to the current precision. The precision is updated internally but,
in very rare cases, a wrong result may be returned if the initial precision
was not sufficient.

The library syntax is \fun{GEN}{polgalois}{GEN T, long prec}.
To enable the new format in library mode,
set the global variable \tet{new_galois_format} to $1$.

\subsec{polred$(T,\{\fl=0\})$}\kbdsidx{polred}\label{se:polred}
This function is \emph{deprecated}, use \tet{polredbest} instead.
Finds polynomials with reasonably small coefficients defining subfields of
the number field defined by $T$. One of the polynomials always defines $\Q$
(hence has degree $1$), and another always defines the same number field
as $T$ if $T$ is irreducible.

All $T$ accepted by \tet{nfinit} are also allowed here;
in particular, the format \kbd{[T, listP]} is recommended, e.g. with
$\kbd{listP} = 10^5$ or a vector containing all ramified primes. Otherwise,
the maximal order of $\Q[x]/(T)$ must be computed.

The following binary digits of $\fl$ are significant:

1: Possibly use a suborder of the maximal order. The
primes dividing the index of the order chosen are larger than
\tet{primelimit} or divide integers stored in the \tet{addprimes} table.
This flag is \emph{deprecated}, the \kbd{[T, listP]} format is more
flexible.

2: gives also elements. The result is a two-column matrix, the first column
giving primitive elements defining these subfields, the second giving the
corresponding minimal polynomials.
\bprog
? M = polred(x^4 + 8, 2)
%1 =
[           1         x - 1]

[ 1/2*x^2 + 1 x^2 - 2*x + 3]

[-1/2*x^2 + 1 x^2 - 2*x + 3]

[     1/2*x^2       x^2 + 2]

[     1/4*x^3       x^4 + 2]
? minpoly(Mod(M[2,1], x^4+8))
%2 = x^2 + 2
@eprog

\synt{polred}{GEN T} ($\fl = 0$). Also available is
\fun{GEN}{polred2}{GEN T} ($\fl = 2$). The function \kbd{polred0} is
deprecated, provided for backward compatibility.

\subsec{polredabs$(T,\{\fl=0\})$}\kbdsidx{polredabs}\label{se:polredabs}
Returns a canonical defining polynomial $P$ for the number field
$\Q[X]/(T)$ defined by $T$, such that the sum of the squares of the modulus
of the roots (i.e.~the $T_2$-norm) is minimal. Different $T$ defining
isomorphic number fields will yield the same $P$. All $T$ accepted by
\tet{nfinit} are also allowed here, e.g. nonmonic polynomials, or pairs
\kbd{[T, listP]} specifying that a nonmaximal order may be used. For
convenience, any number field structure (\var{nf}, \var{bnf},\dots) can also
be used instead of $T$.
\bprog
? polredabs(x^2 + 16)
%1 = x^2 + 1
? K = bnfinit(x^2 + 16); polredabs(K)
%2 = x^2 + 1
@eprog

\misctitle{Warning 1} Using a \typ{POL} $T$ requires computing
and fully factoring the discriminant $d_K$ of the maximal order which may be
very hard. You can use the format \kbd{[T, listP]}, where \kbd{listP}
encodes a list of known coprime divisors of $\disc(T)$ (see \kbd{??nfbasis}),
to help the routine, thereby replacing this part of the algorithm by a
polynomial time computation But this may only compute a suborder of the
maximal order, when the divisors are not squarefree or do not include all
primes dividing $d_K$. The routine attempts to certify the result
independently of this order computation as per \tet{nfcertify}: we try to
prove that the computed order is maximal. If the certification fails,
the routine then fully factors the integers returned by \kbd{nfcertify}.
You can also use \tet{polredbest} to avoid this factorization step; in this
case, the result is small but no longer canonical.

\misctitle{Warning 2} Apart from the factorization of the discriminant of
$T$, this routine runs in polynomial time for a \emph{fixed} degree.
But the complexity is exponential in the degree: this routine
may be exceedingly slow when the number field has many subfields, hence a
lot of elements of small $T_2$-norm. If you do not need a canonical
polynomial, the function \tet{polredbest} is in general much faster (it runs
in polynomial time), and tends to return polynomials with smaller
discriminants.

The binary digits of $\fl$ mean

1: outputs a two-component row vector $[P,a]$, where $P$ is the default
output and \kbd{Mod(a, P)} is a root of the original $T$.

4: gives \emph{all} polynomials of minimal $T_2$ norm; of the two polynomials
$P(x)$ and $\pm P(-x)$, only one is given.

16: (OBSOLETE) Possibly use a suborder of the maximal order, \emph{without}
attempting to certify the result as in Warning 1. This makes \kbd{polredabs}
behave like \kbd{polredbest}. Just use the latter.

\bprog
? T = x^16 - 136*x^14 + 6476*x^12 - 141912*x^10 + 1513334*x^8 \
      - 7453176*x^6 + 13950764*x^4 - 5596840*x^2 + 46225
? T1 = polredabs(T); T2 = polredbest(T);
? [ norml2(polroots(T1)), norml2(polroots(T2)) ]
%3 = [88.0000000, 120.000000]
? [ sizedigit(poldisc(T1)), sizedigit(poldisc(T2)) ]
%4 = [75, 67]
@eprog

The precise definition of the output of \tet{polredabs} is as follows.

\item Consider the finite list of characteristic polynomials of primitive
elements of~$K$ that are in~$\Z_K$ and minimal for the~$T_2$ norm;
now remove from the list the polynomials whose discriminant do not have
minimal absolute value. Note that this condition is restricted to the
original list of polynomials with minimal $T_2$ norm and does not imply that
the defining polynomial for the field with smallest discriminant belongs to
the list !

\item To a polynomial $P(x) = x^n + \dots + a_n \in \R[x]$ we attach
the sequence $S(P)$ given by $|a_1|, a_1, \dots, |a_n|, a_n$.
Order the polynomials $P$ by the lexicographic order on the coefficient
vectors $S(P)$. Then the output of \tet{polredabs} is the smallest
polynomial in the above list for that order. In other words, the monic
polynomial which is lexicographically smallest with respect to the absolute
values of coefficients, favouring negative coefficients to break ties, i.e.
choosing $x^3-2$ rather than $x^3+2$.

The library syntax is \fun{GEN}{polredabs0}{GEN T, long flag}.
Instead of the above hardcoded numerical flags, one should use an
or-ed combination of

\item \tet{nf_PARTIALFACT} (OBSOLETE): possibly use a suborder of the maximal
order, \emph{without} attempting to certify the result.

\item \tet{nf_ORIG}: return $[P, a]$, where \kbd{Mod(a, P)} is a root of $T$.

\item \tet{nf_RAW}: return $[P, b]$, where \kbd{Mod(b, T)} is a root of $P$.
The algebraic integer $b$ is the raw result produced by the small vectors
enumeration in the maximal order; $P$ was computed as the characteristic
polynomial of \kbd{Mod(b, T)}. \kbd{Mod(a, P)} as in \tet{nf_ORIG}
is obtained with \tet{modreverse}.

\item \tet{nf_ADDZK}: if $r$ is the result produced with some of the above
flags (of the form $P$ or $[P,c]$), return \kbd{[r,zk]}, where \kbd{zk} is a
$\Z$-basis for the maximal order of $\Q[X]/(P)$.

\item \tet{nf_ALL}: return a vector of results of the above form, for all
polynomials of minimal $T_2$-norm.

\subsec{polredbest$(T,\{\fl=0\})$}\kbdsidx{polredbest}\label{se:polredbest}
Finds a polynomial with reasonably
small coefficients defining the same number field as $T$.
All $T$ accepted by \tet{nfinit} are also allowed here (e.g. nonmonic
polynomials, \kbd{nf}, \kbd{bnf}, \kbd{[T,Z\_K\_basis]}). Contrary to
\tet{polredabs}, this routine runs in polynomial time, but it offers no
guarantee as to the minimality of its result.

This routine computes an LLL-reduced basis for an order in $\Q[X]/(T)$, then
examines small linear combinations of the basis vectors, computing their
characteristic polynomials. It returns the \emph{separable} polynomial $P$ of
smallest discriminant, the one with lexicographically smallest
\kbd{abs(Vec(P))} in case of ties. This is a good candidate for subsequent
number field computations since it guarantees that the denominators of
algebraic integers, when expressed in the power basis, are reasonably small.
With no claim of minimality, though.

It can happen that iterating this functions yields better and better
polynomials, until it stabilizes:
\bprog
? \p5
? P = X^12+8*X^8-50*X^6+16*X^4-3069*X^2+625;
? poldisc(P)*1.
%2 = 1.2622 E55
? P = polredbest(P);
? poldisc(P)*1.
%4 = 2.9012 E51
? P = polredbest(P);
? poldisc(P)*1.
%6 = 8.8704 E44
@eprog\noindent In this example, the initial polynomial $P$ is the one
returned by \tet{polredabs}, and the last one is stable.

If $\fl = 1$: outputs a two-component row vector $[P,a]$,  where $P$ is the
default output and \kbd{Mod(a, P)} is a root of the original $T$.
\bprog
? [P,a] = polredbest(x^4 + 8, 1)
%1 = [x^4 + 2, Mod(x^3, x^4 + 2)]
? charpoly(a)
%2 = x^4 + 8
@eprog\noindent In particular, the map $\Q[x]/(T) \to \Q[x]/(P)$,
$x\mapsto \kbd{Mod(a,P)}$ defines an isomorphism of number fields, which can
be computed as
\bprog
  subst(lift(Q), 'x, a)
@eprog\noindent if $Q$ is a \typ{POLMOD} modulo $T$; \kbd{b = modreverse(a)}
returns a \typ{POLMOD} giving the inverse of the above map (which should be
useless since $\Q[x]/(P)$ is a priori a better representation for the number
field and its elements).

The library syntax is \fun{GEN}{polredbest}{GEN T, long flag}.

\subsec{polredord$(x)$}\kbdsidx{polredord}\label{se:polredord}
This function is obsolete, use polredbest.

The library syntax is \fun{GEN}{polredord}{GEN x}.

\subsec{poltschirnhaus$(x)$}\kbdsidx{poltschirnhaus}\label{se:poltschirnhaus}
Applies a random Tschirnhausen
transformation to the polynomial $x$, which is assumed to be nonconstant
and separable, so as to obtain a new equation for the \'etale algebra
defined by $x$. This is for instance useful when computing resolvents,
hence is used by the \kbd{polgalois} function.

The library syntax is \fun{GEN}{tschirnhaus}{GEN x}.

\subsec{rnfalgtobasis$(\var{rnf},x)$}\kbdsidx{rnfalgtobasis}\label{se:rnfalgtobasis}
Expresses $x$ on the relative
integral basis. Here, $\var{rnf}$ is a relative number field extension $L/K$
as output by \kbd{rnfinit}, and $x$ an element of $L$ in absolute form, i.e.
expressed as a polynomial or polmod with polmod coefficients, \emph{not} on
the relative integral basis.

The library syntax is \fun{GEN}{rnfalgtobasis}{GEN rnf, GEN x}.

\subsec{rnfbasis$(\var{bnf},M)$}\kbdsidx{rnfbasis}\label{se:rnfbasis}
Let $K$ the field represented by
\var{bnf}, as output by \kbd{bnfinit}. $M$ is a projective $\Z_K$-module
of rank $n$ ($M\otimes K$ is an $n$-dimensional $K$-vector space), given by a
pseudo-basis of size $n$. The routine returns either a true $\Z_K$-basis of
$M$ (of size $n$) if it exists, or an $n+1$-element generating set of $M$ if
not.

It is allowed to use a monic irreducible polynomial $P$ in $K[X]$ instead of
$M$, in which case, $M$ is defined as the ring of integers of $K[X]/(P)$,
viewed as a $\Z_K$-module.

\misctitle{Huge discriminants, helping rnfdisc} The format $[T,B]$ is
also accepted instead of $T$ and computes an order which is maximal at all
maximal ideals specified by $B$, see \kbd{??rnfinit}: the valuation of $D$ is
then correct at all such maximal ideals but may be incorrect at other primes.

The library syntax is \fun{GEN}{rnfbasis}{GEN bnf, GEN M}.

\subsec{rnfbasistoalg$(\var{rnf},x)$}\kbdsidx{rnfbasistoalg}\label{se:rnfbasistoalg}
Computes the representation of $x$
as a polmod with polmods coefficients. Here, $\var{rnf}$ is a relative number
field extension $L/K$ as output by \kbd{rnfinit}, and $x$ an element of
$L$ expressed on the relative integral basis.

The library syntax is \fun{GEN}{rnfbasistoalg}{GEN rnf, GEN x}.

\subsec{rnfcharpoly$(\var{nf},T,a,\{\var{var}='x\})$}\kbdsidx{rnfcharpoly}\label{se:rnfcharpoly}
Characteristic polynomial of
$a$ over $\var{nf}$, where $a$ belongs to the algebra defined by $T$ over
$\var{nf}$, i.e.~$\var{nf}[X]/(T)$. Returns a polynomial in variable $v$
($x$ by default).
\bprog
? nf = nfinit(y^2+1);
? rnfcharpoly(nf, x^2+y*x+1, x+y)
%2 = x^2 + Mod(-y, y^2 + 1)*x + 1
@eprog

The library syntax is \fun{GEN}{rnfcharpoly}{GEN nf, GEN T, GEN a, long var = -1} where \kbd{var} is a variable number.

\subsec{rnfconductor$(\var{bnf},T,\{\fl=0\})$}\kbdsidx{rnfconductor}\label{se:rnfconductor}
Given a \var{bnf} structure attached to a number field $K$, as produced
by \kbd{bnfinit}, and $T$ an irreducible polynomial in $K[x]$
defining an \idx{Abelian extension} $L = K[x]/(T)$, computes the class field
theory conductor of this Abelian extension. If $T$ does not define an Abelian
extension over $K$, the result is undefined; it may be the integer $0$ (in
which case the extension is definitely not Abelian) or a wrong result.

The result is a 3-component vector $[f,\var{bnr},H]$, where $f$ is the
conductor of the extension given as a 2-component row vector $[f_0,f_\infty]$,
\var{bnr} is the attached \kbd{bnr} structure and $H$ is a matrix in HNF
defining the subgroup of the ray class group on the ray class group generators
\kbd{bnr.gen}; in particular, it is a left divisor of the diagonal matrix
attached to \kbd{bnr.cyc} and $|\det H| = N = \deg T$.

\item If \fl\ is $1$, return $[f,\var{bnrmod}, H]$, where
\kbd{bnrmod} is now attached to $\text{Cl}_f / \text{Cl}_f^N$, and $H$ is as
before since it contains the $N$-th powers. This is useful when $f$ contains
a maximal ideal with huge residue field, since the corresponding tough
discrete logarithms are trivialized: in the quotient group, all elements have
small order dividing $N$. This allows to work in $\text{Cl}_f/H$ but no
longer in $\text{Cl}_f$.

\item If \fl\ is $2$, only return $[f, \kbd{fa}]$ where \kbd{fa} is the
factorization of the conductor finite part ($=f[1]$).

\misctitle{Huge discriminants, helping rnfdisc} The format $[T,B]$ is
also accepted instead of $T$ and computes the conductor of the extension
provided it factors completely over the maximal ideals specified by $B$,
see \kbd{??rnfinit}: the valuation of $f_0$ is then correct at all such
maximal ideals but may be incorrect at other primes.

The library syntax is \fun{GEN}{rnfconductor0}{GEN bnf, GEN T, long flag}.
Also available is \fun{GEN}{rnfconductor}{GEN bnf, GEN T} when $\fl =
0$.

\subsec{rnfdedekind$(\var{nf},\var{pol},\{\var{pr}\},\{\fl=0\})$}\kbdsidx{rnfdedekind}\label{se:rnfdedekind}
Given a number field $K$ coded by $\var{nf}$ and a monic
polynomial $P\in \Z_K[X]$, irreducible over $K$ and thus defining a relative
extension $L$ of $K$, applies \idx{Dedekind}'s criterion to the order
$\Z_K[X]/(P)$, at the prime ideal \var{pr}. It is possible to set \var{pr}
to a vector of prime ideals (test maximality at all primes in the vector),
or to omit altogether, in which case maximality at \emph{all} primes is tested;
in this situation \fl\ is automatically set to $1$.

The default historic behavior (\fl\ is 0 or omitted and \var{pr} is a
single prime ideal) is not so useful since
\kbd{rnfpseudobasis} gives more information and is generally not that
much slower. It returns a 3-component vector $[\var{max}, \var{basis}, v]$:

\item \var{basis} is a pseudo-basis of an enlarged order $O$ produced by
Dedekind's criterion, containing the original order $\Z_K[X]/(P)$
with index a power of \var{pr}. Possibly equal to the original order.

\item \var{max} is a flag equal to 1 if the enlarged order $O$
could be proven to be \var{pr}-maximal and to 0 otherwise; it may still be
maximal in the latter case if \var{pr} is ramified in $L$,

\item $v$ is the valuation at \var{pr} of the order discriminant.

If \fl\ is nonzero, on the other hand, we just return $1$ if the order
$\Z_K[X]/(P)$ is \var{pr}-maximal (resp.~maximal at all relevant primes, as
described above), and $0$ if not. This is much faster than the default,
since the enlarged order is not computed.
\bprog
? nf = nfinit(y^2-3); P = x^3 - 2*y;
? pr3 = idealprimedec(nf,3)[1];
? rnfdedekind(nf, P, pr3)
%3 = [1, [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, 1]], 8]
? rnfdedekind(nf, P, pr3, 1)
%4 = 1
@eprog\noindent In this example, \kbd{pr3} is the ramified ideal above $3$,
and the order generated by the cube roots of $y$ is already
\kbd{pr3}-maximal. The order-discriminant has valuation $8$. On the other
hand, the order is not maximal at the prime above 2:
\bprog
? pr2 = idealprimedec(nf,2)[1];
? rnfdedekind(nf, P, pr2, 1)
%6 = 0
? rnfdedekind(nf, P, pr2)
%7 = [0, [[2, 0, 0; 0, 1, 0; 0, 0, 1], [[1, 0; 0, 1], [1, 0; 0, 1],
     [1, 1/2; 0, 1/2]]], 2]
@eprog
The enlarged order is not proven to be \kbd{pr2}-maximal yet. In fact, it
is; it is in fact the maximal order:
\bprog
? B = rnfpseudobasis(nf, P)
%8 = [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, [1, 1/2; 0, 1/2]],
     [162, 0; 0, 162], -1]
? idealval(nf,B[3], pr2)
%9 = 2
@eprog\noindent
It is possible to use this routine with nonmonic
$P = \sum_{i\leq n} p_i X^i \in \Z_K[X]$ if $\fl = 1$;
in this case, we test maximality of Dedekind's order generated by
$$1, p_n \alpha, p_n\alpha^2 + p_{n-1}\alpha, \dots,
p_n\alpha^{n-1} + p_{n-1}\alpha^{n-2} + \cdots + p_1\alpha.$$
The routine will fail if $P$ vanishes on the projective line over the residue
field $\Z_K/\kbd{pr}$ (FIXME).

The library syntax is \fun{GEN}{rnfdedekind}{GEN nf, GEN pol, GEN pr = NULL, long flag}.

\subsec{rnfdet$(\var{nf},M)$}\kbdsidx{rnfdet}\label{se:rnfdet}
Given a pseudo-matrix $M$ over the maximal
order of $\var{nf}$, computes its determinant.

The library syntax is \fun{GEN}{rnfdet}{GEN nf, GEN M}.

\subsec{rnfdisc$(\var{nf},T)$}\kbdsidx{rnfdisc}\label{se:rnfdisc}
Given an \var{nf} structure attached to a number field $K$, as output
by \kbd{nfinit}, and a monic irreducible polynomial $T\in K[x]$ defining a
relative extension $L = K[x]/(T)$, compute the relative discriminant of $L$.
This is a vector $[D,d]$, where $D$ is the relative ideal discriminant and
$d$ is the relative discriminant considered as an element of $K^*/{K^*}^2$.
The main variable of $\var{nf}$ \emph{must} be of lower priority than that of
$T$, see \secref{se:priority}.

\misctitle{Huge discriminants, helping rnfdisc} The format $[T,B]$ is
also accepted instead of $T$ and computes an order which is maximal at all
maximal ideals specified by $B$, see \kbd{??rnfinit}: the valuation of $D$ is
then correct at all such maximal ideals but may be incorrect at other primes.

The library syntax is \fun{GEN}{rnfdiscf}{GEN nf, GEN T}.

\subsec{rnfeltabstorel$(\var{rnf},x)$}\kbdsidx{rnfeltabstorel}\label{se:rnfeltabstorel}
Let $\var{rnf}$ be a relative
number field extension $L/K$ as output by \kbd{rnfinit} and let $x$ be an
element of $L$ expressed as a polynomial modulo the absolute equation
\kbd{\var{rnf}.pol}, or in terms of the absolute $\Z$-basis for $\Z_L$
if \var{rnf} contains one (as in \kbd{rnfinit(nf,pol,1)}, or after
a call to \kbd{nfinit(rnf)}).
Computes $x$ as an element of the relative extension
$L/K$ as a polmod with polmod coefficients.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.polabs
%2 = x^4 + 1
? rnfeltabstorel(L, Mod(x, L.polabs))
%3 = Mod(x, x^2 + Mod(-y, y^2 + 1))
? rnfeltabstorel(L, 1/3)
%4 = 1/3
? rnfeltabstorel(L, Mod(x, x^2-y))
%5 = Mod(x, x^2 + Mod(-y, y^2 + 1))

? rnfeltabstorel(L, [0,0,0,1]~) \\ Z_L not initialized yet
 ***   at top-level: rnfeltabstorel(L,[0,
 ***                 ^--------------------
 *** rnfeltabstorel: incorrect type in rnfeltabstorel, apply nfinit(rnf).
? nfinit(L); \\ initialize now
? rnfeltabstorel(L, [0,0,0,1]~)
%6 = Mod(Mod(y, y^2 + 1)*x, x^2 + Mod(-y, y^2 + 1))
@eprog

The library syntax is \fun{GEN}{rnfeltabstorel}{GEN rnf, GEN x}.

\subsec{rnfeltdown$(\var{rnf},x,\{\fl=0\})$}\kbdsidx{rnfeltdown}\label{se:rnfeltdown}
$\var{rnf}$ being a relative number
field extension $L/K$ as output by \kbd{rnfinit} and $x$ being an element of
$L$ expressed as a polynomial or polmod with polmod coefficients (or as a
\typ{COL} on \kbd{nfinit(rnf).zk}), computes
$x$ as an element of $K$ as a \typ{POLMOD} if $\fl = 0$ and as a \typ{COL}
otherwise. If $x$ is not in $K$, a domain error occurs.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltdown(L, Mod(x^2, L.pol))
%3 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(x^2, L.pol), 1)
%4 = [0, 1]~
? rnfeltdown(L, Mod(y, x^2-y))
%5 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(y,K.pol))
%6 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(x, L.pol))
 ***   at top-level: rnfeltdown(L,Mod(x,x
 ***                 ^--------------------
 *** rnfeltdown: domain error in rnfeltdown: element not in the base field
? rnfeltdown(L, Mod(y, x^2-y), 1) \\ as a t_COL
%7 = [0, 1]~
? rnfeltdown(L, [0,1,0,0]~) \\ not allowed without absolute nf struct
  *** rnfeltdown: incorrect type in rnfeltdown (t_COL).
? nfinit(L); \\ add absolute nf structure to L
? rnfeltdown(L, [0,1,0,0]~) \\ now OK
%8 = Mod(y, y^2 + 1)
@eprog\noindent If we had started with
\kbd{L = rnfinit(K, x\pow2-y, 1)}, then the final would have worked directly.

The library syntax is \fun{GEN}{rnfeltdown0}{GEN rnf, GEN x, long flag}.
Also available is
\fun{GEN}{rnfeltdown}{GEN rnf, GEN x} ($\fl = 0$).

\subsec{rnfeltnorm$(\var{rnf},x)$}\kbdsidx{rnfeltnorm}\label{se:rnfeltnorm}
$\var{rnf}$ being a relative number field extension $L/K$ as output by
\kbd{rnfinit} and $x$ being an element of $L$, returns the relative norm
$N_{L/K}(x)$ as an element of $K$.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? rnfeltnorm(L, Mod(x, L.pol))
%2 = Mod(x, x^2 + Mod(-y, y^2 + 1))
? rnfeltnorm(L, 2)
%3 = 4
? rnfeltnorm(L, Mod(x, x^2-y))
@eprog

The library syntax is \fun{GEN}{rnfeltnorm}{GEN rnf, GEN x}.

\subsec{rnfeltreltoabs$(\var{rnf},x)$}\kbdsidx{rnfeltreltoabs}\label{se:rnfeltreltoabs}
$\var{rnf}$ being a relative
number field extension $L/K$ as output by \kbd{rnfinit} and $x$ being an
element of $L$ expressed as a polynomial or polmod with polmod
coefficients, computes $x$ as an element of the absolute extension $L/\Q$ as
a polynomial modulo the absolute equation \kbd{\var{rnf}.pol}.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltreltoabs(L, Mod(x, L.pol))
%3 = Mod(x, x^4 + 1)
? rnfeltreltoabs(L, Mod(y, x^2-y))
%4 = Mod(x^2, x^4 + 1)
? rnfeltreltoabs(L, Mod(y,K.pol))
%5 = Mod(x^2, x^4 + 1)
@eprog

The library syntax is \fun{GEN}{rnfeltreltoabs}{GEN rnf, GEN x}.

\subsec{rnfelttrace$(\var{rnf},x)$}\kbdsidx{rnfelttrace}\label{se:rnfelttrace}
$\var{rnf}$ being a relative number field extension $L/K$ as output by
\kbd{rnfinit} and $x$ being an element of $L$, returns the relative trace
$Tr_{L/K}(x)$ as an element of $K$.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? rnfelttrace(L, Mod(x, L.pol))
%2 = 0
? rnfelttrace(L, 2)
%3 = 4
? rnfelttrace(L, Mod(x, x^2-y))
@eprog

The library syntax is \fun{GEN}{rnfelttrace}{GEN rnf, GEN x}.

\subsec{rnfeltup$(\var{rnf},x,\{\fl=0\})$}\kbdsidx{rnfeltup}\label{se:rnfeltup}
$\var{rnf}$ being a relative number field extension $L/K$ as output by
\kbd{rnfinit} and $x$ being an element of $K$, computes $x$ as an element of
the absolute extension $L/\Q$. As a \typ{POLMOD} modulo \kbd{\var{rnf}.pol}
if $\fl = 0$ and as a \typ{COL} on the absolute field integer basis if
$\fl = 1$.
\bprog
? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltup(L, Mod(y, K.pol))
%3 = Mod(x^2, x^4 + 1)
? rnfeltup(L, y)
%4 = Mod(x^2, x^4 + 1)
? rnfeltup(L, [1,2]~) \\ in terms of K.zk
%5 = Mod(2*x^2 + 1, x^4 + 1)
? rnfeltup(L, y, 1) \\ in terms of nfinit(L).zk
%6 = [0, 1, 0, 0]~
? rnfeltup(L, [1,2]~, 1)
%7 = [1, 2, 0, 0]~
@eprog

The library syntax is \fun{GEN}{rnfeltup0}{GEN rnf, GEN x, long flag}.

\subsec{rnfequation$(\var{nf},\var{pol},\{\fl=0\})$}\kbdsidx{rnfequation}\label{se:rnfequation}
Given a number field $\var{nf}$ as output by \kbd{nfinit}
(or simply a monic irreducible integral polynomial defining the field)
and a polynomial \var{pol} with coefficients in $\var{nf}$ defining a
relative extension $L$ of $\var{nf}$, computes an absolute equation of $L$
over $\Q$.

The main variable of $\var{nf}$ \emph{must} be of lower priority than that
of \var{pol} (see \secref{se:priority}). Note that for efficiency, this does
not check whether the relative equation is irreducible over $\var{nf}$, but
only if it is squarefree. If it is reducible but squarefree, the result will
be the absolute equation of the \'etale algebra defined by \var{pol}. If
\var{pol} is not squarefree, raise an \kbd{e\_DOMAIN} exception.
\bprog
? rnfequation(y^2+1, x^2 - y)
%1 = x^4 + 1
? T = y^3-2; rnfequation(nfinit(T), (x^3-2)/(x-Mod(y,T)))
%2 = x^6 + 108  \\ Galois closure of Q(2^(1/3))
@eprog

If $\fl$ is nonzero, outputs a 3-component row vector $[z,a,k]$, where

\item $z$ is the absolute equation of $L$ over $\Q$, as in the default
behavior,

\item $a$ expresses as a \typ{POLMOD} modulo $z$ a root $\alpha$ of the
polynomial defining the base field $\var{nf}$,

\item $k$ is a small integer such that $\theta = \beta+k\alpha$
is a root of $z$, where $\beta$ is a root of $\var{pol}$. It is guaranteed
that $k=0$ whenever $\Q(\beta) = L$.
\bprog
? T = y^3-2; pol = x^2 +x*y + y^2;
? [z,a,k] = rnfequation(T, pol, 1);
? z
%3 = x^6 + 108
? subst(T, y, a)
%4 = 0
? alpha= Mod(y, T);
? beta = Mod(x*Mod(1,T), pol);
? subst(z, x, beta + k*alpha)
%7 = 0
@eprog

The library syntax is \fun{GEN}{rnfequation0}{GEN nf, GEN pol, long flag}.
Also available are
\fun{GEN}{rnfequation}{GEN nf, GEN pol} ($\fl = 0$) and
\fun{GEN}{rnfequation2}{GEN nf, GEN pol} ($\fl = 1$).

\subsec{rnfhnfbasis$(\var{bnf},M)$}\kbdsidx{rnfhnfbasis}\label{se:rnfhnfbasis}
Given a \var{bnf} attached to a number field $K$ and a projective
$\Z_K$-module $M$ given by a pseudo-matrix, returns either a true HNF basis
of $M$ if one exists, or zero otherwise. If $M$ is a polynomial with
coefficients in $K$, replace it by the pseudo-matrix returned by
\kbd{rnfpseudobasis}.

The library syntax is \fun{GEN}{rnfhnfbasis}{GEN bnf, GEN M}.

\subsec{rnfidealabstorel$(\var{rnf},x)$}\kbdsidx{rnfidealabstorel}\label{se:rnfidealabstorel}
Let $\var{rnf}$ be a relative
number field extension $L/K$ as output by \kbd{rnfinit} and let $x$ be an
ideal of the absolute extension $L/\Q$. Returns the relative pseudo-matrix in
HNF giving the ideal $x$ considered as an ideal of the relative extension
$L/K$, i.e.~as a $\Z_K$-module.

Let \kbd{Labs} be an (absolute) \kbd{nf} structure attached to $L$,
obtained via \kbd{Labs = nfinit(rnf))}. Then \kbd{rnf} ``knows'' about
\kbd{Labs} and $x$ may be given in any format
attached to \kbd{Labs}, e.g. a prime ideal or an ideal in HNF wrt.
\kbd{Labs.zk}:
\bprog
? K = nfinit(y^2+1); rnf = rnfinit(K, x^2-y); Labs = nfinit(rnf);
? m = idealhnf(Labs, 17, x^3+2); \\ some ideal in HNF wrt. Labs.zk
? B = rnfidealabstorel(rnf, m)
%3 = [[1, 8; 0, 1], [[17, 4; 0, 1], 1]] \\ pseudo-basis for m as Z_K-module
? A = rnfidealreltoabs(rnf, B)
%4 = [17, x^2 + 4, x + 8, x^3 + 8*x^2]  \\ Z-basis for m in Q[x]/(rnf.polabs)
? mathnf(matalgtobasis(Labs, A)) == m
%5 = 1
@eprog\noindent If on the other hand, we do not have a \kbd{Labs} at hand,
because it would be too expensive to compute, but we nevertheless have
a $\Z$-basis for $x$, then we can use the function with this basis as
argument. The entries of $x$ may be given either modulo \kbd{rnf.polabs}
(absolute form, possibly lifted) or modulo \kbd{rnf.pol} (relative form as
\typ{POLMOD}s):
\bprog
? K = nfinit(y^2+1); rnf = rnfinit(K, x^2-y);
? rnfidealabstorel(rnf, [17, x^2 + 4, x + 8, x^3 + 8*x^2])
%2 = [[1, 8; 0, 1], [[17, 4; 0, 1], 1]]
? rnfidealabstorel(rnf, Mod([17, y + 4, x + 8, y*x + 8*y], x^2-y))
%3 = [[1, 8; 0, 1], [[17, 4; 0, 1], 1]]
@eprog

The library syntax is \fun{GEN}{rnfidealabstorel}{GEN rnf, GEN x}.

\subsec{rnfidealdown$(\var{rnf},x)$}\kbdsidx{rnfidealdown}\label{se:rnfidealdown}
Let $\var{rnf}$ be a relative number
field extension $L/K$ as output by \kbd{rnfinit}, and $x$ an ideal of
$L$, given either in relative form or by a $\Z$-basis of elements of $L$
(see \secref{se:rnfidealabstorel}). This function returns the ideal of $K$
below $x$, i.e.~the intersection of $x$ with $K$.

The library syntax is \fun{GEN}{rnfidealdown}{GEN rnf, GEN x}.

\subsec{rnfidealfactor$(\var{rnf},x)$}\kbdsidx{rnfidealfactor}\label{se:rnfidealfactor}
Factor into prime ideal powers the
ideal $x$ in the attached absolute number field $L = \kbd{nfinit}(\var{rnf})$.
The output format is similar to the \kbd{factor} function, and the prime
ideals are represented in the form output by the \kbd{idealprimedec}
function for $L$.
\bprog
? rnf = rnfinit(nfinit(y^2+1), x^2-y+1);
? rnfidealfactor(rnf, y+1)  \\ P_2^2
%2 =
[[2, [0,0,1,0]~, 4, 1, [0,0,0,2;0,0,-2,0;-1,-1,0,0;1,-1,0,0]] 2]

? rnfidealfactor(rnf, x) \\ P_2
%3 =
[[2, [0,0,1,0]~, 4, 1, [0,0,0,2;0,0,-2,0;-1,-1,0,0;1,-1,0,0]] 1]

? L = nfinit(rnf);
? id = idealhnf(L, idealhnf(L, 25, (x+1)^2));
? idealfactor(L, id) == rnfidealfactor(rnf, id)
%6 = 1
@eprog\noindent Note that ideals of the base field $K$ must be explicitly
lifted to $L$ via \kbd{rnfidealup} before they can be factored.

The library syntax is \fun{GEN}{rnfidealfactor}{GEN rnf, GEN x}.

\subsec{rnfidealhnf$(\var{rnf},x)$}\kbdsidx{rnfidealhnf}\label{se:rnfidealhnf}
$\var{rnf}$ being a relative number
field extension $L/K$ as output by \kbd{rnfinit} and $x$ being a relative
ideal (which can be, as in the absolute case, of many different types,
including of course elements), computes the HNF pseudo-matrix attached to
$x$, viewed as a $\Z_K$-module.

The library syntax is \fun{GEN}{rnfidealhnf}{GEN rnf, GEN x}.

\subsec{rnfidealmul$(\var{rnf},x,y)$}\kbdsidx{rnfidealmul}\label{se:rnfidealmul}
$\var{rnf}$ being a relative number
field extension $L/K$ as output by \kbd{rnfinit} and $x$ and $y$ being ideals
of the relative extension $L/K$ given by pseudo-matrices, outputs the ideal
product, again as a relative ideal.

The library syntax is \fun{GEN}{rnfidealmul}{GEN rnf, GEN x, GEN y}.

\subsec{rnfidealnormabs$(\var{rnf},x)$}\kbdsidx{rnfidealnormabs}\label{se:rnfidealnormabs}
Let $\var{rnf}$ be a relative
number field extension $L/K$ as output by \kbd{rnfinit} and let $x$ be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the norm of the
$x$ considered as an ideal of the absolute extension $L/\Q$. This is
identical to
\bprog
   idealnorm(rnf, rnfidealnormrel(rnf,x))
@eprog\noindent but faster.

The library syntax is \fun{GEN}{rnfidealnormabs}{GEN rnf, GEN x}.

\subsec{rnfidealnormrel$(\var{rnf},x)$}\kbdsidx{rnfidealnormrel}\label{se:rnfidealnormrel}
Let $\var{rnf}$ be a relative
number field extension $L/K$ as output by \kbd{rnfinit} and let $x$ be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the relative
norm of $x$ as an ideal of $K$ in HNF.

The library syntax is \fun{GEN}{rnfidealnormrel}{GEN rnf, GEN x}.

\subsec{rnfidealprimedec$(\var{rnf},\var{pr})$}\kbdsidx{rnfidealprimedec}\label{se:rnfidealprimedec}
Let \var{rnf} be a relative number
field extension $L/K$ as output by \kbd{rnfinit}, and \var{pr} a maximal
ideal of $K$ (\var{prid}), this function completes the \var{rnf}
with a \var{nf} structure attached to $L$ (see \secref{se:rnfinit})
and returns the vector $S$ of prime ideals of $\Z_L$ above \var{pr}.
\bprog
? K = nfinit(y^2+1); rnf = rnfinit(K, x^3+y+1);
? pr = idealprimedec(K, 2)[1];
? S = rnfidealprimedec(rnf, pr);
? #S
%4 = 1
@eprog\noindent The relative ramification indices and residue degrees
can be obtained as \kbd{PR.e / pr.e} and \kbd{PR.f / PR.f}, if \kbd{PR}
is an element of $S$.

The argument \var{pr} is also allowed to be a prime number $p$, in which
case the function returns a pair of vectors \kbd{[SK,SL]}, where \kbd{SK}
contains the primes of $K$ above $p$ and \kbd{SL}$[i]$ is the vector of primes
of $L$ above \kbd{SK}$[i]$.
\bprog
? [SK,SL] = rnfidealprimedec(rnf, 5);
? [#SK, vector(#SL,i,#SL[i])]
%6 = [2, [2, 2]]
@eprog

The library syntax is \fun{GEN}{rnfidealprimedec}{GEN rnf, GEN pr}.

\subsec{rnfidealreltoabs$(\var{rnf},x,\{\fl=0\})$}\kbdsidx{rnfidealreltoabs}\label{se:rnfidealreltoabs}
Let $\var{rnf}$ be a relative
number field extension $L/K$ as output by \kbd{rnfinit} and let $x$ be a
relative ideal, given as a $\Z_K$-module by a pseudo matrix $[A,I]$.
This function returns the ideal $x$ as an absolute ideal of $L/\Q$.
If $\fl = 0$, the result is given by a vector of \typ{POLMOD}s modulo
\kbd{rnf.pol} forming a $\Z$-basis; if $\fl = 1$, it is given in HNF in terms
of the fixed $\Z$-basis for $\Z_L$, see \secref{se:rnfinit}.
\bprog
? K = nfinit(y^2+1); rnf = rnfinit(K, x^2-y);
? P = idealprimedec(K,2)[1];
? P = rnfidealup(rnf, P)
%3 = [2, x^2 + 1, 2*x, x^3 + x]
? Prel = rnfidealhnf(rnf, P)
%4 = [[1, 0; 0, 1], [[2, 1; 0, 1], [2, 1; 0, 1]]]
? rnfidealreltoabs(rnf,Prel)
%5 = [2, x^2 + 1, 2*x, x^3 + x]
? rnfidealreltoabs(rnf,Prel,1)
%6 =
[2 1 0 0]

[0 1 0 0]

[0 0 2 1]

[0 0 0 1]
@eprog
The reason why we do not return by default ($\fl = 0$) the customary HNF in
terms of a fixed $\Z$-basis for $\Z_L$ is precisely because
a \var{rnf} does not contain such a basis by default. Completing the
structure so that it contains a \var{nf} structure for $L$ is polynomial
time but costly when the absolute degree is large, thus it is not done by
default. Note that setting $\fl = 1$ will complete the \var{rnf}.

The library syntax is \fun{GEN}{rnfidealreltoabs0}{GEN rnf, GEN x, long flag}.
Also available is
\fun{GEN}{rnfidealreltoabs}{GEN rnf, GEN x} ($\fl = 0$).

\subsec{rnfidealtwoelt$(\var{rnf},x)$}\kbdsidx{rnfidealtwoelt}\label{se:rnfidealtwoelt}
$\var{rnf}$ being a relative
number field extension $L/K$ as output by \kbd{rnfinit} and $x$ being an
ideal of the relative extension $L/K$ given by a pseudo-matrix, gives a
vector of two generators of $x$ over $\Z_L$ expressed as polmods with polmod
coefficients.

The library syntax is \fun{GEN}{rnfidealtwoelement}{GEN rnf, GEN x}.

\subsec{rnfidealup$(\var{rnf},x,\{\fl=0\})$}\kbdsidx{rnfidealup}\label{se:rnfidealup}
Let $\var{rnf}$ be a relative number
field extension $L/K$ as output by \kbd{rnfinit} and let $x$ be an ideal of
$K$. This function returns the ideal $x\Z_L$ as an absolute ideal of $L/\Q$,
in the form of a $\Z$-basis. If $\fl = 0$, the result is given by a vector of
polynomials (modulo \kbd{rnf.pol}); if $\fl = 1$, it is given in HNF in terms
of the fixed $\Z$-basis for $\Z_L$, see \secref{se:rnfinit}.
\bprog
? K = nfinit(y^2+1); rnf = rnfinit(K, x^2-y);
? P = idealprimedec(K,2)[1];
? rnfidealup(rnf, P)
%3 = [2, x^2 + 1, 2*x, x^3 + x]
? rnfidealup(rnf, P,1)
%4 =
[2 1 0 0]

[0 1 0 0]

[0 0 2 1]

[0 0 0 1]
@eprog
The reason why we do not return by default ($\fl = 0$) the customary HNF in
terms of a fixed $\Z$-basis for $\Z_L$ is precisely because
a \var{rnf} does not contain such a basis by default. Completing the
structure so that it contains a \var{nf} structure for $L$ is polynomial
time but costly when the absolute degree is large, thus it is not done by
default. Note that setting $\fl = 1$ will complete the \var{rnf}.

The library syntax is \fun{GEN}{rnfidealup0}{GEN rnf, GEN x, long flag}.
Also available is
 \fun{GEN}{rnfidealup}{GEN rnf, GEN x} ($\fl = 0$).

\subsec{rnfinit$(\var{nf},T,\{\fl=0\})$}\kbdsidx{rnfinit}\label{se:rnfinit}
Given an \var{nf} structure attached to a number field $K$, as output by
\kbd{nfinit}, and a monic irreducible polynomial $T$ in $\Z_K[x]$ defining a
relative extension $L = K[x]/(T)$, this computes data to work in $L/K$
The main variable of $T$ must be of higher priority
(see \secref{se:priority}) than that of $\var{nf}$, and the coefficients of
$T$ must be in $K$.

The result is a row vector, whose components are technical.
We let $m = [K:\Q]$ the degree of the base field, $n = [L:K]$ the relative
degree, $r_1$ and $r_2$ the number of real and complex places of $K$. Access
to this information via \emph{member functions} is preferred since the
specific data organization specified below will change in the future.

If $\fl = 1$, add an \var{nf} structure attached to $L$ to \var{rnf}.
This is likely to be very expensive if the absolute degree $mn$ is large,
but fixes an integer basis for $\Z_L$ as a $\Z$-module and allows to input
and output elements of $L$ in absolute form: as \typ{COL} for elements,
as \typ{MAT} in HNF for ideals, as \kbd{prid} for prime ideals. Without such
a call, elements of $L$ are represented as \typ{POLMOD}, etc.
Note that a subsequent \kbd{nfinit}$(\var{rnf})$ will also explicitly
add such a component, and so will the following functions \kbd{rnfidealmul},
\kbd{rnfidealtwoelt}, \kbd{rnfidealprimedec}, \kbd{rnfidealup} (with flag 1)
and \kbd{rnfidealreltoabs} (with flag 1). The absolute \var{nf} structure
attached to $L$ can be recovered using \kbd{nfinit(rnf)}.

$\var{rnf}[1]$(\kbd{rnf.pol}) contains the relative polynomial $T$.

$\var{rnf}[2]$ contains the integer basis $[A,d]$ of $K$, as
(integral) elements of $L/\Q$. More precisely, $A$ is a vector of
polynomial with integer coefficients, $d$ is a denominator, and the integer
basis is given by $A/d$.

$\var{rnf}[3]$ (\kbd{rnf.disc}) is a two-component row vector
$[\goth{d}(L/K),s]$ where $\goth{d}(L/K)$ is the relative ideal discriminant
of $L/K$ and $s$ is the discriminant of $L/K$ viewed as an element of
$K^*/(K^*)^2$, in other words it is the output of \kbd{rnfdisc}.

$\var{rnf}[4]$(\kbd{rnf.index}) is the ideal index $\goth{f}$, i.e.~such
that $d(T)\Z_K=\goth{f}^2\goth{d}(L/K)$.

$\var{rnf}[5]$(\kbd{rnf.p}) is the list of rational primes dividing the norm
of the relative discriminant ideal.

$\var{rnf}[7]$ (\kbd{rnf.zk}) is the pseudo-basis $(A,I)$ for the maximal
order $\Z_L$ as a $\Z_K$-module: $A$ is the relative integral pseudo basis
expressed as polynomials (in the variable of $T$) with polmod coefficients
in $\var{nf}$, and the second component $I$ is the ideal list of the
pseudobasis in HNF.

$\var{rnf}[8]$ is the inverse matrix of the integral basis matrix, with
coefficients polmods in $\var{nf}$.

$\var{rnf}[9]$ is currently unused.

$\var{rnf}[10]$ (\kbd{rnf.nf}) is $\var{nf}$.

$\var{rnf}[11]$ is an extension of \kbd{rnfequation(K, T, 1)}. Namely, a
vector $[P, a, k, \kbd{K.pol}, T]$ describing the \emph{absolute}
extension $L/\Q$: $P$ is an absolute equation, more conveniently obtained
as \kbd{rnf.polabs}; $a$ expresses the generator $\alpha = y \mod \kbd{K.pol}$
of the number field $K$ as an element of $L$, i.e.~a polynomial modulo the
absolute equation $P$;

$k$ is a small integer such that, if $\beta$ is an abstract root of $T$
and $\alpha$ the generator of $K$ given above, then $P(\beta + k\alpha) = 0$.
It is guaranteed that $k = 0$ if $\Q(\beta) = L$.

\misctitle{Caveat} Be careful if $k\neq0$ when dealing simultaneously with
absolute and relative quantities since $L = \Q(\beta + k\alpha) =
K(\alpha)$, and the generator chosen for the absolute extension is not the
same as for the relative one. If this happens, one can of course go on
working, but we advise to change the relative polynomial so that its root
becomes $\beta + k \alpha$. Typical GP instructions would be
\bprog
  [P,a,k] = rnfequation(K, T, 1);
  if (k, T = subst(T, x, x - k*Mod(y, K.pol)));
  L = rnfinit(K, T);
@eprog

$\var{rnf}[12]$ is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available (which
is rarely needed, hence would be too expensive to compute during the initial
\kbd{rnfinit} call).

\misctitle{Huge discriminants, helping rnfdisc} When $T$ has a
discriminant which is difficult to factor, it is hard to compute
$\Z_L$. As in \kbd{nfinit}, the special input format $[T,B]$
is also accepted, where $T$ is a polynomial as above and $B$ specifies a
list of maximal ideals. The following formats are recognized for $B$:

\item an integer: the list of all maximal ideals above a rational
prime $p < B$.

\item a vector of rational primes or prime ideals: the list of all maximal
ideals dividing an element in the list.

Instead of $\Z_L$, this produces an order which is maximal at all such
maximal ideals primes. The result may actually be a complete and correct
\var{rnf} structure if the relative ideal discriminant factors completely
over this list of maximal ideals but this is not guaranteed. In general, the
order may not be maximal at primes $\goth{p}$ not in the list such that
$\goth{p}^2$ divides the relative ideal discriminant.

The library syntax is \fun{GEN}{rnfinit0}{GEN nf, GEN T, long flag}.
Also available is
\fun{GEN}{rnfinit}{GEN nf,GEN T} ($\fl = 0$).

\subsec{rnfisabelian$(\var{nf},T)$}\kbdsidx{rnfisabelian}\label{se:rnfisabelian}
$T$ being a relative polynomial with coefficients
in \var{nf}, return 1 if it defines an abelian extension, and 0 otherwise.
\bprog
? K = nfinit(y^2 + 23);
? rnfisabelian(K, x^3 - 3*x - y)
%2 = 1
@eprog

The library syntax is \fun{long}{rnfisabelian}{GEN nf, GEN T}.

\subsec{rnfisfree$(\var{bnf},M)$}\kbdsidx{rnfisfree}\label{se:rnfisfree}
Given a $\var{bnf}$ attached to a number field $K$ and
a projective $\Z_K$-module $M$ given by a pseudo-matrix, return true (1) if
$M$ is free else return false (0). If $M$ is a polynomial with coefficients
in $K$, replace it by the pseudo-matrix returned by \kbd{rnfpseudobasis}.

The library syntax is \fun{long}{rnfisfree}{GEN bnf, GEN M}.

\subsec{rnfislocalcyclo$(\var{rnf})$}\kbdsidx{rnfislocalcyclo}\label{se:rnfislocalcyclo}
Let \var{rnf} be a relative number field extension $L/K$ as output
by \kbd{rnfinit} whose degree $[L:K]$ is a power of a prime $\ell$.
Return $1$ if the $\ell$-extension is locally cyclotomic (locally contained in
the cyclotomic $\Z_\ell$-extension of $K_v$ at all places $v | \ell$), and
$0$ if not.
\bprog
? K = nfinit(y^2 + y + 1);
? L = rnfinit(K, x^3 - y); /* = K(zeta_9), globally cyclotomic */
? rnfislocalcyclo(L)
%3 = 1
\\ we expect 3-adic continuity by Krasner's lemma
? vector(5, i, rnfislocalcyclo(rnfinit(K, x^3 - y + 3^i)))
%5 = [0, 1, 1, 1, 1]
@eprog

The library syntax is \fun{long}{rnfislocalcyclo}{GEN rnf}.

\subsec{rnfisnorm$(T,a,\{\fl=0\})$}\kbdsidx{rnfisnorm}\label{se:rnfisnorm}
Similar to
\kbd{bnfisnorm} but in the relative case. $T$ is as output by
\tet{rnfisnorminit} applied to the extension $L/K$. This tries to decide
whether the element $a$ in $K$ is the norm of some $x$ in the extension
$L/K$.

The output is a vector $[x,q]$, where $a = \Norm(x)*q$. The
algorithm looks for a solution $x$ which is an $S$-integer, with $S$ a list
of places of $K$ containing at least the ramified primes, the generators of
the class group of $L$, as well as those primes dividing $a$. If $L/K$ is
Galois, then this is enough but you may want to add more primes to $S$ to
produce different elements, possibly smaller; otherwise, $\fl$ is used to
add more primes to $S$: all the places above the primes $p \leq \fl$
(resp.~$p|\fl$) if $\fl>0$ (resp.~$\fl<0$).

The answer is guaranteed (i.e.~$a$ is a norm iff $q = 1$) if the field is
Galois, or, under \idx{GRH}, if $S$ contains all primes less than
$12\log^2\left|\disc(M)\right|$, where $M$ is the normal
closure of $L/K$.

If \tet{rnfisnorminit} has determined (or was told) that $L/K$ is
\idx{Galois}, and $\fl \neq 0$, a Warning is issued (so that you can set
$\fl = 1$ to check whether $L/K$ is known to be Galois, according to $T$).
Example:

\bprog
bnf = bnfinit(y^3 + y^2 - 2*y - 1);
p = x^2 + Mod(y^2 + 2*y + 1, bnf.pol);
T = rnfisnorminit(bnf, p);
rnfisnorm(T, 17)
@eprog\noindent
checks whether $17$ is a norm in the Galois extension $\Q(\beta) /
\Q(\alpha)$, where $\alpha^3 + \alpha^2 - 2\alpha - 1 = 0$ and $\beta^2 +
\alpha^2 + 2\alpha + 1 = 0$ (it is).

The library syntax is \fun{GEN}{rnfisnorm}{GEN T, GEN a, long flag}.

\subsec{rnfisnorminit$(\var{pol},\var{polrel},\{\fl=2\})$}\kbdsidx{rnfisnorminit}\label{se:rnfisnorminit}
Let $K$ be defined by a root of \var{pol}, and $L/K$ the extension defined
by the polynomial \var{polrel}. As usual, \var{pol} can in fact be an \var{nf},
or \var{bnf}, etc; if \var{pol} has degree $1$ (the base field is $\Q$),
polrel is also allowed to be an \var{nf}, etc. Computes technical data needed
by \tet{rnfisnorm} to solve norm equations $Nx = a$, for $x$ in $L$, and $a$
in $K$.

If $\fl = 0$, do not care whether $L/K$ is Galois or not.

If $\fl = 1$, $L/K$ is assumed to be Galois (unchecked), which speeds up
\tet{rnfisnorm}.

If $\fl = 2$, let the routine determine whether $L/K$ is Galois.

The library syntax is \fun{GEN}{rnfisnorminit}{GEN pol, GEN polrel, long flag}.

\subsec{rnfkummer$(\var{bnr},\{\var{subgp}\})$}\kbdsidx{rnfkummer}\label{se:rnfkummer}
This function is deprecated, use \kbd{bnrclassfield}.

The library syntax is \fun{GEN}{rnfkummer}{GEN bnr, GEN subgp = NULL, long prec}.

\subsec{rnflllgram$(\var{nf},\var{pol},\var{order})$}\kbdsidx{rnflllgram}\label{se:rnflllgram}
Given a polynomial
\var{pol} with coefficients in \var{nf} defining a relative extension $L$ and
a suborder \var{order} of $L$ (of maximal rank), as output by
\kbd{rnfpseudobasis}$(\var{nf},\var{pol})$ or similar, gives
$[[\var{neworder}],U]$, where \var{neworder} is a reduced order and $U$ is
the unimodular transformation matrix.

The library syntax is \fun{GEN}{rnflllgram}{GEN nf, GEN pol, GEN order, long prec}.

\subsec{rnfnormgroup$(\var{bnr},\var{pol})$}\kbdsidx{rnfnormgroup}\label{se:rnfnormgroup}
\var{bnr} being a big ray
class field as output by \kbd{bnrinit} and \var{pol} a relative polynomial
defining an \idx{Abelian extension}, computes the norm group (alias Artin
or Takagi group) corresponding to the Abelian extension of
$\var{bnf}=$\kbd{bnr.bnf}
defined by \var{pol}, where the module corresponding to \var{bnr} is assumed
to be a multiple of the conductor (i.e.~\var{pol} defines a subextension of
bnr). The result is the HNF defining the norm group on the given generators
of \kbd{bnr.gen}. Note that neither the fact that \var{pol} defines an
Abelian extension nor the fact that the module is a multiple of the conductor
is checked. The result is undefined if the assumption is not correct,
but the function will return the empty matrix \kbd{[;]} if it detects a
problem; it may also not detect the problem and return a wrong result.

The library syntax is \fun{GEN}{rnfnormgroup}{GEN bnr, GEN pol}.

\subsec{rnfpolred$(\var{nf},\var{pol})$}\kbdsidx{rnfpolred}\label{se:rnfpolred}
This function is obsolete: use \tet{rnfpolredbest} instead.
Relative version of \kbd{polred}. Given a monic polynomial \var{pol} with
coefficients in $\var{nf}$, finds a list of relative polynomials defining some
subfields, hopefully simpler and containing the original field. In the present
version \vers, this is slower and less efficient than \kbd{rnfpolredbest}.

\misctitle{Remark} This function is based on an incomplete reduction
theory of lattices over number fields, implemented by \kbd{rnflllgram}, which
deserves to be improved.

The library syntax is \fun{GEN}{rnfpolred}{GEN nf, GEN pol, long prec}.

\subsec{rnfpolredabs$(\var{nf},\var{pol},\{\fl=0\})$}\kbdsidx{rnfpolredabs}\label{se:rnfpolredabs}
Relative version of \kbd{polredabs}. Given an irreducible monic polynomial
\var{pol} with coefficients in the maximal order of $\var{nf}$, finds a
canonical relative
polynomial defining the same field, hopefully with small coefficients.
Note that the equation is only canonical for a fixed \var{nf}, using a
different defining polynomial in the \var{nf} structure will produce a
different relative equation.

The binary digits of $\fl$ correspond to $1$: add information to convert
elements to the new representation, $2$: absolute polynomial, instead of
relative, $16$: possibly use a suborder of the maximal order. More precisely:

0: default, return $P$

1: returns $[P,a]$ where $P$ is the default output and $a$,
a \typ{POLMOD} modulo $P$, is a root of \var{pol}.

2: returns \var{Pabs}, an absolute, instead of a relative, polynomial.
This polynomial is canonical and does not depend on the \var{nf} structure.
Same as but faster than
\bprog
  polredabs(rnfequation(nf, pol))
@eprog

3: returns $[\var{Pabs},a,b]$, where \var{Pabs} is an absolute polynomial
as above, $a$, $b$ are \typ{POLMOD} modulo \var{Pabs}, roots of \kbd{nf.pol}
and \var{pol} respectively.

16: (OBSOLETE) possibly use a suborder of the maximal order. This makes
\kbd{rnfpolredabs} behave as \kbd{rnfpolredbest}. Just use the latter.

\misctitle{Warning} The complexity of \kbd{rnfpolredabs}
is exponential in the absolute degree. The function \tet{rnfpolredbest} runs
in polynomial time, and  tends  to return polynomials with smaller
discriminants. It also supports polynomials with arbitrary coefficients in
\var{nf}, neither integral nor necessarily monic.

The library syntax is \fun{GEN}{rnfpolredabs}{GEN nf, GEN pol, long flag}.

\subsec{rnfpolredbest$(\var{nf},\var{pol},\{\fl=0\})$}\kbdsidx{rnfpolredbest}\label{se:rnfpolredbest}
Relative version of \kbd{polredbest}. Given a polynomial \var{pol}
with coefficients in $\var{nf}$, finds a simpler relative polynomial $P$
defining the same field. As opposed to \tet{rnfpolredabs} this function does
not return a \emph{smallest} (canonical) polynomial with respect to some
measure, but it does run in polynomial time.

The binary digits of $\fl$ correspond to $1$: add information to convert
elements to the new representation, $2$: absolute polynomial, instead of
relative. More precisely:

0: default, return $P$

1: returns $[P,a]$ where $P$ is the default output and $a$,
a \typ{POLMOD} modulo $P$, is a root of \var{pol}.

2: returns \var{Pabs}, an absolute, instead of a relative, polynomial.
Same as but faster than
\bprog
  rnfequation(nf, rnfpolredbest(nf,pol))
@eprog

3: returns $[\var{Pabs},a,b]$, where \var{Pabs} is an absolute polynomial
as above, $a$, $b$ are \typ{POLMOD} modulo \var{Pabs}, roots of \kbd{nf.pol}
and \var{pol} respectively.

\bprog
? K = nfinit(y^3-2); pol = x^2 +x*y + y^2;
? [P, a] = rnfpolredbest(K,pol,1);
? P
%3 = x^2 - x + Mod(y - 1, y^3 - 2)
? a
%4 = Mod(Mod(2*y^2+3*y+4,y^3-2)*x + Mod(-y^2-2*y-2,y^3-2),
         x^2 - x + Mod(y-1,y^3-2))
? subst(K.pol,y,a)
%5 = 0
? [Pabs, a, b] = rnfpolredbest(K,pol,3);
? Pabs
%7 = x^6 - 3*x^5 + 5*x^3 - 3*x + 1
? a
%8 = Mod(-x^2+x+1, x^6-3*x^5+5*x^3-3*x+1)
? b
%9 = Mod(2*x^5-5*x^4-3*x^3+10*x^2+5*x-5, x^6-3*x^5+5*x^3-3*x+1)
? subst(K.pol,y,a)
%10 = 0
? substvec(pol,[x,y],[a,b])
%11 = 0
@eprog

The library syntax is \fun{GEN}{rnfpolredbest}{GEN nf, GEN pol, long flag}.

\subsec{rnfpseudobasis$(\var{nf},T)$}\kbdsidx{rnfpseudobasis}\label{se:rnfpseudobasis}
Given an \var{nf} structure attached to a number field $K$, as output by
\kbd{nfinit}, and a monic irreducible polynomial $T$ in $\Z_K[x]$ defining a
relative extension $L = K[x]/(T)$, computes the relative discriminant of $L$
and a pseudo-basis $(A,J)$ for the maximal order $\Z_L$ viewed as a
$\Z_K$-module. This is output as a vector $[A,J,D,d]$, where $D$ is the
relative ideal discriminant and $d$ is the relative discriminant considered
as an element of $K^*/{K^*}^2$.
\bprog
? K = nfinit(y^2+1);
? [A,J,D,d] = rnfpseudobasis(K, x^2+y);
? A
%3 =
[1 0]

[0 1]

? J
%4 = [1, 1]
? D
%5 = [0, -4]~
? d
%6 = [0, -1]~
@eprog

\misctitle{Huge discriminants, helping rnfdisc} The format $[T,B]$ is
also accepted instead of $T$ and produce an order which is maximal at all
prime ideals specified by $B$, see \kbd{??rnfinit}.
\bprog
? p = 585403248812100232206609398101;
? q = 711171340236468512951957953369;
? T = x^2 + 3*(p*q)^2;
? [A,J,D,d] = V = rnfpseudobasis(K, T); D
time = 22,178 ms.
%10 = 3
? [A,J,D,d] = W = rnfpseudobasis(K, [T,100]); D
time = 5 ms.
%11 = 3
? V == W
%12 = 1
? [A,J,D,d] = W = rnfpseudobasis(K, [T, [3]]); D
%13 = 3
? V == W
%14 = 1
@eprog\noindent In this example, the results are identical since $D \cap \Z$
factors over primes less than $100$ (and in fact, over $3$). Had it not been
the case, the order would have been guaranteed maximal at primes
$\goth{p} | p $ for $p \leq 100$ only (resp.~$\goth{p} | 3$).
And might have been nonmaximal at any other prime ideal $\goth{p}$ such
that $\goth{p}^2$ divided $D$.

The library syntax is \fun{GEN}{rnfpseudobasis}{GEN nf, GEN T}.

\subsec{rnfsteinitz$(\var{nf},M)$}\kbdsidx{rnfsteinitz}\label{se:rnfsteinitz}
Given a $\var{nf}$ attached to a number field $K$ and a projective
module $M$ given by a pseudo-matrix, returns a pseudo-basis $(A,I)$
(not in HNF in general) such that all the ideals of $I$ except perhaps the
last one are equal to the ring of integers of $\var{nf}$. If $M$ is a
polynomial with coefficients in $K$, replace it by the pseudo-matrix
returned by \kbd{rnfpseudobasis} and return the four-component row vector
$[A,I,D,d]$ where $(A,I)$ are as before and $(D,d)$ are discriminants
as returned by \kbd{rnfpseudobasis}. The ideal class of the last ideal of
$I$ is well defined; it is the \idx{Steinitz class} of $M$ (its image
in $SK_0(\Z_K)$).

The library syntax is \fun{GEN}{rnfsteinitz}{GEN nf, GEN M}.

\subsec{subcyclohminus$(\var{fH}, \{p=0\})$}\kbdsidx{subcyclohminus}\label{se:subcyclohminus}
Let $F$ be the abelian number field contained in $\Q(\zeta_f)$
corresponding to the subgroup $H$ of $(\Z/f\Z)^*$.
Computes the relative class number $h^-(F)=h(F)/h(F^+)$ of $F$.
The argument \kbd{fH} encodes $F$ and the data $[f,H]$ as follows:

\item $\kbd{fH} = [f, H]$, where $H$ is given by a vector of
integral generators,

\item $\kbd{fH} = [\var{bnr}, H]$, where \var{bnr} is attached to
$\Cl_f(\Q)$ and $H$ is a congruence subgroup,

\item $\kbd{fH} = [G, H]$, where $G$ is \kbd{idealstar}$(f,1)$, and $H$ is
a subgroup of $(\Z/f\Z)^\times$,

\item $\kbd{fH} = f$, where we assume that $H = \{1\}$, i.e., $F =
\Q(\zeta_f)$,

\item an irreducible integral polynomial defining a primitive element for $F$.

The algorithm is based on an analytic class number formula:
$$h^-(F)=Q(F)w(F)\prod_{K\subset F}N_{\Q(\zeta_d)/\Q}
  \Bigl(-B_{1,\chi}/2\Bigr)\;,$$
where $Q(F)$ is the unit index of $F$, $w(F)$ is the number of roots of unity
contained in $F$ and $K$ runs through all imaginary cyclic subfields of $F$.
For each $K$, $d$ is the degree $[K:\Q]$, $\chi$ is an arbitrary injective
character of $G(K/\Q)$ to $\C^{\times}$ and the Bernoulli number is given by
$$B_{1,\chi}=(1/f_\chi)\sum_{a=1}^{f_\chi}a\chi(a)=-(1/(2-\overline{\chi}(2))
\sum_{1\leq a\leq f_\chi/2}\chi(a)\;,$$
where $f_\chi$ is the conductor of $\chi$, namely the conductor of $K$.
The unit index $Q\in\{1,2\}$ is difficult to determine in general. If it
could be computed, the function returns $[a, b] = [h^-, Q]$; else
it returns $[2h^-/Q, 0]$. More precisely, the second component is $0$ unless
we are in one of the following cases:

\item If $f=p^a$ with a prime number $p$, then $Q=1$.

\item If $F=\Q(\zeta_f)$, then $Q=1$ if and only if $f=p^a$.

\item If $f=4p^a$ or $p^aq^b$ with odd prime numbers $p,\,q$,
then $Q=1$ if and only if $[\Q(\zeta_f):F]$ is even.

Finally, the optional parameter $p$ is an \emph{odd} prime number.
If $p$ is given, then \kbd{subcyclohminus} outputs the valuation at $p$ of
$h^-(F)$, in other words the maximal integer $e$ such that
$p^e\,|\,h^-(F)$ by evaluating $p$-adic valuations of Bernoulli numbers.
Since $p$ is odd and $Q\in \{1,2\}$, the latter can be disregarded and
the result is the same as \kbd{valuation(subcyclohminus(f,H)[1], p)}, but
adding this argument $p$ can be much faster when $p$ does not divide $[F:\Q]$
or if a high power of $p$ divides $[F:\Q]$.
\bprog
? [a,b] = subcyclohminus(22220); b
%1 = 2 \\ = Q
? sizedigit(a)
%2 = 4306  \\ huge...
? valuation(a, 101)
%3 = 41
? subcyclohminus(22220, 101) \\ directly compute the valuation
%4 = 41
@eprog\noindent
shows that $101^{41}$ divides $h^-(\Q(\zeta_{22220}))$ exactly.
Let $k_n$ be the $n$-th layer of the cyclotomic $\Z_3$-extension of
$k=\Q(\sqrt{-1501391})$; the following computes $e_n$ for $1 \leq n \leq 3$,
where $3^{e_n}$ is the $3$-part of the relative class number $h^-(k_n)$:
\bprog
? d = 1501391;
? subcyclohminus([9*d, [28,10,8]], 3)
%1 = 5
? subcyclohminus([27*d, [28,188,53]], 3)
%2 = 12
? subcyclohminus([81*d, [161,80,242]], 3)
%3 = 26
@eprog\noindent Note that $h^+(k_n)$ is prime to $3$ for all $n\geq 0$.

The following example computes the $3$-part of $h^-(F)$, where $F$ is
the subfield of the $7860079$-th cyclotomic field with degree $2\cdot 3^8$.
\bprog
? p=7860079; a=znprimroot(p)^(2*3^8);
? valuation(subcyclohminus([p,a])[1], 3)
time = 1min, 47,896 ms.
%2 = 65
? subcyclohminus([p,a], 3)
time = 1,290 ms.
%3 = 65
@eprog\noindent

The library syntax is \fun{GEN}{subcyclohminus}{GEN fH, GEN p = NULL}.

\subsec{subcycloiwasawa$(\var{fH}, p, \{n=0\})$}\kbdsidx{subcycloiwasawa}\label{se:subcycloiwasawa}
Let $F$ be the abelian number field contained in $\Q(\zeta_f)$
corresponding to the subgroup $H$ of $(\Z/f\Z)^*$, let $p > 2$ be an odd
prime not dividing $[F:\Q]$, let $F_\infty$ be the cyclotomic
$\Z_p$-extension of $F$ and let $F_n$ by its $n$-th layer.
Computes the minus part of Iwasawa polynomials and
$\lambda$-invariants attached to $F_\infty$, using the Stickelberger elements
$\xi_n^{\chi}$ belonging to $F_n$.

The function is only implemented when $p$ and $f$ are relatively small: both
$p^4$ and $f$ must fit into an \kbd{unsigned long} integer. The argument
\kbd{fH} encodes the data $[f,H]$ as follows:

\item $\kbd{fH} = [f, H]$, where $H$ is given by a vector of
integral generators,

\item $\kbd{fH} = [\var{bnr}, H]$, where \var{bnr} is attached to
$\Cl_f(\Q)$ and $H$ is a congruence subgroup,

\item $\kbd{fH} = [G, H]$, where $G$ is \kbd{idealstar}$(f,1)$, and $H$ is
a subgroup of $(\Z/f\Z)^\times$,

\item $\kbd{fH} = f$, where we assume that $H = \{1\}$, i.e., $F =
\Q(\zeta_f)$,

\item an irreducible integral polynomial defining a primitive element for $F$.

\noindent If $F$ is quadratic, we also allow $p = 2$ and more data is
output (see below).

For a number field $K$, we write $K_n$ for the $n$-th layer of the
cyclotomic $\Z_p$-extension of $K$. The algorithm considers all cyclic
subfields $K$ of $F$ and all injective odd characters
$\chi:\text{Gal}(K/\Q)\rightarrow\overline{\Q}_p^{\times}$. Let $\Sigma_n =
\text{Gal}(K_n/K)$, which is cyclic generated by the Frobenius automorphism
$\sigma$; we write $K_\chi=\Q_p(\chi)$,
${\cal O}_\chi=\Z_p[\chi]$ with maximal ideal $\goth{p}$.
The Stickelberger element
$\xi_n^\chi$ belongs to ${\cal O}_\chi[\Sigma_n]$;
the polynomial $f_n^{\chi}(x)\in{\cal O}_{\chi}[x]$
is constructed from $\xi_n^{\chi}$ by the correspondence
$\sigma \mapsto 1+x$. If $n$ is sufficiently large, then
$\goth{p}$ does not divide $f_n^{\chi}(x)$ and the distinguished polynomial
$g_n^{\chi}(x)\in{\cal O}_{\chi}[x]$ is uniquely determined by the relation
$f_n^{\chi}(x)=u(x)g_n^{\chi}(x),\,u(x)\in{\cal O}_{\chi}[x]^{\times}$.
Owing to Iwasawa Main Conjecture proved by Mazur-Wiles, we can define
the Iwasawa polynomial
$g_{\chi}(x)=\lim_{n\rightarrow\infty}g_n^{\chi}(x)\in{\cal O}_{\chi}[x]$.
If $r$ is the smallest integer satisfying
$\deg g_n^{\chi}\leq p^r$, then we have
$$g_{\chi}(x)\equiv g_n^{\chi}(x)\pmod{\goth{p}^{n+1-r}}\;.$$
Applying the norm from $K_\chi$ down to $\Q_p$, we obtain polynomials
$G_{\chi}(x), G_n^{\chi}(x)\in\Z_p[x]$ satisfying the congruence
$$G_{\chi}(x)\equiv G_n^{\chi}(x)\pmod{p^{n+1-r}}\;.$$
Note that $\lambda_p^-(F)=\sum_{K,\chi} \deg G_\chi(x)$ is the Iwasawa
$\lambda^-$-invariant of $F$, while the $\mu$-invariant $\mu_p(F)$ is
known to be zero by the theorem of Ferrero-Washington.

If $n = 0$, the function returns $[\lambda^-_p(F)]$ (the vector may contain
further useful components, see below); for positive $n$, it returns
all non-constant $G_n^{\chi}(x)\bmod{p^{n+1-r}}$ as $(K,\chi)$ vary.

\bprog
? subcycloiwasawa(22220, 41)  \\ f = 22220, H = {1}
%1 = [217]
? T = polcompositum(x^2 - 42853, polcyclo(5))[1];
? subcycloiwasawa(T, 5)
%3 = [3]
? subcycloiwasawa(T, 5, 4) \\ the sum of the degrees is indeed 3
%4 = [x + 585, x^2 + 405*x]
@eprog
The first example corresponds to $F = \Q(\zeta_{22220})$ and shows, that
$\lambda_{41}^-(F) = 217$. The second one builds $F=\Q(\sqrt{42853},
\zeta_5)$ then lists the non-constant $G_4^\chi(x)\bmod{p^4}$ for $p=5$.
Note that in this case all degrees are $\leq 5$ hence $r \leq 1$ and
$n+1-r\geq n$; so the above also gives $G_\chi$ modulo $p^4$.

We henceforth restrict to the quadratic case, where more information is
available, and $p = 2$ is now allowed: we write $F = \Q(\sqrt{d})$
of discriminant $d$ ($\neq 1$) and character $\chi$.

\misctitle{Algorithm and output for $n = 0$, $F = \Q(\sqrt{d})$}
Currently, only the case $d < 0$ ($F$ quadratic imaginary,
i.e.~$\chi(-1)=-1$) is implemented.

\item If $p > 2$, the function returns
$[\lambda, \kappa, [e_0,\dots,e_k]]$, where $\lambda=\lambda_p^-(F)$,
$p^{e_n}$ denotes the $p$-part of the class number of $F_n$ and $e_n =
\lambda n + \kappa$ for all $n > k$. We use Gold's theorem
(Acta Arith. vol.26 (1974), pp.~21--32, vol.26 (1975), pp.~233--240).
Then as soon as $e_n - e_{n-1} < \varphi(p^n)$ for some $n \geq 1$, we have
$\lambda_p(F)=e_n-e_{n-1}$;
if $\chi(p)=1$ we can weaken the hypothesis to $e_n-e_{n-1}\leq \varphi(p^n)$
for some $n\geq 1$ and obtain the same conclusion.
To compute $e_n - e_{n-1}$ we use Bernoulli numbers (\kbd{subcyclohminus}) if
$\chi(p) = 0$ and a much faster algorithm of Gold
(Pacific J. Math. vol.40 (1972), pp.83--88) otherwise.

\item For $p=2$, we use Kida's formula (Tohoku Math. J. vol. 31 (1979),
pp.~91--96) and only return $[\lambda^-]$.

When $d > 1$, \kbd{subcycloiwasawa} should calculate
$\lambda_p(F)=\lambda_p^+(F)$, which is conjectured to be zero.
But this is not yet implemented.

\bprog
? subcycloiwasawa(x^2+11111, 2)
%1 = [5]  /*@Ccom $\lambda_2(\Q(\sqrt{-11111}))=5$ */
? subcycloiwasawa(x^2+11111, 3)
%2 = [1, 0, []]
? subcycloiwasawa(x^2+11111, 11)
%3 = [0, 0, []]
@eprog\noindent This shows that for $p = 3$, we have $\lambda = 1$,
$\kappa = 0$, and $e_n = n$ for all $n \geq 0$.
And at $p = 11$, we have $e_n = 0$ for all $n \geq 0$.

\bprog
? subcycloiwasawa(x^2+1501391, 3)
time = 23 ms.
%4 = [14, -16, [2, 5]]
@eprog\noindent
computes $e_n$ by Gold's algorithm for $F=\Q(\sqrt{-1501391})$.
This shows that at $p = 3$, we have $\lambda=14$, $\kappa=-16$, then
$e_0=2$, $e_1=5$, and $e_n=14n-16$ for $n\geq 2$.
\bprog
? subcycloiwasawa(x^2+956238, 3)
time = 141 ms.
%5 = [14, -19, [1, 3]]
@eprog\noindent
computes $e_n$ using Bernoulli numbers for $F=\Q(\sqrt{-956238})$.
This shows that $e_0=1$, $e_1=3$ and $e_n=14n-19$ for $n \geq 2$.

\misctitle{Algorithm and output for $n > 0$; $F = \Q(\sqrt{d})$}

\item When $d < 0$ and $n\geq 1$,
\kbd{subcycloiwasawa} computes the Stickelberger element
$\xi_n = \xi_n^{\chi}\in\Z_p[\Sigma_n]$ and the Iwasawa polynomial
$g(x) = g_{\chi}(x)\in\Z_p[x]$
from the $n$-th layer $F_n$ of the cyclotomic $\Z_p$-extension of $F$.
Let $q$ be $p$ ($p$ odd) or 4 ($p = 2$) and let
$q_0$ be the lcm of $q$ and the discriminant $d$ of $F$, and let $q_n=q_0p^n$.
Then $\Sigma_n=\text{Gal}(\Q_n/\Q)=\text{Gal}(F_n/F)=\langle\,s\,\rangle$,
where $s$ is the Frobenius automorphism $(\Q_n/\Q,1+q_0)$ and
$$\xi_n=q_n^{-1}\sum_{a=1, (a,q_n)=1}^{q_n}a\chi(a)^{-1}(\Q_n/\Q,a)^{-1}$$
is an element of $\Q[\Sigma_n]$.
For $(p,d)=(2,-1),(2,-2),(2,-3), (2,-6),(3,-3)$,
we know that $\lambda_p(F)=0$ and there is nothing to do.
For the other cases, it is proved that $(1/2)\xi_n\in\Z_p[\Sigma_n]$.
The polynomial $f_n(x)\in\Z_p[x]$ is constructed from $(1/2)\xi_n$ by the
correspondence $s\longleftrightarrow 1+x$. If $n$ is sufficiently large, then
$p$ does not divide $f_n(x)$ and the distinguished polynomial
$g_n(x)\in\Z_p[x]$ is uniquely determined by the relation
$f_n(x)=u(x)g_n(x)$, $u(x)\in\Z_p[[x]]^{\times}$. The Iwasawa polynomial
$g(x)$ is defined by $g(x)=\lim_{n\rightarrow\infty}g_n(x)$; if $r$ is the
smallest integer satisfying $\deg g=\lambda_p(F)\leq p^r$, then we have
$g(x)\equiv g_n(x)\pmod{\,p^{n+1-r}}$ when $p>2$ and modulo $2^{n-r}$
otherwise.

\noindent Conjecturally, we have further

1. case $q_0=p$: $\xi_n\in\Z[\Sigma_n]$.

2. case $d=-1$ and $\chi(p)=-1$: $\xi_n\in\Z[\Sigma_n]$.

3. case $d=-3$ and $\chi(p)=-1$: $(3/2)\xi_n\in\Z[\Sigma_n]$.

4. other cases: $(1/2)\xi_n\in\Z[\Sigma_n]$.

\noindent Finally, \kbd{subcycloiwasawa} outputs $[g]$ where
$g$ is $g_n(x)\bmod{p^{n+1-r}}$ ($p$ odd) or $\bmod{2^{n-r}}$ ($p = 2$).

\bprog
? subcycloiwasawa(x^2+239, 3, 10)
%6 = [x^6 + 18780*x^5 + 14526*x^4 + 18168*x^3 + 3951*x^2 + 1128*x]
@eprog\noindent This is $g(x)\bmod{3^9}$. Indeed, $n = 10$,
$\lambda = 6$ (the degree), hence $r = 2$ and $n + 1 - r = 2$.

\item When $d > 1$ and $n\geq 1$, $\xi_n^*\in\Q[\Sigma_n]$ is constructed from
$\chi^*=\chi^{-1}\omega$, where $\chi$ is the character of $F=\Q(\sqrt{d}\,)$
and $\omega$ is the Teichm\"uller character $\bmod{\,q}$. Next we construct
$f_n^*(x)\in\Z_p[x]$ from $(1/2)\xi_n^*$ by the correspondence
$s^{-1}\longleftrightarrow (1+x)(1+q_0)^{-1}$ and define the distinguished
polynomial $g_n^*(x)\in\Z_p[x]$ using $f_n^*(x)$.
Then $g^*(x)=\lim_{n\rightarrow\infty}g_n^*(x)$ is the Iwasawa polynomial,
which has a connection with Greenberg conjecture for $F$.
Let $r$ be the smallest integer satisfying $\deg g^*\leq p^r$,
then we have $g^*(x)\equiv g^*_n(x)\pmod{\,p^{n+1-r}}$
when $p>2$ and $g^*(x)\equiv g^*_n(x)\pmod{\,2^{n-r}}$ when $p=2$.
Finally, \kbd{subcycloiwasawa} outputs $[g^*]$ where
$g^*$ is $g_n^*(x)\bmod{p^{n+1-r}}$ ($p$ odd) or $\bmod{2^{n-r}}$ ($p = 2$).

\bprog
? subcycloiwasawa(x^2-13841, 2, 19)
time = 1min, 17,238 ms.
%7 = [x^3 + 30644*x^2 + 126772*x + 44128]
@eprog
\noindent
This is $g^*(x)\bmod{\,2^{17}}$ ($r = 2$), the distinguished polynomial
treated in a paper of T. Fukuda, K. Komatsu, M. Ozaki and T. Tsuji
(Funct. Approx. Comment. Math. vol.54.1, pp.~7--17, 2016).

The library syntax is \fun{GEN}{subcycloiwasawa}{GEN fH, GEN p, long n}.

\subsec{subcyclopclgp$(\var{fH}, p, \{\fl=0\})$}\kbdsidx{subcyclopclgp}\label{se:subcyclopclgp}
Let $F$ be the abelian number field contained in $\Q(\zeta_f)$
corresponding to the subgroup $H$ of $(\Z/f\Z)^*$, let $p > 2$ be an odd
prime not dividing $[F:\Q]$. Computes the $p$-Sylow subgroup $A_F$ of the
ideal class group using an unconditional algorithm of M.~Aoki and T.~Fukuda
(LNCS. vol.4076, pp.56--71, 2006).

The argument \kbd{fH} encodes the data $[f,H]$ as follows:

\item $\kbd{fH} = [f, H]$, where $H$ is given by a vector of
integral generators,

\item $\kbd{fH} = [\var{bnr}, H]$, where \var{bnr} is attached to
$\Cl_f(\Q)$ and $H$ is a congruence subgroup,

\item $\kbd{fH} = [G, H]$, where $G$ is \kbd{idealstar}$(f,1)$, and $H$ is
a subgroup of $(\Z/f\Z)^\times$,

\item $\kbd{fH} = f$, where we assume that $H = \{1\}$, i.e., $F =
\Q(\zeta_f)$,

\item an irreducible integral polynomial defining a primitive element for
$F$.

\noindent The result is a 6-component vector $v$, and components $2$ or $3$
can be left empty or only partially computed to save time (see \fl\ below):

$v[1]$ is $p$.

$v[2]$ contains $[E, [e_1,\dots,e_k]]$ with $E = \sum_i e_i$, meaning that
the order of $A_F^+$ is $p^E$ and its cyclic structure is $\Z/p^{e_1}\Z \times
\dots \Z/p^{e_k}\Z$

$v[3]$ similarly describes the order and the structure of $A_F^-$.

$v[4]$ contains the structure of $\text{Gal}(F/\Q)$ as a product of cyclic
groups (elementary divisors).

$v[5]$ is the number of cyclic subfields $K$ of $F$ except for $\Q$.

$v[6]$ is the number of $\Q_p$-conjugacy classes of injective
characters $\chi:\text{Gal}(K/\Q)\rightarrow\overline{\Q}_p^{\times}$.

\noindent A vector of primes $p$ is also accepted and the result is then a
vector of vectors as above, in the same order as the primes.

The group $A_F$ is the direct sum of $A_F^+$ and $A_F^-$; each of $A_F^+$
and $A_F^-$ is decomposed into $\chi$-parts $A_\chi$.
By default, the function computes only $|A_F^-|$ and an upper bound
for $|A_F^+|$ (expected to be equal to $|A_F^+|$) separately with
different algorithms. This is expected to be fast. The behavior is controled
by the binary digits of \fl:

1: if $|A_F^+|$ or $|A_F^-|$ is computed, also determines its group structure
and guarantees informations about $A_F^+$. This last part is usually
costly.

2: do not compute quantities related to $A_F^+$ (the corresponding $(e_i)$
in $v[2]$ is replaced with a dummy empty vector).

4: do not compute quantities related to $A_F^-$ (the corresponding $(e_i)$
in $v[3]$ is replaced with a dummy empty vector).

8: ignores proper subfields of $F$. This is motivated by the following kind
of problems: let $\Q(p^k)$ be the $k$-th layer of the cyclotomic
$\Z_p$-extenson of $\Q$ and define $\Q(n)=\Q(p_1^{e_1})\cdots\Q(p_r^{e_r})$
when $n$ factors as $n=p_1^{e_1}\cdots p_r^{e_r}$, which is a real cyclic
field of degree $n$ satisfying $\Q(n) \subset \Q(m)$ when $n\mid m$. What are
the prime factors of the class number $h(n)$ of $\Q(n)$ ? The new prime
factors of $h(n)$, not occurring in a lower level, will all be present
when using this \fl.

The other value are technical and only useful when bit 1 (certification and
structure) is set; do not set them unless you run into difficulties with
default parameters.

16: when this bit is set, the function tries to save memory, sacrificing
speed; this typically uses half the memory for a slowdown of a factor $2$.

32: likely to speed up the algorithm when the rank of $A_\chi$ is large and
to create a minor slowdown otherwise. Though the effect is restricted, the
$3$-class group of $\Q(\sqrt{15338}, \zeta_5)$ is computed 4 times faster
when this bit is set (see below).

\misctitle{Examples} With default $\fl=0$, the function (quickly)
determines the exact value of $|A_F^-|$ and a rigorous upper bound of $|A_F^+|$
which is expected to be equal to $|A_F^+|$; of course, when the upper bound
is $0$, we know for sure that $A_F^+$ is trivial. With $\fl=1$ we obtain the
group structure of $A_F$ completely and guarantee the informations about
$A_F^+$ (slow).

\bprog
? subcyclopclgp(22220, 101)
time = 113 ms.
%1 = [101, [0, []], [41, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]],
[100, 20, 2, 2], 479, 7999]
@eprog\noindent
This computes the 101-part $A_F$ of the ideal class group of
$F=\Q(\zeta_{22220})$.
The output says that $A_F^+=0$, which is rigorous (since trivial),
and $|A_F^-|=101^{41}$, more precisely $A_F^-$ is isomorphic to
$(\Z/101\Z)^{41}$ which is also rigorous
(since the description of $A_F^-$ is always rigorous). The Galois group
$\text{Gal}(F/\Q)$ is $\Z/100\Z\oplus\Z/20\Z\oplus\Z/2\Z\oplus\Z/2\Z$.
The field $F$ has 479 cyclic subfields different from $\Q$ and
there are 7999 $\Q_{101}$-conjugacy classes of injective characters
$\chi:\text{Gal}(K/\Q)\rightarrow\overline{\Q}_{101}^{\times}$.

\bprog
? subcyclopclgp(22220, 11)
time = 83 ms.
%2 = [11, [2, [1, 1]], [16, []], [100, 20, 2, 2], 479, 1799]
@eprog\noindent
This computes the 11-part $A_F$ for the same $F$. The result says that
$|A_F^+|=11^2$, $A^+_F$ is isomorphic to $(\Z/11\Z)^2$ which is not rigorous
and is only an upper bound, and $|A_F^-|=11^{16}$ which is rigorous. The
group structure of $A_F^-$ is unknown.

\bprog
? subcyclopclgp(22220, 11, 1)
time = 185 ms.
%3 = [11, [2, [1, 1]], [16, [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]],
[100, 20, 2, 2], 479, 1799]
@eprog\noindent now guarantees that $A^+_F$ is isomorphic to $(\Z/11\Z)^2$
and determines that $A_F^-$ is isomorphic to $\Z/11^2\Z\oplus(\Z/11\Z)^{14}$,
at the expense of slightly increasing the running time.

We now try a much harder example: $F=\Q(\sqrt{36322},\zeta_5)$, which
we could define using $f = 726440$ and $H = [41, 61, 111, 131]$ (prove it!).
We will use a defining polynomial instead:
\bprog
? T = polcompositum(x^2-36322, polcyclo(5), 2);
? subcyclopclgp(T, 5) \\ fast when non rigorous for A^+
time = 82 ms.
%4 = [5, [1, [1]], [4, []], [4, 2], 5, 7]
\\ try to certify; requires about 2GB of memory
? subcyclopclgp(T, 5, 1)
*** subcyclopclgp: the PARI stack overflows !
 current stack size: 1000003072 (1907.352 Mbytes)
? default(parisizemax,"2G");
? subcyclopclgp(T, 5, 1) \\ with more memory, we get an answer
time = 36,201 ms.
%6 = [5, [1, [1]], [4, [3, 1]], [4, 2], 5, 7]
\\ trying to reduce memory use does not work (still need 2GB); slower
? subcyclopclgp(T, 5, 1+16)
time = 39,450 ms.
@eprog\noindent This shows that $A_F^+$ is isomorphic to $\Z/5\Z$ and
$A_F^-$ is isomorphic to $\Z/5^3\Z\oplus\Z/5\Z$ for $p=5$. For this example,
trying to reduce memory use with $\fl = 1+16$ fails: the computation becomes
slower and still needs 2GB; $\fl = 1+16+32$ is a disaster: it requires about
8GB and 9 minutes of computation.

Here's a situation where the technical flags make a difference:
let $F = \Q(\sqrt{15338}, \zeta_5)$.
\bprog
? T = polcompositum(x^2-15338, polcyclo(5), 2);
? subcyclopclgp(T, 3)
time = 123 ms.
%2 = [3, [1, [1]], [4, []], [4, 2], 5, 5]
? subcyclopclgp(T, 3, 1) \\ requires a stack of 8GB
time = 4min, 47,822 ms.
%3 = [3, [1, [1]], [4, [1, 1, 1, 1]], [4, 2], 5, 5]
? subcyclopclgp(T, 3, 1+16);
time = 7min, 20,876 ms. \\ works with 5GB, but slower
? subcyclopclgp(T, 3, 1+32);
time = 1min, 11,424 ms. \\ also works with 5GB, 4 times faster than original
? subcyclopclgp(T, 3, 1+16+32);
time = 1min, 47,285 ms. \\ now works with 2.5GB
@eprog

Let $F = \Q(106)$ defined as above; namely, $F$ is the composite field
of $\Q(\sqrt{2})$ and the subfield of $\Q(\zeta_{53^2})$ with degree 53.
This time we shall build the compositum using class field theory:
\bprog
? Q = bnfinit(y);
? bnr1 = bnrinit(Q, 8); H1 = Mat(2);
? bnr2 = bnrinit(Q, [53^2, [1]]); H2 = Mat(53);
? [bnr,H] = bnrcompositum([bnr1, H1], [bnr2, H2]);
? subcyclopclgp([bnr,H], 107)
time = 10 ms.
%5 = [107, [1, [1]], [0, []], [106], 3, 105]
? subcyclopclgp([bnr,H], 107, 1) \\ requires 2.5GB
time = 15min, 13,537 ms.
%6 = [107, [1, [1]], [0, []], [106], 3, 105]
@eprog\noindent Both results are identical (and they were expected to be),
but only the second is rigorous. Flag bit 32 has a minor impact in this case
(reduces timings by 20 s.)

The library syntax is \fun{GEN}{subcyclopclgp}{GEN fH, GEN p, long flag}.

\subsec{subgrouplist$(\var{cyc},\{\var{bound}\},\{\fl=0\})$}\kbdsidx{subgrouplist}\label{se:subgrouplist}
\var{cyc} being a vector of positive integers giving the cyclic
components for a finite Abelian group $G$ (or any object which has a
\kbd{.cyc} method), outputs the list of subgroups of $G$. Subgroups are
given as HNF left divisors of the SNF matrix corresponding to $G$.

If $\fl=0$ (default) and \var{cyc} is a \var{bnr} structure output by
\kbd{bnrinit}, gives only the subgroups whose modulus is the conductor.
Otherwise, all subgroups are given.

If \var{bound} is present, and is a positive integer, restrict the output to
subgroups of index less than \var{bound}. If \var{bound} is a vector
containing a single positive integer $B$, then only subgroups of index
exactly equal to $B$ are computed. For instance
\bprog
? subgrouplist([6,2])
%1 = [[6, 0; 0, 2], [2, 0; 0, 2], [6, 3; 0, 1], [2, 1; 0, 1], [3, 0; 0, 2],
[1, 0; 0, 2], [6, 0; 0, 1], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
? subgrouplist([6,2],3)    \\@com index less than 3
%2 = [[2, 1; 0, 1], [1, 0; 0, 2], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
? subgrouplist([6,2],[3])  \\@com index 3
%3 = [[3, 0; 0, 1]]
? bnr = bnrinit(bnfinit(x), [120,[1]], 1);
? L = subgrouplist(bnr, [8]);
@eprog\noindent
In the last example, $L$ corresponds to the 24 subfields of
$\Q(\zeta_{120})$, of degree $8$ and conductor $120\infty$ (by setting \fl,
we see there are a total of $43$ subgroups of degree $8$).
\bprog
? vector(#L, i, galoissubcyclo(bnr, L[i]))
@eprog\noindent
will produce their equations. (For a general base field, you would
have to rely on \tet{bnrstark}, or \tet{bnrclassfield}.)

\misctitle{Warning} This function requires factoring the exponent of $G$.
If you are only interested in subgroups of index $n$ (or dividing $n$), you
may considerably speed up the function by computing the subgroups of
$G/G^n$, whose cyclic components are \kbd{apply(x->gcd(n,x), C)} (where
$C$ gives the cyclic components of $G$). If you want the \var{bnr} variant,
now is a good time to use \kbd{bnrinit(,,, n)} as well, to directly compute
the ray class group modulo $n$-th powers.

The library syntax is \fun{GEN}{subgrouplist0}{GEN cyc, GEN bound = NULL, long flag}.

\section{Associative and central simple algebras}

This section collects functions related to associative algebras and central
simple algebras (CSA) over number fields.

\subsec{Algebra definitions} %GPHELPskip

Let $A$ be a finite-dimensional unital associative algebra over a field $K$.
The algebra $A$ is \emph{central} if its center is $K$ and it is
\emph{simple} if it has no nontrivial two-sided ideals.

We provide functions to handle associative algebras of finite
dimension over~$\Q$ or~$\F_p$. We represent them by the left multiplication
table on a basis over the prime subfield; the function \kbd{algtableinit}
creates the object representing an associative algebra. We also provide
functions to handle central simple algebras over a number field $K$. We
represent them either by the left multiplication table on a basis over the
center $K$ or by a cyclic algebra (see below); the function~\kbd{alginit}
creates the object representing a central simple algebra.

The set of elements of an algebra~$A$ that annihilate every simple left
$A$-module is a two-sided ideal, called the \emph{Jacobson radical} of~$A$.
If the Jacobson radical is trivial, the algebra is \emph{semisimple}: it is
isomorphic to a direct product of simple algebras. The
dimension of a CSA over its center $K$ is always a
square $d^2$ and the integer $d$ is called the \emph{degree} of the
algebra over~$K$. A CSA over a field~$K$ is always isomorphic to~$M_k(D)$
for some integer~$k$ and some central division algebra~$D$ of degree~$e$:
the integer~$e$ is the \emph{index} of the algebra.

Let $L/K$ be a cyclic extension of degree $d$, let $\sigma$ be a
generator of $\text{Gal}(L/K)$ and let $b\in K^*$. Then the
\emph{cyclic algebra} $(L/K,\sigma,b)$ is the algebra
$\bigoplus_{i=0}^{d-1}x^iL$ with $x^d=b$ and $\ell x=x\sigma(\ell)$ for
all~$\ell\in L$. The algebra $(L/K,\sigma,b)$ is a central simple $K$-algebra
of degree~$d$, and it is an $L$-vector space. Left multiplication is
$L$-linear and induces a $K$-algebra isomorphism $(L/K,\sigma,b)\otimes_K L\to
M_d(L)$.

Let $K$ be a nonarchimedean local field with uniformizer $\pi$, and let
$L/K$ be the unique unramified extension of degree $d$. Then every central
simple algebra $A$ of degree $d$ over $K$ is isomorphic to
$(L/K, \Frob, \pi^h)$ for some integer $h$. The element $h/d\in
\Q/\Z$ is called the \emph{Hasse invariant} of $A$.

\subsec{Orders in algebras} %GPHELPskip

Let~$A$ be an algebra of finite dimension over~$\Q$. An \emph{order}
in~$A$ is a finitely generated $\Z$-submodule~${\cal O}$ such
that~$\Q{\cal O} = A$, that is also a subring with unit.
By default the data computed by~\kbd{alginit} contains a~$\Z$-basis of a maximal
order~${\cal O}_0$. We define natural
orders in central simple algebras defined by a cyclic algebra or by a
multiplication table over the center. Let~$A = (L/K,\sigma,b) =
\bigoplus_{i=0}^{d-1}x^iL$ be a cyclic algebra over a number field~$K$ of
degree~$n$ with ring of integers~$\Z_K$. Let~$\Z_L$ be the ring of integers
of~$L$, and assume that~$b$ is integral. Then the submodule~${\cal O} =
\bigoplus_{i=0}^{d-1}x^i\Z_L$ is an order in~$A$, called the
\emph{natural order}. Let~$\omega_0,\dots,\omega_{nd-1}$ be a~$\Z$-basis
of~$\Z_L$. The \emph{natural basis} of~${\cal O}$ is~$b_0,\dots,b_{nd^2-1}$
where~$b_i = x^{i/(nd)}\omega_{(i \mod nd)}$. Now let~$A$ be a central simple
algebra of degree~$d$ over a number field~$K$ of degree~$n$ with ring of
integers~$\Z_K$. Let~$e_0,\dots,e_{d^2-1}$ be a basis of~$A$ over~$K$ and
assume that the left multiplication table of~$A$ on~$(e_i)$ is integral. Then
the submodule~${\cal O} = \bigoplus_{i=0}^{d^2-1}\Z_K e_i$ is an order
in~$A$, called the \emph{natural order}. Let~$\omega_0,\dots,\omega_{n-1}$ be
a~$\Z$-basis of~$\Z_K$. The \emph{natural basis} of~${\cal O}$
is~$b_0,\dots,b_{nd^2-1}$ where~$b_i = \omega_{(i \mod n)}e_{i/n}$.

\subsec{Lattices in algebras} %GPHELPskip

We also provide functions to handle full lattices in algebras over~$\Q$. A
full lattice~$J\subset A$ is represented by a $2$-component \typ{VEC}~$[I,t]$
representing~$J = tI$, where

\item $I$ is an integral nonsingular upper-triangular matrix representing a
sublattice of~${\cal O}_0$ expressed on the integral basis, and

\item $t\in\Q_{>0}$ is a \typ{INT} or \typ{FRAC}.

For the sake of efficiency you should use matrices~$I$ that are primitive and
in Hermite Normal Form; this makes the representation unique. No GP function
uses this property, but all GP functions return lattices in this form. The
prefix for lattice functions is \kbd{alglat}.

\subsec{GP conventions for algebras} %GPHELPskip

As with number fields, we represent elements of central simple algebras
in two ways, called the \emph{algebraic representation} and the \emph{basis
representation}, and you can convert betweeen the two with the functions
\kbd{algalgtobasis} and \kbd{algbasistoalg}. In every central simple algebra
object, we store a~$\Z$-basis of an order~${\cal O}_0$, and the basis
representation is simply a \typ{COL} with coefficients in~$\Q$ expressing the
element in that basis. If no maximal order was computed by~\kbd{alginit},
then~${\cal O}_0$ is the natural order. If a maximal order was computed,
then~${\cal O}_0$ is a maximal order containing the natural order. For a cyclic
algebra~$A = (L/K,\sigma,b)$, the algebraic representation is a \typ{COL} with
coefficients in~$L$ representing the element in the decomposition~$A =
\bigoplus_{i=0}^{d-1}x^iL$. For a central simple algebra defined by a
multiplication table over its center~$K$ on a basis~$(e_i)$, the algebraic
representation is a \typ{COL} with coefficients in~$K$ representing the element
on the basis~$(e_i)$.

\misctitle{Warning} The coefficients in the decomposition~$A =
\bigoplus_{i=0}^{d-1}x^iL$ are not the same as those in the decomposition~$A
= \bigoplus_{i=0}^{d-1}Lx^i$! The $i$-th coefficients are related by
conjugating by~$x^i$, which on~$L$ amounts to acting by~$\sigma^i$.

\misctitle{Warning} For a central simple algebra over $\Q$ defined by a
multiplication table, we cannot distinguish between the basis and the algebraic
representations from the size of the vectors. The behavior is then to always
interpret the column vector as a basis representation if the coefficients are
\typ{INT} or \typ{FRAC}, and as an algebraic representation if the coefficients
are \typ{POL} or \typ{POLMOD}.

\subsec{algadd$(\var{al},x,y)$}\kbdsidx{algadd}\label{se:algadd}
Given two elements $x$ and $y$ in \var{al}, computes their sum $x+y$ in
the algebra~\var{al}.
\bprog
? A = alginit(nfinit(y),[-1,1]);
? algadd(A,[1,0]~,[1,2]~)
%2 = [2, 2]~
@eprog

Also accepts matrices with coefficients in \var{al}.

The library syntax is \fun{GEN}{algadd}{GEN al, GEN x, GEN y}.

\subsec{algalgtobasis$(\var{al},x)$}\kbdsidx{algalgtobasis}\label{se:algalgtobasis}
Given an element \var{x} in the central simple algebra \var{al} output
by \tet{alginit}, transforms it to a column vector on the integral basis of
\var{al}. This is the inverse function of \tet{algbasistoalg}.
\bprog
? A = alginit(nfinit(y^2-5),[2,y]);
? algalgtobasis(A,[y,1]~)
%2 = [0, 2, 0, -1, 2, 0, 0, 0]~
? algbasistoalg(A,algalgtobasis(A,[y,1]~))
%3 = [Mod(Mod(y, y^2 - 5), x^2 - 2), 1]~
@eprog

The library syntax is \fun{GEN}{algalgtobasis}{GEN al, GEN x}.

\subsec{algaut$(\var{al})$}\kbdsidx{algaut}\label{se:algaut}
Given a cyclic algebra $\var{al} = (L/K,\sigma,b)$ output by
\tet{alginit}, returns the automorphism $\sigma$.
\bprog
? nf = nfinit(y);
? p = idealprimedec(nf,7)[1];
? p2 = idealprimedec(nf,11)[1];
? A = alginit(nf,[3,[[p,p2],[1/3,2/3]],[0]]);
? algaut(A)
%5 = -1/3*x^2 + 1/3*x + 26/3
@eprog

The library syntax is \fun{GEN}{algaut}{GEN al}.

\subsec{algb$(\var{al})$}\kbdsidx{algb}\label{se:algb}
Given a cyclic algebra $\var{al} = (L/K,\sigma,b)$ output by
\tet{alginit}, returns the element $b\in K$.
\bprog
nf = nfinit(y);
? p = idealprimedec(nf,7)[1];
? p2 = idealprimedec(nf,11)[1];
? A = alginit(nf,[3,[[p,p2],[1/3,2/3]],[0]]);
? algb(A)
%5 = Mod(-77, y)
@eprog

The library syntax is \fun{GEN}{algb}{GEN al}.

\subsec{algbasis$(\var{al})$}\kbdsidx{algbasis}\label{se:algbasis}
Given a central simple algebra \var{al} output by \tet{alginit}, returns
a $\Z$-basis of the order~${\cal O}_0$ stored in \var{al} with respect to the
natural order in \var{al}. It is a maximal order if one has been computed.
\bprog
A = alginit(nfinit(y), [-1,-1]);
? algbasis(A)
%2 =
[1 0 0 1/2]

[0 1 0 1/2]

[0 0 1 1/2]

[0 0 0 1/2]
@eprog

The library syntax is \fun{GEN}{algbasis}{GEN al}.

\subsec{algbasistoalg$(\var{al},x)$}\kbdsidx{algbasistoalg}\label{se:algbasistoalg}
Given an element \var{x} in the central simple algebra \var{al} output
by \tet{alginit}, transforms it to its algebraic representation in \var{al}.
This is the inverse function of \tet{algalgtobasis}.
\bprog
? A = alginit(nfinit(y^2-5),[2,y]);
? z = algbasistoalg(A,[0,1,0,0,2,-3,0,0]~);
? liftall(z)
%3 = [(-1/2*y - 2)*x + (-1/4*y + 5/4), -3/4*y + 7/4]~
? algalgtobasis(A,z)
%4 = [0, 1, 0, 0, 2, -3, 0, 0]~
@eprog

The library syntax is \fun{GEN}{algbasistoalg}{GEN al, GEN x}.

\subsec{algcenter$(\var{al})$}\kbdsidx{algcenter}\label{se:algcenter}
If \var{al} is a table algebra output by \tet{algtableinit}, returns a
basis of the center of the algebra~\var{al} over its prime field ($\Q$ or
$\F_p$). If \var{al} is a central simple algebra output by \tet{alginit},
returns the center of~\var{al}, which is stored in \var{al}.

A simple example: the $2\times 2$ upper triangular matrices over $\Q$,
generated by $I_2$, $a = \kbd{[0,1;0,0]}$ and $b = \kbd{[0,0;0,1]}$,
such that $a^2 = 0$, $ab = a$, $ba = 0$, $b^2 = b$: the diagonal matrices
form the center.
\bprog
? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algcenter(A) \\ = (I_2)
%3 =
[1]

[0]

[0]
@eprog

An example in the central simple case:

\bprog
? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algcenter(A).pol
%3 = y^3 - y + 1
@eprog

The library syntax is \fun{GEN}{algcenter}{GEN al}.

\subsec{algcentralproj$(\var{al},z,\{\var{maps}=0\})$}\kbdsidx{algcentralproj}\label{se:algcentralproj}
Given a table algebra \var{al} output by \tet{algtableinit} and a
\typ{VEC} $\var{z}=[z_1,\dots,z_n]$ of orthogonal central idempotents,
returns a \typ{VEC} $[al_1,\dots,al_n]$ of algebras such that
$al_i = z_i\, al$. If $\var{maps}=1$, each $al_i$ is a \typ{VEC}
$[quo,proj,lift]$ where \var{quo} is the quotient algebra, \var{proj} is a
\typ{MAT} representing the projection onto this quotient and \var{lift} is a
\typ{MAT} representing a lift.

A simple example: $\F_2\times \F_4$, generated by~$1=(1,1)$, $e=(1,0)$
and~$x$ such that~$x^2+x+1=0$. We have~$e^2=e$, $x^2=x+1$ and~$ex=0$.
\bprog
? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? e = [0,1,0]~;
? e2 = algsub(A,[1,0,0]~,e);
? [a,a2] = algcentralproj(A,[e,e2]);
? algdim(a)
%6 = 1
? algdim(a2)
%7 = 2
@eprog

The library syntax is \fun{GEN}{alg_centralproj}{GEN al, GEN z, long maps}.

\subsec{algchar$(\var{al})$}\kbdsidx{algchar}\label{se:algchar}
Given an algebra \var{al} output by \tet{alginit} or \tet{algtableinit},
returns the characteristic of \var{al}.
\bprog
? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,13);
? algchar(A)
%3 = 13
@eprog

The library syntax is \fun{GEN}{algchar}{GEN al}.

\subsec{algcharpoly$(\var{al},b,\{v='x\},\{\var{abs}=0\})$}\kbdsidx{algcharpoly}\label{se:algcharpoly}
Given an element $b$ in \var{al}, returns its characteristic polynomial
as a polynomial in the variable $v$. If \var{al} is a table algebra output
by \tet{algtableinit} or if $abs=1$, returns the absolute characteristic
polynomial of \var{b}, which is an element of $\F_p[v]$ or~$\Q[v]$; if \var{al}
is a central simple algebra output by \tet{alginit} and $abs=0$, returns the
reduced characteristic polynomial of \var{b}, which is an element of~$K[v]$
where~$K$ is the center of \var{al}.
\bprog
? al = alginit(nfinit(y), [-1,-1]); \\ (-1,-1)_Q
? algcharpoly(al, [0,1]~)
%2 = x^2 + 1
? algcharpoly(al, [0,1]~,,1)
%3 = x^4 + 2*x^2 + 1
? nf = nfinit(y^2-5);
? al = alginit(nf,[-1,y]);
? a = [y,1+x]~*Mod(1,y^2-5)*Mod(1,x^2+1);
? P = lift(algcharpoly(al,a))
%7 = x^2 - 2*y*x + (-2*y + 5)
? algcharpoly(al,a,,1)
%8 = x^8 - 20*x^6 - 80*x^5 + 110*x^4 + 800*x^3 + 1500*x^2 - 400*x + 25
? lift(P*subst(P,y,-y)*Mod(1,y^2-5))^2
%9 = x^8 - 20*x^6 - 80*x^5 + 110*x^4 + 800*x^3 + 1500*x^2 - 400*x + 25
@eprog

Also accepts a square matrix with coefficients in \var{al}.

The library syntax is \fun{GEN}{algcharpoly}{GEN al, GEN b, long v = -1, long abs} where \kbd{v} is a variable number.

\subsec{algdegree$(\var{al})$}\kbdsidx{algdegree}\label{se:algdegree}
Given a central simple algebra \var{al} output by \tet{alginit}, returns
the degree of \var{al}.
\bprog
? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algdegree(A)
%3 = 2
@eprog

The library syntax is \fun{long}{algdegree}{GEN al}.

\subsec{algdim$(\var{al},\{\var{abs}=0\})$}\kbdsidx{algdim}\label{se:algdim}
If \var{al} is a table algebra output by \tet{algtableinit} or if~$abs=1$,
returns the dimension of \var{al} over its prime subfield ($\Q$ or $\F_p$).
If~\var{al} is a central simple algebra output by \tet{alginit} and~$abs=0$,
returns the dimension of \var{al} over its center.

\bprog
? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algdim(A)
%3 = 4
? algdim(A,1)
%4 = 12
@eprog

The library syntax is \fun{long}{algdim}{GEN al, long abs}.

\subsec{algdisc$(\var{al})$}\kbdsidx{algdisc}\label{se:algdisc}
Given a central simple algebra \var{al} output by \tet{alginit}, computes
the discriminant of the order ${\cal O}_0$ stored in \var{al}, that is the
determinant of the trace form $\rm{Tr} : {\cal O}_0\times {\cal O}_0 \to \Z$.
\bprog
? nf = nfinit(y^2-5);
? A = alginit(nf, [-3,1-y]);
? [PR,h] = alghassef(A)
%3 = [[[2, [2, 0]~, 1, 2, 1], [3, [3, 0]~, 1, 2, 1]], Vecsmall([0, 1])]
? n = algdegree(A);
? D = algdim(A,1);
? h = vector(#h, i, n - gcd(n,h[i]));
? n^D * nf.disc^(n^2) * idealnorm(nf, idealfactorback(nf,PR,h))^n
%4 = 12960000
? algdisc(A)
%5 = 12960000
@eprog

The library syntax is \fun{GEN}{algdisc}{GEN al}.

\subsec{algdivl$(\var{al},x,y)$}\kbdsidx{algdivl}\label{se:algdivl}
Given two elements $x$ and $y$ in \var{al}, computes their left quotient
$x\backslash y$ in the algebra \var{al}: an element $z$ such that $xz=y$ (such
an element is not unique when $x$ is a zerodivisor). If~$x$ is invertible, this
is the same as $x^{-1}y$. Assumes that $y$ is left divisible by $x$ (i.e. that
$z$ exists). Also accepts matrices with coefficients in~\var{al}.

The library syntax is \fun{GEN}{algdivl}{GEN al, GEN x, GEN y}.

\subsec{algdivr$(\var{al},x,y)$}\kbdsidx{algdivr}\label{se:algdivr}
Given two elements $x$ and $y$ in \var{al}, returns $xy^{-1}$. Also accepts
matrices with coefficients in \var{al}.

The library syntax is \fun{GEN}{algdivr}{GEN al, GEN x, GEN y}.

\subsec{alggroup$(\var{gal}, \{p=0\})$}\kbdsidx{alggroup}\label{se:alggroup}
Initializes the group algebra~$K[G]$ over~$K=\Q$ ($p$ omitted) or~$\F_p$
where~$G$ is the underlying group of the \kbd{galoisinit} structure~\var{gal}.
The input~\var{gal} is also allowed to be a \typ{VEC} of permutations that is
closed under products.

Example:
\bprog
? K = nfsplitting(x^3-x+1);
? gal = galoisinit(K);
? al = alggroup(gal);
? algissemisimple(al)
%4 = 1
? G = [Vecsmall([1,2,3]), Vecsmall([1,3,2])];
? al2 = alggroup(G, 2);
? algissemisimple(al2)
%8 = 0
@eprog

The library syntax is \fun{GEN}{alggroup}{GEN gal, GEN p = NULL}.

\subsec{alggroupcenter$(\var{gal},\{p=0\},\{\&\var{cc}\})$}\kbdsidx{alggroupcenter}\label{se:alggroupcenter}
Initializes the center~$Z(K[G])$ of the group algebra~$K[G]$ over~$K=\Q$
($p = 0$ or omitted) or~$\F_p$ where~$G$ is the underlying group of the
\kbd{galoisinit} structure~\var{gal}. The input~\var{gal} is also allowed to
be a \typ{VEC} of permutations that is closed under products.
Sets~\var{cc} to a \typ{VEC}~$[\var{elts},\var{conjclass},\var{rep},\var{flag}]$
where~\var{elts} is a sorted \typ{VEC} containing the list of elements
of~$G$, \var{conjclass} is a \typ{VECSMALL} of the same length as~\var{elts}
containing the index of the conjugacy class of the corresponding element (an
integer between $1$ and the number of conjugacy classes), and~\var{rep} is a
\typ{VECSMALL} of length the number of conjugacy classes giving for each
conjugacy class the index in~\var{elts} of a representative of this conjugacy
class. Finally \var{flag} is $1$ if and only if the permutation
representation of $G$ is transitive, in which case the $i$-th element
of \var{elts} is characterized by $g[1] = i$; this is always the case
when \var{gal} is a \kbd{galoisinit} structure. The basis of~$Z(K[G])$ as
output consists of the indicator functions of the conjugacy classes in the
ordering given by~\var{cc}. Example:
\bprog
? K = nfsplitting(x^4+x+1);
? gal = galoisinit(K); \\ S4
? al = alggroupcenter(gal,,&cc);
? algiscommutative(al)
%4 = 1
? #cc[3] \\ number of conjugacy classes of S4
%5 = 5
? gal = [Vecsmall([1,2,3]),Vecsmall([1,3,2])]; \\ C2
? al = alggroupcenter(gal,,&cc);
? cc[3]
%8 = Vecsmall([1, 2])
? cc[4]
%9 = 0
@eprog

The library syntax is \fun{GEN}{alggroupcenter}{GEN gal, GEN p = NULL, GEN *cc = NULL}.

\subsec{alghasse$(\var{al},\var{pl})$}\kbdsidx{alghasse}\label{se:alghasse}
Given a central simple algebra \var{al} output by \tet{alginit} and a prime
ideal or an integer between $1$ and $r_1+r_2$, returns a \typ{FRAC} $h$ : the
local Hasse invariant of \var{al} at the place specified by \var{pl}.
\bprog
? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? alghasse(A, 1)
%3 = 1/2
? alghasse(A, 2)
%4 = 0
? alghasse(A, idealprimedec(nf,2)[1])
%5 = 1/2
? alghasse(A, idealprimedec(nf,5)[1])
%6 = 0
@eprog

The library syntax is \fun{GEN}{alghasse}{GEN al, GEN pl}.

\subsec{alghassef$(\var{al})$}\kbdsidx{alghassef}\label{se:alghassef}
Given a central simple algebra \var{al} output by \tet{alginit}, returns
a \typ{VEC} $[\kbd{PR}, h_f]$ describing the local Hasse invariants at the
finite places of the center: \kbd{PR} is a \typ{VEC} of primes and $h_f$ is a
\typ{VECSMALL} of integers modulo the degree $d$ of \var{al}. The Hasse
invariant of~\var{al} at the primes outside~\kbd{PR} is~$0$, but~\kbd{PR} can
include primes at which the Hasse invariant is~$0$.
\bprog
? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,2*y-1]);
? [PR,hf] = alghassef(A);
? PR
%4 = [[19, [10, 2]~, 1, 1, [-8, 2; 2, -10]], [2, [2, 0]~, 1, 2, 1]]
? hf
%5 = Vecsmall([1, 0])
@eprog

The library syntax is \fun{GEN}{alghassef}{GEN al}.

\subsec{alghassei$(\var{al})$}\kbdsidx{alghassei}\label{se:alghassei}
Given a central simple algebra \var{al} output by \tet{alginit}, returns
a \typ{VECSMALL} $h_i$ of $r_1$ integers modulo the degree $d$ of \var{al},
where $r_1$ is the number of real places of the center: the local Hasse
invariants of \var{al} at infinite places.
\bprog
? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? alghassei(A)
%3 = Vecsmall([1, 0])
@eprog

The library syntax is \fun{GEN}{alghassei}{GEN al}.

\subsec{algindex$(\var{al},\{\var{pl}\})$}\kbdsidx{algindex}\label{se:algindex}
Returns the index of the central simple algebra~$A$ over~$K$ (as output by
alginit), that is the degree~$e$ of the unique central division algebra~$D$
over $K$ such that~$A$ is isomorphic to some matrix algebra~$M_k(D)$. If
\var{pl} is set, it should be a prime ideal of~$K$ or an integer between~$1$
and~$r_1+r_2$, and in that case return the local index at the place \var{pl}
instead.

\bprog
? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algindex(A, 1)
%3 = 2
? algindex(A, 2)
%4 = 1
? algindex(A, idealprimedec(nf,2)[1])
%5 = 2
? algindex(A, idealprimedec(nf,5)[1])
%6 = 1
? algindex(A)
%7 = 2
@eprog

The library syntax is \fun{long}{algindex}{GEN al, GEN pl = NULL}.

\subsec{alginit$(B, C, \{v\}, \{\var{maxord} = 1\})$}\kbdsidx{alginit}\label{se:alginit}
Initializes the central simple algebra defined by data $B$, $C$ and
variable $v$, as follows.

\item (multiplication table) $B$ is the base number field $K$ in \tet{nfinit}
form, $C$ is a ``multiplication table'' over $K$.
As a $K$-vector space, the algebra is generated by a basis
$(e_1 = 1,\dots, e_n)$; the table is given as a \typ{VEC} of $n$ matrices in
$M_n(K)$, giving the left multiplication by the basis elements~$e_i$, in the
given basis.
Assumes that $e_1= 1$, that the multiplication table is integral, and that
$(\bigoplus_{i=1}^nK e_i,C)$ describes a central simple algebra over $K$.
\bprog
{ mi = [0,-1,0, 0;
         1, 0,0, 0;
         0, 0,0,-1;
         0, 0,1, 0];
  mj = [0, 0,-1,0;
         0, 0, 0,1;
         1, 0, 0,0;
         0,-1, 0,0];
  mk = [0, 0, 0, -1;
         0, 0,-1, 0;
         0, 1, 0, 0;
         1, 0, 0, 0];
  A = alginit(nfinit(y), [matid(4), mi,mj,mk], , 0); }
@eprog represents (in a complicated way) the quaternion algebra $(-1,-1)_\Q$.
See below for a simpler solution.

\item (cyclic algebra) $B$ is an \kbd{rnf} structure attached to a cyclic
number field extension $L/K$ of degree $d$, $C$ is a \typ{VEC}
\kbd{[sigma,b]} with 2 components: \kbd{sigma} is a \typ{POLMOD} representing
an automorphism generating $\text{Gal}(L/K)$, $b$ is an element in $K^*$. This
represents the cyclic algebra~$(L/K,\sigma,b)$. Currently the element $b$ has
to be integral.
\bprog
 ? Q = nfinit(y); T = polcyclo(5, 'x); F = rnfinit(Q, T);
 ? A = alginit(F, [Mod(x^2,T), 3]);
@eprog defines the cyclic algebra $(L/\Q, \sigma, 3)$, where
$L = \Q(\zeta_5)$ and $\sigma:\zeta\mapsto\zeta^2$ generates
$\text{Gal}(L/\Q)$.

\item (quaternion algebra, special case of the above) $B$ is an \kbd{nf}
structure attached to a number field $K$, $C = [a,b]$ is a vector
containing two elements of $K^*$ with $a$ not a square in $K$, returns the quaternion algebra $(a,b)_K$.
The variable $v$ (\kbd{'x} by default) must have higher priority than the
variable of $K$\kbd{.pol} and is used to represent elements in the splitting
field $L = K[x]/(x^2-a)$.
\bprog
 ? Q = nfinit(y); A = alginit(Q, [-1,-1]);  \\@com $(-1,-1)_\Q$
@eprog

\item (algebra/$K$ defined by local Hasse invariants)
$B$ is an \kbd{nf} structure attached to a number field $K$,
$C = [d, [\kbd{PR},h_f], h_i]$ is a triple
containing an integer $d > 1$, a pair $[\kbd{PR}, h_f]$ describing the
Hasse invariants at finite places, and $h_i$ the Hasse invariants
at archimedean (real) places. A local Hasse invariant belongs to $(1/d)\Z/\Z
\subset \Q/\Z$, and is given either as a \typ{FRAC} (lift to $(1/d)\Z$),
a \typ{INT} or \typ{INTMOD} modulo $d$ (lift to $\Z/d\Z$); a whole vector
of local invariants can also be given as a \typ{VECSMALL}, whose
entries are handled as \typ{INT}s. \kbd{PR} is a list of prime ideals
(\kbd{prid} structures), and $h_f$ is a vector of the same length giving the
local invariants at those maximal ideals. The invariants at infinite real
places are indexed by the real roots $K$\kbd{.roots}: if the Archimedean
place $v$ is attached to the $j$-th root, the value of
$h_v$ is given by $h_i[j]$, must be $0$ or $1/2$ (or~$d/2$ modulo~$d$), and
can be nonzero only if~$d$ is even.

By class field theory, provided the local invariants $h_v$ sum to $0$, up
to Brauer equivalence, there is a unique central simple algebra over $K$
with given local invariants and trivial invariant elsewhere. In particular,
up to isomorphism, there is a unique such algebra $A$ of degree $d$.

We realize $A$ as a cyclic algebra through class field theory. The variable $v$
(\kbd{'x} by default) must have higher priority than the variable of
$K$\kbd{.pol} and is used to represent elements in the (cyclic) splitting
field extension $L/K$ for $A$.

\bprog
 ? nf = nfinit(y^2+1);
 ? PR = idealprimedec(nf,5); #PR
 %2 = 2
 ? hi = [];
 ? hf = [PR, [1/3,-1/3]];
 ? A = alginit(nf, [3,hf,hi]);
 ? algsplittingfield(A).pol
 %6 = x^3 - 21*x + 7
@eprog

\item (matrix algebra, toy example) $B$ is an \kbd{nf} structure attached
to a number field $K$, $C = d$ is a positive integer. Returns a cyclic
algebra isomorphic to the matrix algebra $M_d(K)$.

In all cases, this function computes a maximal order for the algebra by default,
which may require a lot of time. Setting $maxord = 0$ prevents this computation.

The pari object representing such an algebra $A$ is a \typ{VEC} with the
following data:

 \item A splitting field $L$ of $A$ of the same degree over $K$ as $A$, in
\kbd{rnfinit} format, accessed with \kbd{algsplittingfield}.

 \item The Hasse invariants at the real places of $K$, accessed with
\kbd{alghassei}.

 \item The Hasse invariants of $A$ at the finite primes of $K$ that ramify in
the natural order of $A$, accessed with \kbd{alghassef}.

 \item A basis of an order ${\cal O}_0$ expressed on the basis of the natural
order, accessed with \kbd{algbasis}.

 \item A basis of the natural order expressed on the basis of ${\cal O}_0$,
accessed with \kbd{alginvbasis}.

 \item The left multiplication table of ${\cal O}_0$ on the previous basis,
accessed with \kbd{algmultable}.

 \item The characteristic of $A$ (always $0$), accessed with \kbd{algchar}.

 \item The absolute traces of the elements of the basis of ${\cal O}_0$.

 \item If $A$ was constructed as a cyclic algebra~$(L/K,\sigma,b)$ of degree
$d$, a \typ{VEC} $[\sigma,\sigma^2,\dots,\sigma^{d-1}]$. The function
\kbd{algaut} returns $\sigma$.

 \item If $A$ was constructed as a cyclic algebra~$(L/K,\sigma,b)$, the
element $b$, accessed with \kbd{algb}.

 \item If $A$ was constructed with its multiplication table $mt$ over $K$,
the \typ{VEC} of \typ{MAT} $mt$, accessed with \kbd{algrelmultable}.

 \item If $A$ was constructed with its multiplication table $mt$ over $K$,
a \typ{VEC} with three components: a \typ{COL} representing an element of $A$
generating the splitting field $L$ as a maximal subfield of $A$, a \typ{MAT}
representing an $L$-basis ${\cal B}$ of $A$ expressed on the $\Z$-basis of
${\cal O}_0$, and a \typ{MAT} representing the $\Z$-basis of ${\cal O}_0$
expressed on ${\cal B}$. This data is accessed with \kbd{algsplittingdata}.

The library syntax is \fun{GEN}{alginit}{GEN B, GEN C, long v = -1, long maxord} where \kbd{v} is a variable number.

\subsec{alginv$(\var{al},x)$}\kbdsidx{alginv}\label{se:alginv}
Given an element $x$ in \var{al}, computes its inverse $x^{-1}$ in the
algebra \var{al}. Assumes that $x$ is invertible.
\bprog
? A = alginit(nfinit(y), [-1,-1]);
? alginv(A,[1,1,0,0]~)
%2 = [1/2, 1/2, 0, 0]~
@eprog

Also accepts matrices with coefficients in \var{al}.

The library syntax is \fun{GEN}{alginv}{GEN al, GEN x}.

\subsec{alginvbasis$(\var{al})$}\kbdsidx{alginvbasis}\label{se:alginvbasis}
Given an central simple algebra \var{al} output by \tet{alginit}, returns
a $\Z$-basis of the natural order in \var{al} with respect to the
order~${\cal O}_0$ stored in \var{al}.
\bprog
A = alginit(nfinit(y), [-1,-1]);
? alginvbasis(A)
%2 =
[1 0 0 -1]

[0 1 0 -1]

[0 0 1 -1]

[0 0 0  2]
@eprog

The library syntax is \fun{GEN}{alginvbasis}{GEN al}.

\subsec{algisassociative$(\var{mt},p=0)$}\kbdsidx{algisassociative}\label{se:algisassociative}
Returns 1 if the multiplication table \kbd{mt} is suitable for
\kbd{algtableinit(mt,p)}, 0 otherwise. More precisely, \kbd{mt} should be
a \typ{VEC} of $n$ matrices in $M_n(K)$, giving the left multiplications
by the basis elements $e_1, \dots, e_n$ (structure constants).
We check whether the first basis element $e_1$ is $1$ and $e_i(e_je_k) =
(e_ie_j)e_k$ for all $i,j,k$.
\bprog
 ? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
 ? algisassociative(mt)
 %2 = 1
@eprog

May be used to check a posteriori an algebra: we also allow \kbd{mt} as
output by \tet{algtableinit} ($p$ is ignored in this case).

The library syntax is \fun{GEN}{algisassociative}{GEN mt, GEN p}.

\subsec{algiscommutative$(\var{al})$}\kbdsidx{algiscommutative}\label{se:algiscommutative}
\var{al} being a table algebra output by \tet{algtableinit} or a central
simple algebra output by \tet{alginit}, tests whether the algebra \var{al} is
commutative.
\bprog
? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algiscommutative(A)
%3 = 0
? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? algiscommutative(A)
%6 = 1
@eprog

The library syntax is \fun{GEN}{algiscommutative}{GEN al}.

\subsec{algisdivision$(\var{al},\{\var{pl}\})$}\kbdsidx{algisdivision}\label{se:algisdivision}
Given a central simple algebra \var{al} output by \tet{alginit}, tests
whether \var{al} is a division algebra. If \var{pl} is set, it should be a
prime ideal of~$K$ or an integer between~$1$ and~$r_1+r_2$, and in that case
tests whether \var{al} is locally a division algebra at the place \var{pl}
instead.

\bprog
? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algisdivision(A, 1)
%3 = 1
? algisdivision(A, 2)
%4 = 0
? algisdivision(A, idealprimedec(nf,2)[1])
%5 = 1
? algisdivision(A, idealprimedec(nf,5)[1])
%6 = 0
? algisdivision(A)
%7 = 1
@eprog

The library syntax is \fun{GEN}{algisdivision}{GEN al, GEN pl = NULL}.

\subsec{algisdivl$(\var{al},x,y,\{\&z\})$}\kbdsidx{algisdivl}\label{se:algisdivl}
Given two elements $x$ and $y$ in \var{al}, tests whether $y$ is left
divisible by $x$, that is whether there exists~$z$ in \var{al} such
that~$xz=y$, and sets $z$ to this element if it exists.
\bprog
? A = alginit(nfinit(y), [-1,1]);
? algisdivl(A,[x+2,-x-2]~,[x,1]~)
%2 = 0
? algisdivl(A,[x+2,-x-2]~,[-x,x]~,&z)
%3 = 1
? z
%4 = [Mod(-2/5*x - 1/5, x^2 + 1), 0]~
@eprog

Also accepts matrices with coefficients in \var{al}.

The library syntax is \fun{GEN}{algisdivl}{GEN al, GEN x, GEN y, GEN *z = NULL}.

\subsec{algisinv$(\var{al},x,\{\&\var{ix}\})$}\kbdsidx{algisinv}\label{se:algisinv}
Given an element $x$ in \var{al}, tests whether $x$ is inverti